// Package criblApidocs4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cribl

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AUTHPROVIDER.
const (
	AUTHPROVIDERAwsEc2 AUTHPROVIDER = "aws-ec2"
	AUTHPROVIDERAwsIam AUTHPROVIDER = "aws-iam"
	AUTHPROVIDERToken  AUTHPROVIDER = "token"
)

// Defines values for AppMode.
const (
	AppModeEdge        AppMode = "edge"
	AppModeManagedEdge AppMode = "managed-edge"
	AppModeMaster      AppMode = "master"
	AppModeSingle      AppMode = "single"
	AppModeWorker      AppMode = "worker"
)

// Defines values for AppScopeProcessStatus.
const (
	AppScopeProcessStatusGreen       AppScopeProcessStatus = "green"
	AppScopeProcessStatusLessThannil AppScopeProcessStatus = "<nil>"
	AppScopeProcessStatusRed         AppScopeProcessStatus = "red"
	AppScopeProcessStatusYellow      AppScopeProcessStatus = "yellow"
)

// Defines values for AppScopeProcessingStatus.
const (
	AppScopeProcessingStatusAttachFailed AppScopeProcessingStatus = "attach_failed"
	AppScopeProcessingStatusAttaching    AppScopeProcessingStatus = "attaching"
	AppScopeProcessingStatusDetachFailed AppScopeProcessingStatus = "detach_failed"
	AppScopeProcessingStatusDetached     AppScopeProcessingStatus = "detached"
	AppScopeProcessingStatusDetaching    AppScopeProcessingStatus = "detaching"
	AppScopeProcessingStatusLessThannil  AppScopeProcessingStatus = "<nil>"
	AppScopeProcessingStatusNormal       AppScopeProcessingStatus = "normal"
	AppScopeProcessingStatusUpdateFailed AppScopeProcessingStatus = "update_failed"
	AppScopeProcessingStatusUpdating     AppScopeProcessingStatus = "updating"
)

// Defines values for AppscopeConfigEventType.
const (
	AppscopeConfigEventTypeNdjson AppscopeConfigEventType = "ndjson"
)

// Defines values for AppscopeConfigLibscopeLogLevel.
const (
	AppscopeConfigLibscopeLogLevelDebug   AppscopeConfigLibscopeLogLevel = "debug"
	AppscopeConfigLibscopeLogLevelError   AppscopeConfigLibscopeLogLevel = "error"
	AppscopeConfigLibscopeLogLevelInfo    AppscopeConfigLibscopeLogLevel = "info"
	AppscopeConfigLibscopeLogLevelNone    AppscopeConfigLibscopeLogLevel = "none"
	AppscopeConfigLibscopeLogLevelWarning AppscopeConfigLibscopeLogLevel = "warning"
)

// Defines values for AppscopeConfigWithCustomEventType.
const (
	AppscopeConfigWithCustomEventTypeNdjson AppscopeConfigWithCustomEventType = "ndjson"
)

// Defines values for AppscopeConfigWithCustomLibscopeLogLevel.
const (
	AppscopeConfigWithCustomLibscopeLogLevelDebug   AppscopeConfigWithCustomLibscopeLogLevel = "debug"
	AppscopeConfigWithCustomLibscopeLogLevelError   AppscopeConfigWithCustomLibscopeLogLevel = "error"
	AppscopeConfigWithCustomLibscopeLogLevelInfo    AppscopeConfigWithCustomLibscopeLogLevel = "info"
	AppscopeConfigWithCustomLibscopeLogLevelNone    AppscopeConfigWithCustomLibscopeLogLevel = "none"
	AppscopeConfigWithCustomLibscopeLogLevelWarning AppscopeConfigWithCustomLibscopeLogLevel = "warning"
)

// Defines values for AppscopeTransportBuffer.
const (
	AppscopeTransportBufferFull AppscopeTransportBuffer = "full"
	AppscopeTransportBufferLine AppscopeTransportBuffer = "line"
)

// Defines values for AuthConfigType.
const (
	AuthConfigTypeLdap   AuthConfigType = "ldap"
	AuthConfigTypeLocal  AuthConfigType = "local"
	AuthConfigTypeOpenid AuthConfigType = "openid"
	AuthConfigTypeSaas   AuthConfigType = "saas"
	AuthConfigTypeSaml   AuthConfigType = "saml"
	AuthConfigTypeSplunk AuthConfigType = "splunk"
)

// Defines values for BannerMessageType.
const (
	BannerMessageTypeCustom BannerMessageType = "custom"
	BannerMessageTypeSystem BannerMessageType = "system"
)

// Defines values for BulletinMessageSeverity.
const (
	BulletinMessageSeverityError BulletinMessageSeverity = "error"
	BulletinMessageSeverityFatal BulletinMessageSeverity = "fatal"
	BulletinMessageSeverityInfo  BulletinMessageSeverity = "info"
	BulletinMessageSeverityWarn  BulletinMessageSeverity = "warn"
)

// Defines values for CHOutConfigAuthType.
const (
	CHOutConfigAuthTypeBasic              CHOutConfigAuthType = "basic"
	CHOutConfigAuthTypeCredentialsSecret  CHOutConfigAuthType = "credentialsSecret"
	CHOutConfigAuthTypeManual             CHOutConfigAuthType = "manual"
	CHOutConfigAuthTypeManualAPIKey       CHOutConfigAuthType = "manualAPIKey"
	CHOutConfigAuthTypeNone               CHOutConfigAuthType = "none"
	CHOutConfigAuthTypeSecret             CHOutConfigAuthType = "secret"
	CHOutConfigAuthTypeSslUserCertificate CHOutConfigAuthType = "sslUserCertificate"
	CHOutConfigAuthTypeTextSecret         CHOutConfigAuthType = "textSecret"
	CHOutConfigAuthTypeToken              CHOutConfigAuthType = "token"
)

// Defines values for ChartType.
const (
	ChartTypeArea          ChartType = "area"
	ChartTypeColumn        ChartType = "column"
	ChartTypeEvents        ChartType = "events"
	ChartTypeFunnel        ChartType = "funnel"
	ChartTypeGauge         ChartType = "gauge"
	ChartTypeHorizontalBar ChartType = "horizontalBar"
	ChartTypeLine          ChartType = "line"
	ChartTypeMap           ChartType = "map"
	ChartTypePie           ChartType = "pie"
	ChartTypeScatter       ChartType = "scatter"
	ChartTypeSingle        ChartType = "single"
	ChartTypeTable         ChartType = "table"
)

// Defines values for CluiItemCategory.
const (
	Link CluiItemCategory = "link"
)

// Defines values for CluiType.
const (
	CluiTypeCollector  CluiType = "collector"
	CluiTypeInput      CluiType = "input"
	CluiTypeKnowledge  CluiType = "knowledge"
	CluiTypeMonitoring CluiType = "monitoring"
	CluiTypeOutput     CluiType = "output"
	CluiTypePack       CluiType = "pack"
	CluiTypePipeline   CluiType = "pipeline"
	CluiTypeRoute      CluiType = "route"
)

// Defines values for ContainerType.
const (
	Containerd ContainerType = "containerd"
	Docker     ContainerType = "docker"
)

// Defines values for CriblLakeDatasetFormat.
const (
	CriblLakeDatasetFormatDdss    CriblLakeDatasetFormat = "ddss"
	CriblLakeDatasetFormatJson    CriblLakeDatasetFormat = "json"
	CriblLakeDatasetFormatParquet CriblLakeDatasetFormat = "parquet"
)

// Defines values for CriblLib.
const (
	CriblLibCribl       CriblLib = "cribl"
	CriblLibCriblCustom CriblLib = "cribl-custom"
	CriblLibCustom      CriblLib = "custom"
)

// Defines values for DashboardElementType.
const (
	ChartArea          DashboardElementType = "chart.area"
	ChartColumn        DashboardElementType = "chart.column"
	ChartFunnel        DashboardElementType = "chart.funnel"
	ChartGauge         DashboardElementType = "chart.gauge"
	ChartHorizontalBar DashboardElementType = "chart.horizontalBar"
	ChartLine          DashboardElementType = "chart.line"
	ChartMap           DashboardElementType = "chart.map"
	ChartPie           DashboardElementType = "chart.pie"
	ChartScatter       DashboardElementType = "chart.scatter"
	CounterSingle      DashboardElementType = "counter.single"
	InputDropdown      DashboardElementType = "input.dropdown"
	InputNumber        DashboardElementType = "input.number"
	InputText          DashboardElementType = "input.text"
	InputTimerange     DashboardElementType = "input.timerange"
	ListEvents         DashboardElementType = "list.events"
	ListTable          DashboardElementType = "list.table"
)

// Defines values for DashboardElementVariant.
const (
	DashboardElementVariantInput         DashboardElementVariant = "input"
	DashboardElementVariantMarkdown      DashboardElementVariant = "markdown"
	DashboardElementVariantVisualization DashboardElementVariant = "visualization"
)

// Defines values for DatabaseConnectionType.
const (
	Mysql     DatabaseConnectionType = "mysql"
	Oracle    DatabaseConnectionType = "oracle"
	Postgres  DatabaseConnectionType = "postgres"
	Sqlserver DatabaseConnectionType = "sqlserver"
)

// Defines values for DatasetMetadataScanMode.
const (
	Detailed DatasetMetadataScanMode = "detailed"
	Quick    DatasetMetadataScanMode = "quick"
)

// Defines values for DatasetOrigin.
const (
	LeaderLocal DatasetOrigin = "leader_local"
	Remote      DatasetOrigin = "remote"
	WorkerLocal DatasetOrigin = "worker_local"
)

// Defines values for DatasetProviderTypeId.
const (
	DatasetProviderTypeIdAmazonSecurityLake   DatasetProviderTypeId = "amazon_security_lake"
	DatasetProviderTypeIdApiAws               DatasetProviderTypeId = "api_aws"
	DatasetProviderTypeIdApiAzure             DatasetProviderTypeId = "api_azure"
	DatasetProviderTypeIdApiAzureDataExplorer DatasetProviderTypeId = "api_azure_data_explorer"
	DatasetProviderTypeIdApiElasticsearch     DatasetProviderTypeId = "api_elasticsearch"
	DatasetProviderTypeIdApiGcp               DatasetProviderTypeId = "api_gcp"
	DatasetProviderTypeIdApiGoogleWorkspace   DatasetProviderTypeId = "api_google_workspace"
	DatasetProviderTypeIdApiHttp              DatasetProviderTypeId = "api_http"
	DatasetProviderTypeIdApiMsgraph           DatasetProviderTypeId = "api_msgraph"
	DatasetProviderTypeIdApiOkta              DatasetProviderTypeId = "api_okta"
	DatasetProviderTypeIdApiOpensearch        DatasetProviderTypeId = "api_opensearch"
	DatasetProviderTypeIdApiTailscale         DatasetProviderTypeId = "api_tailscale"
	DatasetProviderTypeIdApiZoom              DatasetProviderTypeId = "api_zoom"
	DatasetProviderTypeIdAzureBlob            DatasetProviderTypeId = "azure_blob"
	DatasetProviderTypeIdClickhouse           DatasetProviderTypeId = "clickhouse"
	DatasetProviderTypeIdCriblEdge            DatasetProviderTypeId = "cribl_edge"
	DatasetProviderTypeIdCriblLake            DatasetProviderTypeId = "cribl_lake"
	DatasetProviderTypeIdCriblLeader          DatasetProviderTypeId = "cribl_leader"
	DatasetProviderTypeIdCriblMeta            DatasetProviderTypeId = "cribl_meta"
	DatasetProviderTypeIdGcs                  DatasetProviderTypeId = "gcs"
	DatasetProviderTypeIdPrometheus           DatasetProviderTypeId = "prometheus"
	DatasetProviderTypeIdS3                   DatasetProviderTypeId = "s3"
	DatasetProviderTypeIdSnowflake            DatasetProviderTypeId = "snowflake"
)

// Defines values for DatatypePreviewInput0Type.
const (
	DatatypePreviewInput0TypeDataset DatatypePreviewInput0Type = "dataset"
)

// Defines values for DatatypePreviewInput1Type.
const (
	RawData DatatypePreviewInput1Type = "rawData"
)

// Defines values for DistributedUpgradeRequestUpgradeMode.
const (
	Batch   DistributedUpgradeRequestUpgradeMode = "batch"
	Regular DistributedUpgradeRequestUpgradeMode = "regular"
	Rolling DistributedUpgradeRequestUpgradeMode = "rolling"
)

// Defines values for EdgeHeartbeatMetricsMode.
const (
	EdgeHeartbeatMetricsModeAll     EdgeHeartbeatMetricsMode = "all"
	EdgeHeartbeatMetricsModeBasic   EdgeHeartbeatMetricsMode = "basic"
	EdgeHeartbeatMetricsModeCustom  EdgeHeartbeatMetricsMode = "custom"
	EdgeHeartbeatMetricsModeMinimal EdgeHeartbeatMetricsMode = "minimal"
)

// Defines values for EventBreakerRuleParser0Type.
const (
	EventBreakerRuleParser0TypeClf   EventBreakerRuleParser0Type = "clf"
	EventBreakerRuleParser0TypeCsv   EventBreakerRuleParser0Type = "csv"
	EventBreakerRuleParser0TypeDelim EventBreakerRuleParser0Type = "delim"
	EventBreakerRuleParser0TypeElff  EventBreakerRuleParser0Type = "elff"
)

// Defines values for EventBreakerRuleParser1Type.
const (
	EventBreakerRuleParser1TypeGrok EventBreakerRuleParser1Type = "grok"
)

// Defines values for EventBreakerRuleParser2Type.
const (
	EventBreakerRuleParser2TypeJson EventBreakerRuleParser2Type = "json"
)

// Defines values for EventBreakerRuleParser3Type.
const (
	Kvp EventBreakerRuleParser3Type = "kvp"
)

// Defines values for EventBreakerRuleTimestampType.
const (
	EventBreakerRuleTimestampTypeAuto    EventBreakerRuleTimestampType = "auto"
	EventBreakerRuleTimestampTypeCurrent EventBreakerRuleTimestampType = "current"
	EventBreakerRuleTimestampTypeFormat  EventBreakerRuleTimestampType = "format"
)

// Defines values for EventBreakerRuleType.
const (
	EventBreakerRuleTypeAwsCloudtrail EventBreakerRuleType = "aws_cloudtrail"
	EventBreakerRuleTypeAwsVpcflow    EventBreakerRuleType = "aws_vpcflow"
	EventBreakerRuleTypeCsv           EventBreakerRuleType = "csv"
	EventBreakerRuleTypeHeader        EventBreakerRuleType = "header"
	EventBreakerRuleTypeJson          EventBreakerRuleType = "json"
	EventBreakerRuleTypeJsonArray     EventBreakerRuleType = "json_array"
	EventBreakerRuleTypeRegex         EventBreakerRuleType = "regex"
	EventBreakerRuleTypeTimestamp     EventBreakerRuleType = "timestamp"
)

// Defines values for EventBreakerRulesetLib.
const (
	EventBreakerRulesetLibCriblCustom EventBreakerRulesetLib = "cribl-custom"
	EventBreakerRulesetLibCustom      EventBreakerRulesetLib = "custom"
)

// Defines values for EventBreakerRulesetRulesTimestampType.
const (
	EventBreakerRulesetRulesTimestampTypeAuto    EventBreakerRulesetRulesTimestampType = "auto"
	EventBreakerRulesetRulesTimestampTypeCurrent EventBreakerRulesetRulesTimestampType = "current"
	EventBreakerRulesetRulesTimestampTypeFormat  EventBreakerRulesetRulesTimestampType = "format"
)

// Defines values for EventBreakerRulesetRulesType.
const (
	EventBreakerRulesetRulesTypeAwsCloudtrail EventBreakerRulesetRulesType = "aws_cloudtrail"
	EventBreakerRulesetRulesTypeAwsVpcflow    EventBreakerRulesetRulesType = "aws_vpcflow"
	EventBreakerRulesetRulesTypeCsv           EventBreakerRulesetRulesType = "csv"
	EventBreakerRulesetRulesTypeHeader        EventBreakerRulesetRulesType = "header"
	EventBreakerRulesetRulesTypeJson          EventBreakerRulesetRulesType = "json"
	EventBreakerRulesetRulesTypeJsonArray     EventBreakerRulesetRulesType = "json_array"
	EventBreakerRulesetRulesTypeRegex         EventBreakerRulesetRulesType = "regex"
	EventBreakerRulesetRulesTypeTimestamp     EventBreakerRulesetRulesType = "timestamp"
)

// Defines values for Filter.
const (
	FilterN2 Filter = 2
)

// Defines values for Format.
const (
	FormatJsonCompactEachRowWithNames Format = "json-compact-each-row-with-names"
	FormatJsonEachRow                 Format = "json-each-row"
)

// Defines values for GitOpsType.
const (
	GitOpsTypeNone GitOpsType = "none"
	GitOpsTypePull GitOpsType = "pull"
	GitOpsTypePush GitOpsType = "push"
)

// Defines values for GlobalVarType.
const (
	GlobalVarTypeAny        GlobalVarType = "any"
	GlobalVarTypeArray      GlobalVarType = "array"
	GlobalVarTypeBoolean    GlobalVarType = "boolean"
	GlobalVarTypeExpression GlobalVarType = "expression"
	GlobalVarTypeNumber     GlobalVarType = "number"
	GlobalVarTypeObject     GlobalVarType = "object"
	GlobalVarTypeString     GlobalVarType = "string"
)

// Defines values for InputAppscopeAuthType.
const (
	InputAppscopeAuthTypeManual InputAppscopeAuthType = "manual"
	InputAppscopeAuthTypeSecret InputAppscopeAuthType = "secret"
)

// Defines values for InputAppscopeEnableUnixPath.
const (
	InputAppscopeEnableUnixPathFalse InputAppscopeEnableUnixPath = false
	InputAppscopeEnableUnixPathTrue  InputAppscopeEnableUnixPath = true
)

// Defines values for InputAppscopePersistenceCompress.
const (
	InputAppscopePersistenceCompressGzip InputAppscopePersistenceCompress = "gzip"
	InputAppscopePersistenceCompressNone InputAppscopePersistenceCompress = "none"
)

// Defines values for InputAppscopePersistenceEnable.
const (
	InputAppscopePersistenceEnableFalse InputAppscopePersistenceEnable = false
	InputAppscopePersistenceEnableTrue  InputAppscopePersistenceEnable = true
)

// Defines values for InputAppscopePqCompress.
const (
	InputAppscopePqCompressGzip InputAppscopePqCompress = "gzip"
	InputAppscopePqCompressNone InputAppscopePqCompress = "none"
)

// Defines values for InputAppscopePqMode.
const (
	InputAppscopePqModeAlways InputAppscopePqMode = "always"
	InputAppscopePqModeSmart  InputAppscopePqMode = "smart"
)

// Defines values for InputAppscopePqEnabled.
const (
	InputAppscopePqEnabledFalse InputAppscopePqEnabled = false
	InputAppscopePqEnabledTrue  InputAppscopePqEnabled = true
)

// Defines values for InputAppscopeSendToRoutes.
const (
	InputAppscopeSendToRoutesFalse InputAppscopeSendToRoutes = false
	InputAppscopeSendToRoutesTrue  InputAppscopeSendToRoutes = true
)

// Defines values for InputAppscopeTlsDisabled.
const (
	InputAppscopeTlsDisabledFalse InputAppscopeTlsDisabled = false
	InputAppscopeTlsDisabledTrue  InputAppscopeTlsDisabled = true
)

// Defines values for InputAppscopeTlsMaxVersion.
const (
	InputAppscopeTlsMaxVersionTLSv1  InputAppscopeTlsMaxVersion = "TLSv1"
	InputAppscopeTlsMaxVersionTLSv11 InputAppscopeTlsMaxVersion = "TLSv1.1"
	InputAppscopeTlsMaxVersionTLSv12 InputAppscopeTlsMaxVersion = "TLSv1.2"
	InputAppscopeTlsMaxVersionTLSv13 InputAppscopeTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputAppscopeTlsMinVersion.
const (
	InputAppscopeTlsMinVersionTLSv1  InputAppscopeTlsMinVersion = "TLSv1"
	InputAppscopeTlsMinVersionTLSv11 InputAppscopeTlsMinVersion = "TLSv1.1"
	InputAppscopeTlsMinVersionTLSv12 InputAppscopeTlsMinVersion = "TLSv1.2"
	InputAppscopeTlsMinVersionTLSv13 InputAppscopeTlsMinVersion = "TLSv1.3"
)

// Defines values for InputAppscopeType.
const (
	InputAppscopeTypeAppscope InputAppscopeType = "appscope"
)

// Defines values for InputAzureBlobAuthType.
const (
	InputAzureBlobAuthTypeClientCert   InputAzureBlobAuthType = "clientCert"
	InputAzureBlobAuthTypeClientSecret InputAzureBlobAuthType = "clientSecret"
	InputAzureBlobAuthTypeManual       InputAzureBlobAuthType = "manual"
	InputAzureBlobAuthTypeSecret       InputAzureBlobAuthType = "secret"
)

// Defines values for InputAzureBlobPqCompress.
const (
	InputAzureBlobPqCompressGzip InputAzureBlobPqCompress = "gzip"
	InputAzureBlobPqCompressNone InputAzureBlobPqCompress = "none"
)

// Defines values for InputAzureBlobPqMode.
const (
	InputAzureBlobPqModeAlways InputAzureBlobPqMode = "always"
	InputAzureBlobPqModeSmart  InputAzureBlobPqMode = "smart"
)

// Defines values for InputAzureBlobPqEnabled.
const (
	InputAzureBlobPqEnabledFalse InputAzureBlobPqEnabled = false
	InputAzureBlobPqEnabledTrue  InputAzureBlobPqEnabled = true
)

// Defines values for InputAzureBlobSendToRoutes.
const (
	InputAzureBlobSendToRoutesFalse InputAzureBlobSendToRoutes = false
	InputAzureBlobSendToRoutesTrue  InputAzureBlobSendToRoutes = true
)

// Defines values for InputAzureBlobType.
const (
	InputAzureBlobTypeAzureBlob InputAzureBlobType = "azure_blob"
)

// Defines values for InputCollectionPqCompress.
const (
	InputCollectionPqCompressGzip InputCollectionPqCompress = "gzip"
	InputCollectionPqCompressNone InputCollectionPqCompress = "none"
)

// Defines values for InputCollectionPqMode.
const (
	InputCollectionPqModeAlways InputCollectionPqMode = "always"
	InputCollectionPqModeSmart  InputCollectionPqMode = "smart"
)

// Defines values for InputCollectionPqEnabled.
const (
	InputCollectionPqEnabledFalse InputCollectionPqEnabled = false
	InputCollectionPqEnabledTrue  InputCollectionPqEnabled = true
)

// Defines values for InputCollectionPreprocessDisabled.
const (
	InputCollectionPreprocessDisabledFalse InputCollectionPreprocessDisabled = false
	InputCollectionPreprocessDisabledTrue  InputCollectionPreprocessDisabled = true
)

// Defines values for InputCollectionSendToRoutes.
const (
	InputCollectionSendToRoutesFalse InputCollectionSendToRoutes = false
	InputCollectionSendToRoutesTrue  InputCollectionSendToRoutes = true
)

// Defines values for InputCollectionType.
const (
	InputCollectionTypeCollection InputCollectionType = "collection"
)

// Defines values for InputConfluentCloudKafkaSchemaRegistryAuthDisabled.
const (
	InputConfluentCloudKafkaSchemaRegistryAuthDisabledFalse InputConfluentCloudKafkaSchemaRegistryAuthDisabled = false
	InputConfluentCloudKafkaSchemaRegistryAuthDisabledTrue  InputConfluentCloudKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for InputConfluentCloudKafkaSchemaRegistryDisabled.
const (
	InputConfluentCloudKafkaSchemaRegistryDisabledFalse InputConfluentCloudKafkaSchemaRegistryDisabled = false
	InputConfluentCloudKafkaSchemaRegistryDisabledTrue  InputConfluentCloudKafkaSchemaRegistryDisabled = true
)

// Defines values for InputConfluentCloudKafkaSchemaRegistryTlsDisabled.
const (
	InputConfluentCloudKafkaSchemaRegistryTlsDisabledFalse InputConfluentCloudKafkaSchemaRegistryTlsDisabled = false
	InputConfluentCloudKafkaSchemaRegistryTlsDisabledTrue  InputConfluentCloudKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion.
const (
	InputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv1  InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	InputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv11 InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	InputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv12 InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	InputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv13 InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputConfluentCloudKafkaSchemaRegistryTlsMinVersion.
const (
	InputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv1  InputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	InputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv11 InputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	InputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv12 InputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	InputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv13 InputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for InputConfluentCloudPqCompress.
const (
	InputConfluentCloudPqCompressGzip InputConfluentCloudPqCompress = "gzip"
	InputConfluentCloudPqCompressNone InputConfluentCloudPqCompress = "none"
)

// Defines values for InputConfluentCloudPqMode.
const (
	InputConfluentCloudPqModeAlways InputConfluentCloudPqMode = "always"
	InputConfluentCloudPqModeSmart  InputConfluentCloudPqMode = "smart"
)

// Defines values for InputConfluentCloudPqEnabled.
const (
	InputConfluentCloudPqEnabledFalse InputConfluentCloudPqEnabled = false
	InputConfluentCloudPqEnabledTrue  InputConfluentCloudPqEnabled = true
)

// Defines values for InputConfluentCloudSaslDisabled.
const (
	InputConfluentCloudSaslDisabledFalse InputConfluentCloudSaslDisabled = false
	InputConfluentCloudSaslDisabledTrue  InputConfluentCloudSaslDisabled = true
)

// Defines values for InputConfluentCloudSaslMechanism.
const (
	InputConfluentCloudSaslMechanismKerberos    InputConfluentCloudSaslMechanism = "kerberos"
	InputConfluentCloudSaslMechanismPlain       InputConfluentCloudSaslMechanism = "plain"
	InputConfluentCloudSaslMechanismScramSha256 InputConfluentCloudSaslMechanism = "scram-sha-256"
	InputConfluentCloudSaslMechanismScramSha512 InputConfluentCloudSaslMechanism = "scram-sha-512"
)

// Defines values for InputConfluentCloudSendToRoutes.
const (
	InputConfluentCloudSendToRoutesFalse InputConfluentCloudSendToRoutes = false
	InputConfluentCloudSendToRoutesTrue  InputConfluentCloudSendToRoutes = true
)

// Defines values for InputConfluentCloudTlsDisabled.
const (
	InputConfluentCloudTlsDisabledFalse InputConfluentCloudTlsDisabled = false
	InputConfluentCloudTlsDisabledTrue  InputConfluentCloudTlsDisabled = true
)

// Defines values for InputConfluentCloudTlsMaxVersion.
const (
	InputConfluentCloudTlsMaxVersionTLSv1  InputConfluentCloudTlsMaxVersion = "TLSv1"
	InputConfluentCloudTlsMaxVersionTLSv11 InputConfluentCloudTlsMaxVersion = "TLSv1.1"
	InputConfluentCloudTlsMaxVersionTLSv12 InputConfluentCloudTlsMaxVersion = "TLSv1.2"
	InputConfluentCloudTlsMaxVersionTLSv13 InputConfluentCloudTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputConfluentCloudTlsMinVersion.
const (
	InputConfluentCloudTlsMinVersionTLSv1  InputConfluentCloudTlsMinVersion = "TLSv1"
	InputConfluentCloudTlsMinVersionTLSv11 InputConfluentCloudTlsMinVersion = "TLSv1.1"
	InputConfluentCloudTlsMinVersionTLSv12 InputConfluentCloudTlsMinVersion = "TLSv1.2"
	InputConfluentCloudTlsMinVersionTLSv13 InputConfluentCloudTlsMinVersion = "TLSv1.3"
)

// Defines values for InputConfluentCloudType.
const (
	InputConfluentCloudTypeConfluentCloud InputConfluentCloudType = "confluent_cloud"
)

// Defines values for InputCriblPqCompress.
const (
	InputCriblPqCompressGzip InputCriblPqCompress = "gzip"
	InputCriblPqCompressNone InputCriblPqCompress = "none"
)

// Defines values for InputCriblPqMode.
const (
	InputCriblPqModeAlways InputCriblPqMode = "always"
	InputCriblPqModeSmart  InputCriblPqMode = "smart"
)

// Defines values for InputCriblPqEnabled.
const (
	InputCriblPqEnabledFalse InputCriblPqEnabled = false
	InputCriblPqEnabledTrue  InputCriblPqEnabled = true
)

// Defines values for InputCriblSendToRoutes.
const (
	InputCriblSendToRoutesFalse InputCriblSendToRoutes = false
	InputCriblSendToRoutesTrue  InputCriblSendToRoutes = true
)

// Defines values for InputCriblType.
const (
	Cribl InputCriblType = "cribl"
)

// Defines values for InputCriblHttpPqCompress.
const (
	InputCriblHttpPqCompressGzip InputCriblHttpPqCompress = "gzip"
	InputCriblHttpPqCompressNone InputCriblHttpPqCompress = "none"
)

// Defines values for InputCriblHttpPqMode.
const (
	InputCriblHttpPqModeAlways InputCriblHttpPqMode = "always"
	InputCriblHttpPqModeSmart  InputCriblHttpPqMode = "smart"
)

// Defines values for InputCriblHttpPqEnabled.
const (
	InputCriblHttpPqEnabledFalse InputCriblHttpPqEnabled = false
	InputCriblHttpPqEnabledTrue  InputCriblHttpPqEnabled = true
)

// Defines values for InputCriblHttpSendToRoutes.
const (
	InputCriblHttpSendToRoutesFalse InputCriblHttpSendToRoutes = false
	InputCriblHttpSendToRoutesTrue  InputCriblHttpSendToRoutes = true
)

// Defines values for InputCriblHttpTlsDisabled.
const (
	InputCriblHttpTlsDisabledFalse InputCriblHttpTlsDisabled = false
	InputCriblHttpTlsDisabledTrue  InputCriblHttpTlsDisabled = true
)

// Defines values for InputCriblHttpTlsMaxVersion.
const (
	InputCriblHttpTlsMaxVersionTLSv1  InputCriblHttpTlsMaxVersion = "TLSv1"
	InputCriblHttpTlsMaxVersionTLSv11 InputCriblHttpTlsMaxVersion = "TLSv1.1"
	InputCriblHttpTlsMaxVersionTLSv12 InputCriblHttpTlsMaxVersion = "TLSv1.2"
	InputCriblHttpTlsMaxVersionTLSv13 InputCriblHttpTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputCriblHttpTlsMinVersion.
const (
	InputCriblHttpTlsMinVersionTLSv1  InputCriblHttpTlsMinVersion = "TLSv1"
	InputCriblHttpTlsMinVersionTLSv11 InputCriblHttpTlsMinVersion = "TLSv1.1"
	InputCriblHttpTlsMinVersionTLSv12 InputCriblHttpTlsMinVersion = "TLSv1.2"
	InputCriblHttpTlsMinVersionTLSv13 InputCriblHttpTlsMinVersion = "TLSv1.3"
)

// Defines values for InputCriblHttpType.
const (
	InputCriblHttpTypeCriblHttp InputCriblHttpType = "cribl_http"
)

// Defines values for InputCriblTcpPqCompress.
const (
	InputCriblTcpPqCompressGzip InputCriblTcpPqCompress = "gzip"
	InputCriblTcpPqCompressNone InputCriblTcpPqCompress = "none"
)

// Defines values for InputCriblTcpPqMode.
const (
	InputCriblTcpPqModeAlways InputCriblTcpPqMode = "always"
	InputCriblTcpPqModeSmart  InputCriblTcpPqMode = "smart"
)

// Defines values for InputCriblTcpPqEnabled.
const (
	InputCriblTcpPqEnabledFalse InputCriblTcpPqEnabled = false
	InputCriblTcpPqEnabledTrue  InputCriblTcpPqEnabled = true
)

// Defines values for InputCriblTcpSendToRoutes.
const (
	InputCriblTcpSendToRoutesFalse InputCriblTcpSendToRoutes = false
	InputCriblTcpSendToRoutesTrue  InputCriblTcpSendToRoutes = true
)

// Defines values for InputCriblTcpTlsDisabled.
const (
	InputCriblTcpTlsDisabledFalse InputCriblTcpTlsDisabled = false
	InputCriblTcpTlsDisabledTrue  InputCriblTcpTlsDisabled = true
)

// Defines values for InputCriblTcpTlsMaxVersion.
const (
	InputCriblTcpTlsMaxVersionTLSv1  InputCriblTcpTlsMaxVersion = "TLSv1"
	InputCriblTcpTlsMaxVersionTLSv11 InputCriblTcpTlsMaxVersion = "TLSv1.1"
	InputCriblTcpTlsMaxVersionTLSv12 InputCriblTcpTlsMaxVersion = "TLSv1.2"
	InputCriblTcpTlsMaxVersionTLSv13 InputCriblTcpTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputCriblTcpTlsMinVersion.
const (
	InputCriblTcpTlsMinVersionTLSv1  InputCriblTcpTlsMinVersion = "TLSv1"
	InputCriblTcpTlsMinVersionTLSv11 InputCriblTcpTlsMinVersion = "TLSv1.1"
	InputCriblTcpTlsMinVersionTLSv12 InputCriblTcpTlsMinVersion = "TLSv1.2"
	InputCriblTcpTlsMinVersionTLSv13 InputCriblTcpTlsMinVersion = "TLSv1.3"
)

// Defines values for InputCriblTcpType.
const (
	InputCriblTcpTypeCriblTcp InputCriblTcpType = "cribl_tcp"
)

// Defines values for InputCriblmetricsPqCompress.
const (
	InputCriblmetricsPqCompressGzip InputCriblmetricsPqCompress = "gzip"
	InputCriblmetricsPqCompressNone InputCriblmetricsPqCompress = "none"
)

// Defines values for InputCriblmetricsPqMode.
const (
	InputCriblmetricsPqModeAlways InputCriblmetricsPqMode = "always"
	InputCriblmetricsPqModeSmart  InputCriblmetricsPqMode = "smart"
)

// Defines values for InputCriblmetricsPqEnabled.
const (
	InputCriblmetricsPqEnabledFalse InputCriblmetricsPqEnabled = false
	InputCriblmetricsPqEnabledTrue  InputCriblmetricsPqEnabled = true
)

// Defines values for InputCriblmetricsSendToRoutes.
const (
	InputCriblmetricsSendToRoutesFalse InputCriblmetricsSendToRoutes = false
	InputCriblmetricsSendToRoutesTrue  InputCriblmetricsSendToRoutes = true
)

// Defines values for InputCriblmetricsType.
const (
	Criblmetrics InputCriblmetricsType = "criblmetrics"
)

// Defines values for InputCrowdstrikeAwsAuthenticationMethod.
const (
	InputCrowdstrikeAwsAuthenticationMethodAuto   InputCrowdstrikeAwsAuthenticationMethod = "auto"
	InputCrowdstrikeAwsAuthenticationMethodManual InputCrowdstrikeAwsAuthenticationMethod = "manual"
	InputCrowdstrikeAwsAuthenticationMethodSecret InputCrowdstrikeAwsAuthenticationMethod = "secret"
)

// Defines values for InputCrowdstrikeCheckpointingEnabled.
const (
	InputCrowdstrikeCheckpointingEnabledFalse InputCrowdstrikeCheckpointingEnabled = false
	InputCrowdstrikeCheckpointingEnabledTrue  InputCrowdstrikeCheckpointingEnabled = true
)

// Defines values for InputCrowdstrikePqCompress.
const (
	InputCrowdstrikePqCompressGzip InputCrowdstrikePqCompress = "gzip"
	InputCrowdstrikePqCompressNone InputCrowdstrikePqCompress = "none"
)

// Defines values for InputCrowdstrikePqMode.
const (
	InputCrowdstrikePqModeAlways InputCrowdstrikePqMode = "always"
	InputCrowdstrikePqModeSmart  InputCrowdstrikePqMode = "smart"
)

// Defines values for InputCrowdstrikePqEnabled.
const (
	InputCrowdstrikePqEnabledFalse InputCrowdstrikePqEnabled = false
	InputCrowdstrikePqEnabledTrue  InputCrowdstrikePqEnabled = true
)

// Defines values for InputCrowdstrikePreprocessDisabled.
const (
	InputCrowdstrikePreprocessDisabledFalse InputCrowdstrikePreprocessDisabled = false
	InputCrowdstrikePreprocessDisabledTrue  InputCrowdstrikePreprocessDisabled = true
)

// Defines values for InputCrowdstrikeSendToRoutes.
const (
	InputCrowdstrikeSendToRoutesFalse InputCrowdstrikeSendToRoutes = false
	InputCrowdstrikeSendToRoutesTrue  InputCrowdstrikeSendToRoutes = true
)

// Defines values for InputCrowdstrikeSignatureVersion.
const (
	InputCrowdstrikeSignatureVersionV2 InputCrowdstrikeSignatureVersion = "v2"
	InputCrowdstrikeSignatureVersionV4 InputCrowdstrikeSignatureVersion = "v4"
)

// Defines values for InputCrowdstrikeType.
const (
	Crowdstrike InputCrowdstrikeType = "crowdstrike"
)

// Defines values for InputDatadogAgentPqCompress.
const (
	InputDatadogAgentPqCompressGzip InputDatadogAgentPqCompress = "gzip"
	InputDatadogAgentPqCompressNone InputDatadogAgentPqCompress = "none"
)

// Defines values for InputDatadogAgentPqMode.
const (
	InputDatadogAgentPqModeAlways InputDatadogAgentPqMode = "always"
	InputDatadogAgentPqModeSmart  InputDatadogAgentPqMode = "smart"
)

// Defines values for InputDatadogAgentPqEnabled.
const (
	InputDatadogAgentPqEnabledFalse InputDatadogAgentPqEnabled = false
	InputDatadogAgentPqEnabledTrue  InputDatadogAgentPqEnabled = true
)

// Defines values for InputDatadogAgentProxyModeEnabled.
const (
	InputDatadogAgentProxyModeEnabledFalse InputDatadogAgentProxyModeEnabled = false
	InputDatadogAgentProxyModeEnabledTrue  InputDatadogAgentProxyModeEnabled = true
)

// Defines values for InputDatadogAgentSendToRoutes.
const (
	InputDatadogAgentSendToRoutesFalse InputDatadogAgentSendToRoutes = false
	InputDatadogAgentSendToRoutesTrue  InputDatadogAgentSendToRoutes = true
)

// Defines values for InputDatadogAgentTlsDisabled.
const (
	InputDatadogAgentTlsDisabledFalse InputDatadogAgentTlsDisabled = false
	InputDatadogAgentTlsDisabledTrue  InputDatadogAgentTlsDisabled = true
)

// Defines values for InputDatadogAgentTlsMaxVersion.
const (
	InputDatadogAgentTlsMaxVersionTLSv1  InputDatadogAgentTlsMaxVersion = "TLSv1"
	InputDatadogAgentTlsMaxVersionTLSv11 InputDatadogAgentTlsMaxVersion = "TLSv1.1"
	InputDatadogAgentTlsMaxVersionTLSv12 InputDatadogAgentTlsMaxVersion = "TLSv1.2"
	InputDatadogAgentTlsMaxVersionTLSv13 InputDatadogAgentTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputDatadogAgentTlsMinVersion.
const (
	InputDatadogAgentTlsMinVersionTLSv1  InputDatadogAgentTlsMinVersion = "TLSv1"
	InputDatadogAgentTlsMinVersionTLSv11 InputDatadogAgentTlsMinVersion = "TLSv1.1"
	InputDatadogAgentTlsMinVersionTLSv12 InputDatadogAgentTlsMinVersion = "TLSv1.2"
	InputDatadogAgentTlsMinVersionTLSv13 InputDatadogAgentTlsMinVersion = "TLSv1.3"
)

// Defines values for InputDatadogAgentType.
const (
	DatadogAgent InputDatadogAgentType = "datadog_agent"
)

// Defines values for InputDatagenPqCompress.
const (
	InputDatagenPqCompressGzip InputDatagenPqCompress = "gzip"
	InputDatagenPqCompressNone InputDatagenPqCompress = "none"
)

// Defines values for InputDatagenPqMode.
const (
	InputDatagenPqModeAlways InputDatagenPqMode = "always"
	InputDatagenPqModeSmart  InputDatagenPqMode = "smart"
)

// Defines values for InputDatagenPqEnabled.
const (
	InputDatagenPqEnabledFalse InputDatagenPqEnabled = false
	InputDatagenPqEnabledTrue  InputDatagenPqEnabled = true
)

// Defines values for InputDatagenSendToRoutes.
const (
	InputDatagenSendToRoutesFalse InputDatagenSendToRoutes = false
	InputDatagenSendToRoutesTrue  InputDatagenSendToRoutes = true
)

// Defines values for InputDatagenType.
const (
	InputDatagenTypeAppscope             InputDatagenType = "appscope"
	InputDatagenTypeAzureBlob            InputDatagenType = "azure_blob"
	InputDatagenTypeConfluentCloud       InputDatagenType = "confluent_cloud"
	InputDatagenTypeCribl                InputDatagenType = "cribl"
	InputDatagenTypeCriblHttp            InputDatagenType = "cribl_http"
	InputDatagenTypeCriblTcp             InputDatagenType = "cribl_tcp"
	InputDatagenTypeCriblmetrics         InputDatagenType = "criblmetrics"
	InputDatagenTypeCrowdstrike          InputDatagenType = "crowdstrike"
	InputDatagenTypeDatadogAgent         InputDatagenType = "datadog_agent"
	InputDatagenTypeDatagen              InputDatagenType = "datagen"
	InputDatagenTypeEdgePrometheus       InputDatagenType = "edge_prometheus"
	InputDatagenTypeElastic              InputDatagenType = "elastic"
	InputDatagenTypeEventhub             InputDatagenType = "eventhub"
	InputDatagenTypeExec                 InputDatagenType = "exec"
	InputDatagenTypeFile                 InputDatagenType = "file"
	InputDatagenTypeFirehose             InputDatagenType = "firehose"
	InputDatagenTypeGooglePubsub         InputDatagenType = "google_pubsub"
	InputDatagenTypeGrafana              InputDatagenType = "grafana"
	InputDatagenTypeHttp                 InputDatagenType = "http"
	InputDatagenTypeHttpRaw              InputDatagenType = "http_raw"
	InputDatagenTypeJournalFiles         InputDatagenType = "journal_files"
	InputDatagenTypeKafka                InputDatagenType = "kafka"
	InputDatagenTypeKinesis              InputDatagenType = "kinesis"
	InputDatagenTypeKubeEvents           InputDatagenType = "kube_events"
	InputDatagenTypeKubeLogs             InputDatagenType = "kube_logs"
	InputDatagenTypeKubeMetrics          InputDatagenType = "kube_metrics"
	InputDatagenTypeLoki                 InputDatagenType = "loki"
	InputDatagenTypeMetrics              InputDatagenType = "metrics"
	InputDatagenTypeModelDrivenTelemetry InputDatagenType = "model_driven_telemetry"
	InputDatagenTypeMsk                  InputDatagenType = "msk"
	InputDatagenTypeNetflow              InputDatagenType = "netflow"
	InputDatagenTypeOffice365Mgmt        InputDatagenType = "office365_mgmt"
	InputDatagenTypeOffice365MsgTrace    InputDatagenType = "office365_msg_trace"
	InputDatagenTypeOffice365Service     InputDatagenType = "office365_service"
	InputDatagenTypeOpenTelemetry        InputDatagenType = "open_telemetry"
	InputDatagenTypePrometheus           InputDatagenType = "prometheus"
	InputDatagenTypePrometheusRw         InputDatagenType = "prometheus_rw"
	InputDatagenTypeRawUdp               InputDatagenType = "raw_udp"
	InputDatagenTypeS3                   InputDatagenType = "s3"
	InputDatagenTypeS3Inventory          InputDatagenType = "s3_inventory"
	InputDatagenTypeSecurityLake         InputDatagenType = "security_lake"
	InputDatagenTypeSnmp                 InputDatagenType = "snmp"
	InputDatagenTypeSplunk               InputDatagenType = "splunk"
	InputDatagenTypeSplunkHec            InputDatagenType = "splunk_hec"
	InputDatagenTypeSplunkSearch         InputDatagenType = "splunk_search"
	InputDatagenTypeSqs                  InputDatagenType = "sqs"
	InputDatagenTypeSyslog               InputDatagenType = "syslog"
	InputDatagenTypeSystemMetrics        InputDatagenType = "system_metrics"
	InputDatagenTypeSystemState          InputDatagenType = "system_state"
	InputDatagenTypeTcp                  InputDatagenType = "tcp"
	InputDatagenTypeTcpjson              InputDatagenType = "tcpjson"
	InputDatagenTypeWef                  InputDatagenType = "wef"
	InputDatagenTypeWinEventLogs         InputDatagenType = "win_event_logs"
	InputDatagenTypeWindowsMetrics       InputDatagenType = "windows_metrics"
	InputDatagenTypeWiz                  InputDatagenType = "wiz"
	InputDatagenTypeZscalerHec           InputDatagenType = "zscaler_hec"
)

// Defines values for InputEdgePrometheusAuthType.
const (
	InputEdgePrometheusAuthTypeKubernetes InputEdgePrometheusAuthType = "kubernetes"
	InputEdgePrometheusAuthTypeManual     InputEdgePrometheusAuthType = "manual"
	InputEdgePrometheusAuthTypeSecret     InputEdgePrometheusAuthType = "secret"
)

// Defines values for InputEdgePrometheusAwsAuthenticationMethod.
const (
	InputEdgePrometheusAwsAuthenticationMethodAuto   InputEdgePrometheusAwsAuthenticationMethod = "auto"
	InputEdgePrometheusAwsAuthenticationMethodManual InputEdgePrometheusAwsAuthenticationMethod = "manual"
	InputEdgePrometheusAwsAuthenticationMethodSecret InputEdgePrometheusAwsAuthenticationMethod = "secret"
)

// Defines values for InputEdgePrometheusDiscoveryType.
const (
	InputEdgePrometheusDiscoveryTypeDns     InputEdgePrometheusDiscoveryType = "dns"
	InputEdgePrometheusDiscoveryTypeEc2     InputEdgePrometheusDiscoveryType = "ec2"
	InputEdgePrometheusDiscoveryTypeK8sNode InputEdgePrometheusDiscoveryType = "k8s-node"
	InputEdgePrometheusDiscoveryTypeK8sPods InputEdgePrometheusDiscoveryType = "k8s-pods"
	InputEdgePrometheusDiscoveryTypeStatic  InputEdgePrometheusDiscoveryType = "static"
)

// Defines values for InputEdgePrometheusPersistenceCompress.
const (
	InputEdgePrometheusPersistenceCompressGzip InputEdgePrometheusPersistenceCompress = "gzip"
	InputEdgePrometheusPersistenceCompressNone InputEdgePrometheusPersistenceCompress = "none"
)

// Defines values for InputEdgePrometheusPersistenceEnable.
const (
	InputEdgePrometheusPersistenceEnableFalse InputEdgePrometheusPersistenceEnable = false
	InputEdgePrometheusPersistenceEnableTrue  InputEdgePrometheusPersistenceEnable = true
)

// Defines values for InputEdgePrometheusPqCompress.
const (
	InputEdgePrometheusPqCompressGzip InputEdgePrometheusPqCompress = "gzip"
	InputEdgePrometheusPqCompressNone InputEdgePrometheusPqCompress = "none"
)

// Defines values for InputEdgePrometheusPqMode.
const (
	InputEdgePrometheusPqModeAlways InputEdgePrometheusPqMode = "always"
	InputEdgePrometheusPqModeSmart  InputEdgePrometheusPqMode = "smart"
)

// Defines values for InputEdgePrometheusPqEnabled.
const (
	InputEdgePrometheusPqEnabledFalse InputEdgePrometheusPqEnabled = false
	InputEdgePrometheusPqEnabledTrue  InputEdgePrometheusPqEnabled = true
)

// Defines values for InputEdgePrometheusRecordType.
const (
	InputEdgePrometheusRecordTypeA    InputEdgePrometheusRecordType = "A"
	InputEdgePrometheusRecordTypeAAAA InputEdgePrometheusRecordType = "AAAA"
	InputEdgePrometheusRecordTypeSRV  InputEdgePrometheusRecordType = "SRV"
)

// Defines values for InputEdgePrometheusScrapeProtocol.
const (
	InputEdgePrometheusScrapeProtocolHttp  InputEdgePrometheusScrapeProtocol = "http"
	InputEdgePrometheusScrapeProtocolHttps InputEdgePrometheusScrapeProtocol = "https"
)

// Defines values for InputEdgePrometheusSendToRoutes.
const (
	InputEdgePrometheusSendToRoutesFalse InputEdgePrometheusSendToRoutes = false
	InputEdgePrometheusSendToRoutesTrue  InputEdgePrometheusSendToRoutes = true
)

// Defines values for InputEdgePrometheusSignatureVersion.
const (
	InputEdgePrometheusSignatureVersionV2 InputEdgePrometheusSignatureVersion = "v2"
	InputEdgePrometheusSignatureVersionV4 InputEdgePrometheusSignatureVersion = "v4"
)

// Defines values for InputEdgePrometheusTargetsProtocol.
const (
	InputEdgePrometheusTargetsProtocolHttp  InputEdgePrometheusTargetsProtocol = "http"
	InputEdgePrometheusTargetsProtocolHttps InputEdgePrometheusTargetsProtocol = "https"
)

// Defines values for InputEdgePrometheusType.
const (
	EdgePrometheus InputEdgePrometheusType = "edge_prometheus"
)

// Defines values for InputElasticApiVersion.
const (
	InputElasticApiVersionCustom InputElasticApiVersion = "custom"
	InputElasticApiVersionN684   InputElasticApiVersion = "6.8.4"
	InputElasticApiVersionN832   InputElasticApiVersion = "8.3.2"
)

// Defines values for InputElasticAuthType.
const (
	InputElasticAuthTypeAuthTokens        InputElasticAuthType = "authTokens"
	InputElasticAuthTypeBasic             InputElasticAuthType = "basic"
	InputElasticAuthTypeCredentialsSecret InputElasticAuthType = "credentialsSecret"
	InputElasticAuthTypeNone              InputElasticAuthType = "none"
)

// Defines values for InputElasticPqCompress.
const (
	InputElasticPqCompressGzip InputElasticPqCompress = "gzip"
	InputElasticPqCompressNone InputElasticPqCompress = "none"
)

// Defines values for InputElasticPqMode.
const (
	InputElasticPqModeAlways InputElasticPqMode = "always"
	InputElasticPqModeSmart  InputElasticPqMode = "smart"
)

// Defines values for InputElasticPqEnabled.
const (
	InputElasticPqEnabledFalse InputElasticPqEnabled = false
	InputElasticPqEnabledTrue  InputElasticPqEnabled = true
)

// Defines values for InputElasticProxyModeAuthType.
const (
	InputElasticProxyModeAuthTypeManual InputElasticProxyModeAuthType = "manual"
	InputElasticProxyModeAuthTypeNone   InputElasticProxyModeAuthType = "none"
	InputElasticProxyModeAuthTypeSecret InputElasticProxyModeAuthType = "secret"
)

// Defines values for InputElasticProxyModeEnabled.
const (
	InputElasticProxyModeEnabledFalse InputElasticProxyModeEnabled = false
	InputElasticProxyModeEnabledTrue  InputElasticProxyModeEnabled = true
)

// Defines values for InputElasticSendToRoutes.
const (
	InputElasticSendToRoutesFalse InputElasticSendToRoutes = false
	InputElasticSendToRoutesTrue  InputElasticSendToRoutes = true
)

// Defines values for InputElasticTlsDisabled.
const (
	InputElasticTlsDisabledFalse InputElasticTlsDisabled = false
	InputElasticTlsDisabledTrue  InputElasticTlsDisabled = true
)

// Defines values for InputElasticTlsMaxVersion.
const (
	InputElasticTlsMaxVersionTLSv1  InputElasticTlsMaxVersion = "TLSv1"
	InputElasticTlsMaxVersionTLSv11 InputElasticTlsMaxVersion = "TLSv1.1"
	InputElasticTlsMaxVersionTLSv12 InputElasticTlsMaxVersion = "TLSv1.2"
	InputElasticTlsMaxVersionTLSv13 InputElasticTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputElasticTlsMinVersion.
const (
	InputElasticTlsMinVersionTLSv1  InputElasticTlsMinVersion = "TLSv1"
	InputElasticTlsMinVersionTLSv11 InputElasticTlsMinVersion = "TLSv1.1"
	InputElasticTlsMinVersionTLSv12 InputElasticTlsMinVersion = "TLSv1.2"
	InputElasticTlsMinVersionTLSv13 InputElasticTlsMinVersion = "TLSv1.3"
)

// Defines values for InputElasticType.
const (
	InputElasticTypeElastic InputElasticType = "elastic"
)

// Defines values for InputEventhubPqCompress.
const (
	InputEventhubPqCompressGzip InputEventhubPqCompress = "gzip"
	InputEventhubPqCompressNone InputEventhubPqCompress = "none"
)

// Defines values for InputEventhubPqMode.
const (
	InputEventhubPqModeAlways InputEventhubPqMode = "always"
	InputEventhubPqModeSmart  InputEventhubPqMode = "smart"
)

// Defines values for InputEventhubPqEnabled.
const (
	InputEventhubPqEnabledFalse InputEventhubPqEnabled = false
	InputEventhubPqEnabledTrue  InputEventhubPqEnabled = true
)

// Defines values for InputEventhubSaslDisabled.
const (
	InputEventhubSaslDisabledFalse InputEventhubSaslDisabled = false
	InputEventhubSaslDisabledTrue  InputEventhubSaslDisabled = true
)

// Defines values for InputEventhubSaslMechanism.
const (
	InputEventhubSaslMechanismOauthbearer InputEventhubSaslMechanism = "oauthbearer"
	InputEventhubSaslMechanismPlain       InputEventhubSaslMechanism = "plain"
)

// Defines values for InputEventhubSendToRoutes.
const (
	InputEventhubSendToRoutesFalse InputEventhubSendToRoutes = false
	InputEventhubSendToRoutesTrue  InputEventhubSendToRoutes = true
)

// Defines values for InputEventhubTlsDisabled.
const (
	InputEventhubTlsDisabledFalse InputEventhubTlsDisabled = false
	InputEventhubTlsDisabledTrue  InputEventhubTlsDisabled = true
)

// Defines values for InputEventhubType.
const (
	Eventhub InputEventhubType = "eventhub"
)

// Defines values for InputExecPqCompress.
const (
	InputExecPqCompressGzip InputExecPqCompress = "gzip"
	InputExecPqCompressNone InputExecPqCompress = "none"
)

// Defines values for InputExecPqMode.
const (
	InputExecPqModeAlways InputExecPqMode = "always"
	InputExecPqModeSmart  InputExecPqMode = "smart"
)

// Defines values for InputExecPqEnabled.
const (
	InputExecPqEnabledFalse InputExecPqEnabled = false
	InputExecPqEnabledTrue  InputExecPqEnabled = true
)

// Defines values for InputExecScheduleType.
const (
	CronSchedule InputExecScheduleType = "cronSchedule"
	Interval     InputExecScheduleType = "interval"
)

// Defines values for InputExecSendToRoutes.
const (
	InputExecSendToRoutesFalse InputExecSendToRoutes = false
	InputExecSendToRoutesTrue  InputExecSendToRoutes = true
)

// Defines values for InputFileForceText.
const (
	InputFileForceTextFalse InputFileForceText = false
	InputFileForceTextTrue  InputFileForceText = true
)

// Defines values for InputFileMode.
const (
	InputFileModeAuto   InputFileMode = "auto"
	InputFileModeManual InputFileMode = "manual"
)

// Defines values for InputFilePqCompress.
const (
	InputFilePqCompressGzip InputFilePqCompress = "gzip"
	InputFilePqCompressNone InputFilePqCompress = "none"
)

// Defines values for InputFilePqMode.
const (
	InputFilePqModeAlways InputFilePqMode = "always"
	InputFilePqModeSmart  InputFilePqMode = "smart"
)

// Defines values for InputFilePqEnabled.
const (
	InputFilePqEnabledFalse InputFilePqEnabled = false
	InputFilePqEnabledTrue  InputFilePqEnabled = true
)

// Defines values for InputFileSendToRoutes.
const (
	InputFileSendToRoutesFalse InputFileSendToRoutes = false
	InputFileSendToRoutesTrue  InputFileSendToRoutes = true
)

// Defines values for InputFirehosePqCompress.
const (
	InputFirehosePqCompressGzip InputFirehosePqCompress = "gzip"
	InputFirehosePqCompressNone InputFirehosePqCompress = "none"
)

// Defines values for InputFirehosePqMode.
const (
	InputFirehosePqModeAlways InputFirehosePqMode = "always"
	InputFirehosePqModeSmart  InputFirehosePqMode = "smart"
)

// Defines values for InputFirehosePqEnabled.
const (
	InputFirehosePqEnabledFalse InputFirehosePqEnabled = false
	InputFirehosePqEnabledTrue  InputFirehosePqEnabled = true
)

// Defines values for InputFirehoseSendToRoutes.
const (
	InputFirehoseSendToRoutesFalse InputFirehoseSendToRoutes = false
	InputFirehoseSendToRoutesTrue  InputFirehoseSendToRoutes = true
)

// Defines values for InputFirehoseTlsDisabled.
const (
	InputFirehoseTlsDisabledFalse InputFirehoseTlsDisabled = false
	InputFirehoseTlsDisabledTrue  InputFirehoseTlsDisabled = true
)

// Defines values for InputFirehoseTlsMaxVersion.
const (
	InputFirehoseTlsMaxVersionTLSv1  InputFirehoseTlsMaxVersion = "TLSv1"
	InputFirehoseTlsMaxVersionTLSv11 InputFirehoseTlsMaxVersion = "TLSv1.1"
	InputFirehoseTlsMaxVersionTLSv12 InputFirehoseTlsMaxVersion = "TLSv1.2"
	InputFirehoseTlsMaxVersionTLSv13 InputFirehoseTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputFirehoseTlsMinVersion.
const (
	InputFirehoseTlsMinVersionTLSv1  InputFirehoseTlsMinVersion = "TLSv1"
	InputFirehoseTlsMinVersionTLSv11 InputFirehoseTlsMinVersion = "TLSv1.1"
	InputFirehoseTlsMinVersionTLSv12 InputFirehoseTlsMinVersion = "TLSv1.2"
	InputFirehoseTlsMinVersionTLSv13 InputFirehoseTlsMinVersion = "TLSv1.3"
)

// Defines values for InputFirehoseType.
const (
	Firehose InputFirehoseType = "firehose"
)

// Defines values for InputGooglePubsubCreateSubscription.
const (
	InputGooglePubsubCreateSubscriptionFalse InputGooglePubsubCreateSubscription = false
	InputGooglePubsubCreateSubscriptionTrue  InputGooglePubsubCreateSubscription = true
)

// Defines values for InputGooglePubsubGoogleAuthMethod.
const (
	InputGooglePubsubGoogleAuthMethodAuto   InputGooglePubsubGoogleAuthMethod = "auto"
	InputGooglePubsubGoogleAuthMethodManual InputGooglePubsubGoogleAuthMethod = "manual"
	InputGooglePubsubGoogleAuthMethodSecret InputGooglePubsubGoogleAuthMethod = "secret"
)

// Defines values for InputGooglePubsubPqCompress.
const (
	InputGooglePubsubPqCompressGzip InputGooglePubsubPqCompress = "gzip"
	InputGooglePubsubPqCompressNone InputGooglePubsubPqCompress = "none"
)

// Defines values for InputGooglePubsubPqMode.
const (
	InputGooglePubsubPqModeAlways InputGooglePubsubPqMode = "always"
	InputGooglePubsubPqModeSmart  InputGooglePubsubPqMode = "smart"
)

// Defines values for InputGooglePubsubPqEnabled.
const (
	InputGooglePubsubPqEnabledFalse InputGooglePubsubPqEnabled = false
	InputGooglePubsubPqEnabledTrue  InputGooglePubsubPqEnabled = true
)

// Defines values for InputGooglePubsubSendToRoutes.
const (
	InputGooglePubsubSendToRoutesFalse InputGooglePubsubSendToRoutes = false
	InputGooglePubsubSendToRoutesTrue  InputGooglePubsubSendToRoutes = true
)

// Defines values for InputGooglePubsubType.
const (
	InputGooglePubsubTypeGooglePubsub InputGooglePubsubType = "google_pubsub"
)

// Defines values for InputGrafanaLokiAuthAuthType.
const (
	InputGrafanaLokiAuthAuthTypeBasic             InputGrafanaLokiAuthAuthType = "basic"
	InputGrafanaLokiAuthAuthTypeCredentialsSecret InputGrafanaLokiAuthAuthType = "credentialsSecret"
	InputGrafanaLokiAuthAuthTypeNone              InputGrafanaLokiAuthAuthType = "none"
	InputGrafanaLokiAuthAuthTypeOauth             InputGrafanaLokiAuthAuthType = "oauth"
	InputGrafanaLokiAuthAuthTypeTextSecret        InputGrafanaLokiAuthAuthType = "textSecret"
	InputGrafanaLokiAuthAuthTypeToken             InputGrafanaLokiAuthAuthType = "token"
)

// Defines values for InputGrafanaPqCompress.
const (
	InputGrafanaPqCompressGzip InputGrafanaPqCompress = "gzip"
	InputGrafanaPqCompressNone InputGrafanaPqCompress = "none"
)

// Defines values for InputGrafanaPqMode.
const (
	InputGrafanaPqModeAlways InputGrafanaPqMode = "always"
	InputGrafanaPqModeSmart  InputGrafanaPqMode = "smart"
)

// Defines values for InputGrafanaPqEnabled.
const (
	InputGrafanaPqEnabledFalse InputGrafanaPqEnabled = false
	InputGrafanaPqEnabledTrue  InputGrafanaPqEnabled = true
)

// Defines values for InputGrafanaPrometheusAuthAuthType.
const (
	InputGrafanaPrometheusAuthAuthTypeBasic             InputGrafanaPrometheusAuthAuthType = "basic"
	InputGrafanaPrometheusAuthAuthTypeCredentialsSecret InputGrafanaPrometheusAuthAuthType = "credentialsSecret"
	InputGrafanaPrometheusAuthAuthTypeNone              InputGrafanaPrometheusAuthAuthType = "none"
	InputGrafanaPrometheusAuthAuthTypeOauth             InputGrafanaPrometheusAuthAuthType = "oauth"
	InputGrafanaPrometheusAuthAuthTypeTextSecret        InputGrafanaPrometheusAuthAuthType = "textSecret"
	InputGrafanaPrometheusAuthAuthTypeToken             InputGrafanaPrometheusAuthAuthType = "token"
)

// Defines values for InputGrafanaSendToRoutes.
const (
	InputGrafanaSendToRoutesFalse InputGrafanaSendToRoutes = false
	InputGrafanaSendToRoutesTrue  InputGrafanaSendToRoutes = true
)

// Defines values for InputGrafanaTlsDisabled.
const (
	InputGrafanaTlsDisabledFalse InputGrafanaTlsDisabled = false
	InputGrafanaTlsDisabledTrue  InputGrafanaTlsDisabled = true
)

// Defines values for InputGrafanaTlsMaxVersion.
const (
	InputGrafanaTlsMaxVersionTLSv1  InputGrafanaTlsMaxVersion = "TLSv1"
	InputGrafanaTlsMaxVersionTLSv11 InputGrafanaTlsMaxVersion = "TLSv1.1"
	InputGrafanaTlsMaxVersionTLSv12 InputGrafanaTlsMaxVersion = "TLSv1.2"
	InputGrafanaTlsMaxVersionTLSv13 InputGrafanaTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputGrafanaTlsMinVersion.
const (
	InputGrafanaTlsMinVersionTLSv1  InputGrafanaTlsMinVersion = "TLSv1"
	InputGrafanaTlsMinVersionTLSv11 InputGrafanaTlsMinVersion = "TLSv1.1"
	InputGrafanaTlsMinVersionTLSv12 InputGrafanaTlsMinVersion = "TLSv1.2"
	InputGrafanaTlsMinVersionTLSv13 InputGrafanaTlsMinVersion = "TLSv1.3"
)

// Defines values for InputGrafanaType.
const (
	Grafana InputGrafanaType = "grafana"
)

// Defines values for InputHttpPqCompress.
const (
	InputHttpPqCompressGzip InputHttpPqCompress = "gzip"
	InputHttpPqCompressNone InputHttpPqCompress = "none"
)

// Defines values for InputHttpPqMode.
const (
	InputHttpPqModeAlways InputHttpPqMode = "always"
	InputHttpPqModeSmart  InputHttpPqMode = "smart"
)

// Defines values for InputHttpPqEnabled.
const (
	InputHttpPqEnabledFalse InputHttpPqEnabled = false
	InputHttpPqEnabledTrue  InputHttpPqEnabled = true
)

// Defines values for InputHttpSendToRoutes.
const (
	InputHttpSendToRoutesFalse InputHttpSendToRoutes = false
	InputHttpSendToRoutesTrue  InputHttpSendToRoutes = true
)

// Defines values for InputHttpTlsDisabled.
const (
	InputHttpTlsDisabledFalse InputHttpTlsDisabled = false
	InputHttpTlsDisabledTrue  InputHttpTlsDisabled = true
)

// Defines values for InputHttpTlsMaxVersion.
const (
	InputHttpTlsMaxVersionTLSv1  InputHttpTlsMaxVersion = "TLSv1"
	InputHttpTlsMaxVersionTLSv11 InputHttpTlsMaxVersion = "TLSv1.1"
	InputHttpTlsMaxVersionTLSv12 InputHttpTlsMaxVersion = "TLSv1.2"
	InputHttpTlsMaxVersionTLSv13 InputHttpTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputHttpTlsMinVersion.
const (
	InputHttpTlsMinVersionTLSv1  InputHttpTlsMinVersion = "TLSv1"
	InputHttpTlsMinVersionTLSv11 InputHttpTlsMinVersion = "TLSv1.1"
	InputHttpTlsMinVersionTLSv12 InputHttpTlsMinVersion = "TLSv1.2"
	InputHttpTlsMinVersionTLSv13 InputHttpTlsMinVersion = "TLSv1.3"
)

// Defines values for InputHttpType.
const (
	InputHttpTypeHttp InputHttpType = "http"
)

// Defines values for InputHttpRawPqCompress.
const (
	InputHttpRawPqCompressGzip InputHttpRawPqCompress = "gzip"
	InputHttpRawPqCompressNone InputHttpRawPqCompress = "none"
)

// Defines values for InputHttpRawPqMode.
const (
	InputHttpRawPqModeAlways InputHttpRawPqMode = "always"
	InputHttpRawPqModeSmart  InputHttpRawPqMode = "smart"
)

// Defines values for InputHttpRawPqEnabled.
const (
	InputHttpRawPqEnabledFalse InputHttpRawPqEnabled = false
	InputHttpRawPqEnabledTrue  InputHttpRawPqEnabled = true
)

// Defines values for InputHttpRawSendToRoutes.
const (
	InputHttpRawSendToRoutesFalse InputHttpRawSendToRoutes = false
	InputHttpRawSendToRoutesTrue  InputHttpRawSendToRoutes = true
)

// Defines values for InputHttpRawTlsDisabled.
const (
	InputHttpRawTlsDisabledFalse InputHttpRawTlsDisabled = false
	InputHttpRawTlsDisabledTrue  InputHttpRawTlsDisabled = true
)

// Defines values for InputHttpRawTlsMaxVersion.
const (
	InputHttpRawTlsMaxVersionTLSv1  InputHttpRawTlsMaxVersion = "TLSv1"
	InputHttpRawTlsMaxVersionTLSv11 InputHttpRawTlsMaxVersion = "TLSv1.1"
	InputHttpRawTlsMaxVersionTLSv12 InputHttpRawTlsMaxVersion = "TLSv1.2"
	InputHttpRawTlsMaxVersionTLSv13 InputHttpRawTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputHttpRawTlsMinVersion.
const (
	InputHttpRawTlsMinVersionTLSv1  InputHttpRawTlsMinVersion = "TLSv1"
	InputHttpRawTlsMinVersionTLSv11 InputHttpRawTlsMinVersion = "TLSv1.1"
	InputHttpRawTlsMinVersionTLSv12 InputHttpRawTlsMinVersion = "TLSv1.2"
	InputHttpRawTlsMinVersionTLSv13 InputHttpRawTlsMinVersion = "TLSv1.3"
)

// Defines values for InputHttpRawType.
const (
	HttpRaw InputHttpRawType = "http_raw"
)

// Defines values for InputJournalFilesPqCompress.
const (
	InputJournalFilesPqCompressGzip InputJournalFilesPqCompress = "gzip"
	InputJournalFilesPqCompressNone InputJournalFilesPqCompress = "none"
)

// Defines values for InputJournalFilesPqMode.
const (
	InputJournalFilesPqModeAlways InputJournalFilesPqMode = "always"
	InputJournalFilesPqModeSmart  InputJournalFilesPqMode = "smart"
)

// Defines values for InputJournalFilesPqEnabled.
const (
	InputJournalFilesPqEnabledFalse InputJournalFilesPqEnabled = false
	InputJournalFilesPqEnabledTrue  InputJournalFilesPqEnabled = true
)

// Defines values for InputJournalFilesSendToRoutes.
const (
	InputJournalFilesSendToRoutesFalse InputJournalFilesSendToRoutes = false
	InputJournalFilesSendToRoutesTrue  InputJournalFilesSendToRoutes = true
)

// Defines values for InputKafkaKafkaSchemaRegistryAuthDisabled.
const (
	InputKafkaKafkaSchemaRegistryAuthDisabledFalse InputKafkaKafkaSchemaRegistryAuthDisabled = false
	InputKafkaKafkaSchemaRegistryAuthDisabledTrue  InputKafkaKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for InputKafkaKafkaSchemaRegistryDisabled.
const (
	InputKafkaKafkaSchemaRegistryDisabledFalse InputKafkaKafkaSchemaRegistryDisabled = false
	InputKafkaKafkaSchemaRegistryDisabledTrue  InputKafkaKafkaSchemaRegistryDisabled = true
)

// Defines values for InputKafkaKafkaSchemaRegistryTlsDisabled.
const (
	InputKafkaKafkaSchemaRegistryTlsDisabledFalse InputKafkaKafkaSchemaRegistryTlsDisabled = false
	InputKafkaKafkaSchemaRegistryTlsDisabledTrue  InputKafkaKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for InputKafkaKafkaSchemaRegistryTlsMaxVersion.
const (
	InputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv1  InputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	InputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv11 InputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	InputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv12 InputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	InputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv13 InputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputKafkaKafkaSchemaRegistryTlsMinVersion.
const (
	InputKafkaKafkaSchemaRegistryTlsMinVersionTLSv1  InputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	InputKafkaKafkaSchemaRegistryTlsMinVersionTLSv11 InputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	InputKafkaKafkaSchemaRegistryTlsMinVersionTLSv12 InputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	InputKafkaKafkaSchemaRegistryTlsMinVersionTLSv13 InputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for InputKafkaPqCompress.
const (
	InputKafkaPqCompressGzip InputKafkaPqCompress = "gzip"
	InputKafkaPqCompressNone InputKafkaPqCompress = "none"
)

// Defines values for InputKafkaPqMode.
const (
	InputKafkaPqModeAlways InputKafkaPqMode = "always"
	InputKafkaPqModeSmart  InputKafkaPqMode = "smart"
)

// Defines values for InputKafkaPqEnabled.
const (
	InputKafkaPqEnabledFalse InputKafkaPqEnabled = false
	InputKafkaPqEnabledTrue  InputKafkaPqEnabled = true
)

// Defines values for InputKafkaSaslDisabled.
const (
	InputKafkaSaslDisabledFalse InputKafkaSaslDisabled = false
	InputKafkaSaslDisabledTrue  InputKafkaSaslDisabled = true
)

// Defines values for InputKafkaSaslMechanism.
const (
	InputKafkaSaslMechanismKerberos    InputKafkaSaslMechanism = "kerberos"
	InputKafkaSaslMechanismPlain       InputKafkaSaslMechanism = "plain"
	InputKafkaSaslMechanismScramSha256 InputKafkaSaslMechanism = "scram-sha-256"
	InputKafkaSaslMechanismScramSha512 InputKafkaSaslMechanism = "scram-sha-512"
)

// Defines values for InputKafkaSendToRoutes.
const (
	InputKafkaSendToRoutesFalse InputKafkaSendToRoutes = false
	InputKafkaSendToRoutesTrue  InputKafkaSendToRoutes = true
)

// Defines values for InputKafkaTlsDisabled.
const (
	InputKafkaTlsDisabledFalse InputKafkaTlsDisabled = false
	InputKafkaTlsDisabledTrue  InputKafkaTlsDisabled = true
)

// Defines values for InputKafkaTlsMaxVersion.
const (
	InputKafkaTlsMaxVersionTLSv1  InputKafkaTlsMaxVersion = "TLSv1"
	InputKafkaTlsMaxVersionTLSv11 InputKafkaTlsMaxVersion = "TLSv1.1"
	InputKafkaTlsMaxVersionTLSv12 InputKafkaTlsMaxVersion = "TLSv1.2"
	InputKafkaTlsMaxVersionTLSv13 InputKafkaTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputKafkaTlsMinVersion.
const (
	InputKafkaTlsMinVersionTLSv1  InputKafkaTlsMinVersion = "TLSv1"
	InputKafkaTlsMinVersionTLSv11 InputKafkaTlsMinVersion = "TLSv1.1"
	InputKafkaTlsMinVersionTLSv12 InputKafkaTlsMinVersion = "TLSv1.2"
	InputKafkaTlsMinVersionTLSv13 InputKafkaTlsMinVersion = "TLSv1.3"
)

// Defines values for InputKafkaType.
const (
	InputKafkaTypeKafka InputKafkaType = "kafka"
)

// Defines values for InputKinesisAwsAuthenticationMethod.
const (
	InputKinesisAwsAuthenticationMethodAuto   InputKinesisAwsAuthenticationMethod = "auto"
	InputKinesisAwsAuthenticationMethodManual InputKinesisAwsAuthenticationMethod = "manual"
	InputKinesisAwsAuthenticationMethodSecret InputKinesisAwsAuthenticationMethod = "secret"
)

// Defines values for InputKinesisLoadBalancingAlgorithm.
const (
	ConsistentHashing InputKinesisLoadBalancingAlgorithm = "ConsistentHashing"
	RoundRobin        InputKinesisLoadBalancingAlgorithm = "RoundRobin"
)

// Defines values for InputKinesisPayloadFormat.
const (
	InputKinesisPayloadFormatCloudwatch InputKinesisPayloadFormat = "cloudwatch"
	InputKinesisPayloadFormatCribl      InputKinesisPayloadFormat = "cribl"
	InputKinesisPayloadFormatLine       InputKinesisPayloadFormat = "line"
	InputKinesisPayloadFormatNdjson     InputKinesisPayloadFormat = "ndjson"
)

// Defines values for InputKinesisPqCompress.
const (
	InputKinesisPqCompressGzip InputKinesisPqCompress = "gzip"
	InputKinesisPqCompressNone InputKinesisPqCompress = "none"
)

// Defines values for InputKinesisPqMode.
const (
	InputKinesisPqModeAlways InputKinesisPqMode = "always"
	InputKinesisPqModeSmart  InputKinesisPqMode = "smart"
)

// Defines values for InputKinesisPqEnabled.
const (
	InputKinesisPqEnabledFalse InputKinesisPqEnabled = false
	InputKinesisPqEnabledTrue  InputKinesisPqEnabled = true
)

// Defines values for InputKinesisSendToRoutes.
const (
	InputKinesisSendToRoutesFalse InputKinesisSendToRoutes = false
	InputKinesisSendToRoutesTrue  InputKinesisSendToRoutes = true
)

// Defines values for InputKinesisShardIteratorType.
const (
	LATEST      InputKinesisShardIteratorType = "LATEST"
	TRIMHORIZON InputKinesisShardIteratorType = "TRIM_HORIZON"
)

// Defines values for InputKinesisSignatureVersion.
const (
	InputKinesisSignatureVersionV2 InputKinesisSignatureVersion = "v2"
	InputKinesisSignatureVersionV4 InputKinesisSignatureVersion = "v4"
)

// Defines values for InputKinesisType.
const (
	InputKinesisTypeKinesis InputKinesisType = "kinesis"
)

// Defines values for InputKubeEventsPqCompress.
const (
	InputKubeEventsPqCompressGzip InputKubeEventsPqCompress = "gzip"
	InputKubeEventsPqCompressNone InputKubeEventsPqCompress = "none"
)

// Defines values for InputKubeEventsPqMode.
const (
	InputKubeEventsPqModeAlways InputKubeEventsPqMode = "always"
	InputKubeEventsPqModeSmart  InputKubeEventsPqMode = "smart"
)

// Defines values for InputKubeEventsPqEnabled.
const (
	InputKubeEventsPqEnabledFalse InputKubeEventsPqEnabled = false
	InputKubeEventsPqEnabledTrue  InputKubeEventsPqEnabled = true
)

// Defines values for InputKubeEventsSendToRoutes.
const (
	InputKubeEventsSendToRoutesFalse InputKubeEventsSendToRoutes = false
	InputKubeEventsSendToRoutesTrue  InputKubeEventsSendToRoutes = true
)

// Defines values for InputKubeEventsType.
const (
	KubeEvents InputKubeEventsType = "kube_events"
)

// Defines values for InputKubeLogsPersistenceCompress.
const (
	InputKubeLogsPersistenceCompressGzip InputKubeLogsPersistenceCompress = "gzip"
	InputKubeLogsPersistenceCompressNone InputKubeLogsPersistenceCompress = "none"
)

// Defines values for InputKubeLogsPersistenceEnable.
const (
	InputKubeLogsPersistenceEnableFalse InputKubeLogsPersistenceEnable = false
	InputKubeLogsPersistenceEnableTrue  InputKubeLogsPersistenceEnable = true
)

// Defines values for InputKubeLogsPqCompress.
const (
	InputKubeLogsPqCompressGzip InputKubeLogsPqCompress = "gzip"
	InputKubeLogsPqCompressNone InputKubeLogsPqCompress = "none"
)

// Defines values for InputKubeLogsPqMode.
const (
	InputKubeLogsPqModeAlways InputKubeLogsPqMode = "always"
	InputKubeLogsPqModeSmart  InputKubeLogsPqMode = "smart"
)

// Defines values for InputKubeLogsPqEnabled.
const (
	InputKubeLogsPqEnabledFalse InputKubeLogsPqEnabled = false
	InputKubeLogsPqEnabledTrue  InputKubeLogsPqEnabled = true
)

// Defines values for InputKubeLogsSendToRoutes.
const (
	InputKubeLogsSendToRoutesFalse InputKubeLogsSendToRoutes = false
	InputKubeLogsSendToRoutesTrue  InputKubeLogsSendToRoutes = true
)

// Defines values for InputKubeLogsType.
const (
	KubeLogs InputKubeLogsType = "kube_logs"
)

// Defines values for InputKubeMetricsPersistenceCompress.
const (
	InputKubeMetricsPersistenceCompressGzip InputKubeMetricsPersistenceCompress = "gzip"
	InputKubeMetricsPersistenceCompressNone InputKubeMetricsPersistenceCompress = "none"
)

// Defines values for InputKubeMetricsPersistenceEnable.
const (
	InputKubeMetricsPersistenceEnableFalse InputKubeMetricsPersistenceEnable = false
	InputKubeMetricsPersistenceEnableTrue  InputKubeMetricsPersistenceEnable = true
)

// Defines values for InputKubeMetricsPqCompress.
const (
	InputKubeMetricsPqCompressGzip InputKubeMetricsPqCompress = "gzip"
	InputKubeMetricsPqCompressNone InputKubeMetricsPqCompress = "none"
)

// Defines values for InputKubeMetricsPqMode.
const (
	InputKubeMetricsPqModeAlways InputKubeMetricsPqMode = "always"
	InputKubeMetricsPqModeSmart  InputKubeMetricsPqMode = "smart"
)

// Defines values for InputKubeMetricsPqEnabled.
const (
	InputKubeMetricsPqEnabledFalse InputKubeMetricsPqEnabled = false
	InputKubeMetricsPqEnabledTrue  InputKubeMetricsPqEnabled = true
)

// Defines values for InputKubeMetricsSendToRoutes.
const (
	InputKubeMetricsSendToRoutesFalse InputKubeMetricsSendToRoutes = false
	InputKubeMetricsSendToRoutesTrue  InputKubeMetricsSendToRoutes = true
)

// Defines values for InputKubeMetricsType.
const (
	KubeMetrics InputKubeMetricsType = "kube_metrics"
)

// Defines values for InputLokiAuthType.
const (
	InputLokiAuthTypeBasic             InputLokiAuthType = "basic"
	InputLokiAuthTypeCredentialsSecret InputLokiAuthType = "credentialsSecret"
	InputLokiAuthTypeNone              InputLokiAuthType = "none"
	InputLokiAuthTypeOauth             InputLokiAuthType = "oauth"
	InputLokiAuthTypeTextSecret        InputLokiAuthType = "textSecret"
	InputLokiAuthTypeToken             InputLokiAuthType = "token"
)

// Defines values for InputLokiPqCompress.
const (
	InputLokiPqCompressGzip InputLokiPqCompress = "gzip"
	InputLokiPqCompressNone InputLokiPqCompress = "none"
)

// Defines values for InputLokiPqMode.
const (
	InputLokiPqModeAlways InputLokiPqMode = "always"
	InputLokiPqModeSmart  InputLokiPqMode = "smart"
)

// Defines values for InputLokiPqEnabled.
const (
	InputLokiPqEnabledFalse InputLokiPqEnabled = false
	InputLokiPqEnabledTrue  InputLokiPqEnabled = true
)

// Defines values for InputLokiSendToRoutes.
const (
	InputLokiSendToRoutesFalse InputLokiSendToRoutes = false
	InputLokiSendToRoutesTrue  InputLokiSendToRoutes = true
)

// Defines values for InputLokiTlsDisabled.
const (
	InputLokiTlsDisabledFalse InputLokiTlsDisabled = false
	InputLokiTlsDisabledTrue  InputLokiTlsDisabled = true
)

// Defines values for InputLokiTlsMaxVersion.
const (
	InputLokiTlsMaxVersionTLSv1  InputLokiTlsMaxVersion = "TLSv1"
	InputLokiTlsMaxVersionTLSv11 InputLokiTlsMaxVersion = "TLSv1.1"
	InputLokiTlsMaxVersionTLSv12 InputLokiTlsMaxVersion = "TLSv1.2"
	InputLokiTlsMaxVersionTLSv13 InputLokiTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputLokiTlsMinVersion.
const (
	InputLokiTlsMinVersionTLSv1  InputLokiTlsMinVersion = "TLSv1"
	InputLokiTlsMinVersionTLSv11 InputLokiTlsMinVersion = "TLSv1.1"
	InputLokiTlsMinVersionTLSv12 InputLokiTlsMinVersion = "TLSv1.2"
	InputLokiTlsMinVersionTLSv13 InputLokiTlsMinVersion = "TLSv1.3"
)

// Defines values for InputLokiType.
const (
	InputLokiTypeLoki InputLokiType = "loki"
)

// Defines values for InputMetricsPqCompress.
const (
	InputMetricsPqCompressGzip InputMetricsPqCompress = "gzip"
	InputMetricsPqCompressNone InputMetricsPqCompress = "none"
)

// Defines values for InputMetricsPqMode.
const (
	InputMetricsPqModeAlways InputMetricsPqMode = "always"
	InputMetricsPqModeSmart  InputMetricsPqMode = "smart"
)

// Defines values for InputMetricsPqEnabled.
const (
	InputMetricsPqEnabledFalse InputMetricsPqEnabled = false
	InputMetricsPqEnabledTrue  InputMetricsPqEnabled = true
)

// Defines values for InputMetricsSendToRoutes.
const (
	InputMetricsSendToRoutesFalse InputMetricsSendToRoutes = false
	InputMetricsSendToRoutesTrue  InputMetricsSendToRoutes = true
)

// Defines values for InputMetricsTlsDisabled.
const (
	InputMetricsTlsDisabledFalse InputMetricsTlsDisabled = false
	InputMetricsTlsDisabledTrue  InputMetricsTlsDisabled = true
)

// Defines values for InputMetricsTlsMaxVersion.
const (
	InputMetricsTlsMaxVersionTLSv1  InputMetricsTlsMaxVersion = "TLSv1"
	InputMetricsTlsMaxVersionTLSv11 InputMetricsTlsMaxVersion = "TLSv1.1"
	InputMetricsTlsMaxVersionTLSv12 InputMetricsTlsMaxVersion = "TLSv1.2"
	InputMetricsTlsMaxVersionTLSv13 InputMetricsTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputMetricsTlsMinVersion.
const (
	InputMetricsTlsMinVersionTLSv1  InputMetricsTlsMinVersion = "TLSv1"
	InputMetricsTlsMinVersionTLSv11 InputMetricsTlsMinVersion = "TLSv1.1"
	InputMetricsTlsMinVersionTLSv12 InputMetricsTlsMinVersion = "TLSv1.2"
	InputMetricsTlsMinVersionTLSv13 InputMetricsTlsMinVersion = "TLSv1.3"
)

// Defines values for InputMetricsType.
const (
	InputMetricsTypeMetrics InputMetricsType = "metrics"
)

// Defines values for InputModelDrivenTelemetryPqCompress.
const (
	InputModelDrivenTelemetryPqCompressGzip InputModelDrivenTelemetryPqCompress = "gzip"
	InputModelDrivenTelemetryPqCompressNone InputModelDrivenTelemetryPqCompress = "none"
)

// Defines values for InputModelDrivenTelemetryPqMode.
const (
	InputModelDrivenTelemetryPqModeAlways InputModelDrivenTelemetryPqMode = "always"
	InputModelDrivenTelemetryPqModeSmart  InputModelDrivenTelemetryPqMode = "smart"
)

// Defines values for InputModelDrivenTelemetryPqEnabled.
const (
	InputModelDrivenTelemetryPqEnabledFalse InputModelDrivenTelemetryPqEnabled = false
	InputModelDrivenTelemetryPqEnabledTrue  InputModelDrivenTelemetryPqEnabled = true
)

// Defines values for InputModelDrivenTelemetrySendToRoutes.
const (
	InputModelDrivenTelemetrySendToRoutesFalse InputModelDrivenTelemetrySendToRoutes = false
	InputModelDrivenTelemetrySendToRoutesTrue  InputModelDrivenTelemetrySendToRoutes = true
)

// Defines values for InputModelDrivenTelemetryTlsDisabled.
const (
	InputModelDrivenTelemetryTlsDisabledFalse InputModelDrivenTelemetryTlsDisabled = false
	InputModelDrivenTelemetryTlsDisabledTrue  InputModelDrivenTelemetryTlsDisabled = true
)

// Defines values for InputModelDrivenTelemetryTlsMaxVersion.
const (
	InputModelDrivenTelemetryTlsMaxVersionTLSv1  InputModelDrivenTelemetryTlsMaxVersion = "TLSv1"
	InputModelDrivenTelemetryTlsMaxVersionTLSv11 InputModelDrivenTelemetryTlsMaxVersion = "TLSv1.1"
	InputModelDrivenTelemetryTlsMaxVersionTLSv12 InputModelDrivenTelemetryTlsMaxVersion = "TLSv1.2"
	InputModelDrivenTelemetryTlsMaxVersionTLSv13 InputModelDrivenTelemetryTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputModelDrivenTelemetryTlsMinVersion.
const (
	InputModelDrivenTelemetryTlsMinVersionTLSv1  InputModelDrivenTelemetryTlsMinVersion = "TLSv1"
	InputModelDrivenTelemetryTlsMinVersionTLSv11 InputModelDrivenTelemetryTlsMinVersion = "TLSv1.1"
	InputModelDrivenTelemetryTlsMinVersionTLSv12 InputModelDrivenTelemetryTlsMinVersion = "TLSv1.2"
	InputModelDrivenTelemetryTlsMinVersionTLSv13 InputModelDrivenTelemetryTlsMinVersion = "TLSv1.3"
)

// Defines values for InputModelDrivenTelemetryType.
const (
	ModelDrivenTelemetry InputModelDrivenTelemetryType = "model_driven_telemetry"
)

// Defines values for InputMskAwsAuthenticationMethod.
const (
	InputMskAwsAuthenticationMethodAuto   InputMskAwsAuthenticationMethod = "auto"
	InputMskAwsAuthenticationMethodManual InputMskAwsAuthenticationMethod = "manual"
	InputMskAwsAuthenticationMethodSecret InputMskAwsAuthenticationMethod = "secret"
)

// Defines values for InputMskKafkaSchemaRegistryAuthDisabled.
const (
	InputMskKafkaSchemaRegistryAuthDisabledFalse InputMskKafkaSchemaRegistryAuthDisabled = false
	InputMskKafkaSchemaRegistryAuthDisabledTrue  InputMskKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for InputMskKafkaSchemaRegistryDisabled.
const (
	InputMskKafkaSchemaRegistryDisabledFalse InputMskKafkaSchemaRegistryDisabled = false
	InputMskKafkaSchemaRegistryDisabledTrue  InputMskKafkaSchemaRegistryDisabled = true
)

// Defines values for InputMskKafkaSchemaRegistryTlsDisabled.
const (
	InputMskKafkaSchemaRegistryTlsDisabledFalse InputMskKafkaSchemaRegistryTlsDisabled = false
	InputMskKafkaSchemaRegistryTlsDisabledTrue  InputMskKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for InputMskKafkaSchemaRegistryTlsMaxVersion.
const (
	InputMskKafkaSchemaRegistryTlsMaxVersionTLSv1  InputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	InputMskKafkaSchemaRegistryTlsMaxVersionTLSv11 InputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	InputMskKafkaSchemaRegistryTlsMaxVersionTLSv12 InputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	InputMskKafkaSchemaRegistryTlsMaxVersionTLSv13 InputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputMskKafkaSchemaRegistryTlsMinVersion.
const (
	InputMskKafkaSchemaRegistryTlsMinVersionTLSv1  InputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	InputMskKafkaSchemaRegistryTlsMinVersionTLSv11 InputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	InputMskKafkaSchemaRegistryTlsMinVersionTLSv12 InputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	InputMskKafkaSchemaRegistryTlsMinVersionTLSv13 InputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for InputMskPqCompress.
const (
	InputMskPqCompressGzip InputMskPqCompress = "gzip"
	InputMskPqCompressNone InputMskPqCompress = "none"
)

// Defines values for InputMskPqMode.
const (
	InputMskPqModeAlways InputMskPqMode = "always"
	InputMskPqModeSmart  InputMskPqMode = "smart"
)

// Defines values for InputMskPqEnabled.
const (
	InputMskPqEnabledFalse InputMskPqEnabled = false
	InputMskPqEnabledTrue  InputMskPqEnabled = true
)

// Defines values for InputMskSendToRoutes.
const (
	InputMskSendToRoutesFalse InputMskSendToRoutes = false
	InputMskSendToRoutesTrue  InputMskSendToRoutes = true
)

// Defines values for InputMskSignatureVersion.
const (
	InputMskSignatureVersionV2 InputMskSignatureVersion = "v2"
	InputMskSignatureVersionV4 InputMskSignatureVersion = "v4"
)

// Defines values for InputMskTlsDisabled.
const (
	InputMskTlsDisabledFalse InputMskTlsDisabled = false
	InputMskTlsDisabledTrue  InputMskTlsDisabled = true
)

// Defines values for InputMskTlsMaxVersion.
const (
	InputMskTlsMaxVersionTLSv1  InputMskTlsMaxVersion = "TLSv1"
	InputMskTlsMaxVersionTLSv11 InputMskTlsMaxVersion = "TLSv1.1"
	InputMskTlsMaxVersionTLSv12 InputMskTlsMaxVersion = "TLSv1.2"
	InputMskTlsMaxVersionTLSv13 InputMskTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputMskTlsMinVersion.
const (
	InputMskTlsMinVersionTLSv1  InputMskTlsMinVersion = "TLSv1"
	InputMskTlsMinVersionTLSv11 InputMskTlsMinVersion = "TLSv1.1"
	InputMskTlsMinVersionTLSv12 InputMskTlsMinVersion = "TLSv1.2"
	InputMskTlsMinVersionTLSv13 InputMskTlsMinVersion = "TLSv1.3"
)

// Defines values for InputMskType.
const (
	InputMskTypeMsk InputMskType = "msk"
)

// Defines values for InputNetflowPqCompress.
const (
	InputNetflowPqCompressGzip InputNetflowPqCompress = "gzip"
	InputNetflowPqCompressNone InputNetflowPqCompress = "none"
)

// Defines values for InputNetflowPqMode.
const (
	InputNetflowPqModeAlways InputNetflowPqMode = "always"
	InputNetflowPqModeSmart  InputNetflowPqMode = "smart"
)

// Defines values for InputNetflowPqEnabled.
const (
	InputNetflowPqEnabledFalse InputNetflowPqEnabled = false
	InputNetflowPqEnabledTrue  InputNetflowPqEnabled = true
)

// Defines values for InputNetflowSendToRoutes.
const (
	InputNetflowSendToRoutesFalse InputNetflowSendToRoutes = false
	InputNetflowSendToRoutesTrue  InputNetflowSendToRoutes = true
)

// Defines values for InputNetflowType.
const (
	InputNetflowTypeNetflow InputNetflowType = "netflow"
)

// Defines values for InputOffice365MgmtAuthType.
const (
	InputOffice365MgmtAuthTypeManual InputOffice365MgmtAuthType = "manual"
	InputOffice365MgmtAuthTypeSecret InputOffice365MgmtAuthType = "secret"
)

// Defines values for InputOffice365MgmtContentConfigLogLevel.
const (
	InputOffice365MgmtContentConfigLogLevelDebug InputOffice365MgmtContentConfigLogLevel = "debug"
	InputOffice365MgmtContentConfigLogLevelError InputOffice365MgmtContentConfigLogLevel = "error"
	InputOffice365MgmtContentConfigLogLevelInfo  InputOffice365MgmtContentConfigLogLevel = "info"
	InputOffice365MgmtContentConfigLogLevelWarn  InputOffice365MgmtContentConfigLogLevel = "warn"
)

// Defines values for InputOffice365MgmtPlanType.
const (
	InputOffice365MgmtPlanTypeDod           InputOffice365MgmtPlanType = "dod"
	InputOffice365MgmtPlanTypeEnterpriseGcc InputOffice365MgmtPlanType = "enterprise_gcc"
	InputOffice365MgmtPlanTypeGcc           InputOffice365MgmtPlanType = "gcc"
	InputOffice365MgmtPlanTypeGccHigh       InputOffice365MgmtPlanType = "gcc_high"
)

// Defines values for InputOffice365MgmtPqCompress.
const (
	InputOffice365MgmtPqCompressGzip InputOffice365MgmtPqCompress = "gzip"
	InputOffice365MgmtPqCompressNone InputOffice365MgmtPqCompress = "none"
)

// Defines values for InputOffice365MgmtPqMode.
const (
	InputOffice365MgmtPqModeAlways InputOffice365MgmtPqMode = "always"
	InputOffice365MgmtPqModeSmart  InputOffice365MgmtPqMode = "smart"
)

// Defines values for InputOffice365MgmtPqEnabled.
const (
	InputOffice365MgmtPqEnabledFalse InputOffice365MgmtPqEnabled = false
	InputOffice365MgmtPqEnabledTrue  InputOffice365MgmtPqEnabled = true
)

// Defines values for InputOffice365MgmtRetryRulesType.
const (
	InputOffice365MgmtRetryRulesTypeBackoff InputOffice365MgmtRetryRulesType = "backoff"
	InputOffice365MgmtRetryRulesTypeNone    InputOffice365MgmtRetryRulesType = "none"
	InputOffice365MgmtRetryRulesTypeStatic  InputOffice365MgmtRetryRulesType = "static"
)

// Defines values for InputOffice365MgmtSendToRoutes.
const (
	InputOffice365MgmtSendToRoutesFalse InputOffice365MgmtSendToRoutes = false
	InputOffice365MgmtSendToRoutesTrue  InputOffice365MgmtSendToRoutes = true
)

// Defines values for InputOffice365MgmtType.
const (
	Office365Mgmt InputOffice365MgmtType = "office365_mgmt"
)

// Defines values for InputOffice365MsgTraceAuthType.
const (
	InputOffice365MsgTraceAuthTypeManual      InputOffice365MsgTraceAuthType = "manual"
	InputOffice365MsgTraceAuthTypeOauth       InputOffice365MsgTraceAuthType = "oauth"
	InputOffice365MsgTraceAuthTypeOauthCert   InputOffice365MsgTraceAuthType = "oauthCert"
	InputOffice365MsgTraceAuthTypeOauthSecret InputOffice365MsgTraceAuthType = "oauthSecret"
	InputOffice365MsgTraceAuthTypeSecret      InputOffice365MsgTraceAuthType = "secret"
)

// Defines values for InputOffice365MsgTraceLogLevel.
const (
	InputOffice365MsgTraceLogLevelDebug InputOffice365MsgTraceLogLevel = "debug"
	InputOffice365MsgTraceLogLevelError InputOffice365MsgTraceLogLevel = "error"
	InputOffice365MsgTraceLogLevelInfo  InputOffice365MsgTraceLogLevel = "info"
	InputOffice365MsgTraceLogLevelSilly InputOffice365MsgTraceLogLevel = "silly"
	InputOffice365MsgTraceLogLevelWarn  InputOffice365MsgTraceLogLevel = "warn"
)

// Defines values for InputOffice365MsgTracePlanType.
const (
	InputOffice365MsgTracePlanTypeDod           InputOffice365MsgTracePlanType = "dod"
	InputOffice365MsgTracePlanTypeEnterpriseGcc InputOffice365MsgTracePlanType = "enterprise_gcc"
	InputOffice365MsgTracePlanTypeGcc           InputOffice365MsgTracePlanType = "gcc"
	InputOffice365MsgTracePlanTypeGccHigh       InputOffice365MsgTracePlanType = "gcc_high"
)

// Defines values for InputOffice365MsgTracePqCompress.
const (
	InputOffice365MsgTracePqCompressGzip InputOffice365MsgTracePqCompress = "gzip"
	InputOffice365MsgTracePqCompressNone InputOffice365MsgTracePqCompress = "none"
)

// Defines values for InputOffice365MsgTracePqMode.
const (
	InputOffice365MsgTracePqModeAlways InputOffice365MsgTracePqMode = "always"
	InputOffice365MsgTracePqModeSmart  InputOffice365MsgTracePqMode = "smart"
)

// Defines values for InputOffice365MsgTracePqEnabled.
const (
	InputOffice365MsgTracePqEnabledFalse InputOffice365MsgTracePqEnabled = false
	InputOffice365MsgTracePqEnabledTrue  InputOffice365MsgTracePqEnabled = true
)

// Defines values for InputOffice365MsgTraceRetryRulesType.
const (
	InputOffice365MsgTraceRetryRulesTypeBackoff InputOffice365MsgTraceRetryRulesType = "backoff"
	InputOffice365MsgTraceRetryRulesTypeNone    InputOffice365MsgTraceRetryRulesType = "none"
	InputOffice365MsgTraceRetryRulesTypeStatic  InputOffice365MsgTraceRetryRulesType = "static"
)

// Defines values for InputOffice365MsgTraceSendToRoutes.
const (
	InputOffice365MsgTraceSendToRoutesFalse InputOffice365MsgTraceSendToRoutes = false
	InputOffice365MsgTraceSendToRoutesTrue  InputOffice365MsgTraceSendToRoutes = true
)

// Defines values for InputOffice365MsgTraceType.
const (
	Office365MsgTrace InputOffice365MsgTraceType = "office365_msg_trace"
)

// Defines values for InputOffice365ServiceAuthType.
const (
	InputOffice365ServiceAuthTypeManual InputOffice365ServiceAuthType = "manual"
	InputOffice365ServiceAuthTypeSecret InputOffice365ServiceAuthType = "secret"
)

// Defines values for InputOffice365ServiceContentConfigLogLevel.
const (
	InputOffice365ServiceContentConfigLogLevelDebug InputOffice365ServiceContentConfigLogLevel = "debug"
	InputOffice365ServiceContentConfigLogLevelError InputOffice365ServiceContentConfigLogLevel = "error"
	InputOffice365ServiceContentConfigLogLevelInfo  InputOffice365ServiceContentConfigLogLevel = "info"
	InputOffice365ServiceContentConfigLogLevelWarn  InputOffice365ServiceContentConfigLogLevel = "warn"
)

// Defines values for InputOffice365ServicePlanType.
const (
	Dod           InputOffice365ServicePlanType = "dod"
	EnterpriseGcc InputOffice365ServicePlanType = "enterprise_gcc"
	Gcc           InputOffice365ServicePlanType = "gcc"
	GccHigh       InputOffice365ServicePlanType = "gcc_high"
)

// Defines values for InputOffice365ServicePqCompress.
const (
	InputOffice365ServicePqCompressGzip InputOffice365ServicePqCompress = "gzip"
	InputOffice365ServicePqCompressNone InputOffice365ServicePqCompress = "none"
)

// Defines values for InputOffice365ServicePqMode.
const (
	InputOffice365ServicePqModeAlways InputOffice365ServicePqMode = "always"
	InputOffice365ServicePqModeSmart  InputOffice365ServicePqMode = "smart"
)

// Defines values for InputOffice365ServicePqEnabled.
const (
	InputOffice365ServicePqEnabledFalse InputOffice365ServicePqEnabled = false
	InputOffice365ServicePqEnabledTrue  InputOffice365ServicePqEnabled = true
)

// Defines values for InputOffice365ServiceRetryRulesType.
const (
	InputOffice365ServiceRetryRulesTypeBackoff InputOffice365ServiceRetryRulesType = "backoff"
	InputOffice365ServiceRetryRulesTypeNone    InputOffice365ServiceRetryRulesType = "none"
	InputOffice365ServiceRetryRulesTypeStatic  InputOffice365ServiceRetryRulesType = "static"
)

// Defines values for InputOffice365ServiceSendToRoutes.
const (
	InputOffice365ServiceSendToRoutesFalse InputOffice365ServiceSendToRoutes = false
	InputOffice365ServiceSendToRoutesTrue  InputOffice365ServiceSendToRoutes = true
)

// Defines values for InputOffice365ServiceType.
const (
	Office365Service InputOffice365ServiceType = "office365_service"
)

// Defines values for InputOpenTelemetryAuthType.
const (
	InputOpenTelemetryAuthTypeBasic             InputOpenTelemetryAuthType = "basic"
	InputOpenTelemetryAuthTypeCredentialsSecret InputOpenTelemetryAuthType = "credentialsSecret"
	InputOpenTelemetryAuthTypeNone              InputOpenTelemetryAuthType = "none"
	InputOpenTelemetryAuthTypeOauth             InputOpenTelemetryAuthType = "oauth"
	InputOpenTelemetryAuthTypeTextSecret        InputOpenTelemetryAuthType = "textSecret"
	InputOpenTelemetryAuthTypeToken             InputOpenTelemetryAuthType = "token"
)

// Defines values for InputOpenTelemetryOtlpVersion.
const (
	InputOpenTelemetryOtlpVersionN0100 InputOpenTelemetryOtlpVersion = "0.10.0"
	InputOpenTelemetryOtlpVersionN131  InputOpenTelemetryOtlpVersion = "1.3.1"
)

// Defines values for InputOpenTelemetryPqCompress.
const (
	InputOpenTelemetryPqCompressGzip InputOpenTelemetryPqCompress = "gzip"
	InputOpenTelemetryPqCompressNone InputOpenTelemetryPqCompress = "none"
)

// Defines values for InputOpenTelemetryPqMode.
const (
	InputOpenTelemetryPqModeAlways InputOpenTelemetryPqMode = "always"
	InputOpenTelemetryPqModeSmart  InputOpenTelemetryPqMode = "smart"
)

// Defines values for InputOpenTelemetryPqEnabled.
const (
	InputOpenTelemetryPqEnabledFalse InputOpenTelemetryPqEnabled = false
	InputOpenTelemetryPqEnabledTrue  InputOpenTelemetryPqEnabled = true
)

// Defines values for InputOpenTelemetryProtocol.
const (
	InputOpenTelemetryProtocolGrpc InputOpenTelemetryProtocol = "grpc"
	InputOpenTelemetryProtocolHttp InputOpenTelemetryProtocol = "http"
)

// Defines values for InputOpenTelemetrySendToRoutes.
const (
	InputOpenTelemetrySendToRoutesFalse InputOpenTelemetrySendToRoutes = false
	InputOpenTelemetrySendToRoutesTrue  InputOpenTelemetrySendToRoutes = true
)

// Defines values for InputOpenTelemetryTlsDisabled.
const (
	InputOpenTelemetryTlsDisabledFalse InputOpenTelemetryTlsDisabled = false
	InputOpenTelemetryTlsDisabledTrue  InputOpenTelemetryTlsDisabled = true
)

// Defines values for InputOpenTelemetryTlsMaxVersion.
const (
	InputOpenTelemetryTlsMaxVersionTLSv1  InputOpenTelemetryTlsMaxVersion = "TLSv1"
	InputOpenTelemetryTlsMaxVersionTLSv11 InputOpenTelemetryTlsMaxVersion = "TLSv1.1"
	InputOpenTelemetryTlsMaxVersionTLSv12 InputOpenTelemetryTlsMaxVersion = "TLSv1.2"
	InputOpenTelemetryTlsMaxVersionTLSv13 InputOpenTelemetryTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputOpenTelemetryTlsMinVersion.
const (
	InputOpenTelemetryTlsMinVersionTLSv1  InputOpenTelemetryTlsMinVersion = "TLSv1"
	InputOpenTelemetryTlsMinVersionTLSv11 InputOpenTelemetryTlsMinVersion = "TLSv1.1"
	InputOpenTelemetryTlsMinVersionTLSv12 InputOpenTelemetryTlsMinVersion = "TLSv1.2"
	InputOpenTelemetryTlsMinVersionTLSv13 InputOpenTelemetryTlsMinVersion = "TLSv1.3"
)

// Defines values for InputOpenTelemetryType.
const (
	InputOpenTelemetryTypeOpenTelemetry InputOpenTelemetryType = "open_telemetry"
)

// Defines values for InputPrometheusAuthType.
const (
	InputPrometheusAuthTypeManual InputPrometheusAuthType = "manual"
	InputPrometheusAuthTypeSecret InputPrometheusAuthType = "secret"
)

// Defines values for InputPrometheusAwsAuthenticationMethod.
const (
	InputPrometheusAwsAuthenticationMethodAuto   InputPrometheusAwsAuthenticationMethod = "auto"
	InputPrometheusAwsAuthenticationMethodManual InputPrometheusAwsAuthenticationMethod = "manual"
	InputPrometheusAwsAuthenticationMethodSecret InputPrometheusAwsAuthenticationMethod = "secret"
)

// Defines values for InputPrometheusDiscoveryType.
const (
	InputPrometheusDiscoveryTypeDns    InputPrometheusDiscoveryType = "dns"
	InputPrometheusDiscoveryTypeEc2    InputPrometheusDiscoveryType = "ec2"
	InputPrometheusDiscoveryTypeStatic InputPrometheusDiscoveryType = "static"
)

// Defines values for InputPrometheusLogLevel.
const (
	InputPrometheusLogLevelDebug InputPrometheusLogLevel = "debug"
	InputPrometheusLogLevelError InputPrometheusLogLevel = "error"
	InputPrometheusLogLevelInfo  InputPrometheusLogLevel = "info"
	InputPrometheusLogLevelWarn  InputPrometheusLogLevel = "warn"
)

// Defines values for InputPrometheusPqCompress.
const (
	InputPrometheusPqCompressGzip InputPrometheusPqCompress = "gzip"
	InputPrometheusPqCompressNone InputPrometheusPqCompress = "none"
)

// Defines values for InputPrometheusPqMode.
const (
	InputPrometheusPqModeAlways InputPrometheusPqMode = "always"
	InputPrometheusPqModeSmart  InputPrometheusPqMode = "smart"
)

// Defines values for InputPrometheusPqEnabled.
const (
	InputPrometheusPqEnabledFalse InputPrometheusPqEnabled = false
	InputPrometheusPqEnabledTrue  InputPrometheusPqEnabled = true
)

// Defines values for InputPrometheusRecordType.
const (
	InputPrometheusRecordTypeA    InputPrometheusRecordType = "A"
	InputPrometheusRecordTypeAAAA InputPrometheusRecordType = "AAAA"
	InputPrometheusRecordTypeSRV  InputPrometheusRecordType = "SRV"
)

// Defines values for InputPrometheusScrapeProtocol.
const (
	InputPrometheusScrapeProtocolHttp  InputPrometheusScrapeProtocol = "http"
	InputPrometheusScrapeProtocolHttps InputPrometheusScrapeProtocol = "https"
)

// Defines values for InputPrometheusSendToRoutes.
const (
	InputPrometheusSendToRoutesFalse InputPrometheusSendToRoutes = false
	InputPrometheusSendToRoutesTrue  InputPrometheusSendToRoutes = true
)

// Defines values for InputPrometheusSignatureVersion.
const (
	InputPrometheusSignatureVersionV2 InputPrometheusSignatureVersion = "v2"
	InputPrometheusSignatureVersionV4 InputPrometheusSignatureVersion = "v4"
)

// Defines values for InputPrometheusType.
const (
	InputPrometheusTypePrometheus InputPrometheusType = "prometheus"
)

// Defines values for InputPrometheusRwAuthType.
const (
	InputPrometheusRwAuthTypeBasic             InputPrometheusRwAuthType = "basic"
	InputPrometheusRwAuthTypeCredentialsSecret InputPrometheusRwAuthType = "credentialsSecret"
	InputPrometheusRwAuthTypeNone              InputPrometheusRwAuthType = "none"
	InputPrometheusRwAuthTypeOauth             InputPrometheusRwAuthType = "oauth"
	InputPrometheusRwAuthTypeTextSecret        InputPrometheusRwAuthType = "textSecret"
	InputPrometheusRwAuthTypeToken             InputPrometheusRwAuthType = "token"
)

// Defines values for InputPrometheusRwPqCompress.
const (
	InputPrometheusRwPqCompressGzip InputPrometheusRwPqCompress = "gzip"
	InputPrometheusRwPqCompressNone InputPrometheusRwPqCompress = "none"
)

// Defines values for InputPrometheusRwPqMode.
const (
	InputPrometheusRwPqModeAlways InputPrometheusRwPqMode = "always"
	InputPrometheusRwPqModeSmart  InputPrometheusRwPqMode = "smart"
)

// Defines values for InputPrometheusRwPqEnabled.
const (
	InputPrometheusRwPqEnabledFalse InputPrometheusRwPqEnabled = false
	InputPrometheusRwPqEnabledTrue  InputPrometheusRwPqEnabled = true
)

// Defines values for InputPrometheusRwSendToRoutes.
const (
	InputPrometheusRwSendToRoutesFalse InputPrometheusRwSendToRoutes = false
	InputPrometheusRwSendToRoutesTrue  InputPrometheusRwSendToRoutes = true
)

// Defines values for InputPrometheusRwTlsDisabled.
const (
	InputPrometheusRwTlsDisabledFalse InputPrometheusRwTlsDisabled = false
	InputPrometheusRwTlsDisabledTrue  InputPrometheusRwTlsDisabled = true
)

// Defines values for InputPrometheusRwTlsMaxVersion.
const (
	InputPrometheusRwTlsMaxVersionTLSv1  InputPrometheusRwTlsMaxVersion = "TLSv1"
	InputPrometheusRwTlsMaxVersionTLSv11 InputPrometheusRwTlsMaxVersion = "TLSv1.1"
	InputPrometheusRwTlsMaxVersionTLSv12 InputPrometheusRwTlsMaxVersion = "TLSv1.2"
	InputPrometheusRwTlsMaxVersionTLSv13 InputPrometheusRwTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputPrometheusRwTlsMinVersion.
const (
	InputPrometheusRwTlsMinVersionTLSv1  InputPrometheusRwTlsMinVersion = "TLSv1"
	InputPrometheusRwTlsMinVersionTLSv11 InputPrometheusRwTlsMinVersion = "TLSv1.1"
	InputPrometheusRwTlsMinVersionTLSv12 InputPrometheusRwTlsMinVersion = "TLSv1.2"
	InputPrometheusRwTlsMinVersionTLSv13 InputPrometheusRwTlsMinVersion = "TLSv1.3"
)

// Defines values for InputPrometheusRwType.
const (
	PrometheusRw InputPrometheusRwType = "prometheus_rw"
)

// Defines values for InputRawUdpPqCompress.
const (
	InputRawUdpPqCompressGzip InputRawUdpPqCompress = "gzip"
	InputRawUdpPqCompressNone InputRawUdpPqCompress = "none"
)

// Defines values for InputRawUdpPqMode.
const (
	InputRawUdpPqModeAlways InputRawUdpPqMode = "always"
	InputRawUdpPqModeSmart  InputRawUdpPqMode = "smart"
)

// Defines values for InputRawUdpPqEnabled.
const (
	InputRawUdpPqEnabledFalse InputRawUdpPqEnabled = false
	InputRawUdpPqEnabledTrue  InputRawUdpPqEnabled = true
)

// Defines values for InputRawUdpSendToRoutes.
const (
	InputRawUdpSendToRoutesFalse InputRawUdpSendToRoutes = false
	InputRawUdpSendToRoutesTrue  InputRawUdpSendToRoutes = true
)

// Defines values for InputRawUdpType.
const (
	RawUdp InputRawUdpType = "raw_udp"
)

// Defines values for InputS3AwsAuthenticationMethod.
const (
	InputS3AwsAuthenticationMethodAuto   InputS3AwsAuthenticationMethod = "auto"
	InputS3AwsAuthenticationMethodManual InputS3AwsAuthenticationMethod = "manual"
	InputS3AwsAuthenticationMethodSecret InputS3AwsAuthenticationMethod = "secret"
)

// Defines values for InputS3CheckpointingEnabled.
const (
	InputS3CheckpointingEnabledFalse InputS3CheckpointingEnabled = false
	InputS3CheckpointingEnabledTrue  InputS3CheckpointingEnabled = true
)

// Defines values for InputS3PqCompress.
const (
	InputS3PqCompressGzip InputS3PqCompress = "gzip"
	InputS3PqCompressNone InputS3PqCompress = "none"
)

// Defines values for InputS3PqMode.
const (
	InputS3PqModeAlways InputS3PqMode = "always"
	InputS3PqModeSmart  InputS3PqMode = "smart"
)

// Defines values for InputS3PqEnabled.
const (
	InputS3PqEnabledFalse InputS3PqEnabled = false
	InputS3PqEnabledTrue  InputS3PqEnabled = true
)

// Defines values for InputS3PreprocessDisabled.
const (
	InputS3PreprocessDisabledFalse InputS3PreprocessDisabled = false
	InputS3PreprocessDisabledTrue  InputS3PreprocessDisabled = true
)

// Defines values for InputS3SendToRoutes.
const (
	InputS3SendToRoutesFalse InputS3SendToRoutes = false
	InputS3SendToRoutesTrue  InputS3SendToRoutes = true
)

// Defines values for InputS3SignatureVersion.
const (
	InputS3SignatureVersionV2 InputS3SignatureVersion = "v2"
	InputS3SignatureVersionV4 InputS3SignatureVersion = "v4"
)

// Defines values for InputS3Type.
const (
	InputS3TypeS3 InputS3Type = "s3"
)

// Defines values for InputS3InventoryAwsAuthenticationMethod.
const (
	InputS3InventoryAwsAuthenticationMethodAuto   InputS3InventoryAwsAuthenticationMethod = "auto"
	InputS3InventoryAwsAuthenticationMethodManual InputS3InventoryAwsAuthenticationMethod = "manual"
	InputS3InventoryAwsAuthenticationMethodSecret InputS3InventoryAwsAuthenticationMethod = "secret"
)

// Defines values for InputS3InventoryCheckpointingEnabled.
const (
	InputS3InventoryCheckpointingEnabledFalse InputS3InventoryCheckpointingEnabled = false
	InputS3InventoryCheckpointingEnabledTrue  InputS3InventoryCheckpointingEnabled = true
)

// Defines values for InputS3InventoryPqCompress.
const (
	InputS3InventoryPqCompressGzip InputS3InventoryPqCompress = "gzip"
	InputS3InventoryPqCompressNone InputS3InventoryPqCompress = "none"
)

// Defines values for InputS3InventoryPqMode.
const (
	InputS3InventoryPqModeAlways InputS3InventoryPqMode = "always"
	InputS3InventoryPqModeSmart  InputS3InventoryPqMode = "smart"
)

// Defines values for InputS3InventoryPqEnabled.
const (
	InputS3InventoryPqEnabledFalse InputS3InventoryPqEnabled = false
	InputS3InventoryPqEnabledTrue  InputS3InventoryPqEnabled = true
)

// Defines values for InputS3InventoryPreprocessDisabled.
const (
	InputS3InventoryPreprocessDisabledFalse InputS3InventoryPreprocessDisabled = false
	InputS3InventoryPreprocessDisabledTrue  InputS3InventoryPreprocessDisabled = true
)

// Defines values for InputS3InventorySendToRoutes.
const (
	InputS3InventorySendToRoutesFalse InputS3InventorySendToRoutes = false
	InputS3InventorySendToRoutesTrue  InputS3InventorySendToRoutes = true
)

// Defines values for InputS3InventorySignatureVersion.
const (
	InputS3InventorySignatureVersionV2 InputS3InventorySignatureVersion = "v2"
	InputS3InventorySignatureVersionV4 InputS3InventorySignatureVersion = "v4"
)

// Defines values for InputS3InventoryType.
const (
	S3Inventory InputS3InventoryType = "s3_inventory"
)

// Defines values for InputSecurityLakeAwsAuthenticationMethod.
const (
	InputSecurityLakeAwsAuthenticationMethodAuto   InputSecurityLakeAwsAuthenticationMethod = "auto"
	InputSecurityLakeAwsAuthenticationMethodManual InputSecurityLakeAwsAuthenticationMethod = "manual"
	InputSecurityLakeAwsAuthenticationMethodSecret InputSecurityLakeAwsAuthenticationMethod = "secret"
)

// Defines values for InputSecurityLakeCheckpointingEnabled.
const (
	InputSecurityLakeCheckpointingEnabledFalse InputSecurityLakeCheckpointingEnabled = false
	InputSecurityLakeCheckpointingEnabledTrue  InputSecurityLakeCheckpointingEnabled = true
)

// Defines values for InputSecurityLakePqCompress.
const (
	InputSecurityLakePqCompressGzip InputSecurityLakePqCompress = "gzip"
	InputSecurityLakePqCompressNone InputSecurityLakePqCompress = "none"
)

// Defines values for InputSecurityLakePqMode.
const (
	InputSecurityLakePqModeAlways InputSecurityLakePqMode = "always"
	InputSecurityLakePqModeSmart  InputSecurityLakePqMode = "smart"
)

// Defines values for InputSecurityLakePqEnabled.
const (
	InputSecurityLakePqEnabledFalse InputSecurityLakePqEnabled = false
	InputSecurityLakePqEnabledTrue  InputSecurityLakePqEnabled = true
)

// Defines values for InputSecurityLakePreprocessDisabled.
const (
	InputSecurityLakePreprocessDisabledFalse InputSecurityLakePreprocessDisabled = false
	InputSecurityLakePreprocessDisabledTrue  InputSecurityLakePreprocessDisabled = true
)

// Defines values for InputSecurityLakeSendToRoutes.
const (
	InputSecurityLakeSendToRoutesFalse InputSecurityLakeSendToRoutes = false
	InputSecurityLakeSendToRoutesTrue  InputSecurityLakeSendToRoutes = true
)

// Defines values for InputSecurityLakeSignatureVersion.
const (
	InputSecurityLakeSignatureVersionV2 InputSecurityLakeSignatureVersion = "v2"
	InputSecurityLakeSignatureVersionV4 InputSecurityLakeSignatureVersion = "v4"
)

// Defines values for InputSecurityLakeType.
const (
	InputSecurityLakeTypeSecurityLake InputSecurityLakeType = "security_lake"
)

// Defines values for InputSnmpPqCompress.
const (
	InputSnmpPqCompressGzip InputSnmpPqCompress = "gzip"
	InputSnmpPqCompressNone InputSnmpPqCompress = "none"
)

// Defines values for InputSnmpPqMode.
const (
	InputSnmpPqModeAlways InputSnmpPqMode = "always"
	InputSnmpPqModeSmart  InputSnmpPqMode = "smart"
)

// Defines values for InputSnmpPqEnabled.
const (
	InputSnmpPqEnabledFalse InputSnmpPqEnabled = false
	InputSnmpPqEnabledTrue  InputSnmpPqEnabled = true
)

// Defines values for InputSnmpSendToRoutes.
const (
	InputSnmpSendToRoutesFalse InputSnmpSendToRoutes = false
	InputSnmpSendToRoutesTrue  InputSnmpSendToRoutes = true
)

// Defines values for InputSnmpSnmpV3AuthV3AuthEnabled.
const (
	InputSnmpSnmpV3AuthV3AuthEnabledFalse InputSnmpSnmpV3AuthV3AuthEnabled = false
	InputSnmpSnmpV3AuthV3AuthEnabledTrue  InputSnmpSnmpV3AuthV3AuthEnabled = true
)

// Defines values for InputSnmpSnmpV3AuthV3UsersAuthProtocol.
const (
	InputSnmpSnmpV3AuthV3UsersAuthProtocolMd5    InputSnmpSnmpV3AuthV3UsersAuthProtocol = "md5"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolNone   InputSnmpSnmpV3AuthV3UsersAuthProtocol = "none"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolSha    InputSnmpSnmpV3AuthV3UsersAuthProtocol = "sha"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolSha224 InputSnmpSnmpV3AuthV3UsersAuthProtocol = "sha224"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolSha256 InputSnmpSnmpV3AuthV3UsersAuthProtocol = "sha256"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolSha384 InputSnmpSnmpV3AuthV3UsersAuthProtocol = "sha384"
	InputSnmpSnmpV3AuthV3UsersAuthProtocolSha512 InputSnmpSnmpV3AuthV3UsersAuthProtocol = "sha512"
)

// Defines values for InputSnmpType.
const (
	InputSnmpTypeSnmp InputSnmpType = "snmp"
)

// Defines values for InputSplunkMaxS2Sversion.
const (
	InputSplunkMaxS2SversionV3 InputSplunkMaxS2Sversion = "v3"
	InputSplunkMaxS2SversionV4 InputSplunkMaxS2Sversion = "v4"
)

// Defines values for InputSplunkPqCompress.
const (
	InputSplunkPqCompressGzip InputSplunkPqCompress = "gzip"
	InputSplunkPqCompressNone InputSplunkPqCompress = "none"
)

// Defines values for InputSplunkPqMode.
const (
	InputSplunkPqModeAlways InputSplunkPqMode = "always"
	InputSplunkPqModeSmart  InputSplunkPqMode = "smart"
)

// Defines values for InputSplunkPqEnabled.
const (
	InputSplunkPqEnabledFalse InputSplunkPqEnabled = false
	InputSplunkPqEnabledTrue  InputSplunkPqEnabled = true
)

// Defines values for InputSplunkSendToRoutes.
const (
	InputSplunkSendToRoutesFalse InputSplunkSendToRoutes = false
	InputSplunkSendToRoutesTrue  InputSplunkSendToRoutes = true
)

// Defines values for InputSplunkTlsDisabled.
const (
	InputSplunkTlsDisabledFalse InputSplunkTlsDisabled = false
	InputSplunkTlsDisabledTrue  InputSplunkTlsDisabled = true
)

// Defines values for InputSplunkTlsMaxVersion.
const (
	InputSplunkTlsMaxVersionTLSv1  InputSplunkTlsMaxVersion = "TLSv1"
	InputSplunkTlsMaxVersionTLSv11 InputSplunkTlsMaxVersion = "TLSv1.1"
	InputSplunkTlsMaxVersionTLSv12 InputSplunkTlsMaxVersion = "TLSv1.2"
	InputSplunkTlsMaxVersionTLSv13 InputSplunkTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputSplunkTlsMinVersion.
const (
	InputSplunkTlsMinVersionTLSv1  InputSplunkTlsMinVersion = "TLSv1"
	InputSplunkTlsMinVersionTLSv11 InputSplunkTlsMinVersion = "TLSv1.1"
	InputSplunkTlsMinVersionTLSv12 InputSplunkTlsMinVersion = "TLSv1.2"
	InputSplunkTlsMinVersionTLSv13 InputSplunkTlsMinVersion = "TLSv1.3"
)

// Defines values for InputSplunkType.
const (
	InputSplunkTypeSplunk InputSplunkType = "splunk"
)

// Defines values for InputSplunkHecAuthTokensAuthType.
const (
	InputSplunkHecAuthTokensAuthTypeManual InputSplunkHecAuthTokensAuthType = "manual"
	InputSplunkHecAuthTokensAuthTypeSecret InputSplunkHecAuthTokensAuthType = "secret"
)

// Defines values for InputSplunkHecPqCompress.
const (
	InputSplunkHecPqCompressGzip InputSplunkHecPqCompress = "gzip"
	InputSplunkHecPqCompressNone InputSplunkHecPqCompress = "none"
)

// Defines values for InputSplunkHecPqMode.
const (
	InputSplunkHecPqModeAlways InputSplunkHecPqMode = "always"
	InputSplunkHecPqModeSmart  InputSplunkHecPqMode = "smart"
)

// Defines values for InputSplunkHecPqEnabled.
const (
	InputSplunkHecPqEnabledFalse InputSplunkHecPqEnabled = false
	InputSplunkHecPqEnabledTrue  InputSplunkHecPqEnabled = true
)

// Defines values for InputSplunkHecSendToRoutes.
const (
	InputSplunkHecSendToRoutesFalse InputSplunkHecSendToRoutes = false
	InputSplunkHecSendToRoutesTrue  InputSplunkHecSendToRoutes = true
)

// Defines values for InputSplunkHecTlsDisabled.
const (
	InputSplunkHecTlsDisabledFalse InputSplunkHecTlsDisabled = false
	InputSplunkHecTlsDisabledTrue  InputSplunkHecTlsDisabled = true
)

// Defines values for InputSplunkHecTlsMaxVersion.
const (
	InputSplunkHecTlsMaxVersionTLSv1  InputSplunkHecTlsMaxVersion = "TLSv1"
	InputSplunkHecTlsMaxVersionTLSv11 InputSplunkHecTlsMaxVersion = "TLSv1.1"
	InputSplunkHecTlsMaxVersionTLSv12 InputSplunkHecTlsMaxVersion = "TLSv1.2"
	InputSplunkHecTlsMaxVersionTLSv13 InputSplunkHecTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputSplunkHecTlsMinVersion.
const (
	InputSplunkHecTlsMinVersionTLSv1  InputSplunkHecTlsMinVersion = "TLSv1"
	InputSplunkHecTlsMinVersionTLSv11 InputSplunkHecTlsMinVersion = "TLSv1.1"
	InputSplunkHecTlsMinVersionTLSv12 InputSplunkHecTlsMinVersion = "TLSv1.2"
	InputSplunkHecTlsMinVersionTLSv13 InputSplunkHecTlsMinVersion = "TLSv1.3"
)

// Defines values for InputSplunkHecType.
const (
	InputSplunkHecTypeSplunkHec InputSplunkHecType = "splunk_hec"
)

// Defines values for InputSplunkSearchAuthType.
const (
	InputSplunkSearchAuthTypeBasic             InputSplunkSearchAuthType = "basic"
	InputSplunkSearchAuthTypeCredentialsSecret InputSplunkSearchAuthType = "credentialsSecret"
	InputSplunkSearchAuthTypeNone              InputSplunkSearchAuthType = "none"
	InputSplunkSearchAuthTypeOauth             InputSplunkSearchAuthType = "oauth"
	InputSplunkSearchAuthTypeTextSecret        InputSplunkSearchAuthType = "textSecret"
	InputSplunkSearchAuthTypeToken             InputSplunkSearchAuthType = "token"
)

// Defines values for InputSplunkSearchLogLevel.
const (
	InputSplunkSearchLogLevelDebug InputSplunkSearchLogLevel = "debug"
	InputSplunkSearchLogLevelError InputSplunkSearchLogLevel = "error"
	InputSplunkSearchLogLevelInfo  InputSplunkSearchLogLevel = "info"
	InputSplunkSearchLogLevelWarn  InputSplunkSearchLogLevel = "warn"
)

// Defines values for InputSplunkSearchOutputMode.
const (
	InputSplunkSearchOutputModeCsv  InputSplunkSearchOutputMode = "csv"
	InputSplunkSearchOutputModeJson InputSplunkSearchOutputMode = "json"
)

// Defines values for InputSplunkSearchPqCompress.
const (
	InputSplunkSearchPqCompressGzip InputSplunkSearchPqCompress = "gzip"
	InputSplunkSearchPqCompressNone InputSplunkSearchPqCompress = "none"
)

// Defines values for InputSplunkSearchPqMode.
const (
	InputSplunkSearchPqModeAlways InputSplunkSearchPqMode = "always"
	InputSplunkSearchPqModeSmart  InputSplunkSearchPqMode = "smart"
)

// Defines values for InputSplunkSearchPqEnabled.
const (
	InputSplunkSearchPqEnabledFalse InputSplunkSearchPqEnabled = false
	InputSplunkSearchPqEnabledTrue  InputSplunkSearchPqEnabled = true
)

// Defines values for InputSplunkSearchRetryRulesType.
const (
	InputSplunkSearchRetryRulesTypeBackoff InputSplunkSearchRetryRulesType = "backoff"
	InputSplunkSearchRetryRulesTypeNone    InputSplunkSearchRetryRulesType = "none"
	InputSplunkSearchRetryRulesTypeStatic  InputSplunkSearchRetryRulesType = "static"
)

// Defines values for InputSplunkSearchSendToRoutes.
const (
	InputSplunkSearchSendToRoutesFalse InputSplunkSearchSendToRoutes = false
	InputSplunkSearchSendToRoutesTrue  InputSplunkSearchSendToRoutes = true
)

// Defines values for InputSplunkSearchType.
const (
	SplunkSearch InputSplunkSearchType = "splunk_search"
)

// Defines values for InputSqsAwsAuthenticationMethod.
const (
	InputSqsAwsAuthenticationMethodAuto   InputSqsAwsAuthenticationMethod = "auto"
	InputSqsAwsAuthenticationMethodManual InputSqsAwsAuthenticationMethod = "manual"
	InputSqsAwsAuthenticationMethodSecret InputSqsAwsAuthenticationMethod = "secret"
)

// Defines values for InputSqsPqCompress.
const (
	InputSqsPqCompressGzip InputSqsPqCompress = "gzip"
	InputSqsPqCompressNone InputSqsPqCompress = "none"
)

// Defines values for InputSqsPqMode.
const (
	InputSqsPqModeAlways InputSqsPqMode = "always"
	InputSqsPqModeSmart  InputSqsPqMode = "smart"
)

// Defines values for InputSqsPqEnabled.
const (
	InputSqsPqEnabledFalse InputSqsPqEnabled = false
	InputSqsPqEnabledTrue  InputSqsPqEnabled = true
)

// Defines values for InputSqsQueueType.
const (
	InputSqsQueueTypeFifo     InputSqsQueueType = "fifo"
	InputSqsQueueTypeStandard InputSqsQueueType = "standard"
)

// Defines values for InputSqsSendToRoutes.
const (
	InputSqsSendToRoutesFalse InputSqsSendToRoutes = false
	InputSqsSendToRoutesTrue  InputSqsSendToRoutes = true
)

// Defines values for InputSqsSignatureVersion.
const (
	InputSqsSignatureVersionV2 InputSqsSignatureVersion = "v2"
	InputSqsSignatureVersionV4 InputSqsSignatureVersion = "v4"
)

// Defines values for InputSqsType.
const (
	InputSqsTypeSqs InputSqsType = "sqs"
)

// Defines values for InputStatusStatusHealth.
const (
	InputStatusStatusHealthGreen  InputStatusStatusHealth = "Green"
	InputStatusStatusHealthRed    InputStatusStatusHealth = "Red"
	InputStatusStatusHealthYellow InputStatusStatusHealth = "Yellow"
)

// Defines values for InputSyslogPqCompress.
const (
	InputSyslogPqCompressGzip InputSyslogPqCompress = "gzip"
	InputSyslogPqCompressNone InputSyslogPqCompress = "none"
)

// Defines values for InputSyslogPqMode.
const (
	InputSyslogPqModeAlways InputSyslogPqMode = "always"
	InputSyslogPqModeSmart  InputSyslogPqMode = "smart"
)

// Defines values for InputSyslogPqEnabled.
const (
	InputSyslogPqEnabledFalse InputSyslogPqEnabled = false
	InputSyslogPqEnabledTrue  InputSyslogPqEnabled = true
)

// Defines values for InputSyslogSendToRoutes.
const (
	InputSyslogSendToRoutesFalse InputSyslogSendToRoutes = false
	InputSyslogSendToRoutesTrue  InputSyslogSendToRoutes = true
)

// Defines values for InputSyslogTlsDisabled.
const (
	InputSyslogTlsDisabledFalse InputSyslogTlsDisabled = false
	InputSyslogTlsDisabledTrue  InputSyslogTlsDisabled = true
)

// Defines values for InputSyslogTlsMaxVersion.
const (
	InputSyslogTlsMaxVersionTLSv1  InputSyslogTlsMaxVersion = "TLSv1"
	InputSyslogTlsMaxVersionTLSv11 InputSyslogTlsMaxVersion = "TLSv1.1"
	InputSyslogTlsMaxVersionTLSv12 InputSyslogTlsMaxVersion = "TLSv1.2"
	InputSyslogTlsMaxVersionTLSv13 InputSyslogTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputSyslogTlsMinVersion.
const (
	InputSyslogTlsMinVersionTLSv1  InputSyslogTlsMinVersion = "TLSv1"
	InputSyslogTlsMinVersionTLSv11 InputSyslogTlsMinVersion = "TLSv1.1"
	InputSyslogTlsMinVersionTLSv12 InputSyslogTlsMinVersion = "TLSv1.2"
	InputSyslogTlsMinVersionTLSv13 InputSyslogTlsMinVersion = "TLSv1.3"
)

// Defines values for InputSyslogType.
const (
	InputSyslogTypeSyslog InputSyslogType = "syslog"
)

// Defines values for InputSystemMetricsContainerMode.
const (
	InputSystemMetricsContainerModeAll      InputSystemMetricsContainerMode = "all"
	InputSystemMetricsContainerModeBasic    InputSystemMetricsContainerMode = "basic"
	InputSystemMetricsContainerModeCustom   InputSystemMetricsContainerMode = "custom"
	InputSystemMetricsContainerModeDisabled InputSystemMetricsContainerMode = "disabled"
)

// Defines values for InputSystemMetricsHostCustomCpuMode.
const (
	InputSystemMetricsHostCustomCpuModeAll      InputSystemMetricsHostCustomCpuMode = "all"
	InputSystemMetricsHostCustomCpuModeBasic    InputSystemMetricsHostCustomCpuMode = "basic"
	InputSystemMetricsHostCustomCpuModeCustom   InputSystemMetricsHostCustomCpuMode = "custom"
	InputSystemMetricsHostCustomCpuModeDisabled InputSystemMetricsHostCustomCpuMode = "disabled"
)

// Defines values for InputSystemMetricsHostCustomDiskMode.
const (
	InputSystemMetricsHostCustomDiskModeAll      InputSystemMetricsHostCustomDiskMode = "all"
	InputSystemMetricsHostCustomDiskModeBasic    InputSystemMetricsHostCustomDiskMode = "basic"
	InputSystemMetricsHostCustomDiskModeCustom   InputSystemMetricsHostCustomDiskMode = "custom"
	InputSystemMetricsHostCustomDiskModeDisabled InputSystemMetricsHostCustomDiskMode = "disabled"
)

// Defines values for InputSystemMetricsHostCustomMemoryMode.
const (
	InputSystemMetricsHostCustomMemoryModeAll      InputSystemMetricsHostCustomMemoryMode = "all"
	InputSystemMetricsHostCustomMemoryModeBasic    InputSystemMetricsHostCustomMemoryMode = "basic"
	InputSystemMetricsHostCustomMemoryModeCustom   InputSystemMetricsHostCustomMemoryMode = "custom"
	InputSystemMetricsHostCustomMemoryModeDisabled InputSystemMetricsHostCustomMemoryMode = "disabled"
)

// Defines values for InputSystemMetricsHostCustomNetworkMode.
const (
	InputSystemMetricsHostCustomNetworkModeAll      InputSystemMetricsHostCustomNetworkMode = "all"
	InputSystemMetricsHostCustomNetworkModeBasic    InputSystemMetricsHostCustomNetworkMode = "basic"
	InputSystemMetricsHostCustomNetworkModeCustom   InputSystemMetricsHostCustomNetworkMode = "custom"
	InputSystemMetricsHostCustomNetworkModeDisabled InputSystemMetricsHostCustomNetworkMode = "disabled"
)

// Defines values for InputSystemMetricsHostCustomSystemMode.
const (
	InputSystemMetricsHostCustomSystemModeAll      InputSystemMetricsHostCustomSystemMode = "all"
	InputSystemMetricsHostCustomSystemModeBasic    InputSystemMetricsHostCustomSystemMode = "basic"
	InputSystemMetricsHostCustomSystemModeCustom   InputSystemMetricsHostCustomSystemMode = "custom"
	InputSystemMetricsHostCustomSystemModeDisabled InputSystemMetricsHostCustomSystemMode = "disabled"
)

// Defines values for InputSystemMetricsHostMode.
const (
	InputSystemMetricsHostModeAll      InputSystemMetricsHostMode = "all"
	InputSystemMetricsHostModeBasic    InputSystemMetricsHostMode = "basic"
	InputSystemMetricsHostModeCustom   InputSystemMetricsHostMode = "custom"
	InputSystemMetricsHostModeDisabled InputSystemMetricsHostMode = "disabled"
)

// Defines values for InputSystemMetricsPersistenceCompress.
const (
	InputSystemMetricsPersistenceCompressGzip InputSystemMetricsPersistenceCompress = "gzip"
	InputSystemMetricsPersistenceCompressNone InputSystemMetricsPersistenceCompress = "none"
)

// Defines values for InputSystemMetricsPersistenceEnable.
const (
	InputSystemMetricsPersistenceEnableFalse InputSystemMetricsPersistenceEnable = false
	InputSystemMetricsPersistenceEnableTrue  InputSystemMetricsPersistenceEnable = true
)

// Defines values for InputSystemMetricsPqCompress.
const (
	InputSystemMetricsPqCompressGzip InputSystemMetricsPqCompress = "gzip"
	InputSystemMetricsPqCompressNone InputSystemMetricsPqCompress = "none"
)

// Defines values for InputSystemMetricsPqMode.
const (
	InputSystemMetricsPqModeAlways InputSystemMetricsPqMode = "always"
	InputSystemMetricsPqModeSmart  InputSystemMetricsPqMode = "smart"
)

// Defines values for InputSystemMetricsPqEnabled.
const (
	InputSystemMetricsPqEnabledFalse InputSystemMetricsPqEnabled = false
	InputSystemMetricsPqEnabledTrue  InputSystemMetricsPqEnabled = true
)

// Defines values for InputSystemMetricsSendToRoutes.
const (
	InputSystemMetricsSendToRoutesFalse InputSystemMetricsSendToRoutes = false
	InputSystemMetricsSendToRoutesTrue  InputSystemMetricsSendToRoutes = true
)

// Defines values for InputSystemMetricsType.
const (
	SystemMetrics InputSystemMetricsType = "system_metrics"
)

// Defines values for InputSystemStatePersistenceCompress.
const (
	InputSystemStatePersistenceCompressGzip InputSystemStatePersistenceCompress = "gzip"
	InputSystemStatePersistenceCompressNone InputSystemStatePersistenceCompress = "none"
)

// Defines values for InputSystemStatePersistenceEnable.
const (
	InputSystemStatePersistenceEnableFalse InputSystemStatePersistenceEnable = false
	InputSystemStatePersistenceEnableTrue  InputSystemStatePersistenceEnable = true
)

// Defines values for InputSystemStatePqCompress.
const (
	InputSystemStatePqCompressGzip InputSystemStatePqCompress = "gzip"
	InputSystemStatePqCompressNone InputSystemStatePqCompress = "none"
)

// Defines values for InputSystemStatePqMode.
const (
	InputSystemStatePqModeAlways InputSystemStatePqMode = "always"
	InputSystemStatePqModeSmart  InputSystemStatePqMode = "smart"
)

// Defines values for InputSystemStatePqEnabled.
const (
	InputSystemStatePqEnabledFalse InputSystemStatePqEnabled = false
	InputSystemStatePqEnabledTrue  InputSystemStatePqEnabled = true
)

// Defines values for InputSystemStateSendToRoutes.
const (
	InputSystemStateSendToRoutesFalse InputSystemStateSendToRoutes = false
	InputSystemStateSendToRoutesTrue  InputSystemStateSendToRoutes = true
)

// Defines values for InputSystemStateType.
const (
	SystemState InputSystemStateType = "system_state"
)

// Defines values for InputTcpAuthType.
const (
	InputTcpAuthTypeManual InputTcpAuthType = "manual"
	InputTcpAuthTypeSecret InputTcpAuthType = "secret"
)

// Defines values for InputTcpEnableHeader.
const (
	InputTcpEnableHeaderFalse InputTcpEnableHeader = false
	InputTcpEnableHeaderTrue  InputTcpEnableHeader = true
)

// Defines values for InputTcpPqCompress.
const (
	InputTcpPqCompressGzip InputTcpPqCompress = "gzip"
	InputTcpPqCompressNone InputTcpPqCompress = "none"
)

// Defines values for InputTcpPqMode.
const (
	InputTcpPqModeAlways InputTcpPqMode = "always"
	InputTcpPqModeSmart  InputTcpPqMode = "smart"
)

// Defines values for InputTcpPqEnabled.
const (
	InputTcpPqEnabledFalse InputTcpPqEnabled = false
	InputTcpPqEnabledTrue  InputTcpPqEnabled = true
)

// Defines values for InputTcpPreprocessDisabled.
const (
	InputTcpPreprocessDisabledFalse InputTcpPreprocessDisabled = false
	InputTcpPreprocessDisabledTrue  InputTcpPreprocessDisabled = true
)

// Defines values for InputTcpSendToRoutes.
const (
	InputTcpSendToRoutesFalse InputTcpSendToRoutes = false
	InputTcpSendToRoutesTrue  InputTcpSendToRoutes = true
)

// Defines values for InputTcpTlsDisabled.
const (
	InputTcpTlsDisabledFalse InputTcpTlsDisabled = false
	InputTcpTlsDisabledTrue  InputTcpTlsDisabled = true
)

// Defines values for InputTcpTlsMaxVersion.
const (
	InputTcpTlsMaxVersionTLSv1  InputTcpTlsMaxVersion = "TLSv1"
	InputTcpTlsMaxVersionTLSv11 InputTcpTlsMaxVersion = "TLSv1.1"
	InputTcpTlsMaxVersionTLSv12 InputTcpTlsMaxVersion = "TLSv1.2"
	InputTcpTlsMaxVersionTLSv13 InputTcpTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputTcpTlsMinVersion.
const (
	InputTcpTlsMinVersionTLSv1  InputTcpTlsMinVersion = "TLSv1"
	InputTcpTlsMinVersionTLSv11 InputTcpTlsMinVersion = "TLSv1.1"
	InputTcpTlsMinVersionTLSv12 InputTcpTlsMinVersion = "TLSv1.2"
	InputTcpTlsMinVersionTLSv13 InputTcpTlsMinVersion = "TLSv1.3"
)

// Defines values for InputTcpType.
const (
	InputTcpTypeTcp InputTcpType = "tcp"
)

// Defines values for InputTcpjsonAuthType.
const (
	InputTcpjsonAuthTypeManual InputTcpjsonAuthType = "manual"
	InputTcpjsonAuthTypeSecret InputTcpjsonAuthType = "secret"
)

// Defines values for InputTcpjsonPqCompress.
const (
	InputTcpjsonPqCompressGzip InputTcpjsonPqCompress = "gzip"
	InputTcpjsonPqCompressNone InputTcpjsonPqCompress = "none"
)

// Defines values for InputTcpjsonPqMode.
const (
	InputTcpjsonPqModeAlways InputTcpjsonPqMode = "always"
	InputTcpjsonPqModeSmart  InputTcpjsonPqMode = "smart"
)

// Defines values for InputTcpjsonPqEnabled.
const (
	InputTcpjsonPqEnabledFalse InputTcpjsonPqEnabled = false
	InputTcpjsonPqEnabledTrue  InputTcpjsonPqEnabled = true
)

// Defines values for InputTcpjsonSendToRoutes.
const (
	InputTcpjsonSendToRoutesFalse InputTcpjsonSendToRoutes = false
	InputTcpjsonSendToRoutesTrue  InputTcpjsonSendToRoutes = true
)

// Defines values for InputTcpjsonTlsDisabled.
const (
	InputTcpjsonTlsDisabledFalse InputTcpjsonTlsDisabled = false
	InputTcpjsonTlsDisabledTrue  InputTcpjsonTlsDisabled = true
)

// Defines values for InputTcpjsonTlsMaxVersion.
const (
	InputTcpjsonTlsMaxVersionTLSv1  InputTcpjsonTlsMaxVersion = "TLSv1"
	InputTcpjsonTlsMaxVersionTLSv11 InputTcpjsonTlsMaxVersion = "TLSv1.1"
	InputTcpjsonTlsMaxVersionTLSv12 InputTcpjsonTlsMaxVersion = "TLSv1.2"
	InputTcpjsonTlsMaxVersionTLSv13 InputTcpjsonTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputTcpjsonTlsMinVersion.
const (
	InputTcpjsonTlsMinVersionTLSv1  InputTcpjsonTlsMinVersion = "TLSv1"
	InputTcpjsonTlsMinVersionTLSv11 InputTcpjsonTlsMinVersion = "TLSv1.1"
	InputTcpjsonTlsMinVersionTLSv12 InputTcpjsonTlsMinVersion = "TLSv1.2"
	InputTcpjsonTlsMinVersionTLSv13 InputTcpjsonTlsMinVersion = "TLSv1.3"
)

// Defines values for InputTcpjsonType.
const (
	InputTcpjsonTypeTcpjson InputTcpjsonType = "tcpjson"
)

// Defines values for InputWefAuthMethod.
const (
	InputWefAuthMethodClientCert InputWefAuthMethod = "clientCert"
	InputWefAuthMethodKerberos   InputWefAuthMethod = "kerberos"
)

// Defines values for InputWefPqCompress.
const (
	InputWefPqCompressGzip InputWefPqCompress = "gzip"
	InputWefPqCompressNone InputWefPqCompress = "none"
)

// Defines values for InputWefPqMode.
const (
	InputWefPqModeAlways InputWefPqMode = "always"
	InputWefPqModeSmart  InputWefPqMode = "smart"
)

// Defines values for InputWefPqEnabled.
const (
	InputWefPqEnabledFalse InputWefPqEnabled = false
	InputWefPqEnabledTrue  InputWefPqEnabled = true
)

// Defines values for InputWefSendToRoutes.
const (
	InputWefSendToRoutesFalse InputWefSendToRoutes = false
	InputWefSendToRoutesTrue  InputWefSendToRoutes = true
)

// Defines values for InputWefSubscriptionsContentFormat.
const (
	InputWefSubscriptionsContentFormatRaw          InputWefSubscriptionsContentFormat = "Raw"
	InputWefSubscriptionsContentFormatRenderedText InputWefSubscriptionsContentFormat = "RenderedText"
)

// Defines values for InputWefSubscriptionsQuerySelector.
const (
	InputWefSubscriptionsQuerySelectorSimple InputWefSubscriptionsQuerySelector = "simple"
	InputWefSubscriptionsQuerySelectorXml    InputWefSubscriptionsQuerySelector = "xml"
)

// Defines values for InputWefTlsMaxVersion.
const (
	InputWefTlsMaxVersionTLSv1  InputWefTlsMaxVersion = "TLSv1"
	InputWefTlsMaxVersionTLSv11 InputWefTlsMaxVersion = "TLSv1.1"
	InputWefTlsMaxVersionTLSv12 InputWefTlsMaxVersion = "TLSv1.2"
	InputWefTlsMaxVersionTLSv13 InputWefTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputWefTlsMinVersion.
const (
	InputWefTlsMinVersionTLSv1  InputWefTlsMinVersion = "TLSv1"
	InputWefTlsMinVersionTLSv11 InputWefTlsMinVersion = "TLSv1.1"
	InputWefTlsMinVersionTLSv12 InputWefTlsMinVersion = "TLSv1.2"
	InputWefTlsMinVersionTLSv13 InputWefTlsMinVersion = "TLSv1.3"
)

// Defines values for InputWefTlsOcspCheck.
const (
	InputWefTlsOcspCheckFalse InputWefTlsOcspCheck = false
	InputWefTlsOcspCheckTrue  InputWefTlsOcspCheck = true
)

// Defines values for InputWefType.
const (
	Wef InputWefType = "wef"
)

// Defines values for InputWinEventLogsDisableNativeModule.
const (
	InputWinEventLogsDisableNativeModuleFalse InputWinEventLogsDisableNativeModule = false
	InputWinEventLogsDisableNativeModuleTrue  InputWinEventLogsDisableNativeModule = true
)

// Defines values for InputWinEventLogsEventFormat.
const (
	InputWinEventLogsEventFormatJson InputWinEventLogsEventFormat = "json"
	InputWinEventLogsEventFormatXml  InputWinEventLogsEventFormat = "xml"
)

// Defines values for InputWinEventLogsPqCompress.
const (
	InputWinEventLogsPqCompressGzip InputWinEventLogsPqCompress = "gzip"
	InputWinEventLogsPqCompressNone InputWinEventLogsPqCompress = "none"
)

// Defines values for InputWinEventLogsPqMode.
const (
	InputWinEventLogsPqModeAlways InputWinEventLogsPqMode = "always"
	InputWinEventLogsPqModeSmart  InputWinEventLogsPqMode = "smart"
)

// Defines values for InputWinEventLogsPqEnabled.
const (
	InputWinEventLogsPqEnabledFalse InputWinEventLogsPqEnabled = false
	InputWinEventLogsPqEnabledTrue  InputWinEventLogsPqEnabled = true
)

// Defines values for InputWinEventLogsReadMode.
const (
	Newest InputWinEventLogsReadMode = "newest"
	Oldest InputWinEventLogsReadMode = "oldest"
)

// Defines values for InputWinEventLogsSendToRoutes.
const (
	InputWinEventLogsSendToRoutesFalse InputWinEventLogsSendToRoutes = false
	InputWinEventLogsSendToRoutesTrue  InputWinEventLogsSendToRoutes = true
)

// Defines values for InputWinEventLogsType.
const (
	WinEventLogs InputWinEventLogsType = "win_event_logs"
)

// Defines values for InputWindowsMetricsHostCustomCpuMode.
const (
	InputWindowsMetricsHostCustomCpuModeAll      InputWindowsMetricsHostCustomCpuMode = "all"
	InputWindowsMetricsHostCustomCpuModeBasic    InputWindowsMetricsHostCustomCpuMode = "basic"
	InputWindowsMetricsHostCustomCpuModeCustom   InputWindowsMetricsHostCustomCpuMode = "custom"
	InputWindowsMetricsHostCustomCpuModeDisabled InputWindowsMetricsHostCustomCpuMode = "disabled"
)

// Defines values for InputWindowsMetricsHostCustomDiskMode.
const (
	InputWindowsMetricsHostCustomDiskModeAll      InputWindowsMetricsHostCustomDiskMode = "all"
	InputWindowsMetricsHostCustomDiskModeBasic    InputWindowsMetricsHostCustomDiskMode = "basic"
	InputWindowsMetricsHostCustomDiskModeCustom   InputWindowsMetricsHostCustomDiskMode = "custom"
	InputWindowsMetricsHostCustomDiskModeDisabled InputWindowsMetricsHostCustomDiskMode = "disabled"
)

// Defines values for InputWindowsMetricsHostCustomMemoryMode.
const (
	InputWindowsMetricsHostCustomMemoryModeAll      InputWindowsMetricsHostCustomMemoryMode = "all"
	InputWindowsMetricsHostCustomMemoryModeBasic    InputWindowsMetricsHostCustomMemoryMode = "basic"
	InputWindowsMetricsHostCustomMemoryModeCustom   InputWindowsMetricsHostCustomMemoryMode = "custom"
	InputWindowsMetricsHostCustomMemoryModeDisabled InputWindowsMetricsHostCustomMemoryMode = "disabled"
)

// Defines values for InputWindowsMetricsHostCustomNetworkMode.
const (
	InputWindowsMetricsHostCustomNetworkModeAll      InputWindowsMetricsHostCustomNetworkMode = "all"
	InputWindowsMetricsHostCustomNetworkModeBasic    InputWindowsMetricsHostCustomNetworkMode = "basic"
	InputWindowsMetricsHostCustomNetworkModeCustom   InputWindowsMetricsHostCustomNetworkMode = "custom"
	InputWindowsMetricsHostCustomNetworkModeDisabled InputWindowsMetricsHostCustomNetworkMode = "disabled"
)

// Defines values for InputWindowsMetricsHostCustomSystemMode.
const (
	InputWindowsMetricsHostCustomSystemModeAll      InputWindowsMetricsHostCustomSystemMode = "all"
	InputWindowsMetricsHostCustomSystemModeBasic    InputWindowsMetricsHostCustomSystemMode = "basic"
	InputWindowsMetricsHostCustomSystemModeCustom   InputWindowsMetricsHostCustomSystemMode = "custom"
	InputWindowsMetricsHostCustomSystemModeDisabled InputWindowsMetricsHostCustomSystemMode = "disabled"
)

// Defines values for InputWindowsMetricsHostMode.
const (
	InputWindowsMetricsHostModeAll      InputWindowsMetricsHostMode = "all"
	InputWindowsMetricsHostModeBasic    InputWindowsMetricsHostMode = "basic"
	InputWindowsMetricsHostModeCustom   InputWindowsMetricsHostMode = "custom"
	InputWindowsMetricsHostModeDisabled InputWindowsMetricsHostMode = "disabled"
)

// Defines values for InputWindowsMetricsPersistenceCompress.
const (
	InputWindowsMetricsPersistenceCompressGzip InputWindowsMetricsPersistenceCompress = "gzip"
	InputWindowsMetricsPersistenceCompressNone InputWindowsMetricsPersistenceCompress = "none"
)

// Defines values for InputWindowsMetricsPersistenceEnable.
const (
	InputWindowsMetricsPersistenceEnableFalse InputWindowsMetricsPersistenceEnable = false
	InputWindowsMetricsPersistenceEnableTrue  InputWindowsMetricsPersistenceEnable = true
)

// Defines values for InputWindowsMetricsPqCompress.
const (
	InputWindowsMetricsPqCompressGzip InputWindowsMetricsPqCompress = "gzip"
	InputWindowsMetricsPqCompressNone InputWindowsMetricsPqCompress = "none"
)

// Defines values for InputWindowsMetricsPqMode.
const (
	InputWindowsMetricsPqModeAlways InputWindowsMetricsPqMode = "always"
	InputWindowsMetricsPqModeSmart  InputWindowsMetricsPqMode = "smart"
)

// Defines values for InputWindowsMetricsPqEnabled.
const (
	InputWindowsMetricsPqEnabledFalse InputWindowsMetricsPqEnabled = false
	InputWindowsMetricsPqEnabledTrue  InputWindowsMetricsPqEnabled = true
)

// Defines values for InputWindowsMetricsSendToRoutes.
const (
	InputWindowsMetricsSendToRoutesFalse InputWindowsMetricsSendToRoutes = false
	InputWindowsMetricsSendToRoutesTrue  InputWindowsMetricsSendToRoutes = true
)

// Defines values for InputWindowsMetricsType.
const (
	WindowsMetrics InputWindowsMetricsType = "windows_metrics"
)

// Defines values for InputWizAuthType.
const (
	InputWizAuthTypeManual InputWizAuthType = "manual"
	InputWizAuthTypeSecret InputWizAuthType = "secret"
)

// Defines values for InputWizPqCompress.
const (
	InputWizPqCompressGzip InputWizPqCompress = "gzip"
	InputWizPqCompressNone InputWizPqCompress = "none"
)

// Defines values for InputWizPqMode.
const (
	InputWizPqModeAlways InputWizPqMode = "always"
	InputWizPqModeSmart  InputWizPqMode = "smart"
)

// Defines values for InputWizPqEnabled.
const (
	InputWizPqEnabledFalse InputWizPqEnabled = false
	InputWizPqEnabledTrue  InputWizPqEnabled = true
)

// Defines values for InputWizRetryRulesType.
const (
	InputWizRetryRulesTypeBackoff InputWizRetryRulesType = "backoff"
	InputWizRetryRulesTypeNone    InputWizRetryRulesType = "none"
	InputWizRetryRulesTypeStatic  InputWizRetryRulesType = "static"
)

// Defines values for InputWizSendToRoutes.
const (
	InputWizSendToRoutesFalse InputWizSendToRoutes = false
	InputWizSendToRoutesTrue  InputWizSendToRoutes = true
)

// Defines values for InputWizType.
const (
	InputWizTypeAppscope             InputWizType = "appscope"
	InputWizTypeAzureBlob            InputWizType = "azure_blob"
	InputWizTypeConfluentCloud       InputWizType = "confluent_cloud"
	InputWizTypeCribl                InputWizType = "cribl"
	InputWizTypeCriblHttp            InputWizType = "cribl_http"
	InputWizTypeCriblTcp             InputWizType = "cribl_tcp"
	InputWizTypeCriblmetrics         InputWizType = "criblmetrics"
	InputWizTypeCrowdstrike          InputWizType = "crowdstrike"
	InputWizTypeDatadogAgent         InputWizType = "datadog_agent"
	InputWizTypeDatagen              InputWizType = "datagen"
	InputWizTypeEdgePrometheus       InputWizType = "edge_prometheus"
	InputWizTypeElastic              InputWizType = "elastic"
	InputWizTypeEventhub             InputWizType = "eventhub"
	InputWizTypeExec                 InputWizType = "exec"
	InputWizTypeFile                 InputWizType = "file"
	InputWizTypeFirehose             InputWizType = "firehose"
	InputWizTypeGooglePubsub         InputWizType = "google_pubsub"
	InputWizTypeGrafana              InputWizType = "grafana"
	InputWizTypeHttp                 InputWizType = "http"
	InputWizTypeHttpRaw              InputWizType = "http_raw"
	InputWizTypeJournalFiles         InputWizType = "journal_files"
	InputWizTypeKafka                InputWizType = "kafka"
	InputWizTypeKinesis              InputWizType = "kinesis"
	InputWizTypeKubeEvents           InputWizType = "kube_events"
	InputWizTypeKubeLogs             InputWizType = "kube_logs"
	InputWizTypeKubeMetrics          InputWizType = "kube_metrics"
	InputWizTypeLoki                 InputWizType = "loki"
	InputWizTypeMetrics              InputWizType = "metrics"
	InputWizTypeModelDrivenTelemetry InputWizType = "model_driven_telemetry"
	InputWizTypeMsk                  InputWizType = "msk"
	InputWizTypeNetflow              InputWizType = "netflow"
	InputWizTypeOffice365Mgmt        InputWizType = "office365_mgmt"
	InputWizTypeOffice365MsgTrace    InputWizType = "office365_msg_trace"
	InputWizTypeOffice365Service     InputWizType = "office365_service"
	InputWizTypeOpenTelemetry        InputWizType = "open_telemetry"
	InputWizTypePrometheus           InputWizType = "prometheus"
	InputWizTypePrometheusRw         InputWizType = "prometheus_rw"
	InputWizTypeRawUdp               InputWizType = "raw_udp"
	InputWizTypeS3                   InputWizType = "s3"
	InputWizTypeS3Inventory          InputWizType = "s3_inventory"
	InputWizTypeSecurityLake         InputWizType = "security_lake"
	InputWizTypeSnmp                 InputWizType = "snmp"
	InputWizTypeSplunk               InputWizType = "splunk"
	InputWizTypeSplunkHec            InputWizType = "splunk_hec"
	InputWizTypeSplunkSearch         InputWizType = "splunk_search"
	InputWizTypeSqs                  InputWizType = "sqs"
	InputWizTypeSyslog               InputWizType = "syslog"
	InputWizTypeSystemMetrics        InputWizType = "system_metrics"
	InputWizTypeSystemState          InputWizType = "system_state"
	InputWizTypeTcp                  InputWizType = "tcp"
	InputWizTypeTcpjson              InputWizType = "tcpjson"
	InputWizTypeWef                  InputWizType = "wef"
	InputWizTypeWinEventLogs         InputWizType = "win_event_logs"
	InputWizTypeWindowsMetrics       InputWizType = "windows_metrics"
	InputWizTypeWiz                  InputWizType = "wiz"
	InputWizTypeZscalerHec           InputWizType = "zscaler_hec"
)

// Defines values for InputZscalerHecAuthTokensAuthType.
const (
	InputZscalerHecAuthTokensAuthTypeManual InputZscalerHecAuthTokensAuthType = "manual"
	InputZscalerHecAuthTokensAuthTypeSecret InputZscalerHecAuthTokensAuthType = "secret"
)

// Defines values for InputZscalerHecPqCompress.
const (
	InputZscalerHecPqCompressGzip InputZscalerHecPqCompress = "gzip"
	InputZscalerHecPqCompressNone InputZscalerHecPqCompress = "none"
)

// Defines values for InputZscalerHecPqMode.
const (
	InputZscalerHecPqModeAlways InputZscalerHecPqMode = "always"
	InputZscalerHecPqModeSmart  InputZscalerHecPqMode = "smart"
)

// Defines values for InputZscalerHecPqEnabled.
const (
	InputZscalerHecPqEnabledFalse InputZscalerHecPqEnabled = false
	InputZscalerHecPqEnabledTrue  InputZscalerHecPqEnabled = true
)

// Defines values for InputZscalerHecSendToRoutes.
const (
	InputZscalerHecSendToRoutesFalse InputZscalerHecSendToRoutes = false
	InputZscalerHecSendToRoutesTrue  InputZscalerHecSendToRoutes = true
)

// Defines values for InputZscalerHecTlsDisabled.
const (
	InputZscalerHecTlsDisabledFalse InputZscalerHecTlsDisabled = false
	InputZscalerHecTlsDisabledTrue  InputZscalerHecTlsDisabled = true
)

// Defines values for InputZscalerHecTlsMaxVersion.
const (
	InputZscalerHecTlsMaxVersionTLSv1  InputZscalerHecTlsMaxVersion = "TLSv1"
	InputZscalerHecTlsMaxVersionTLSv11 InputZscalerHecTlsMaxVersion = "TLSv1.1"
	InputZscalerHecTlsMaxVersionTLSv12 InputZscalerHecTlsMaxVersion = "TLSv1.2"
	InputZscalerHecTlsMaxVersionTLSv13 InputZscalerHecTlsMaxVersion = "TLSv1.3"
)

// Defines values for InputZscalerHecTlsMinVersion.
const (
	InputZscalerHecTlsMinVersionTLSv1  InputZscalerHecTlsMinVersion = "TLSv1"
	InputZscalerHecTlsMinVersionTLSv11 InputZscalerHecTlsMinVersion = "TLSv1.1"
	InputZscalerHecTlsMinVersionTLSv12 InputZscalerHecTlsMinVersion = "TLSv1.2"
	InputZscalerHecTlsMinVersionTLSv13 InputZscalerHecTlsMinVersion = "TLSv1.3"
)

// Defines values for InputZscalerHecType.
const (
	ZscalerHec InputZscalerHecType = "zscaler_hec"
)

// Defines values for KMSHealthStatus.
const (
	KMSHealthStatusN0 KMSHealthStatus = 0
	KMSHealthStatusN1 KMSHealthStatus = 1
	KMSHealthStatusN2 KMSHealthStatus = 2
	KMSHealthStatusN3 KMSHealthStatus = 3
)

// Defines values for KeyMetadataEntityAlgorithm.
const (
	Aes256Cbc KeyMetadataEntityAlgorithm = "aes-256-cbc"
	Aes256Gcm KeyMetadataEntityAlgorithm = "aes-256-gcm"
)

// Defines values for KeyMetadataEntityIvSize.
const (
	KeyMetadataEntityIvSizeN12 KeyMetadataEntityIvSize = 12
	KeyMetadataEntityIvSizeN13 KeyMetadataEntityIvSize = 13
	KeyMetadataEntityIvSizeN14 KeyMetadataEntityIvSize = 14
	KeyMetadataEntityIvSizeN15 KeyMetadataEntityIvSize = 15
	KeyMetadataEntityIvSizeN16 KeyMetadataEntityIvSize = 16
)

// Defines values for KeyMetadataEntityKms.
const (
	KeyMetadataEntityKmsLocal KeyMetadataEntityKms = "local"
)

// Defines values for LicenseCls.
const (
	LicenseClsFree  LicenseCls = "free"
	LicenseClsProd  LicenseCls = "prod"
	LicenseClsTrial LicenseCls = "trial"
)

// Defines values for LicenseInfoType.
const (
	LicenseInfoTypeFree  LicenseInfoType = "free"
	LicenseInfoTypeProd  LicenseInfoType = "prod"
	LicenseInfoTypeTrial LicenseInfoType = "trial"
)

// Defines values for MappingType.
const (
	MappingTypeAutomatic MappingType = "automatic"
	MappingTypeCustom    MappingType = "custom"
)

// Defines values for MasterWorkerEntryType.
const (
	MasterWorkerEntryTypeInfo MasterWorkerEntryType = "info"
	MasterWorkerEntryTypeReq  MasterWorkerEntryType = "req"
	MasterWorkerEntryTypeResp MasterWorkerEntryType = "resp"
)

// Defines values for MultiFactorAuthSchemaType.
const (
	Piv MultiFactorAuthSchemaType = "piv"
)

// Defines values for NodeActiveUpgradeStatus.
const (
	NodeActiveUpgradeStatusN0 NodeActiveUpgradeStatus = 0
	NodeActiveUpgradeStatusN1 NodeActiveUpgradeStatus = 1
	NodeActiveUpgradeStatusN2 NodeActiveUpgradeStatus = 2
)

// Defines values for NodeFailedUpgradeStatus.
const (
	NodeFailedUpgradeStatusN0 NodeFailedUpgradeStatus = 0
	NodeFailedUpgradeStatusN1 NodeFailedUpgradeStatus = 1
)

// Defines values for NodeSkippedUpgradeStatus.
const (
	NodeSkippedUpgradeStatusN0 NodeSkippedUpgradeStatus = 0
	NodeSkippedUpgradeStatusN1 NodeSkippedUpgradeStatus = 1
	NodeSkippedUpgradeStatusN2 NodeSkippedUpgradeStatus = 2
	NodeSkippedUpgradeStatusN3 NodeSkippedUpgradeStatus = 3
)

// Defines values for NodeUpgradeState.
const (
	NodeUpgradeStateN0 NodeUpgradeState = 0
	NodeUpgradeStateN1 NodeUpgradeState = 1
	NodeUpgradeStateN2 NodeUpgradeState = 2
	NodeUpgradeStateN3 NodeUpgradeState = 3
)

// Defines values for OutputAzureBlobAuthType.
const (
	OutputAzureBlobAuthTypeClientCert   OutputAzureBlobAuthType = "clientCert"
	OutputAzureBlobAuthTypeClientSecret OutputAzureBlobAuthType = "clientSecret"
	OutputAzureBlobAuthTypeManual       OutputAzureBlobAuthType = "manual"
	OutputAzureBlobAuthTypeSecret       OutputAzureBlobAuthType = "secret"
)

// Defines values for OutputAzureBlobCompress.
const (
	OutputAzureBlobCompressGzip OutputAzureBlobCompress = "gzip"
	OutputAzureBlobCompressNone OutputAzureBlobCompress = "none"
)

// Defines values for OutputAzureBlobCompressionLevel.
const (
	OutputAzureBlobCompressionLevelBestCompression OutputAzureBlobCompressionLevel = "best_compression"
	OutputAzureBlobCompressionLevelBestSpeed       OutputAzureBlobCompressionLevel = "best_speed"
	OutputAzureBlobCompressionLevelNormal          OutputAzureBlobCompressionLevel = "normal"
)

// Defines values for OutputAzureBlobDeadletterEnabled.
const (
	OutputAzureBlobDeadletterEnabledFalse OutputAzureBlobDeadletterEnabled = false
	OutputAzureBlobDeadletterEnabledTrue  OutputAzureBlobDeadletterEnabled = true
)

// Defines values for OutputAzureBlobFormat.
const (
	OutputAzureBlobFormatJson    OutputAzureBlobFormat = "json"
	OutputAzureBlobFormatParquet OutputAzureBlobFormat = "parquet"
	OutputAzureBlobFormatRaw     OutputAzureBlobFormat = "raw"
)

// Defines values for OutputAzureBlobOnBackpressure.
const (
	OutputAzureBlobOnBackpressureBlock OutputAzureBlobOnBackpressure = "block"
	OutputAzureBlobOnBackpressureDrop  OutputAzureBlobOnBackpressure = "drop"
)

// Defines values for OutputAzureBlobOnDiskFullBackpressure.
const (
	OutputAzureBlobOnDiskFullBackpressureBlock OutputAzureBlobOnDiskFullBackpressure = "block"
	OutputAzureBlobOnDiskFullBackpressureDrop  OutputAzureBlobOnDiskFullBackpressure = "drop"
)

// Defines values for OutputAzureBlobParquetDataPageVersion.
const (
	OutputAzureBlobParquetDataPageVersionDATAPAGEV1 OutputAzureBlobParquetDataPageVersion = "DATA_PAGE_V1"
	OutputAzureBlobParquetDataPageVersionDATAPAGEV2 OutputAzureBlobParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputAzureBlobParquetVersion.
const (
	OutputAzureBlobParquetVersionPARQUET10 OutputAzureBlobParquetVersion = "PARQUET_1_0"
	OutputAzureBlobParquetVersionPARQUET24 OutputAzureBlobParquetVersion = "PARQUET_2_4"
	OutputAzureBlobParquetVersionPARQUET26 OutputAzureBlobParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputAzureBlobRemoveEmptyDirs.
const (
	OutputAzureBlobRemoveEmptyDirsFalse OutputAzureBlobRemoveEmptyDirs = false
	OutputAzureBlobRemoveEmptyDirsTrue  OutputAzureBlobRemoveEmptyDirs = true
)

// Defines values for OutputAzureBlobStorageClass.
const (
	Archive  OutputAzureBlobStorageClass = "Archive"
	Cold     OutputAzureBlobStorageClass = "Cold"
	Cool     OutputAzureBlobStorageClass = "Cool"
	Hot      OutputAzureBlobStorageClass = "Hot"
	Inferred OutputAzureBlobStorageClass = "Inferred"
)

// Defines values for OutputAzureBlobType.
const (
	AzureBlob OutputAzureBlobType = "azure_blob"
)

// Defines values for OutputAzureDataExplorerCompress.
const (
	OutputAzureDataExplorerCompressGzip OutputAzureDataExplorerCompress = "gzip"
	OutputAzureDataExplorerCompressNone OutputAzureDataExplorerCompress = "none"
)

// Defines values for OutputAzureDataExplorerDeadletterEnabled.
const (
	OutputAzureDataExplorerDeadletterEnabledFalse OutputAzureDataExplorerDeadletterEnabled = false
	OutputAzureDataExplorerDeadletterEnabledTrue  OutputAzureDataExplorerDeadletterEnabled = true
)

// Defines values for OutputAzureDataExplorerExtentTagsPrefix.
const (
	DropBy   OutputAzureDataExplorerExtentTagsPrefix = "dropBy"
	IngestBy OutputAzureDataExplorerExtentTagsPrefix = "ingestBy"
)

// Defines values for OutputAzureDataExplorerFormat.
const (
	OutputAzureDataExplorerFormatJson    OutputAzureDataExplorerFormat = "json"
	OutputAzureDataExplorerFormatParquet OutputAzureDataExplorerFormat = "parquet"
	OutputAzureDataExplorerFormatRaw     OutputAzureDataExplorerFormat = "raw"
)

// Defines values for OutputAzureDataExplorerIngestMode.
const (
	Batching  OutputAzureDataExplorerIngestMode = "batching"
	Streaming OutputAzureDataExplorerIngestMode = "streaming"
)

// Defines values for OutputAzureDataExplorerOauthEndpoint.
const (
	HttpsloginMicrosoftonlineCom       OutputAzureDataExplorerOauthEndpoint = "https://login.microsoftonline.com"
	HttpsloginMicrosoftonlineUs        OutputAzureDataExplorerOauthEndpoint = "https://login.microsoftonline.us"
	HttpsloginPartnerMicrosoftonlineCn OutputAzureDataExplorerOauthEndpoint = "https://login.partner.microsoftonline.cn"
)

// Defines values for OutputAzureDataExplorerOauthType.
const (
	OutputAzureDataExplorerOauthTypeCertificate      OutputAzureDataExplorerOauthType = "certificate"
	OutputAzureDataExplorerOauthTypeClientSecret     OutputAzureDataExplorerOauthType = "clientSecret"
	OutputAzureDataExplorerOauthTypeClientTextSecret OutputAzureDataExplorerOauthType = "clientTextSecret"
)

// Defines values for OutputAzureDataExplorerOnBackpressure.
const (
	OutputAzureDataExplorerOnBackpressureBlock OutputAzureDataExplorerOnBackpressure = "block"
	OutputAzureDataExplorerOnBackpressureDrop  OutputAzureDataExplorerOnBackpressure = "drop"
	OutputAzureDataExplorerOnBackpressureQueue OutputAzureDataExplorerOnBackpressure = "queue"
)

// Defines values for OutputAzureDataExplorerOnDiskFullBackpressure.
const (
	OutputAzureDataExplorerOnDiskFullBackpressureBlock OutputAzureDataExplorerOnDiskFullBackpressure = "block"
	OutputAzureDataExplorerOnDiskFullBackpressureDrop  OutputAzureDataExplorerOnDiskFullBackpressure = "drop"
)

// Defines values for OutputAzureDataExplorerPqCompress.
const (
	OutputAzureDataExplorerPqCompressGzip OutputAzureDataExplorerPqCompress = "gzip"
	OutputAzureDataExplorerPqCompressNone OutputAzureDataExplorerPqCompress = "none"
)

// Defines values for OutputAzureDataExplorerPqMode.
const (
	OutputAzureDataExplorerPqModeAlways       OutputAzureDataExplorerPqMode = "always"
	OutputAzureDataExplorerPqModeBackpressure OutputAzureDataExplorerPqMode = "backpressure"
	OutputAzureDataExplorerPqModeError        OutputAzureDataExplorerPqMode = "error"
)

// Defines values for OutputAzureDataExplorerPqOnBackpressure.
const (
	OutputAzureDataExplorerPqOnBackpressureBlock OutputAzureDataExplorerPqOnBackpressure = "block"
	OutputAzureDataExplorerPqOnBackpressureDrop  OutputAzureDataExplorerPqOnBackpressure = "drop"
)

// Defines values for OutputAzureDataExplorerRemoveEmptyDirs.
const (
	OutputAzureDataExplorerRemoveEmptyDirsFalse OutputAzureDataExplorerRemoveEmptyDirs = false
	OutputAzureDataExplorerRemoveEmptyDirsTrue  OutputAzureDataExplorerRemoveEmptyDirs = true
)

// Defines values for OutputAzureDataExplorerReportLevel.
const (
	DoNotReport          OutputAzureDataExplorerReportLevel = "doNotReport"
	FailuresAndSuccesses OutputAzureDataExplorerReportLevel = "failuresAndSuccesses"
	FailuresOnly         OutputAzureDataExplorerReportLevel = "failuresOnly"
)

// Defines values for OutputAzureDataExplorerReportMethod.
const (
	OutputAzureDataExplorerReportMethodQueue         OutputAzureDataExplorerReportMethod = "queue"
	OutputAzureDataExplorerReportMethodQueueAndTable OutputAzureDataExplorerReportMethod = "queueAndTable"
	OutputAzureDataExplorerReportMethodTable         OutputAzureDataExplorerReportMethod = "table"
)

// Defines values for OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry.
const (
	OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetryFalse OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry = false
	OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetryTrue  OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputAzureDataExplorerType.
const (
	AzureDataExplorer OutputAzureDataExplorerType = "azure_data_explorer"
)

// Defines values for OutputAzureEventhubAck.
const (
	OutputAzureEventhubAckMinus1 OutputAzureEventhubAck = -1
	OutputAzureEventhubAckN0     OutputAzureEventhubAck = 0
	OutputAzureEventhubAckN1     OutputAzureEventhubAck = 1
)

// Defines values for OutputAzureEventhubFormat.
const (
	OutputAzureEventhubFormatJson OutputAzureEventhubFormat = "json"
	OutputAzureEventhubFormatRaw  OutputAzureEventhubFormat = "raw"
)

// Defines values for OutputAzureEventhubOnBackpressure.
const (
	OutputAzureEventhubOnBackpressureBlock OutputAzureEventhubOnBackpressure = "block"
	OutputAzureEventhubOnBackpressureDrop  OutputAzureEventhubOnBackpressure = "drop"
	OutputAzureEventhubOnBackpressureQueue OutputAzureEventhubOnBackpressure = "queue"
)

// Defines values for OutputAzureEventhubPqCompress.
const (
	OutputAzureEventhubPqCompressGzip OutputAzureEventhubPqCompress = "gzip"
	OutputAzureEventhubPqCompressNone OutputAzureEventhubPqCompress = "none"
)

// Defines values for OutputAzureEventhubPqMode.
const (
	OutputAzureEventhubPqModeAlways       OutputAzureEventhubPqMode = "always"
	OutputAzureEventhubPqModeBackpressure OutputAzureEventhubPqMode = "backpressure"
	OutputAzureEventhubPqModeError        OutputAzureEventhubPqMode = "error"
)

// Defines values for OutputAzureEventhubPqOnBackpressure.
const (
	OutputAzureEventhubPqOnBackpressureBlock OutputAzureEventhubPqOnBackpressure = "block"
	OutputAzureEventhubPqOnBackpressureDrop  OutputAzureEventhubPqOnBackpressure = "drop"
)

// Defines values for OutputAzureEventhubSaslDisabled.
const (
	OutputAzureEventhubSaslDisabledFalse OutputAzureEventhubSaslDisabled = false
	OutputAzureEventhubSaslDisabledTrue  OutputAzureEventhubSaslDisabled = true
)

// Defines values for OutputAzureEventhubSaslMechanism.
const (
	OutputAzureEventhubSaslMechanismOauthbearer OutputAzureEventhubSaslMechanism = "oauthbearer"
	OutputAzureEventhubSaslMechanismPlain       OutputAzureEventhubSaslMechanism = "plain"
)

// Defines values for OutputAzureEventhubTlsDisabled.
const (
	OutputAzureEventhubTlsDisabledFalse OutputAzureEventhubTlsDisabled = false
	OutputAzureEventhubTlsDisabledTrue  OutputAzureEventhubTlsDisabled = true
)

// Defines values for OutputAzureEventhubType.
const (
	AzureEventhub OutputAzureEventhubType = "azure_eventhub"
)

// Defines values for OutputAzureLogsAuthType.
const (
	OutputAzureLogsAuthTypeManual OutputAzureLogsAuthType = "manual"
	OutputAzureLogsAuthTypeSecret OutputAzureLogsAuthType = "secret"
)

// Defines values for OutputAzureLogsFailedRequestLoggingMode.
const (
	OutputAzureLogsFailedRequestLoggingModeNone              OutputAzureLogsFailedRequestLoggingMode = "none"
	OutputAzureLogsFailedRequestLoggingModePayload           OutputAzureLogsFailedRequestLoggingMode = "payload"
	OutputAzureLogsFailedRequestLoggingModePayloadAndHeaders OutputAzureLogsFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputAzureLogsOnBackpressure.
const (
	OutputAzureLogsOnBackpressureBlock OutputAzureLogsOnBackpressure = "block"
	OutputAzureLogsOnBackpressureDrop  OutputAzureLogsOnBackpressure = "drop"
	OutputAzureLogsOnBackpressureQueue OutputAzureLogsOnBackpressure = "queue"
)

// Defines values for OutputAzureLogsPqCompress.
const (
	OutputAzureLogsPqCompressGzip OutputAzureLogsPqCompress = "gzip"
	OutputAzureLogsPqCompressNone OutputAzureLogsPqCompress = "none"
)

// Defines values for OutputAzureLogsPqMode.
const (
	OutputAzureLogsPqModeAlways       OutputAzureLogsPqMode = "always"
	OutputAzureLogsPqModeBackpressure OutputAzureLogsPqMode = "backpressure"
	OutputAzureLogsPqModeError        OutputAzureLogsPqMode = "error"
)

// Defines values for OutputAzureLogsPqOnBackpressure.
const (
	OutputAzureLogsPqOnBackpressureBlock OutputAzureLogsPqOnBackpressure = "block"
	OutputAzureLogsPqOnBackpressureDrop  OutputAzureLogsPqOnBackpressure = "drop"
)

// Defines values for OutputAzureLogsTimeoutRetrySettingsTimeoutRetry.
const (
	OutputAzureLogsTimeoutRetrySettingsTimeoutRetryFalse OutputAzureLogsTimeoutRetrySettingsTimeoutRetry = false
	OutputAzureLogsTimeoutRetrySettingsTimeoutRetryTrue  OutputAzureLogsTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputAzureLogsType.
const (
	AzureLogs OutputAzureLogsType = "azure_logs"
)

// Defines values for OutputClickHouseAsyncInserts.
const (
	OutputClickHouseAsyncInsertsFalse OutputClickHouseAsyncInserts = false
	OutputClickHouseAsyncInsertsTrue  OutputClickHouseAsyncInserts = true
)

// Defines values for OutputClickHouseAuthType.
const (
	OutputClickHouseAuthTypeBasic              OutputClickHouseAuthType = "basic"
	OutputClickHouseAuthTypeCredentialsSecret  OutputClickHouseAuthType = "credentialsSecret"
	OutputClickHouseAuthTypeNone               OutputClickHouseAuthType = "none"
	OutputClickHouseAuthTypeOauth              OutputClickHouseAuthType = "oauth"
	OutputClickHouseAuthTypeSslUserCertificate OutputClickHouseAuthType = "sslUserCertificate"
	OutputClickHouseAuthTypeTextSecret         OutputClickHouseAuthType = "textSecret"
	OutputClickHouseAuthTypeToken              OutputClickHouseAuthType = "token"
)

// Defines values for OutputClickHouseFailedRequestLoggingMode.
const (
	OutputClickHouseFailedRequestLoggingModeNone              OutputClickHouseFailedRequestLoggingMode = "none"
	OutputClickHouseFailedRequestLoggingModePayload           OutputClickHouseFailedRequestLoggingMode = "payload"
	OutputClickHouseFailedRequestLoggingModePayloadAndHeaders OutputClickHouseFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputClickHouseFormat.
const (
	OutputClickHouseFormatJsonCompactEachRowWithNames OutputClickHouseFormat = "json-compact-each-row-with-names"
	OutputClickHouseFormatJsonEachRow                 OutputClickHouseFormat = "json-each-row"
)

// Defines values for OutputClickHouseMappingType.
const (
	OutputClickHouseMappingTypeAutomatic OutputClickHouseMappingType = "automatic"
	OutputClickHouseMappingTypeCustom    OutputClickHouseMappingType = "custom"
)

// Defines values for OutputClickHouseOnBackpressure.
const (
	OutputClickHouseOnBackpressureBlock OutputClickHouseOnBackpressure = "block"
	OutputClickHouseOnBackpressureDrop  OutputClickHouseOnBackpressure = "drop"
	OutputClickHouseOnBackpressureQueue OutputClickHouseOnBackpressure = "queue"
)

// Defines values for OutputClickHousePqCompress.
const (
	OutputClickHousePqCompressGzip OutputClickHousePqCompress = "gzip"
	OutputClickHousePqCompressNone OutputClickHousePqCompress = "none"
)

// Defines values for OutputClickHousePqMode.
const (
	OutputClickHousePqModeAlways       OutputClickHousePqMode = "always"
	OutputClickHousePqModeBackpressure OutputClickHousePqMode = "backpressure"
	OutputClickHousePqModeError        OutputClickHousePqMode = "error"
)

// Defines values for OutputClickHousePqOnBackpressure.
const (
	OutputClickHousePqOnBackpressureBlock OutputClickHousePqOnBackpressure = "block"
	OutputClickHousePqOnBackpressureDrop  OutputClickHousePqOnBackpressure = "drop"
)

// Defines values for OutputClickHouseTimeoutRetrySettingsTimeoutRetry.
const (
	OutputClickHouseTimeoutRetrySettingsTimeoutRetryFalse OutputClickHouseTimeoutRetrySettingsTimeoutRetry = false
	OutputClickHouseTimeoutRetrySettingsTimeoutRetryTrue  OutputClickHouseTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputClickHouseTlsDisabled.
const (
	OutputClickHouseTlsDisabledFalse OutputClickHouseTlsDisabled = false
	OutputClickHouseTlsDisabledTrue  OutputClickHouseTlsDisabled = true
)

// Defines values for OutputClickHouseTlsMaxVersion.
const (
	OutputClickHouseTlsMaxVersionTLSv1  OutputClickHouseTlsMaxVersion = "TLSv1"
	OutputClickHouseTlsMaxVersionTLSv11 OutputClickHouseTlsMaxVersion = "TLSv1.1"
	OutputClickHouseTlsMaxVersionTLSv12 OutputClickHouseTlsMaxVersion = "TLSv1.2"
	OutputClickHouseTlsMaxVersionTLSv13 OutputClickHouseTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputClickHouseTlsMinVersion.
const (
	OutputClickHouseTlsMinVersionTLSv1  OutputClickHouseTlsMinVersion = "TLSv1"
	OutputClickHouseTlsMinVersionTLSv11 OutputClickHouseTlsMinVersion = "TLSv1.1"
	OutputClickHouseTlsMinVersionTLSv12 OutputClickHouseTlsMinVersion = "TLSv1.2"
	OutputClickHouseTlsMinVersionTLSv13 OutputClickHouseTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputClickHouseType.
const (
	ClickHouse OutputClickHouseType = "click_house"
)

// Defines values for OutputCloudwatchAwsAuthenticationMethod.
const (
	OutputCloudwatchAwsAuthenticationMethodAuto   OutputCloudwatchAwsAuthenticationMethod = "auto"
	OutputCloudwatchAwsAuthenticationMethodManual OutputCloudwatchAwsAuthenticationMethod = "manual"
	OutputCloudwatchAwsAuthenticationMethodSecret OutputCloudwatchAwsAuthenticationMethod = "secret"
)

// Defines values for OutputCloudwatchOnBackpressure.
const (
	OutputCloudwatchOnBackpressureBlock OutputCloudwatchOnBackpressure = "block"
	OutputCloudwatchOnBackpressureDrop  OutputCloudwatchOnBackpressure = "drop"
	OutputCloudwatchOnBackpressureQueue OutputCloudwatchOnBackpressure = "queue"
)

// Defines values for OutputCloudwatchPqCompress.
const (
	OutputCloudwatchPqCompressGzip OutputCloudwatchPqCompress = "gzip"
	OutputCloudwatchPqCompressNone OutputCloudwatchPqCompress = "none"
)

// Defines values for OutputCloudwatchPqMode.
const (
	OutputCloudwatchPqModeAlways       OutputCloudwatchPqMode = "always"
	OutputCloudwatchPqModeBackpressure OutputCloudwatchPqMode = "backpressure"
	OutputCloudwatchPqModeError        OutputCloudwatchPqMode = "error"
)

// Defines values for OutputCloudwatchPqOnBackpressure.
const (
	OutputCloudwatchPqOnBackpressureBlock OutputCloudwatchPqOnBackpressure = "block"
	OutputCloudwatchPqOnBackpressureDrop  OutputCloudwatchPqOnBackpressure = "drop"
)

// Defines values for OutputCloudwatchType.
const (
	Cloudwatch OutputCloudwatchType = "cloudwatch"
)

// Defines values for OutputConfluentCloudAck.
const (
	OutputConfluentCloudAckMinus1 OutputConfluentCloudAck = -1
	OutputConfluentCloudAckN0     OutputConfluentCloudAck = 0
	OutputConfluentCloudAckN1     OutputConfluentCloudAck = 1
)

// Defines values for OutputConfluentCloudCompression.
const (
	OutputConfluentCloudCompressionGzip   OutputConfluentCloudCompression = "gzip"
	OutputConfluentCloudCompressionLz4    OutputConfluentCloudCompression = "lz4"
	OutputConfluentCloudCompressionNone   OutputConfluentCloudCompression = "none"
	OutputConfluentCloudCompressionSnappy OutputConfluentCloudCompression = "snappy"
)

// Defines values for OutputConfluentCloudFormat.
const (
	OutputConfluentCloudFormatJson     OutputConfluentCloudFormat = "json"
	OutputConfluentCloudFormatProtobuf OutputConfluentCloudFormat = "protobuf"
	OutputConfluentCloudFormatRaw      OutputConfluentCloudFormat = "raw"
)

// Defines values for OutputConfluentCloudKafkaSchemaRegistryAuthDisabled.
const (
	OutputConfluentCloudKafkaSchemaRegistryAuthDisabledFalse OutputConfluentCloudKafkaSchemaRegistryAuthDisabled = false
	OutputConfluentCloudKafkaSchemaRegistryAuthDisabledTrue  OutputConfluentCloudKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for OutputConfluentCloudKafkaSchemaRegistryDisabled.
const (
	OutputConfluentCloudKafkaSchemaRegistryDisabledFalse OutputConfluentCloudKafkaSchemaRegistryDisabled = false
	OutputConfluentCloudKafkaSchemaRegistryDisabledTrue  OutputConfluentCloudKafkaSchemaRegistryDisabled = true
)

// Defines values for OutputConfluentCloudKafkaSchemaRegistryTlsDisabled.
const (
	OutputConfluentCloudKafkaSchemaRegistryTlsDisabledFalse OutputConfluentCloudKafkaSchemaRegistryTlsDisabled = false
	OutputConfluentCloudKafkaSchemaRegistryTlsDisabledTrue  OutputConfluentCloudKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion.
const (
	OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv1  OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv11 OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv12 OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersionTLSv13 OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion.
const (
	OutputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv1  OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	OutputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv11 OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	OutputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv12 OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	OutputConfluentCloudKafkaSchemaRegistryTlsMinVersionTLSv13 OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputConfluentCloudOnBackpressure.
const (
	OutputConfluentCloudOnBackpressureBlock OutputConfluentCloudOnBackpressure = "block"
	OutputConfluentCloudOnBackpressureDrop  OutputConfluentCloudOnBackpressure = "drop"
	OutputConfluentCloudOnBackpressureQueue OutputConfluentCloudOnBackpressure = "queue"
)

// Defines values for OutputConfluentCloudPqCompress.
const (
	OutputConfluentCloudPqCompressGzip OutputConfluentCloudPqCompress = "gzip"
	OutputConfluentCloudPqCompressNone OutputConfluentCloudPqCompress = "none"
)

// Defines values for OutputConfluentCloudPqMode.
const (
	OutputConfluentCloudPqModeAlways       OutputConfluentCloudPqMode = "always"
	OutputConfluentCloudPqModeBackpressure OutputConfluentCloudPqMode = "backpressure"
	OutputConfluentCloudPqModeError        OutputConfluentCloudPqMode = "error"
)

// Defines values for OutputConfluentCloudPqOnBackpressure.
const (
	OutputConfluentCloudPqOnBackpressureBlock OutputConfluentCloudPqOnBackpressure = "block"
	OutputConfluentCloudPqOnBackpressureDrop  OutputConfluentCloudPqOnBackpressure = "drop"
)

// Defines values for OutputConfluentCloudSaslDisabled.
const (
	OutputConfluentCloudSaslDisabledFalse OutputConfluentCloudSaslDisabled = false
	OutputConfluentCloudSaslDisabledTrue  OutputConfluentCloudSaslDisabled = true
)

// Defines values for OutputConfluentCloudSaslMechanism.
const (
	OutputConfluentCloudSaslMechanismKerberos    OutputConfluentCloudSaslMechanism = "kerberos"
	OutputConfluentCloudSaslMechanismPlain       OutputConfluentCloudSaslMechanism = "plain"
	OutputConfluentCloudSaslMechanismScramSha256 OutputConfluentCloudSaslMechanism = "scram-sha-256"
	OutputConfluentCloudSaslMechanismScramSha512 OutputConfluentCloudSaslMechanism = "scram-sha-512"
)

// Defines values for OutputConfluentCloudTlsDisabled.
const (
	OutputConfluentCloudTlsDisabledFalse OutputConfluentCloudTlsDisabled = false
	OutputConfluentCloudTlsDisabledTrue  OutputConfluentCloudTlsDisabled = true
)

// Defines values for OutputConfluentCloudTlsMaxVersion.
const (
	OutputConfluentCloudTlsMaxVersionTLSv1  OutputConfluentCloudTlsMaxVersion = "TLSv1"
	OutputConfluentCloudTlsMaxVersionTLSv11 OutputConfluentCloudTlsMaxVersion = "TLSv1.1"
	OutputConfluentCloudTlsMaxVersionTLSv12 OutputConfluentCloudTlsMaxVersion = "TLSv1.2"
	OutputConfluentCloudTlsMaxVersionTLSv13 OutputConfluentCloudTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputConfluentCloudTlsMinVersion.
const (
	OutputConfluentCloudTlsMinVersionTLSv1  OutputConfluentCloudTlsMinVersion = "TLSv1"
	OutputConfluentCloudTlsMinVersionTLSv11 OutputConfluentCloudTlsMinVersion = "TLSv1.1"
	OutputConfluentCloudTlsMinVersionTLSv12 OutputConfluentCloudTlsMinVersion = "TLSv1.2"
	OutputConfluentCloudTlsMinVersionTLSv13 OutputConfluentCloudTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputConfluentCloudType.
const (
	OutputConfluentCloudTypeConfluentCloud OutputConfluentCloudType = "confluent_cloud"
)

// Defines values for OutputCriblHttpCompression.
const (
	OutputCriblHttpCompressionGzip OutputCriblHttpCompression = "gzip"
	OutputCriblHttpCompressionNone OutputCriblHttpCompression = "none"
)

// Defines values for OutputCriblHttpFailedRequestLoggingMode.
const (
	OutputCriblHttpFailedRequestLoggingModeNone              OutputCriblHttpFailedRequestLoggingMode = "none"
	OutputCriblHttpFailedRequestLoggingModePayload           OutputCriblHttpFailedRequestLoggingMode = "payload"
	OutputCriblHttpFailedRequestLoggingModePayloadAndHeaders OutputCriblHttpFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputCriblHttpLoadBalanced.
const (
	OutputCriblHttpLoadBalancedFalse OutputCriblHttpLoadBalanced = false
	OutputCriblHttpLoadBalancedTrue  OutputCriblHttpLoadBalanced = true
)

// Defines values for OutputCriblHttpOnBackpressure.
const (
	OutputCriblHttpOnBackpressureBlock OutputCriblHttpOnBackpressure = "block"
	OutputCriblHttpOnBackpressureDrop  OutputCriblHttpOnBackpressure = "drop"
	OutputCriblHttpOnBackpressureQueue OutputCriblHttpOnBackpressure = "queue"
)

// Defines values for OutputCriblHttpPqCompress.
const (
	OutputCriblHttpPqCompressGzip OutputCriblHttpPqCompress = "gzip"
	OutputCriblHttpPqCompressNone OutputCriblHttpPqCompress = "none"
)

// Defines values for OutputCriblHttpPqMode.
const (
	OutputCriblHttpPqModeAlways       OutputCriblHttpPqMode = "always"
	OutputCriblHttpPqModeBackpressure OutputCriblHttpPqMode = "backpressure"
	OutputCriblHttpPqModeError        OutputCriblHttpPqMode = "error"
)

// Defines values for OutputCriblHttpPqOnBackpressure.
const (
	OutputCriblHttpPqOnBackpressureBlock OutputCriblHttpPqOnBackpressure = "block"
	OutputCriblHttpPqOnBackpressureDrop  OutputCriblHttpPqOnBackpressure = "drop"
)

// Defines values for OutputCriblHttpTimeoutRetrySettingsTimeoutRetry.
const (
	OutputCriblHttpTimeoutRetrySettingsTimeoutRetryFalse OutputCriblHttpTimeoutRetrySettingsTimeoutRetry = false
	OutputCriblHttpTimeoutRetrySettingsTimeoutRetryTrue  OutputCriblHttpTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputCriblHttpTlsDisabled.
const (
	OutputCriblHttpTlsDisabledFalse OutputCriblHttpTlsDisabled = false
	OutputCriblHttpTlsDisabledTrue  OutputCriblHttpTlsDisabled = true
)

// Defines values for OutputCriblHttpTlsMaxVersion.
const (
	OutputCriblHttpTlsMaxVersionTLSv1  OutputCriblHttpTlsMaxVersion = "TLSv1"
	OutputCriblHttpTlsMaxVersionTLSv11 OutputCriblHttpTlsMaxVersion = "TLSv1.1"
	OutputCriblHttpTlsMaxVersionTLSv12 OutputCriblHttpTlsMaxVersion = "TLSv1.2"
	OutputCriblHttpTlsMaxVersionTLSv13 OutputCriblHttpTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputCriblHttpTlsMinVersion.
const (
	OutputCriblHttpTlsMinVersionTLSv1  OutputCriblHttpTlsMinVersion = "TLSv1"
	OutputCriblHttpTlsMinVersionTLSv11 OutputCriblHttpTlsMinVersion = "TLSv1.1"
	OutputCriblHttpTlsMinVersionTLSv12 OutputCriblHttpTlsMinVersion = "TLSv1.2"
	OutputCriblHttpTlsMinVersionTLSv13 OutputCriblHttpTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputCriblHttpType.
const (
	OutputCriblHttpTypeCriblHttp OutputCriblHttpType = "cribl_http"
)

// Defines values for OutputCriblLakeAwsAuthenticationMethod.
const (
	OutputCriblLakeAwsAuthenticationMethodAuto    OutputCriblLakeAwsAuthenticationMethod = "auto"
	OutputCriblLakeAwsAuthenticationMethodAutoRpc OutputCriblLakeAwsAuthenticationMethod = "auto_rpc"
	OutputCriblLakeAwsAuthenticationMethodManual  OutputCriblLakeAwsAuthenticationMethod = "manual"
)

// Defines values for OutputCriblLakeDeadletterEnabled.
const (
	OutputCriblLakeDeadletterEnabledFalse OutputCriblLakeDeadletterEnabled = false
	OutputCriblLakeDeadletterEnabledTrue  OutputCriblLakeDeadletterEnabled = true
)

// Defines values for OutputCriblLakeFormat.
const (
	OutputCriblLakeFormatDdss    OutputCriblLakeFormat = "ddss"
	OutputCriblLakeFormatJson    OutputCriblLakeFormat = "json"
	OutputCriblLakeFormatParquet OutputCriblLakeFormat = "parquet"
)

// Defines values for OutputCriblLakeObjectACL.
const (
	OutputCriblLakeObjectACLAuthenticatedRead      OutputCriblLakeObjectACL = "authenticated-read"
	OutputCriblLakeObjectACLAwsExecRead            OutputCriblLakeObjectACL = "aws-exec-read"
	OutputCriblLakeObjectACLBucketOwnerFullControl OutputCriblLakeObjectACL = "bucket-owner-full-control"
	OutputCriblLakeObjectACLBucketOwnerRead        OutputCriblLakeObjectACL = "bucket-owner-read"
	OutputCriblLakeObjectACLPrivate                OutputCriblLakeObjectACL = "private"
	OutputCriblLakeObjectACLPublicRead             OutputCriblLakeObjectACL = "public-read"
	OutputCriblLakeObjectACLPublicReadWrite        OutputCriblLakeObjectACL = "public-read-write"
)

// Defines values for OutputCriblLakeOnBackpressure.
const (
	OutputCriblLakeOnBackpressureBlock OutputCriblLakeOnBackpressure = "block"
	OutputCriblLakeOnBackpressureDrop  OutputCriblLakeOnBackpressure = "drop"
)

// Defines values for OutputCriblLakeOnDiskFullBackpressure.
const (
	OutputCriblLakeOnDiskFullBackpressureBlock OutputCriblLakeOnDiskFullBackpressure = "block"
	OutputCriblLakeOnDiskFullBackpressureDrop  OutputCriblLakeOnDiskFullBackpressure = "drop"
)

// Defines values for OutputCriblLakeRemoveEmptyDirs.
const (
	OutputCriblLakeRemoveEmptyDirsFalse OutputCriblLakeRemoveEmptyDirs = false
	OutputCriblLakeRemoveEmptyDirsTrue  OutputCriblLakeRemoveEmptyDirs = true
)

// Defines values for OutputCriblLakeServerSideEncryption.
const (
	OutputCriblLakeServerSideEncryptionAES256 OutputCriblLakeServerSideEncryption = "AES256"
	OutputCriblLakeServerSideEncryptionAwsKms OutputCriblLakeServerSideEncryption = "aws:kms"
)

// Defines values for OutputCriblLakeSignatureVersion.
const (
	OutputCriblLakeSignatureVersionV2 OutputCriblLakeSignatureVersion = "v2"
	OutputCriblLakeSignatureVersionV4 OutputCriblLakeSignatureVersion = "v4"
)

// Defines values for OutputCriblLakeStorageClass.
const (
	OutputCriblLakeStorageClassDEEPARCHIVE        OutputCriblLakeStorageClass = "DEEP_ARCHIVE"
	OutputCriblLakeStorageClassGLACIER            OutputCriblLakeStorageClass = "GLACIER"
	OutputCriblLakeStorageClassGLACIERIR          OutputCriblLakeStorageClass = "GLACIER_IR"
	OutputCriblLakeStorageClassINTELLIGENTTIERING OutputCriblLakeStorageClass = "INTELLIGENT_TIERING"
	OutputCriblLakeStorageClassONEZONEIA          OutputCriblLakeStorageClass = "ONEZONE_IA"
	OutputCriblLakeStorageClassREDUCEDREDUNDANCY  OutputCriblLakeStorageClass = "REDUCED_REDUNDANCY"
	OutputCriblLakeStorageClassSTANDARD           OutputCriblLakeStorageClass = "STANDARD"
	OutputCriblLakeStorageClassSTANDARDIA         OutputCriblLakeStorageClass = "STANDARD_IA"
)

// Defines values for OutputCriblLakeType.
const (
	CriblLake OutputCriblLakeType = "cribl_lake"
)

// Defines values for OutputCriblTcpCompression.
const (
	OutputCriblTcpCompressionGzip OutputCriblTcpCompression = "gzip"
	OutputCriblTcpCompressionNone OutputCriblTcpCompression = "none"
)

// Defines values for OutputCriblTcpHostsTls.
const (
	OutputCriblTcpHostsTlsInherit OutputCriblTcpHostsTls = "inherit"
	OutputCriblTcpHostsTlsOff     OutputCriblTcpHostsTls = "off"
)

// Defines values for OutputCriblTcpLoadBalanced.
const (
	OutputCriblTcpLoadBalancedFalse OutputCriblTcpLoadBalanced = false
	OutputCriblTcpLoadBalancedTrue  OutputCriblTcpLoadBalanced = true
)

// Defines values for OutputCriblTcpOnBackpressure.
const (
	OutputCriblTcpOnBackpressureBlock OutputCriblTcpOnBackpressure = "block"
	OutputCriblTcpOnBackpressureDrop  OutputCriblTcpOnBackpressure = "drop"
	OutputCriblTcpOnBackpressureQueue OutputCriblTcpOnBackpressure = "queue"
)

// Defines values for OutputCriblTcpPqCompress.
const (
	OutputCriblTcpPqCompressGzip OutputCriblTcpPqCompress = "gzip"
	OutputCriblTcpPqCompressNone OutputCriblTcpPqCompress = "none"
)

// Defines values for OutputCriblTcpPqMode.
const (
	OutputCriblTcpPqModeAlways       OutputCriblTcpPqMode = "always"
	OutputCriblTcpPqModeBackpressure OutputCriblTcpPqMode = "backpressure"
	OutputCriblTcpPqModeError        OutputCriblTcpPqMode = "error"
)

// Defines values for OutputCriblTcpPqOnBackpressure.
const (
	OutputCriblTcpPqOnBackpressureBlock OutputCriblTcpPqOnBackpressure = "block"
	OutputCriblTcpPqOnBackpressureDrop  OutputCriblTcpPqOnBackpressure = "drop"
)

// Defines values for OutputCriblTcpTlsDisabled.
const (
	OutputCriblTcpTlsDisabledFalse OutputCriblTcpTlsDisabled = false
	OutputCriblTcpTlsDisabledTrue  OutputCriblTcpTlsDisabled = true
)

// Defines values for OutputCriblTcpTlsMaxVersion.
const (
	OutputCriblTcpTlsMaxVersionTLSv1  OutputCriblTcpTlsMaxVersion = "TLSv1"
	OutputCriblTcpTlsMaxVersionTLSv11 OutputCriblTcpTlsMaxVersion = "TLSv1.1"
	OutputCriblTcpTlsMaxVersionTLSv12 OutputCriblTcpTlsMaxVersion = "TLSv1.2"
	OutputCriblTcpTlsMaxVersionTLSv13 OutputCriblTcpTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputCriblTcpTlsMinVersion.
const (
	OutputCriblTcpTlsMinVersionTLSv1  OutputCriblTcpTlsMinVersion = "TLSv1"
	OutputCriblTcpTlsMinVersionTLSv11 OutputCriblTcpTlsMinVersion = "TLSv1.1"
	OutputCriblTcpTlsMinVersionTLSv12 OutputCriblTcpTlsMinVersion = "TLSv1.2"
	OutputCriblTcpTlsMinVersionTLSv13 OutputCriblTcpTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputCriblTcpType.
const (
	OutputCriblTcpTypeCriblTcp OutputCriblTcpType = "cribl_tcp"
)

// Defines values for OutputCrowdstrikeNextGenSiemAuthType.
const (
	OutputCrowdstrikeNextGenSiemAuthTypeManual OutputCrowdstrikeNextGenSiemAuthType = "manual"
	OutputCrowdstrikeNextGenSiemAuthTypeSecret OutputCrowdstrikeNextGenSiemAuthType = "secret"
)

// Defines values for OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode.
const (
	OutputCrowdstrikeNextGenSiemFailedRequestLoggingModeNone              OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode = "none"
	OutputCrowdstrikeNextGenSiemFailedRequestLoggingModePayload           OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode = "payload"
	OutputCrowdstrikeNextGenSiemFailedRequestLoggingModePayloadAndHeaders OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputCrowdstrikeNextGenSiemFormat.
const (
	OutputCrowdstrikeNextGenSiemFormatJSON OutputCrowdstrikeNextGenSiemFormat = "JSON"
	OutputCrowdstrikeNextGenSiemFormatRaw  OutputCrowdstrikeNextGenSiemFormat = "raw"
)

// Defines values for OutputCrowdstrikeNextGenSiemOnBackpressure.
const (
	OutputCrowdstrikeNextGenSiemOnBackpressureBlock OutputCrowdstrikeNextGenSiemOnBackpressure = "block"
	OutputCrowdstrikeNextGenSiemOnBackpressureDrop  OutputCrowdstrikeNextGenSiemOnBackpressure = "drop"
	OutputCrowdstrikeNextGenSiemOnBackpressureQueue OutputCrowdstrikeNextGenSiemOnBackpressure = "queue"
)

// Defines values for OutputCrowdstrikeNextGenSiemPqCompress.
const (
	OutputCrowdstrikeNextGenSiemPqCompressGzip OutputCrowdstrikeNextGenSiemPqCompress = "gzip"
	OutputCrowdstrikeNextGenSiemPqCompressNone OutputCrowdstrikeNextGenSiemPqCompress = "none"
)

// Defines values for OutputCrowdstrikeNextGenSiemPqMode.
const (
	OutputCrowdstrikeNextGenSiemPqModeAlways       OutputCrowdstrikeNextGenSiemPqMode = "always"
	OutputCrowdstrikeNextGenSiemPqModeBackpressure OutputCrowdstrikeNextGenSiemPqMode = "backpressure"
	OutputCrowdstrikeNextGenSiemPqModeError        OutputCrowdstrikeNextGenSiemPqMode = "error"
)

// Defines values for OutputCrowdstrikeNextGenSiemPqOnBackpressure.
const (
	OutputCrowdstrikeNextGenSiemPqOnBackpressureBlock OutputCrowdstrikeNextGenSiemPqOnBackpressure = "block"
	OutputCrowdstrikeNextGenSiemPqOnBackpressureDrop  OutputCrowdstrikeNextGenSiemPqOnBackpressure = "drop"
)

// Defines values for OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry.
const (
	OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetryFalse OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry = false
	OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetryTrue  OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputCrowdstrikeNextGenSiemType.
const (
	CrowdstrikeNextGenSiem OutputCrowdstrikeNextGenSiemType = "crowdstrike_next_gen_siem"
)

// Defines values for OutputDatadogAuthType.
const (
	OutputDatadogAuthTypeManual OutputDatadogAuthType = "manual"
	OutputDatadogAuthTypeSecret OutputDatadogAuthType = "secret"
)

// Defines values for OutputDatadogContentType.
const (
	OutputDatadogContentTypeJson OutputDatadogContentType = "json"
	OutputDatadogContentTypeText OutputDatadogContentType = "text"
)

// Defines values for OutputDatadogFailedRequestLoggingMode.
const (
	OutputDatadogFailedRequestLoggingModeNone              OutputDatadogFailedRequestLoggingMode = "none"
	OutputDatadogFailedRequestLoggingModePayload           OutputDatadogFailedRequestLoggingMode = "payload"
	OutputDatadogFailedRequestLoggingModePayloadAndHeaders OutputDatadogFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputDatadogOnBackpressure.
const (
	OutputDatadogOnBackpressureBlock OutputDatadogOnBackpressure = "block"
	OutputDatadogOnBackpressureDrop  OutputDatadogOnBackpressure = "drop"
	OutputDatadogOnBackpressureQueue OutputDatadogOnBackpressure = "queue"
)

// Defines values for OutputDatadogPqCompress.
const (
	OutputDatadogPqCompressGzip OutputDatadogPqCompress = "gzip"
	OutputDatadogPqCompressNone OutputDatadogPqCompress = "none"
)

// Defines values for OutputDatadogPqMode.
const (
	OutputDatadogPqModeAlways       OutputDatadogPqMode = "always"
	OutputDatadogPqModeBackpressure OutputDatadogPqMode = "backpressure"
	OutputDatadogPqModeError        OutputDatadogPqMode = "error"
)

// Defines values for OutputDatadogPqOnBackpressure.
const (
	OutputDatadogPqOnBackpressureBlock OutputDatadogPqOnBackpressure = "block"
	OutputDatadogPqOnBackpressureDrop  OutputDatadogPqOnBackpressure = "drop"
)

// Defines values for OutputDatadogSeverity.
const (
	OutputDatadogSeverityAlert     OutputDatadogSeverity = "alert"
	OutputDatadogSeverityCritical  OutputDatadogSeverity = "critical"
	OutputDatadogSeverityDebug     OutputDatadogSeverity = "debug"
	OutputDatadogSeverityEmergency OutputDatadogSeverity = "emergency"
	OutputDatadogSeverityError     OutputDatadogSeverity = "error"
	OutputDatadogSeverityInfo      OutputDatadogSeverity = "info"
	OutputDatadogSeverityNotice    OutputDatadogSeverity = "notice"
	OutputDatadogSeverityWarning   OutputDatadogSeverity = "warning"
)

// Defines values for OutputDatadogSite.
const (
	OutputDatadogSiteAp1    OutputDatadogSite = "ap1"
	OutputDatadogSiteCustom OutputDatadogSite = "custom"
	OutputDatadogSiteEu     OutputDatadogSite = "eu"
	OutputDatadogSiteFed1   OutputDatadogSite = "fed1"
	OutputDatadogSiteUs     OutputDatadogSite = "us"
	OutputDatadogSiteUs3    OutputDatadogSite = "us3"
	OutputDatadogSiteUs5    OutputDatadogSite = "us5"
)

// Defines values for OutputDatadogTimeoutRetrySettingsTimeoutRetry.
const (
	OutputDatadogTimeoutRetrySettingsTimeoutRetryFalse OutputDatadogTimeoutRetrySettingsTimeoutRetry = false
	OutputDatadogTimeoutRetrySettingsTimeoutRetryTrue  OutputDatadogTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputDatadogType.
const (
	Datadog OutputDatadogType = "datadog"
)

// Defines values for OutputDatasetAuthType.
const (
	OutputDatasetAuthTypeManual OutputDatasetAuthType = "manual"
	OutputDatasetAuthTypeSecret OutputDatasetAuthType = "secret"
)

// Defines values for OutputDatasetDefaultSeverity.
const (
	OutputDatasetDefaultSeverityError   OutputDatasetDefaultSeverity = "error"
	OutputDatasetDefaultSeverityFatal   OutputDatasetDefaultSeverity = "fatal"
	OutputDatasetDefaultSeverityFine    OutputDatasetDefaultSeverity = "fine"
	OutputDatasetDefaultSeverityFiner   OutputDatasetDefaultSeverity = "finer"
	OutputDatasetDefaultSeverityFinest  OutputDatasetDefaultSeverity = "finest"
	OutputDatasetDefaultSeverityInfo    OutputDatasetDefaultSeverity = "info"
	OutputDatasetDefaultSeverityWarning OutputDatasetDefaultSeverity = "warning"
)

// Defines values for OutputDatasetFailedRequestLoggingMode.
const (
	OutputDatasetFailedRequestLoggingModeNone              OutputDatasetFailedRequestLoggingMode = "none"
	OutputDatasetFailedRequestLoggingModePayload           OutputDatasetFailedRequestLoggingMode = "payload"
	OutputDatasetFailedRequestLoggingModePayloadAndHeaders OutputDatasetFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputDatasetOnBackpressure.
const (
	OutputDatasetOnBackpressureBlock OutputDatasetOnBackpressure = "block"
	OutputDatasetOnBackpressureDrop  OutputDatasetOnBackpressure = "drop"
	OutputDatasetOnBackpressureQueue OutputDatasetOnBackpressure = "queue"
)

// Defines values for OutputDatasetPqCompress.
const (
	OutputDatasetPqCompressGzip OutputDatasetPqCompress = "gzip"
	OutputDatasetPqCompressNone OutputDatasetPqCompress = "none"
)

// Defines values for OutputDatasetPqMode.
const (
	OutputDatasetPqModeAlways       OutputDatasetPqMode = "always"
	OutputDatasetPqModeBackpressure OutputDatasetPqMode = "backpressure"
	OutputDatasetPqModeError        OutputDatasetPqMode = "error"
)

// Defines values for OutputDatasetPqOnBackpressure.
const (
	OutputDatasetPqOnBackpressureBlock OutputDatasetPqOnBackpressure = "block"
	OutputDatasetPqOnBackpressureDrop  OutputDatasetPqOnBackpressure = "drop"
)

// Defines values for OutputDatasetSite.
const (
	OutputDatasetSiteCustom OutputDatasetSite = "custom"
	OutputDatasetSiteEu     OutputDatasetSite = "eu"
	OutputDatasetSiteUs     OutputDatasetSite = "us"
)

// Defines values for OutputDatasetTimeoutRetrySettingsTimeoutRetry.
const (
	OutputDatasetTimeoutRetrySettingsTimeoutRetryFalse OutputDatasetTimeoutRetrySettingsTimeoutRetry = false
	OutputDatasetTimeoutRetrySettingsTimeoutRetryTrue  OutputDatasetTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputDatasetType.
const (
	OutputDatasetTypeDataset OutputDatasetType = "dataset"
)

// Defines values for OutputDefaultType.
const (
	OutputDefaultTypeDefault OutputDefaultType = "default"
)

// Defines values for OutputDevnullType.
const (
	Devnull OutputDevnullType = "devnull"
)

// Defines values for OutputDiskSpoolCompress.
const (
	OutputDiskSpoolCompressGzip OutputDiskSpoolCompress = "gzip"
	OutputDiskSpoolCompressNone OutputDiskSpoolCompress = "none"
)

// Defines values for OutputDiskSpoolType.
const (
	DiskSpool OutputDiskSpoolType = "disk_spool"
)

// Defines values for OutputDlS3AwsAuthenticationMethod.
const (
	OutputDlS3AwsAuthenticationMethodAuto   OutputDlS3AwsAuthenticationMethod = "auto"
	OutputDlS3AwsAuthenticationMethodManual OutputDlS3AwsAuthenticationMethod = "manual"
	OutputDlS3AwsAuthenticationMethodSecret OutputDlS3AwsAuthenticationMethod = "secret"
)

// Defines values for OutputDlS3Compress.
const (
	OutputDlS3CompressGzip OutputDlS3Compress = "gzip"
	OutputDlS3CompressNone OutputDlS3Compress = "none"
)

// Defines values for OutputDlS3CompressionLevel.
const (
	OutputDlS3CompressionLevelBestCompression OutputDlS3CompressionLevel = "best_compression"
	OutputDlS3CompressionLevelBestSpeed       OutputDlS3CompressionLevel = "best_speed"
	OutputDlS3CompressionLevelNormal          OutputDlS3CompressionLevel = "normal"
)

// Defines values for OutputDlS3DeadletterEnabled.
const (
	OutputDlS3DeadletterEnabledFalse OutputDlS3DeadletterEnabled = false
	OutputDlS3DeadletterEnabledTrue  OutputDlS3DeadletterEnabled = true
)

// Defines values for OutputDlS3Format.
const (
	OutputDlS3FormatJson    OutputDlS3Format = "json"
	OutputDlS3FormatParquet OutputDlS3Format = "parquet"
	OutputDlS3FormatRaw     OutputDlS3Format = "raw"
)

// Defines values for OutputDlS3ObjectACL.
const (
	OutputDlS3ObjectACLAuthenticatedRead      OutputDlS3ObjectACL = "authenticated-read"
	OutputDlS3ObjectACLAwsExecRead            OutputDlS3ObjectACL = "aws-exec-read"
	OutputDlS3ObjectACLBucketOwnerFullControl OutputDlS3ObjectACL = "bucket-owner-full-control"
	OutputDlS3ObjectACLBucketOwnerRead        OutputDlS3ObjectACL = "bucket-owner-read"
	OutputDlS3ObjectACLPrivate                OutputDlS3ObjectACL = "private"
	OutputDlS3ObjectACLPublicRead             OutputDlS3ObjectACL = "public-read"
	OutputDlS3ObjectACLPublicReadWrite        OutputDlS3ObjectACL = "public-read-write"
)

// Defines values for OutputDlS3OnBackpressure.
const (
	OutputDlS3OnBackpressureBlock OutputDlS3OnBackpressure = "block"
	OutputDlS3OnBackpressureDrop  OutputDlS3OnBackpressure = "drop"
)

// Defines values for OutputDlS3OnDiskFullBackpressure.
const (
	OutputDlS3OnDiskFullBackpressureBlock OutputDlS3OnDiskFullBackpressure = "block"
	OutputDlS3OnDiskFullBackpressureDrop  OutputDlS3OnDiskFullBackpressure = "drop"
)

// Defines values for OutputDlS3ParquetDataPageVersion.
const (
	OutputDlS3ParquetDataPageVersionDATAPAGEV1 OutputDlS3ParquetDataPageVersion = "DATA_PAGE_V1"
	OutputDlS3ParquetDataPageVersionDATAPAGEV2 OutputDlS3ParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputDlS3ParquetVersion.
const (
	OutputDlS3ParquetVersionPARQUET10 OutputDlS3ParquetVersion = "PARQUET_1_0"
	OutputDlS3ParquetVersionPARQUET24 OutputDlS3ParquetVersion = "PARQUET_2_4"
	OutputDlS3ParquetVersionPARQUET26 OutputDlS3ParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputDlS3RemoveEmptyDirs.
const (
	OutputDlS3RemoveEmptyDirsFalse OutputDlS3RemoveEmptyDirs = false
	OutputDlS3RemoveEmptyDirsTrue  OutputDlS3RemoveEmptyDirs = true
)

// Defines values for OutputDlS3ServerSideEncryption.
const (
	OutputDlS3ServerSideEncryptionAES256 OutputDlS3ServerSideEncryption = "AES256"
	OutputDlS3ServerSideEncryptionAwsKms OutputDlS3ServerSideEncryption = "aws:kms"
)

// Defines values for OutputDlS3SignatureVersion.
const (
	OutputDlS3SignatureVersionV2 OutputDlS3SignatureVersion = "v2"
	OutputDlS3SignatureVersionV4 OutputDlS3SignatureVersion = "v4"
)

// Defines values for OutputDlS3StorageClass.
const (
	OutputDlS3StorageClassDEEPARCHIVE        OutputDlS3StorageClass = "DEEP_ARCHIVE"
	OutputDlS3StorageClassGLACIER            OutputDlS3StorageClass = "GLACIER"
	OutputDlS3StorageClassGLACIERIR          OutputDlS3StorageClass = "GLACIER_IR"
	OutputDlS3StorageClassINTELLIGENTTIERING OutputDlS3StorageClass = "INTELLIGENT_TIERING"
	OutputDlS3StorageClassONEZONEIA          OutputDlS3StorageClass = "ONEZONE_IA"
	OutputDlS3StorageClassREDUCEDREDUNDANCY  OutputDlS3StorageClass = "REDUCED_REDUNDANCY"
	OutputDlS3StorageClassSTANDARD           OutputDlS3StorageClass = "STANDARD"
	OutputDlS3StorageClassSTANDARDIA         OutputDlS3StorageClass = "STANDARD_IA"
)

// Defines values for OutputDlS3Type.
const (
	DlS3 OutputDlS3Type = "dl_s3"
)

// Defines values for OutputDynatraceHttpAuthType.
const (
	OutputDynatraceHttpAuthTypeTextSecret OutputDynatraceHttpAuthType = "textSecret"
	OutputDynatraceHttpAuthTypeToken      OutputDynatraceHttpAuthType = "token"
)

// Defines values for OutputDynatraceHttpEndpoint.
const (
	OutputDynatraceHttpEndpointActiveGate OutputDynatraceHttpEndpoint = "activeGate"
	OutputDynatraceHttpEndpointCloud      OutputDynatraceHttpEndpoint = "cloud"
	OutputDynatraceHttpEndpointManual     OutputDynatraceHttpEndpoint = "manual"
)

// Defines values for OutputDynatraceHttpFailedRequestLoggingMode.
const (
	OutputDynatraceHttpFailedRequestLoggingModeNone              OutputDynatraceHttpFailedRequestLoggingMode = "none"
	OutputDynatraceHttpFailedRequestLoggingModePayload           OutputDynatraceHttpFailedRequestLoggingMode = "payload"
	OutputDynatraceHttpFailedRequestLoggingModePayloadAndHeaders OutputDynatraceHttpFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputDynatraceHttpFormat.
const (
	OutputDynatraceHttpFormatJsonArray OutputDynatraceHttpFormat = "json_array"
	OutputDynatraceHttpFormatPlaintext OutputDynatraceHttpFormat = "plaintext"
)

// Defines values for OutputDynatraceHttpMethod.
const (
	OutputDynatraceHttpMethodPATCH OutputDynatraceHttpMethod = "PATCH"
	OutputDynatraceHttpMethodPOST  OutputDynatraceHttpMethod = "POST"
	OutputDynatraceHttpMethodPUT   OutputDynatraceHttpMethod = "PUT"
)

// Defines values for OutputDynatraceHttpOnBackpressure.
const (
	OutputDynatraceHttpOnBackpressureBlock OutputDynatraceHttpOnBackpressure = "block"
	OutputDynatraceHttpOnBackpressureDrop  OutputDynatraceHttpOnBackpressure = "drop"
	OutputDynatraceHttpOnBackpressureQueue OutputDynatraceHttpOnBackpressure = "queue"
)

// Defines values for OutputDynatraceHttpPqCompress.
const (
	OutputDynatraceHttpPqCompressGzip OutputDynatraceHttpPqCompress = "gzip"
	OutputDynatraceHttpPqCompressNone OutputDynatraceHttpPqCompress = "none"
)

// Defines values for OutputDynatraceHttpPqMode.
const (
	OutputDynatraceHttpPqModeAlways       OutputDynatraceHttpPqMode = "always"
	OutputDynatraceHttpPqModeBackpressure OutputDynatraceHttpPqMode = "backpressure"
	OutputDynatraceHttpPqModeError        OutputDynatraceHttpPqMode = "error"
)

// Defines values for OutputDynatraceHttpPqOnBackpressure.
const (
	OutputDynatraceHttpPqOnBackpressureBlock OutputDynatraceHttpPqOnBackpressure = "block"
	OutputDynatraceHttpPqOnBackpressureDrop  OutputDynatraceHttpPqOnBackpressure = "drop"
)

// Defines values for OutputDynatraceHttpTelemetryType.
const (
	OutputDynatraceHttpTelemetryTypeLogs    OutputDynatraceHttpTelemetryType = "logs"
	OutputDynatraceHttpTelemetryTypeMetrics OutputDynatraceHttpTelemetryType = "metrics"
)

// Defines values for OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry.
const (
	OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetryFalse OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry = false
	OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetryTrue  OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputDynatraceHttpType.
const (
	OutputDynatraceHttpTypeDynatraceHttp OutputDynatraceHttpType = "dynatrace_http"
	OutputDynatraceHttpTypeSentinel      OutputDynatraceHttpType = "sentinel"
	OutputDynatraceHttpTypeWebhook       OutputDynatraceHttpType = "webhook"
)

// Defines values for OutputDynatraceOtlpCompress.
const (
	OutputDynatraceOtlpCompressDeflate OutputDynatraceOtlpCompress = "deflate"
	OutputDynatraceOtlpCompressGzip    OutputDynatraceOtlpCompress = "gzip"
	OutputDynatraceOtlpCompressNone    OutputDynatraceOtlpCompress = "none"
)

// Defines values for OutputDynatraceOtlpEndpointType.
const (
	Ag   OutputDynatraceOtlpEndpointType = "ag"
	Saas OutputDynatraceOtlpEndpointType = "saas"
)

// Defines values for OutputDynatraceOtlpFailedRequestLoggingMode.
const (
	OutputDynatraceOtlpFailedRequestLoggingModeNone              OutputDynatraceOtlpFailedRequestLoggingMode = "none"
	OutputDynatraceOtlpFailedRequestLoggingModePayload           OutputDynatraceOtlpFailedRequestLoggingMode = "payload"
	OutputDynatraceOtlpFailedRequestLoggingModePayloadAndHeaders OutputDynatraceOtlpFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputDynatraceOtlpHttpCompress.
const (
	OutputDynatraceOtlpHttpCompressGzip OutputDynatraceOtlpHttpCompress = "gzip"
	OutputDynatraceOtlpHttpCompressNone OutputDynatraceOtlpHttpCompress = "none"
)

// Defines values for OutputDynatraceOtlpOnBackpressure.
const (
	OutputDynatraceOtlpOnBackpressureBlock OutputDynatraceOtlpOnBackpressure = "block"
	OutputDynatraceOtlpOnBackpressureDrop  OutputDynatraceOtlpOnBackpressure = "drop"
	OutputDynatraceOtlpOnBackpressureQueue OutputDynatraceOtlpOnBackpressure = "queue"
)

// Defines values for OutputDynatraceOtlpOtlpVersion.
const (
	OutputDynatraceOtlpOtlpVersionN131 OutputDynatraceOtlpOtlpVersion = "1.3.1"
)

// Defines values for OutputDynatraceOtlpPqCompress.
const (
	OutputDynatraceOtlpPqCompressGzip OutputDynatraceOtlpPqCompress = "gzip"
	OutputDynatraceOtlpPqCompressNone OutputDynatraceOtlpPqCompress = "none"
)

// Defines values for OutputDynatraceOtlpPqMode.
const (
	OutputDynatraceOtlpPqModeAlways       OutputDynatraceOtlpPqMode = "always"
	OutputDynatraceOtlpPqModeBackpressure OutputDynatraceOtlpPqMode = "backpressure"
	OutputDynatraceOtlpPqModeError        OutputDynatraceOtlpPqMode = "error"
)

// Defines values for OutputDynatraceOtlpPqOnBackpressure.
const (
	OutputDynatraceOtlpPqOnBackpressureBlock OutputDynatraceOtlpPqOnBackpressure = "block"
	OutputDynatraceOtlpPqOnBackpressureDrop  OutputDynatraceOtlpPqOnBackpressure = "drop"
)

// Defines values for OutputDynatraceOtlpProtocol.
const (
	OutputDynatraceOtlpProtocolHttp OutputDynatraceOtlpProtocol = "http"
)

// Defines values for OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry.
const (
	OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetryFalse OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry = false
	OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetryTrue  OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputDynatraceOtlpType.
const (
	DynatraceOtlp OutputDynatraceOtlpType = "dynatrace_otlp"
)

// Defines values for OutputElasticAuthAuthType.
const (
	OutputElasticAuthAuthTypeManual       OutputElasticAuthAuthType = "manual"
	OutputElasticAuthAuthTypeManualAPIKey OutputElasticAuthAuthType = "manualAPIKey"
	OutputElasticAuthAuthTypeSecret       OutputElasticAuthAuthType = "secret"
	OutputElasticAuthAuthTypeTextSecret   OutputElasticAuthAuthType = "textSecret"
)

// Defines values for OutputElasticAuthDisabled.
const (
	OutputElasticAuthDisabledFalse OutputElasticAuthDisabled = false
	OutputElasticAuthDisabledTrue  OutputElasticAuthDisabled = true
)

// Defines values for OutputElasticElasticVersion.
const (
	OutputElasticElasticVersionAuto OutputElasticElasticVersion = "auto"
	OutputElasticElasticVersionN6   OutputElasticElasticVersion = "6"
	OutputElasticElasticVersionN7   OutputElasticElasticVersion = "7"
)

// Defines values for OutputElasticFailedRequestLoggingMode.
const (
	OutputElasticFailedRequestLoggingModeNone              OutputElasticFailedRequestLoggingMode = "none"
	OutputElasticFailedRequestLoggingModePayload           OutputElasticFailedRequestLoggingMode = "payload"
	OutputElasticFailedRequestLoggingModePayloadAndHeaders OutputElasticFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputElasticLoadBalanced.
const (
	OutputElasticLoadBalancedFalse OutputElasticLoadBalanced = false
	OutputElasticLoadBalancedTrue  OutputElasticLoadBalanced = true
)

// Defines values for OutputElasticOnBackpressure.
const (
	OutputElasticOnBackpressureBlock OutputElasticOnBackpressure = "block"
	OutputElasticOnBackpressureDrop  OutputElasticOnBackpressure = "drop"
	OutputElasticOnBackpressureQueue OutputElasticOnBackpressure = "queue"
)

// Defines values for OutputElasticPqCompress.
const (
	OutputElasticPqCompressGzip OutputElasticPqCompress = "gzip"
	OutputElasticPqCompressNone OutputElasticPqCompress = "none"
)

// Defines values for OutputElasticPqMode.
const (
	OutputElasticPqModeAlways       OutputElasticPqMode = "always"
	OutputElasticPqModeBackpressure OutputElasticPqMode = "backpressure"
	OutputElasticPqModeError        OutputElasticPqMode = "error"
)

// Defines values for OutputElasticPqOnBackpressure.
const (
	OutputElasticPqOnBackpressureBlock OutputElasticPqOnBackpressure = "block"
	OutputElasticPqOnBackpressureDrop  OutputElasticPqOnBackpressure = "drop"
)

// Defines values for OutputElasticTimeoutRetrySettingsTimeoutRetry.
const (
	OutputElasticTimeoutRetrySettingsTimeoutRetryFalse OutputElasticTimeoutRetrySettingsTimeoutRetry = false
	OutputElasticTimeoutRetrySettingsTimeoutRetryTrue  OutputElasticTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputElasticType.
const (
	OutputElasticTypeElastic OutputElasticType = "elastic"
)

// Defines values for OutputElasticWriteAction.
const (
	Create OutputElasticWriteAction = "create"
	Index  OutputElasticWriteAction = "index"
)

// Defines values for OutputElasticCloudAuthAuthType.
const (
	OutputElasticCloudAuthAuthTypeManual       OutputElasticCloudAuthAuthType = "manual"
	OutputElasticCloudAuthAuthTypeManualAPIKey OutputElasticCloudAuthAuthType = "manualAPIKey"
	OutputElasticCloudAuthAuthTypeSecret       OutputElasticCloudAuthAuthType = "secret"
	OutputElasticCloudAuthAuthTypeTextSecret   OutputElasticCloudAuthAuthType = "textSecret"
)

// Defines values for OutputElasticCloudAuthDisabled.
const (
	OutputElasticCloudAuthDisabledFalse OutputElasticCloudAuthDisabled = false
	OutputElasticCloudAuthDisabledTrue  OutputElasticCloudAuthDisabled = true
)

// Defines values for OutputElasticCloudFailedRequestLoggingMode.
const (
	OutputElasticCloudFailedRequestLoggingModeNone              OutputElasticCloudFailedRequestLoggingMode = "none"
	OutputElasticCloudFailedRequestLoggingModePayload           OutputElasticCloudFailedRequestLoggingMode = "payload"
	OutputElasticCloudFailedRequestLoggingModePayloadAndHeaders OutputElasticCloudFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputElasticCloudOnBackpressure.
const (
	OutputElasticCloudOnBackpressureBlock OutputElasticCloudOnBackpressure = "block"
	OutputElasticCloudOnBackpressureDrop  OutputElasticCloudOnBackpressure = "drop"
	OutputElasticCloudOnBackpressureQueue OutputElasticCloudOnBackpressure = "queue"
)

// Defines values for OutputElasticCloudPqCompress.
const (
	OutputElasticCloudPqCompressGzip OutputElasticCloudPqCompress = "gzip"
	OutputElasticCloudPqCompressNone OutputElasticCloudPqCompress = "none"
)

// Defines values for OutputElasticCloudPqMode.
const (
	OutputElasticCloudPqModeAlways       OutputElasticCloudPqMode = "always"
	OutputElasticCloudPqModeBackpressure OutputElasticCloudPqMode = "backpressure"
	OutputElasticCloudPqModeError        OutputElasticCloudPqMode = "error"
)

// Defines values for OutputElasticCloudPqOnBackpressure.
const (
	OutputElasticCloudPqOnBackpressureBlock OutputElasticCloudPqOnBackpressure = "block"
	OutputElasticCloudPqOnBackpressureDrop  OutputElasticCloudPqOnBackpressure = "drop"
)

// Defines values for OutputElasticCloudTimeoutRetrySettingsTimeoutRetry.
const (
	OutputElasticCloudTimeoutRetrySettingsTimeoutRetryFalse OutputElasticCloudTimeoutRetrySettingsTimeoutRetry = false
	OutputElasticCloudTimeoutRetrySettingsTimeoutRetryTrue  OutputElasticCloudTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputElasticCloudType.
const (
	ElasticCloud OutputElasticCloudType = "elastic_cloud"
)

// Defines values for OutputExabeamDeadletterEnabled.
const (
	OutputExabeamDeadletterEnabledFalse OutputExabeamDeadletterEnabled = false
	OutputExabeamDeadletterEnabledTrue  OutputExabeamDeadletterEnabled = true
)

// Defines values for OutputExabeamObjectACL.
const (
	OutputExabeamObjectACLAuthenticatedRead      OutputExabeamObjectACL = "authenticated-read"
	OutputExabeamObjectACLBucketOwnerFullControl OutputExabeamObjectACL = "bucket-owner-full-control"
	OutputExabeamObjectACLBucketOwnerRead        OutputExabeamObjectACL = "bucket-owner-read"
	OutputExabeamObjectACLPrivate                OutputExabeamObjectACL = "private"
	OutputExabeamObjectACLProjectPrivate         OutputExabeamObjectACL = "project-private"
	OutputExabeamObjectACLPublicRead             OutputExabeamObjectACL = "public-read"
)

// Defines values for OutputExabeamOnBackpressure.
const (
	OutputExabeamOnBackpressureBlock OutputExabeamOnBackpressure = "block"
	OutputExabeamOnBackpressureDrop  OutputExabeamOnBackpressure = "drop"
)

// Defines values for OutputExabeamOnDiskFullBackpressure.
const (
	OutputExabeamOnDiskFullBackpressureBlock OutputExabeamOnDiskFullBackpressure = "block"
	OutputExabeamOnDiskFullBackpressureDrop  OutputExabeamOnDiskFullBackpressure = "drop"
)

// Defines values for OutputExabeamRemoveEmptyDirs.
const (
	OutputExabeamRemoveEmptyDirsFalse OutputExabeamRemoveEmptyDirs = false
	OutputExabeamRemoveEmptyDirsTrue  OutputExabeamRemoveEmptyDirs = true
)

// Defines values for OutputExabeamSignatureVersion.
const (
	OutputExabeamSignatureVersionV2 OutputExabeamSignatureVersion = "v2"
	OutputExabeamSignatureVersionV4 OutputExabeamSignatureVersion = "v4"
)

// Defines values for OutputExabeamStorageClass.
const (
	OutputExabeamStorageClassARCHIVE  OutputExabeamStorageClass = "ARCHIVE"
	OutputExabeamStorageClassCOLDLINE OutputExabeamStorageClass = "COLDLINE"
	OutputExabeamStorageClassNEARLINE OutputExabeamStorageClass = "NEARLINE"
	OutputExabeamStorageClassSTANDARD OutputExabeamStorageClass = "STANDARD"
)

// Defines values for OutputExabeamType.
const (
	Exabeam OutputExabeamType = "exabeam"
)

// Defines values for OutputFilesystemCompress.
const (
	OutputFilesystemCompressGzip OutputFilesystemCompress = "gzip"
	OutputFilesystemCompressNone OutputFilesystemCompress = "none"
)

// Defines values for OutputFilesystemCompressionLevel.
const (
	OutputFilesystemCompressionLevelBestCompression OutputFilesystemCompressionLevel = "best_compression"
	OutputFilesystemCompressionLevelBestSpeed       OutputFilesystemCompressionLevel = "best_speed"
	OutputFilesystemCompressionLevelNormal          OutputFilesystemCompressionLevel = "normal"
)

// Defines values for OutputFilesystemDeadletterEnabled.
const (
	OutputFilesystemDeadletterEnabledFalse OutputFilesystemDeadletterEnabled = false
	OutputFilesystemDeadletterEnabledTrue  OutputFilesystemDeadletterEnabled = true
)

// Defines values for OutputFilesystemFormat.
const (
	OutputFilesystemFormatJson    OutputFilesystemFormat = "json"
	OutputFilesystemFormatParquet OutputFilesystemFormat = "parquet"
	OutputFilesystemFormatRaw     OutputFilesystemFormat = "raw"
)

// Defines values for OutputFilesystemOnBackpressure.
const (
	OutputFilesystemOnBackpressureBlock OutputFilesystemOnBackpressure = "block"
	OutputFilesystemOnBackpressureDrop  OutputFilesystemOnBackpressure = "drop"
)

// Defines values for OutputFilesystemOnDiskFullBackpressure.
const (
	OutputFilesystemOnDiskFullBackpressureBlock OutputFilesystemOnDiskFullBackpressure = "block"
	OutputFilesystemOnDiskFullBackpressureDrop  OutputFilesystemOnDiskFullBackpressure = "drop"
)

// Defines values for OutputFilesystemParquetDataPageVersion.
const (
	OutputFilesystemParquetDataPageVersionDATAPAGEV1 OutputFilesystemParquetDataPageVersion = "DATA_PAGE_V1"
	OutputFilesystemParquetDataPageVersionDATAPAGEV2 OutputFilesystemParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputFilesystemParquetVersion.
const (
	OutputFilesystemParquetVersionPARQUET10 OutputFilesystemParquetVersion = "PARQUET_1_0"
	OutputFilesystemParquetVersionPARQUET24 OutputFilesystemParquetVersion = "PARQUET_2_4"
	OutputFilesystemParquetVersionPARQUET26 OutputFilesystemParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputFilesystemRemoveEmptyDirs.
const (
	OutputFilesystemRemoveEmptyDirsFalse OutputFilesystemRemoveEmptyDirs = false
	OutputFilesystemRemoveEmptyDirsTrue  OutputFilesystemRemoveEmptyDirs = true
)

// Defines values for OutputFilesystemType.
const (
	Filesystem OutputFilesystemType = "filesystem"
)

// Defines values for OutputGoogleChronicleApiVersion.
const (
	OutputGoogleChronicleApiVersionV1 OutputGoogleChronicleApiVersion = "v1"
	OutputGoogleChronicleApiVersionV2 OutputGoogleChronicleApiVersion = "v2"
)

// Defines values for OutputGoogleChronicleAuthenticationMethod.
const (
	OutputGoogleChronicleAuthenticationMethodManual               OutputGoogleChronicleAuthenticationMethod = "manual"
	OutputGoogleChronicleAuthenticationMethodSecret               OutputGoogleChronicleAuthenticationMethod = "secret"
	OutputGoogleChronicleAuthenticationMethodServiceAccount       OutputGoogleChronicleAuthenticationMethod = "serviceAccount"
	OutputGoogleChronicleAuthenticationMethodServiceAccountSecret OutputGoogleChronicleAuthenticationMethod = "serviceAccountSecret"
)

// Defines values for OutputGoogleChronicleFailedRequestLoggingMode.
const (
	OutputGoogleChronicleFailedRequestLoggingModeNone              OutputGoogleChronicleFailedRequestLoggingMode = "none"
	OutputGoogleChronicleFailedRequestLoggingModePayload           OutputGoogleChronicleFailedRequestLoggingMode = "payload"
	OutputGoogleChronicleFailedRequestLoggingModePayloadAndHeaders OutputGoogleChronicleFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputGoogleChronicleLogFormatType.
const (
	Udm          OutputGoogleChronicleLogFormatType = "udm"
	Unstructured OutputGoogleChronicleLogFormatType = "unstructured"
)

// Defines values for OutputGoogleChronicleOnBackpressure.
const (
	OutputGoogleChronicleOnBackpressureBlock OutputGoogleChronicleOnBackpressure = "block"
	OutputGoogleChronicleOnBackpressureDrop  OutputGoogleChronicleOnBackpressure = "drop"
	OutputGoogleChronicleOnBackpressureQueue OutputGoogleChronicleOnBackpressure = "queue"
)

// Defines values for OutputGoogleChroniclePqCompress.
const (
	OutputGoogleChroniclePqCompressGzip OutputGoogleChroniclePqCompress = "gzip"
	OutputGoogleChroniclePqCompressNone OutputGoogleChroniclePqCompress = "none"
)

// Defines values for OutputGoogleChroniclePqMode.
const (
	OutputGoogleChroniclePqModeAlways       OutputGoogleChroniclePqMode = "always"
	OutputGoogleChroniclePqModeBackpressure OutputGoogleChroniclePqMode = "backpressure"
	OutputGoogleChroniclePqModeError        OutputGoogleChroniclePqMode = "error"
)

// Defines values for OutputGoogleChroniclePqOnBackpressure.
const (
	OutputGoogleChroniclePqOnBackpressureBlock OutputGoogleChroniclePqOnBackpressure = "block"
	OutputGoogleChroniclePqOnBackpressureDrop  OutputGoogleChroniclePqOnBackpressure = "drop"
)

// Defines values for OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry.
const (
	OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetryFalse OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry = false
	OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetryTrue  OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputGoogleChronicleType.
const (
	GoogleChronicle OutputGoogleChronicleType = "google_chronicle"
)

// Defines values for OutputGoogleCloudLoggingGoogleAuthMethod.
const (
	OutputGoogleCloudLoggingGoogleAuthMethodAuto   OutputGoogleCloudLoggingGoogleAuthMethod = "auto"
	OutputGoogleCloudLoggingGoogleAuthMethodManual OutputGoogleCloudLoggingGoogleAuthMethod = "manual"
	OutputGoogleCloudLoggingGoogleAuthMethodSecret OutputGoogleCloudLoggingGoogleAuthMethod = "secret"
)

// Defines values for OutputGoogleCloudLoggingLogLocationType.
const (
	BillingAccount OutputGoogleCloudLoggingLogLocationType = "billingAccount"
	Folder         OutputGoogleCloudLoggingLogLocationType = "folder"
	Organization   OutputGoogleCloudLoggingLogLocationType = "organization"
	Project        OutputGoogleCloudLoggingLogLocationType = "project"
)

// Defines values for OutputGoogleCloudLoggingOnBackpressure.
const (
	OutputGoogleCloudLoggingOnBackpressureBlock OutputGoogleCloudLoggingOnBackpressure = "block"
	OutputGoogleCloudLoggingOnBackpressureDrop  OutputGoogleCloudLoggingOnBackpressure = "drop"
	OutputGoogleCloudLoggingOnBackpressureQueue OutputGoogleCloudLoggingOnBackpressure = "queue"
)

// Defines values for OutputGoogleCloudLoggingPayloadFormat.
const (
	OutputGoogleCloudLoggingPayloadFormatJson OutputGoogleCloudLoggingPayloadFormat = "json"
	OutputGoogleCloudLoggingPayloadFormatText OutputGoogleCloudLoggingPayloadFormat = "text"
)

// Defines values for OutputGoogleCloudLoggingPqCompress.
const (
	OutputGoogleCloudLoggingPqCompressGzip OutputGoogleCloudLoggingPqCompress = "gzip"
	OutputGoogleCloudLoggingPqCompressNone OutputGoogleCloudLoggingPqCompress = "none"
)

// Defines values for OutputGoogleCloudLoggingPqMode.
const (
	OutputGoogleCloudLoggingPqModeAlways       OutputGoogleCloudLoggingPqMode = "always"
	OutputGoogleCloudLoggingPqModeBackpressure OutputGoogleCloudLoggingPqMode = "backpressure"
	OutputGoogleCloudLoggingPqModeError        OutputGoogleCloudLoggingPqMode = "error"
)

// Defines values for OutputGoogleCloudLoggingPqOnBackpressure.
const (
	OutputGoogleCloudLoggingPqOnBackpressureBlock OutputGoogleCloudLoggingPqOnBackpressure = "block"
	OutputGoogleCloudLoggingPqOnBackpressureDrop  OutputGoogleCloudLoggingPqOnBackpressure = "drop"
)

// Defines values for OutputGoogleCloudLoggingType.
const (
	GoogleCloudLogging OutputGoogleCloudLoggingType = "google_cloud_logging"
)

// Defines values for OutputGoogleCloudStorageAwsAuthenticationMethod.
const (
	OutputGoogleCloudStorageAwsAuthenticationMethodAuto   OutputGoogleCloudStorageAwsAuthenticationMethod = "auto"
	OutputGoogleCloudStorageAwsAuthenticationMethodManual OutputGoogleCloudStorageAwsAuthenticationMethod = "manual"
	OutputGoogleCloudStorageAwsAuthenticationMethodSecret OutputGoogleCloudStorageAwsAuthenticationMethod = "secret"
)

// Defines values for OutputGoogleCloudStorageCompress.
const (
	OutputGoogleCloudStorageCompressGzip OutputGoogleCloudStorageCompress = "gzip"
	OutputGoogleCloudStorageCompressNone OutputGoogleCloudStorageCompress = "none"
)

// Defines values for OutputGoogleCloudStorageCompressionLevel.
const (
	OutputGoogleCloudStorageCompressionLevelBestCompression OutputGoogleCloudStorageCompressionLevel = "best_compression"
	OutputGoogleCloudStorageCompressionLevelBestSpeed       OutputGoogleCloudStorageCompressionLevel = "best_speed"
	OutputGoogleCloudStorageCompressionLevelNormal          OutputGoogleCloudStorageCompressionLevel = "normal"
)

// Defines values for OutputGoogleCloudStorageDeadletterEnabled.
const (
	OutputGoogleCloudStorageDeadletterEnabledFalse OutputGoogleCloudStorageDeadletterEnabled = false
	OutputGoogleCloudStorageDeadletterEnabledTrue  OutputGoogleCloudStorageDeadletterEnabled = true
)

// Defines values for OutputGoogleCloudStorageFormat.
const (
	OutputGoogleCloudStorageFormatJson    OutputGoogleCloudStorageFormat = "json"
	OutputGoogleCloudStorageFormatParquet OutputGoogleCloudStorageFormat = "parquet"
	OutputGoogleCloudStorageFormatRaw     OutputGoogleCloudStorageFormat = "raw"
)

// Defines values for OutputGoogleCloudStorageObjectACL.
const (
	OutputGoogleCloudStorageObjectACLAuthenticatedRead      OutputGoogleCloudStorageObjectACL = "authenticated-read"
	OutputGoogleCloudStorageObjectACLBucketOwnerFullControl OutputGoogleCloudStorageObjectACL = "bucket-owner-full-control"
	OutputGoogleCloudStorageObjectACLBucketOwnerRead        OutputGoogleCloudStorageObjectACL = "bucket-owner-read"
	OutputGoogleCloudStorageObjectACLPrivate                OutputGoogleCloudStorageObjectACL = "private"
	OutputGoogleCloudStorageObjectACLProjectPrivate         OutputGoogleCloudStorageObjectACL = "project-private"
	OutputGoogleCloudStorageObjectACLPublicRead             OutputGoogleCloudStorageObjectACL = "public-read"
)

// Defines values for OutputGoogleCloudStorageOnBackpressure.
const (
	OutputGoogleCloudStorageOnBackpressureBlock OutputGoogleCloudStorageOnBackpressure = "block"
	OutputGoogleCloudStorageOnBackpressureDrop  OutputGoogleCloudStorageOnBackpressure = "drop"
)

// Defines values for OutputGoogleCloudStorageOnDiskFullBackpressure.
const (
	OutputGoogleCloudStorageOnDiskFullBackpressureBlock OutputGoogleCloudStorageOnDiskFullBackpressure = "block"
	OutputGoogleCloudStorageOnDiskFullBackpressureDrop  OutputGoogleCloudStorageOnDiskFullBackpressure = "drop"
)

// Defines values for OutputGoogleCloudStorageParquetDataPageVersion.
const (
	OutputGoogleCloudStorageParquetDataPageVersionDATAPAGEV1 OutputGoogleCloudStorageParquetDataPageVersion = "DATA_PAGE_V1"
	OutputGoogleCloudStorageParquetDataPageVersionDATAPAGEV2 OutputGoogleCloudStorageParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputGoogleCloudStorageParquetVersion.
const (
	OutputGoogleCloudStorageParquetVersionPARQUET10 OutputGoogleCloudStorageParquetVersion = "PARQUET_1_0"
	OutputGoogleCloudStorageParquetVersionPARQUET24 OutputGoogleCloudStorageParquetVersion = "PARQUET_2_4"
	OutputGoogleCloudStorageParquetVersionPARQUET26 OutputGoogleCloudStorageParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputGoogleCloudStorageRemoveEmptyDirs.
const (
	OutputGoogleCloudStorageRemoveEmptyDirsFalse OutputGoogleCloudStorageRemoveEmptyDirs = false
	OutputGoogleCloudStorageRemoveEmptyDirsTrue  OutputGoogleCloudStorageRemoveEmptyDirs = true
)

// Defines values for OutputGoogleCloudStorageSignatureVersion.
const (
	OutputGoogleCloudStorageSignatureVersionV2 OutputGoogleCloudStorageSignatureVersion = "v2"
	OutputGoogleCloudStorageSignatureVersionV4 OutputGoogleCloudStorageSignatureVersion = "v4"
)

// Defines values for OutputGoogleCloudStorageStorageClass.
const (
	OutputGoogleCloudStorageStorageClassARCHIVE  OutputGoogleCloudStorageStorageClass = "ARCHIVE"
	OutputGoogleCloudStorageStorageClassCOLDLINE OutputGoogleCloudStorageStorageClass = "COLDLINE"
	OutputGoogleCloudStorageStorageClassNEARLINE OutputGoogleCloudStorageStorageClass = "NEARLINE"
	OutputGoogleCloudStorageStorageClassSTANDARD OutputGoogleCloudStorageStorageClass = "STANDARD"
)

// Defines values for OutputGoogleCloudStorageType.
const (
	GoogleCloudStorage OutputGoogleCloudStorageType = "google_cloud_storage"
)

// Defines values for OutputGooglePubsubGoogleAuthMethod.
const (
	OutputGooglePubsubGoogleAuthMethodAuto   OutputGooglePubsubGoogleAuthMethod = "auto"
	OutputGooglePubsubGoogleAuthMethodManual OutputGooglePubsubGoogleAuthMethod = "manual"
	OutputGooglePubsubGoogleAuthMethodSecret OutputGooglePubsubGoogleAuthMethod = "secret"
)

// Defines values for OutputGooglePubsubOnBackpressure.
const (
	OutputGooglePubsubOnBackpressureBlock OutputGooglePubsubOnBackpressure = "block"
	OutputGooglePubsubOnBackpressureDrop  OutputGooglePubsubOnBackpressure = "drop"
	OutputGooglePubsubOnBackpressureQueue OutputGooglePubsubOnBackpressure = "queue"
)

// Defines values for OutputGooglePubsubPqCompress.
const (
	OutputGooglePubsubPqCompressGzip OutputGooglePubsubPqCompress = "gzip"
	OutputGooglePubsubPqCompressNone OutputGooglePubsubPqCompress = "none"
)

// Defines values for OutputGooglePubsubPqMode.
const (
	OutputGooglePubsubPqModeAlways       OutputGooglePubsubPqMode = "always"
	OutputGooglePubsubPqModeBackpressure OutputGooglePubsubPqMode = "backpressure"
	OutputGooglePubsubPqModeError        OutputGooglePubsubPqMode = "error"
)

// Defines values for OutputGooglePubsubPqOnBackpressure.
const (
	OutputGooglePubsubPqOnBackpressureBlock OutputGooglePubsubPqOnBackpressure = "block"
	OutputGooglePubsubPqOnBackpressureDrop  OutputGooglePubsubPqOnBackpressure = "drop"
)

// Defines values for OutputGooglePubsubType.
const (
	OutputGooglePubsubTypeGooglePubsub OutputGooglePubsubType = "google_pubsub"
)

// Defines values for OutputGrafanaCloudFailedRequestLoggingMode.
const (
	OutputGrafanaCloudFailedRequestLoggingModeNone              OutputGrafanaCloudFailedRequestLoggingMode = "none"
	OutputGrafanaCloudFailedRequestLoggingModePayload           OutputGrafanaCloudFailedRequestLoggingMode = "payload"
	OutputGrafanaCloudFailedRequestLoggingModePayloadAndHeaders OutputGrafanaCloudFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputGrafanaCloudLokiAuthAuthType.
const (
	OutputGrafanaCloudLokiAuthAuthTypeBasic             OutputGrafanaCloudLokiAuthAuthType = "basic"
	OutputGrafanaCloudLokiAuthAuthTypeCredentialsSecret OutputGrafanaCloudLokiAuthAuthType = "credentialsSecret"
	OutputGrafanaCloudLokiAuthAuthTypeNone              OutputGrafanaCloudLokiAuthAuthType = "none"
	OutputGrafanaCloudLokiAuthAuthTypeTextSecret        OutputGrafanaCloudLokiAuthAuthType = "textSecret"
	OutputGrafanaCloudLokiAuthAuthTypeToken             OutputGrafanaCloudLokiAuthAuthType = "token"
)

// Defines values for OutputGrafanaCloudMessageFormat.
const (
	OutputGrafanaCloudMessageFormatJson     OutputGrafanaCloudMessageFormat = "json"
	OutputGrafanaCloudMessageFormatProtobuf OutputGrafanaCloudMessageFormat = "protobuf"
)

// Defines values for OutputGrafanaCloudOnBackpressure.
const (
	OutputGrafanaCloudOnBackpressureBlock OutputGrafanaCloudOnBackpressure = "block"
	OutputGrafanaCloudOnBackpressureDrop  OutputGrafanaCloudOnBackpressure = "drop"
	OutputGrafanaCloudOnBackpressureQueue OutputGrafanaCloudOnBackpressure = "queue"
)

// Defines values for OutputGrafanaCloudPqCompress.
const (
	OutputGrafanaCloudPqCompressGzip OutputGrafanaCloudPqCompress = "gzip"
	OutputGrafanaCloudPqCompressNone OutputGrafanaCloudPqCompress = "none"
)

// Defines values for OutputGrafanaCloudPqMode.
const (
	OutputGrafanaCloudPqModeAlways       OutputGrafanaCloudPqMode = "always"
	OutputGrafanaCloudPqModeBackpressure OutputGrafanaCloudPqMode = "backpressure"
	OutputGrafanaCloudPqModeError        OutputGrafanaCloudPqMode = "error"
)

// Defines values for OutputGrafanaCloudPqOnBackpressure.
const (
	OutputGrafanaCloudPqOnBackpressureBlock OutputGrafanaCloudPqOnBackpressure = "block"
	OutputGrafanaCloudPqOnBackpressureDrop  OutputGrafanaCloudPqOnBackpressure = "drop"
)

// Defines values for OutputGrafanaCloudPrometheusAuthAuthType.
const (
	OutputGrafanaCloudPrometheusAuthAuthTypeBasic             OutputGrafanaCloudPrometheusAuthAuthType = "basic"
	OutputGrafanaCloudPrometheusAuthAuthTypeCredentialsSecret OutputGrafanaCloudPrometheusAuthAuthType = "credentialsSecret"
	OutputGrafanaCloudPrometheusAuthAuthTypeNone              OutputGrafanaCloudPrometheusAuthAuthType = "none"
	OutputGrafanaCloudPrometheusAuthAuthTypeTextSecret        OutputGrafanaCloudPrometheusAuthAuthType = "textSecret"
	OutputGrafanaCloudPrometheusAuthAuthTypeToken             OutputGrafanaCloudPrometheusAuthAuthType = "token"
)

// Defines values for OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry.
const (
	OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetryFalse OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry = false
	OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetryTrue  OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputGrafanaCloudType.
const (
	GrafanaCloud OutputGrafanaCloudType = "grafana_cloud"
)

// Defines values for OutputGraphiteOnBackpressure.
const (
	OutputGraphiteOnBackpressureBlock OutputGraphiteOnBackpressure = "block"
	OutputGraphiteOnBackpressureDrop  OutputGraphiteOnBackpressure = "drop"
	OutputGraphiteOnBackpressureQueue OutputGraphiteOnBackpressure = "queue"
)

// Defines values for OutputGraphitePqCompress.
const (
	OutputGraphitePqCompressGzip OutputGraphitePqCompress = "gzip"
	OutputGraphitePqCompressNone OutputGraphitePqCompress = "none"
)

// Defines values for OutputGraphitePqMode.
const (
	OutputGraphitePqModeAlways       OutputGraphitePqMode = "always"
	OutputGraphitePqModeBackpressure OutputGraphitePqMode = "backpressure"
	OutputGraphitePqModeError        OutputGraphitePqMode = "error"
)

// Defines values for OutputGraphitePqOnBackpressure.
const (
	OutputGraphitePqOnBackpressureBlock OutputGraphitePqOnBackpressure = "block"
	OutputGraphitePqOnBackpressureDrop  OutputGraphitePqOnBackpressure = "drop"
)

// Defines values for OutputGraphiteProtocol.
const (
	OutputGraphiteProtocolTcp OutputGraphiteProtocol = "tcp"
	OutputGraphiteProtocolUdp OutputGraphiteProtocol = "udp"
)

// Defines values for OutputGraphiteType.
const (
	Graphite OutputGraphiteType = "graphite"
)

// Defines values for OutputHoneycombAuthType.
const (
	OutputHoneycombAuthTypeManual OutputHoneycombAuthType = "manual"
	OutputHoneycombAuthTypeSecret OutputHoneycombAuthType = "secret"
)

// Defines values for OutputHoneycombFailedRequestLoggingMode.
const (
	OutputHoneycombFailedRequestLoggingModeNone              OutputHoneycombFailedRequestLoggingMode = "none"
	OutputHoneycombFailedRequestLoggingModePayload           OutputHoneycombFailedRequestLoggingMode = "payload"
	OutputHoneycombFailedRequestLoggingModePayloadAndHeaders OutputHoneycombFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputHoneycombOnBackpressure.
const (
	OutputHoneycombOnBackpressureBlock OutputHoneycombOnBackpressure = "block"
	OutputHoneycombOnBackpressureDrop  OutputHoneycombOnBackpressure = "drop"
	OutputHoneycombOnBackpressureQueue OutputHoneycombOnBackpressure = "queue"
)

// Defines values for OutputHoneycombPqCompress.
const (
	OutputHoneycombPqCompressGzip OutputHoneycombPqCompress = "gzip"
	OutputHoneycombPqCompressNone OutputHoneycombPqCompress = "none"
)

// Defines values for OutputHoneycombPqMode.
const (
	OutputHoneycombPqModeAlways       OutputHoneycombPqMode = "always"
	OutputHoneycombPqModeBackpressure OutputHoneycombPqMode = "backpressure"
	OutputHoneycombPqModeError        OutputHoneycombPqMode = "error"
)

// Defines values for OutputHoneycombPqOnBackpressure.
const (
	OutputHoneycombPqOnBackpressureBlock OutputHoneycombPqOnBackpressure = "block"
	OutputHoneycombPqOnBackpressureDrop  OutputHoneycombPqOnBackpressure = "drop"
)

// Defines values for OutputHoneycombTimeoutRetrySettingsTimeoutRetry.
const (
	OutputHoneycombTimeoutRetrySettingsTimeoutRetryFalse OutputHoneycombTimeoutRetrySettingsTimeoutRetry = false
	OutputHoneycombTimeoutRetrySettingsTimeoutRetryTrue  OutputHoneycombTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputHoneycombType.
const (
	Honeycomb OutputHoneycombType = "honeycomb"
)

// Defines values for OutputHumioHecAuthType.
const (
	OutputHumioHecAuthTypeManual OutputHumioHecAuthType = "manual"
	OutputHumioHecAuthTypeSecret OutputHumioHecAuthType = "secret"
)

// Defines values for OutputHumioHecFailedRequestLoggingMode.
const (
	OutputHumioHecFailedRequestLoggingModeNone              OutputHumioHecFailedRequestLoggingMode = "none"
	OutputHumioHecFailedRequestLoggingModePayload           OutputHumioHecFailedRequestLoggingMode = "payload"
	OutputHumioHecFailedRequestLoggingModePayloadAndHeaders OutputHumioHecFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputHumioHecFormat.
const (
	OutputHumioHecFormatJSON OutputHumioHecFormat = "JSON"
	OutputHumioHecFormatRaw  OutputHumioHecFormat = "raw"
)

// Defines values for OutputHumioHecOnBackpressure.
const (
	OutputHumioHecOnBackpressureBlock OutputHumioHecOnBackpressure = "block"
	OutputHumioHecOnBackpressureDrop  OutputHumioHecOnBackpressure = "drop"
	OutputHumioHecOnBackpressureQueue OutputHumioHecOnBackpressure = "queue"
)

// Defines values for OutputHumioHecPqCompress.
const (
	OutputHumioHecPqCompressGzip OutputHumioHecPqCompress = "gzip"
	OutputHumioHecPqCompressNone OutputHumioHecPqCompress = "none"
)

// Defines values for OutputHumioHecPqMode.
const (
	OutputHumioHecPqModeAlways       OutputHumioHecPqMode = "always"
	OutputHumioHecPqModeBackpressure OutputHumioHecPqMode = "backpressure"
	OutputHumioHecPqModeError        OutputHumioHecPqMode = "error"
)

// Defines values for OutputHumioHecPqOnBackpressure.
const (
	OutputHumioHecPqOnBackpressureBlock OutputHumioHecPqOnBackpressure = "block"
	OutputHumioHecPqOnBackpressureDrop  OutputHumioHecPqOnBackpressure = "drop"
)

// Defines values for OutputHumioHecTimeoutRetrySettingsTimeoutRetry.
const (
	OutputHumioHecTimeoutRetrySettingsTimeoutRetryFalse OutputHumioHecTimeoutRetrySettingsTimeoutRetry = false
	OutputHumioHecTimeoutRetrySettingsTimeoutRetryTrue  OutputHumioHecTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputHumioHecType.
const (
	HumioHec OutputHumioHecType = "humio_hec"
)

// Defines values for OutputInfluxdbAuthType.
const (
	OutputInfluxdbAuthTypeBasic             OutputInfluxdbAuthType = "basic"
	OutputInfluxdbAuthTypeCredentialsSecret OutputInfluxdbAuthType = "credentialsSecret"
	OutputInfluxdbAuthTypeNone              OutputInfluxdbAuthType = "none"
	OutputInfluxdbAuthTypeOauth             OutputInfluxdbAuthType = "oauth"
	OutputInfluxdbAuthTypeTextSecret        OutputInfluxdbAuthType = "textSecret"
	OutputInfluxdbAuthTypeToken             OutputInfluxdbAuthType = "token"
)

// Defines values for OutputInfluxdbFailedRequestLoggingMode.
const (
	OutputInfluxdbFailedRequestLoggingModeNone              OutputInfluxdbFailedRequestLoggingMode = "none"
	OutputInfluxdbFailedRequestLoggingModePayload           OutputInfluxdbFailedRequestLoggingMode = "payload"
	OutputInfluxdbFailedRequestLoggingModePayloadAndHeaders OutputInfluxdbFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputInfluxdbOnBackpressure.
const (
	OutputInfluxdbOnBackpressureBlock OutputInfluxdbOnBackpressure = "block"
	OutputInfluxdbOnBackpressureDrop  OutputInfluxdbOnBackpressure = "drop"
	OutputInfluxdbOnBackpressureQueue OutputInfluxdbOnBackpressure = "queue"
)

// Defines values for OutputInfluxdbPqCompress.
const (
	OutputInfluxdbPqCompressGzip OutputInfluxdbPqCompress = "gzip"
	OutputInfluxdbPqCompressNone OutputInfluxdbPqCompress = "none"
)

// Defines values for OutputInfluxdbPqMode.
const (
	OutputInfluxdbPqModeAlways       OutputInfluxdbPqMode = "always"
	OutputInfluxdbPqModeBackpressure OutputInfluxdbPqMode = "backpressure"
	OutputInfluxdbPqModeError        OutputInfluxdbPqMode = "error"
)

// Defines values for OutputInfluxdbPqOnBackpressure.
const (
	OutputInfluxdbPqOnBackpressureBlock OutputInfluxdbPqOnBackpressure = "block"
	OutputInfluxdbPqOnBackpressureDrop  OutputInfluxdbPqOnBackpressure = "drop"
)

// Defines values for OutputInfluxdbTimeoutRetrySettingsTimeoutRetry.
const (
	OutputInfluxdbTimeoutRetrySettingsTimeoutRetryFalse OutputInfluxdbTimeoutRetrySettingsTimeoutRetry = false
	OutputInfluxdbTimeoutRetrySettingsTimeoutRetryTrue  OutputInfluxdbTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputInfluxdbTimestampPrecision.
const (
	H  OutputInfluxdbTimestampPrecision = "h"
	M  OutputInfluxdbTimestampPrecision = "m"
	Ms OutputInfluxdbTimestampPrecision = "ms"
	Ns OutputInfluxdbTimestampPrecision = "ns"
	S  OutputInfluxdbTimestampPrecision = "s"
	U  OutputInfluxdbTimestampPrecision = "u"
)

// Defines values for OutputInfluxdbType.
const (
	Influxdb OutputInfluxdbType = "influxdb"
)

// Defines values for OutputInfluxdbUseV2API.
const (
	OutputInfluxdbUseV2APIFalse OutputInfluxdbUseV2API = false
	OutputInfluxdbUseV2APITrue  OutputInfluxdbUseV2API = true
)

// Defines values for OutputKafkaAck.
const (
	OutputKafkaAckMinus1 OutputKafkaAck = -1
	OutputKafkaAckN0     OutputKafkaAck = 0
	OutputKafkaAckN1     OutputKafkaAck = 1
)

// Defines values for OutputKafkaCompression.
const (
	OutputKafkaCompressionGzip   OutputKafkaCompression = "gzip"
	OutputKafkaCompressionLz4    OutputKafkaCompression = "lz4"
	OutputKafkaCompressionNone   OutputKafkaCompression = "none"
	OutputKafkaCompressionSnappy OutputKafkaCompression = "snappy"
)

// Defines values for OutputKafkaFormat.
const (
	OutputKafkaFormatJson     OutputKafkaFormat = "json"
	OutputKafkaFormatProtobuf OutputKafkaFormat = "protobuf"
	OutputKafkaFormatRaw      OutputKafkaFormat = "raw"
)

// Defines values for OutputKafkaKafkaSchemaRegistryAuthDisabled.
const (
	OutputKafkaKafkaSchemaRegistryAuthDisabledFalse OutputKafkaKafkaSchemaRegistryAuthDisabled = false
	OutputKafkaKafkaSchemaRegistryAuthDisabledTrue  OutputKafkaKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for OutputKafkaKafkaSchemaRegistryDisabled.
const (
	OutputKafkaKafkaSchemaRegistryDisabledFalse OutputKafkaKafkaSchemaRegistryDisabled = false
	OutputKafkaKafkaSchemaRegistryDisabledTrue  OutputKafkaKafkaSchemaRegistryDisabled = true
)

// Defines values for OutputKafkaKafkaSchemaRegistryTlsDisabled.
const (
	OutputKafkaKafkaSchemaRegistryTlsDisabledFalse OutputKafkaKafkaSchemaRegistryTlsDisabled = false
	OutputKafkaKafkaSchemaRegistryTlsDisabledTrue  OutputKafkaKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for OutputKafkaKafkaSchemaRegistryTlsMaxVersion.
const (
	OutputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv1  OutputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	OutputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv11 OutputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	OutputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv12 OutputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	OutputKafkaKafkaSchemaRegistryTlsMaxVersionTLSv13 OutputKafkaKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputKafkaKafkaSchemaRegistryTlsMinVersion.
const (
	OutputKafkaKafkaSchemaRegistryTlsMinVersionTLSv1  OutputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	OutputKafkaKafkaSchemaRegistryTlsMinVersionTLSv11 OutputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	OutputKafkaKafkaSchemaRegistryTlsMinVersionTLSv12 OutputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	OutputKafkaKafkaSchemaRegistryTlsMinVersionTLSv13 OutputKafkaKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputKafkaOnBackpressure.
const (
	OutputKafkaOnBackpressureBlock OutputKafkaOnBackpressure = "block"
	OutputKafkaOnBackpressureDrop  OutputKafkaOnBackpressure = "drop"
	OutputKafkaOnBackpressureQueue OutputKafkaOnBackpressure = "queue"
)

// Defines values for OutputKafkaPqCompress.
const (
	OutputKafkaPqCompressGzip OutputKafkaPqCompress = "gzip"
	OutputKafkaPqCompressNone OutputKafkaPqCompress = "none"
)

// Defines values for OutputKafkaPqMode.
const (
	OutputKafkaPqModeAlways       OutputKafkaPqMode = "always"
	OutputKafkaPqModeBackpressure OutputKafkaPqMode = "backpressure"
	OutputKafkaPqModeError        OutputKafkaPqMode = "error"
)

// Defines values for OutputKafkaPqOnBackpressure.
const (
	OutputKafkaPqOnBackpressureBlock OutputKafkaPqOnBackpressure = "block"
	OutputKafkaPqOnBackpressureDrop  OutputKafkaPqOnBackpressure = "drop"
)

// Defines values for OutputKafkaSaslDisabled.
const (
	OutputKafkaSaslDisabledFalse OutputKafkaSaslDisabled = false
	OutputKafkaSaslDisabledTrue  OutputKafkaSaslDisabled = true
)

// Defines values for OutputKafkaSaslMechanism.
const (
	Kerberos    OutputKafkaSaslMechanism = "kerberos"
	Plain       OutputKafkaSaslMechanism = "plain"
	ScramSha256 OutputKafkaSaslMechanism = "scram-sha-256"
	ScramSha512 OutputKafkaSaslMechanism = "scram-sha-512"
)

// Defines values for OutputKafkaTlsDisabled.
const (
	OutputKafkaTlsDisabledFalse OutputKafkaTlsDisabled = false
	OutputKafkaTlsDisabledTrue  OutputKafkaTlsDisabled = true
)

// Defines values for OutputKafkaTlsMaxVersion.
const (
	OutputKafkaTlsMaxVersionTLSv1  OutputKafkaTlsMaxVersion = "TLSv1"
	OutputKafkaTlsMaxVersionTLSv11 OutputKafkaTlsMaxVersion = "TLSv1.1"
	OutputKafkaTlsMaxVersionTLSv12 OutputKafkaTlsMaxVersion = "TLSv1.2"
	OutputKafkaTlsMaxVersionTLSv13 OutputKafkaTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputKafkaTlsMinVersion.
const (
	OutputKafkaTlsMinVersionTLSv1  OutputKafkaTlsMinVersion = "TLSv1"
	OutputKafkaTlsMinVersionTLSv11 OutputKafkaTlsMinVersion = "TLSv1.1"
	OutputKafkaTlsMinVersionTLSv12 OutputKafkaTlsMinVersion = "TLSv1.2"
	OutputKafkaTlsMinVersionTLSv13 OutputKafkaTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputKafkaType.
const (
	OutputKafkaTypeKafka OutputKafkaType = "kafka"
)

// Defines values for OutputKinesisAwsAuthenticationMethod.
const (
	OutputKinesisAwsAuthenticationMethodAuto   OutputKinesisAwsAuthenticationMethod = "auto"
	OutputKinesisAwsAuthenticationMethodManual OutputKinesisAwsAuthenticationMethod = "manual"
	OutputKinesisAwsAuthenticationMethodSecret OutputKinesisAwsAuthenticationMethod = "secret"
)

// Defines values for OutputKinesisCompression.
const (
	OutputKinesisCompressionGzip OutputKinesisCompression = "gzip"
	OutputKinesisCompressionNone OutputKinesisCompression = "none"
)

// Defines values for OutputKinesisOnBackpressure.
const (
	OutputKinesisOnBackpressureBlock OutputKinesisOnBackpressure = "block"
	OutputKinesisOnBackpressureDrop  OutputKinesisOnBackpressure = "drop"
	OutputKinesisOnBackpressureQueue OutputKinesisOnBackpressure = "queue"
)

// Defines values for OutputKinesisPqCompress.
const (
	OutputKinesisPqCompressGzip OutputKinesisPqCompress = "gzip"
	OutputKinesisPqCompressNone OutputKinesisPqCompress = "none"
)

// Defines values for OutputKinesisPqMode.
const (
	OutputKinesisPqModeAlways       OutputKinesisPqMode = "always"
	OutputKinesisPqModeBackpressure OutputKinesisPqMode = "backpressure"
	OutputKinesisPqModeError        OutputKinesisPqMode = "error"
)

// Defines values for OutputKinesisPqOnBackpressure.
const (
	OutputKinesisPqOnBackpressureBlock OutputKinesisPqOnBackpressure = "block"
	OutputKinesisPqOnBackpressureDrop  OutputKinesisPqOnBackpressure = "drop"
)

// Defines values for OutputKinesisSignatureVersion.
const (
	OutputKinesisSignatureVersionV2 OutputKinesisSignatureVersion = "v2"
	OutputKinesisSignatureVersionV4 OutputKinesisSignatureVersion = "v4"
)

// Defines values for OutputKinesisType.
const (
	OutputKinesisTypeKinesis OutputKinesisType = "kinesis"
)

// Defines values for OutputLokiAuthType.
const (
	OutputLokiAuthTypeBasic             OutputLokiAuthType = "basic"
	OutputLokiAuthTypeCredentialsSecret OutputLokiAuthType = "credentialsSecret"
	OutputLokiAuthTypeNone              OutputLokiAuthType = "none"
	OutputLokiAuthTypeTextSecret        OutputLokiAuthType = "textSecret"
	OutputLokiAuthTypeToken             OutputLokiAuthType = "token"
)

// Defines values for OutputLokiFailedRequestLoggingMode.
const (
	OutputLokiFailedRequestLoggingModeNone              OutputLokiFailedRequestLoggingMode = "none"
	OutputLokiFailedRequestLoggingModePayload           OutputLokiFailedRequestLoggingMode = "payload"
	OutputLokiFailedRequestLoggingModePayloadAndHeaders OutputLokiFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputLokiMessageFormat.
const (
	OutputLokiMessageFormatJson     OutputLokiMessageFormat = "json"
	OutputLokiMessageFormatProtobuf OutputLokiMessageFormat = "protobuf"
)

// Defines values for OutputLokiOnBackpressure.
const (
	OutputLokiOnBackpressureBlock OutputLokiOnBackpressure = "block"
	OutputLokiOnBackpressureDrop  OutputLokiOnBackpressure = "drop"
	OutputLokiOnBackpressureQueue OutputLokiOnBackpressure = "queue"
)

// Defines values for OutputLokiPqCompress.
const (
	OutputLokiPqCompressGzip OutputLokiPqCompress = "gzip"
	OutputLokiPqCompressNone OutputLokiPqCompress = "none"
)

// Defines values for OutputLokiPqMode.
const (
	OutputLokiPqModeAlways       OutputLokiPqMode = "always"
	OutputLokiPqModeBackpressure OutputLokiPqMode = "backpressure"
	OutputLokiPqModeError        OutputLokiPqMode = "error"
)

// Defines values for OutputLokiPqOnBackpressure.
const (
	OutputLokiPqOnBackpressureBlock OutputLokiPqOnBackpressure = "block"
	OutputLokiPqOnBackpressureDrop  OutputLokiPqOnBackpressure = "drop"
)

// Defines values for OutputLokiTimeoutRetrySettingsTimeoutRetry.
const (
	OutputLokiTimeoutRetrySettingsTimeoutRetryFalse OutputLokiTimeoutRetrySettingsTimeoutRetry = false
	OutputLokiTimeoutRetrySettingsTimeoutRetryTrue  OutputLokiTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputLokiType.
const (
	OutputLokiTypeLoki OutputLokiType = "loki"
)

// Defines values for OutputMinioAwsAuthenticationMethod.
const (
	OutputMinioAwsAuthenticationMethodAuto   OutputMinioAwsAuthenticationMethod = "auto"
	OutputMinioAwsAuthenticationMethodManual OutputMinioAwsAuthenticationMethod = "manual"
	OutputMinioAwsAuthenticationMethodSecret OutputMinioAwsAuthenticationMethod = "secret"
)

// Defines values for OutputMinioCompress.
const (
	OutputMinioCompressGzip OutputMinioCompress = "gzip"
	OutputMinioCompressNone OutputMinioCompress = "none"
)

// Defines values for OutputMinioCompressionLevel.
const (
	OutputMinioCompressionLevelBestCompression OutputMinioCompressionLevel = "best_compression"
	OutputMinioCompressionLevelBestSpeed       OutputMinioCompressionLevel = "best_speed"
	OutputMinioCompressionLevelNormal          OutputMinioCompressionLevel = "normal"
)

// Defines values for OutputMinioDeadletterEnabled.
const (
	OutputMinioDeadletterEnabledFalse OutputMinioDeadletterEnabled = false
	OutputMinioDeadletterEnabledTrue  OutputMinioDeadletterEnabled = true
)

// Defines values for OutputMinioFormat.
const (
	OutputMinioFormatJson    OutputMinioFormat = "json"
	OutputMinioFormatParquet OutputMinioFormat = "parquet"
	OutputMinioFormatRaw     OutputMinioFormat = "raw"
)

// Defines values for OutputMinioObjectACL.
const (
	OutputMinioObjectACLAuthenticatedRead      OutputMinioObjectACL = "authenticated-read"
	OutputMinioObjectACLAwsExecRead            OutputMinioObjectACL = "aws-exec-read"
	OutputMinioObjectACLBucketOwnerFullControl OutputMinioObjectACL = "bucket-owner-full-control"
	OutputMinioObjectACLBucketOwnerRead        OutputMinioObjectACL = "bucket-owner-read"
	OutputMinioObjectACLPrivate                OutputMinioObjectACL = "private"
	OutputMinioObjectACLPublicRead             OutputMinioObjectACL = "public-read"
	OutputMinioObjectACLPublicReadWrite        OutputMinioObjectACL = "public-read-write"
)

// Defines values for OutputMinioOnBackpressure.
const (
	OutputMinioOnBackpressureBlock OutputMinioOnBackpressure = "block"
	OutputMinioOnBackpressureDrop  OutputMinioOnBackpressure = "drop"
)

// Defines values for OutputMinioOnDiskFullBackpressure.
const (
	OutputMinioOnDiskFullBackpressureBlock OutputMinioOnDiskFullBackpressure = "block"
	OutputMinioOnDiskFullBackpressureDrop  OutputMinioOnDiskFullBackpressure = "drop"
)

// Defines values for OutputMinioParquetDataPageVersion.
const (
	OutputMinioParquetDataPageVersionDATAPAGEV1 OutputMinioParquetDataPageVersion = "DATA_PAGE_V1"
	OutputMinioParquetDataPageVersionDATAPAGEV2 OutputMinioParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputMinioParquetVersion.
const (
	OutputMinioParquetVersionPARQUET10 OutputMinioParquetVersion = "PARQUET_1_0"
	OutputMinioParquetVersionPARQUET24 OutputMinioParquetVersion = "PARQUET_2_4"
	OutputMinioParquetVersionPARQUET26 OutputMinioParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputMinioRemoveEmptyDirs.
const (
	OutputMinioRemoveEmptyDirsFalse OutputMinioRemoveEmptyDirs = false
	OutputMinioRemoveEmptyDirsTrue  OutputMinioRemoveEmptyDirs = true
)

// Defines values for OutputMinioServerSideEncryption.
const (
	OutputMinioServerSideEncryptionAES256 OutputMinioServerSideEncryption = "AES256"
)

// Defines values for OutputMinioSignatureVersion.
const (
	OutputMinioSignatureVersionV2 OutputMinioSignatureVersion = "v2"
	OutputMinioSignatureVersionV4 OutputMinioSignatureVersion = "v4"
)

// Defines values for OutputMinioStorageClass.
const (
	OutputMinioStorageClassREDUCEDREDUNDANCY OutputMinioStorageClass = "REDUCED_REDUNDANCY"
	OutputMinioStorageClassSTANDARD          OutputMinioStorageClass = "STANDARD"
)

// Defines values for OutputMinioType.
const (
	Minio OutputMinioType = "minio"
)

// Defines values for OutputMskAck.
const (
	OutputMskAckMinus1 OutputMskAck = -1
	OutputMskAckN0     OutputMskAck = 0
	OutputMskAckN1     OutputMskAck = 1
)

// Defines values for OutputMskAwsAuthenticationMethod.
const (
	OutputMskAwsAuthenticationMethodAuto   OutputMskAwsAuthenticationMethod = "auto"
	OutputMskAwsAuthenticationMethodManual OutputMskAwsAuthenticationMethod = "manual"
	OutputMskAwsAuthenticationMethodSecret OutputMskAwsAuthenticationMethod = "secret"
)

// Defines values for OutputMskCompression.
const (
	OutputMskCompressionGzip   OutputMskCompression = "gzip"
	OutputMskCompressionLz4    OutputMskCompression = "lz4"
	OutputMskCompressionNone   OutputMskCompression = "none"
	OutputMskCompressionSnappy OutputMskCompression = "snappy"
)

// Defines values for OutputMskFormat.
const (
	OutputMskFormatJson     OutputMskFormat = "json"
	OutputMskFormatProtobuf OutputMskFormat = "protobuf"
	OutputMskFormatRaw      OutputMskFormat = "raw"
)

// Defines values for OutputMskKafkaSchemaRegistryAuthDisabled.
const (
	OutputMskKafkaSchemaRegistryAuthDisabledFalse OutputMskKafkaSchemaRegistryAuthDisabled = false
	OutputMskKafkaSchemaRegistryAuthDisabledTrue  OutputMskKafkaSchemaRegistryAuthDisabled = true
)

// Defines values for OutputMskKafkaSchemaRegistryDisabled.
const (
	OutputMskKafkaSchemaRegistryDisabledFalse OutputMskKafkaSchemaRegistryDisabled = false
	OutputMskKafkaSchemaRegistryDisabledTrue  OutputMskKafkaSchemaRegistryDisabled = true
)

// Defines values for OutputMskKafkaSchemaRegistryTlsDisabled.
const (
	OutputMskKafkaSchemaRegistryTlsDisabledFalse OutputMskKafkaSchemaRegistryTlsDisabled = false
	OutputMskKafkaSchemaRegistryTlsDisabledTrue  OutputMskKafkaSchemaRegistryTlsDisabled = true
)

// Defines values for OutputMskKafkaSchemaRegistryTlsMaxVersion.
const (
	OutputMskKafkaSchemaRegistryTlsMaxVersionTLSv1  OutputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1"
	OutputMskKafkaSchemaRegistryTlsMaxVersionTLSv11 OutputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.1"
	OutputMskKafkaSchemaRegistryTlsMaxVersionTLSv12 OutputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.2"
	OutputMskKafkaSchemaRegistryTlsMaxVersionTLSv13 OutputMskKafkaSchemaRegistryTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputMskKafkaSchemaRegistryTlsMinVersion.
const (
	OutputMskKafkaSchemaRegistryTlsMinVersionTLSv1  OutputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1"
	OutputMskKafkaSchemaRegistryTlsMinVersionTLSv11 OutputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.1"
	OutputMskKafkaSchemaRegistryTlsMinVersionTLSv12 OutputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.2"
	OutputMskKafkaSchemaRegistryTlsMinVersionTLSv13 OutputMskKafkaSchemaRegistryTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputMskOnBackpressure.
const (
	OutputMskOnBackpressureBlock OutputMskOnBackpressure = "block"
	OutputMskOnBackpressureDrop  OutputMskOnBackpressure = "drop"
	OutputMskOnBackpressureQueue OutputMskOnBackpressure = "queue"
)

// Defines values for OutputMskPqCompress.
const (
	OutputMskPqCompressGzip OutputMskPqCompress = "gzip"
	OutputMskPqCompressNone OutputMskPqCompress = "none"
)

// Defines values for OutputMskPqMode.
const (
	OutputMskPqModeAlways       OutputMskPqMode = "always"
	OutputMskPqModeBackpressure OutputMskPqMode = "backpressure"
	OutputMskPqModeError        OutputMskPqMode = "error"
)

// Defines values for OutputMskPqOnBackpressure.
const (
	OutputMskPqOnBackpressureBlock OutputMskPqOnBackpressure = "block"
	OutputMskPqOnBackpressureDrop  OutputMskPqOnBackpressure = "drop"
)

// Defines values for OutputMskSignatureVersion.
const (
	OutputMskSignatureVersionV2 OutputMskSignatureVersion = "v2"
	OutputMskSignatureVersionV4 OutputMskSignatureVersion = "v4"
)

// Defines values for OutputMskTlsDisabled.
const (
	OutputMskTlsDisabledFalse OutputMskTlsDisabled = false
	OutputMskTlsDisabledTrue  OutputMskTlsDisabled = true
)

// Defines values for OutputMskTlsMaxVersion.
const (
	OutputMskTlsMaxVersionTLSv1  OutputMskTlsMaxVersion = "TLSv1"
	OutputMskTlsMaxVersionTLSv11 OutputMskTlsMaxVersion = "TLSv1.1"
	OutputMskTlsMaxVersionTLSv12 OutputMskTlsMaxVersion = "TLSv1.2"
	OutputMskTlsMaxVersionTLSv13 OutputMskTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputMskTlsMinVersion.
const (
	OutputMskTlsMinVersionTLSv1  OutputMskTlsMinVersion = "TLSv1"
	OutputMskTlsMinVersionTLSv11 OutputMskTlsMinVersion = "TLSv1.1"
	OutputMskTlsMinVersionTLSv12 OutputMskTlsMinVersion = "TLSv1.2"
	OutputMskTlsMinVersionTLSv13 OutputMskTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputMskType.
const (
	OutputMskTypeMsk OutputMskType = "msk"
)

// Defines values for OutputNetflowType.
const (
	OutputNetflowTypeNetflow OutputNetflowType = "netflow"
)

// Defines values for OutputNewrelicAuthType.
const (
	OutputNewrelicAuthTypeManual OutputNewrelicAuthType = "manual"
	OutputNewrelicAuthTypeSecret OutputNewrelicAuthType = "secret"
)

// Defines values for OutputNewrelicFailedRequestLoggingMode.
const (
	OutputNewrelicFailedRequestLoggingModeNone              OutputNewrelicFailedRequestLoggingMode = "none"
	OutputNewrelicFailedRequestLoggingModePayload           OutputNewrelicFailedRequestLoggingMode = "payload"
	OutputNewrelicFailedRequestLoggingModePayloadAndHeaders OutputNewrelicFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputNewrelicMetadataName.
const (
	AuditId   OutputNewrelicMetadataName = "auditId"
	Hostname  OutputNewrelicMetadataName = "hostname"
	Service   OutputNewrelicMetadataName = "service"
	Timestamp OutputNewrelicMetadataName = "timestamp"
)

// Defines values for OutputNewrelicOnBackpressure.
const (
	OutputNewrelicOnBackpressureBlock OutputNewrelicOnBackpressure = "block"
	OutputNewrelicOnBackpressureDrop  OutputNewrelicOnBackpressure = "drop"
	OutputNewrelicOnBackpressureQueue OutputNewrelicOnBackpressure = "queue"
)

// Defines values for OutputNewrelicPqCompress.
const (
	OutputNewrelicPqCompressGzip OutputNewrelicPqCompress = "gzip"
	OutputNewrelicPqCompressNone OutputNewrelicPqCompress = "none"
)

// Defines values for OutputNewrelicPqMode.
const (
	OutputNewrelicPqModeAlways       OutputNewrelicPqMode = "always"
	OutputNewrelicPqModeBackpressure OutputNewrelicPqMode = "backpressure"
	OutputNewrelicPqModeError        OutputNewrelicPqMode = "error"
)

// Defines values for OutputNewrelicPqOnBackpressure.
const (
	OutputNewrelicPqOnBackpressureBlock OutputNewrelicPqOnBackpressure = "block"
	OutputNewrelicPqOnBackpressureDrop  OutputNewrelicPqOnBackpressure = "drop"
)

// Defines values for OutputNewrelicRegion.
const (
	OutputNewrelicRegionCustom OutputNewrelicRegion = "Custom"
	OutputNewrelicRegionEU     OutputNewrelicRegion = "EU"
	OutputNewrelicRegionUS     OutputNewrelicRegion = "US"
)

// Defines values for OutputNewrelicTimeoutRetrySettingsTimeoutRetry.
const (
	OutputNewrelicTimeoutRetrySettingsTimeoutRetryFalse OutputNewrelicTimeoutRetrySettingsTimeoutRetry = false
	OutputNewrelicTimeoutRetrySettingsTimeoutRetryTrue  OutputNewrelicTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputNewrelicType.
const (
	Newrelic OutputNewrelicType = "newrelic"
)

// Defines values for OutputNewrelicEventsAuthType.
const (
	OutputNewrelicEventsAuthTypeManual OutputNewrelicEventsAuthType = "manual"
	OutputNewrelicEventsAuthTypeSecret OutputNewrelicEventsAuthType = "secret"
)

// Defines values for OutputNewrelicEventsFailedRequestLoggingMode.
const (
	OutputNewrelicEventsFailedRequestLoggingModeNone              OutputNewrelicEventsFailedRequestLoggingMode = "none"
	OutputNewrelicEventsFailedRequestLoggingModePayload           OutputNewrelicEventsFailedRequestLoggingMode = "payload"
	OutputNewrelicEventsFailedRequestLoggingModePayloadAndHeaders OutputNewrelicEventsFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputNewrelicEventsOnBackpressure.
const (
	OutputNewrelicEventsOnBackpressureBlock OutputNewrelicEventsOnBackpressure = "block"
	OutputNewrelicEventsOnBackpressureDrop  OutputNewrelicEventsOnBackpressure = "drop"
	OutputNewrelicEventsOnBackpressureQueue OutputNewrelicEventsOnBackpressure = "queue"
)

// Defines values for OutputNewrelicEventsPqCompress.
const (
	OutputNewrelicEventsPqCompressGzip OutputNewrelicEventsPqCompress = "gzip"
	OutputNewrelicEventsPqCompressNone OutputNewrelicEventsPqCompress = "none"
)

// Defines values for OutputNewrelicEventsPqMode.
const (
	OutputNewrelicEventsPqModeAlways       OutputNewrelicEventsPqMode = "always"
	OutputNewrelicEventsPqModeBackpressure OutputNewrelicEventsPqMode = "backpressure"
	OutputNewrelicEventsPqModeError        OutputNewrelicEventsPqMode = "error"
)

// Defines values for OutputNewrelicEventsPqOnBackpressure.
const (
	OutputNewrelicEventsPqOnBackpressureBlock OutputNewrelicEventsPqOnBackpressure = "block"
	OutputNewrelicEventsPqOnBackpressureDrop  OutputNewrelicEventsPqOnBackpressure = "drop"
)

// Defines values for OutputNewrelicEventsRegion.
const (
	OutputNewrelicEventsRegionCustom OutputNewrelicEventsRegion = "Custom"
	OutputNewrelicEventsRegionEU     OutputNewrelicEventsRegion = "EU"
	OutputNewrelicEventsRegionUS     OutputNewrelicEventsRegion = "US"
)

// Defines values for OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry.
const (
	OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetryFalse OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry = false
	OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetryTrue  OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputNewrelicEventsType.
const (
	NewrelicEvents OutputNewrelicEventsType = "newrelic_events"
)

// Defines values for OutputOpenTelemetryAuthType.
const (
	OutputOpenTelemetryAuthTypeBasic             OutputOpenTelemetryAuthType = "basic"
	OutputOpenTelemetryAuthTypeCredentialsSecret OutputOpenTelemetryAuthType = "credentialsSecret"
	OutputOpenTelemetryAuthTypeNone              OutputOpenTelemetryAuthType = "none"
	OutputOpenTelemetryAuthTypeOauth             OutputOpenTelemetryAuthType = "oauth"
	OutputOpenTelemetryAuthTypeTextSecret        OutputOpenTelemetryAuthType = "textSecret"
	OutputOpenTelemetryAuthTypeToken             OutputOpenTelemetryAuthType = "token"
)

// Defines values for OutputOpenTelemetryCompress.
const (
	OutputOpenTelemetryCompressDeflate OutputOpenTelemetryCompress = "deflate"
	OutputOpenTelemetryCompressGzip    OutputOpenTelemetryCompress = "gzip"
	OutputOpenTelemetryCompressNone    OutputOpenTelemetryCompress = "none"
)

// Defines values for OutputOpenTelemetryFailedRequestLoggingMode.
const (
	OutputOpenTelemetryFailedRequestLoggingModeNone              OutputOpenTelemetryFailedRequestLoggingMode = "none"
	OutputOpenTelemetryFailedRequestLoggingModePayload           OutputOpenTelemetryFailedRequestLoggingMode = "payload"
	OutputOpenTelemetryFailedRequestLoggingModePayloadAndHeaders OutputOpenTelemetryFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputOpenTelemetryHttpCompress.
const (
	OutputOpenTelemetryHttpCompressGzip OutputOpenTelemetryHttpCompress = "gzip"
	OutputOpenTelemetryHttpCompressNone OutputOpenTelemetryHttpCompress = "none"
)

// Defines values for OutputOpenTelemetryOnBackpressure.
const (
	OutputOpenTelemetryOnBackpressureBlock OutputOpenTelemetryOnBackpressure = "block"
	OutputOpenTelemetryOnBackpressureDrop  OutputOpenTelemetryOnBackpressure = "drop"
	OutputOpenTelemetryOnBackpressureQueue OutputOpenTelemetryOnBackpressure = "queue"
)

// Defines values for OutputOpenTelemetryOtlpVersion.
const (
	OutputOpenTelemetryOtlpVersionN0100 OutputOpenTelemetryOtlpVersion = "0.10.0"
	OutputOpenTelemetryOtlpVersionN131  OutputOpenTelemetryOtlpVersion = "1.3.1"
)

// Defines values for OutputOpenTelemetryPqCompress.
const (
	OutputOpenTelemetryPqCompressGzip OutputOpenTelemetryPqCompress = "gzip"
	OutputOpenTelemetryPqCompressNone OutputOpenTelemetryPqCompress = "none"
)

// Defines values for OutputOpenTelemetryPqMode.
const (
	OutputOpenTelemetryPqModeAlways       OutputOpenTelemetryPqMode = "always"
	OutputOpenTelemetryPqModeBackpressure OutputOpenTelemetryPqMode = "backpressure"
	OutputOpenTelemetryPqModeError        OutputOpenTelemetryPqMode = "error"
)

// Defines values for OutputOpenTelemetryPqOnBackpressure.
const (
	OutputOpenTelemetryPqOnBackpressureBlock OutputOpenTelemetryPqOnBackpressure = "block"
	OutputOpenTelemetryPqOnBackpressureDrop  OutputOpenTelemetryPqOnBackpressure = "drop"
)

// Defines values for OutputOpenTelemetryProtocol.
const (
	OutputOpenTelemetryProtocolGrpc OutputOpenTelemetryProtocol = "grpc"
	OutputOpenTelemetryProtocolHttp OutputOpenTelemetryProtocol = "http"
)

// Defines values for OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry.
const (
	OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetryFalse OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry = false
	OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetryTrue  OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputOpenTelemetryTlsDisabled.
const (
	OutputOpenTelemetryTlsDisabledFalse OutputOpenTelemetryTlsDisabled = false
	OutputOpenTelemetryTlsDisabledTrue  OutputOpenTelemetryTlsDisabled = true
)

// Defines values for OutputOpenTelemetryTlsMaxVersion.
const (
	OutputOpenTelemetryTlsMaxVersionTLSv1  OutputOpenTelemetryTlsMaxVersion = "TLSv1"
	OutputOpenTelemetryTlsMaxVersionTLSv11 OutputOpenTelemetryTlsMaxVersion = "TLSv1.1"
	OutputOpenTelemetryTlsMaxVersionTLSv12 OutputOpenTelemetryTlsMaxVersion = "TLSv1.2"
	OutputOpenTelemetryTlsMaxVersionTLSv13 OutputOpenTelemetryTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputOpenTelemetryTlsMinVersion.
const (
	OutputOpenTelemetryTlsMinVersionTLSv1  OutputOpenTelemetryTlsMinVersion = "TLSv1"
	OutputOpenTelemetryTlsMinVersionTLSv11 OutputOpenTelemetryTlsMinVersion = "TLSv1.1"
	OutputOpenTelemetryTlsMinVersionTLSv12 OutputOpenTelemetryTlsMinVersion = "TLSv1.2"
	OutputOpenTelemetryTlsMinVersionTLSv13 OutputOpenTelemetryTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputOpenTelemetryType.
const (
	OutputOpenTelemetryTypeOpenTelemetry OutputOpenTelemetryType = "open_telemetry"
)

// Defines values for OutputPrometheusAuthType.
const (
	OutputPrometheusAuthTypeBasic             OutputPrometheusAuthType = "basic"
	OutputPrometheusAuthTypeCredentialsSecret OutputPrometheusAuthType = "credentialsSecret"
	OutputPrometheusAuthTypeNone              OutputPrometheusAuthType = "none"
	OutputPrometheusAuthTypeOauth             OutputPrometheusAuthType = "oauth"
	OutputPrometheusAuthTypeTextSecret        OutputPrometheusAuthType = "textSecret"
	OutputPrometheusAuthTypeToken             OutputPrometheusAuthType = "token"
)

// Defines values for OutputPrometheusFailedRequestLoggingMode.
const (
	OutputPrometheusFailedRequestLoggingModeNone              OutputPrometheusFailedRequestLoggingMode = "none"
	OutputPrometheusFailedRequestLoggingModePayload           OutputPrometheusFailedRequestLoggingMode = "payload"
	OutputPrometheusFailedRequestLoggingModePayloadAndHeaders OutputPrometheusFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputPrometheusOnBackpressure.
const (
	OutputPrometheusOnBackpressureBlock OutputPrometheusOnBackpressure = "block"
	OutputPrometheusOnBackpressureDrop  OutputPrometheusOnBackpressure = "drop"
	OutputPrometheusOnBackpressureQueue OutputPrometheusOnBackpressure = "queue"
)

// Defines values for OutputPrometheusPqCompress.
const (
	OutputPrometheusPqCompressGzip OutputPrometheusPqCompress = "gzip"
	OutputPrometheusPqCompressNone OutputPrometheusPqCompress = "none"
)

// Defines values for OutputPrometheusPqMode.
const (
	OutputPrometheusPqModeAlways       OutputPrometheusPqMode = "always"
	OutputPrometheusPqModeBackpressure OutputPrometheusPqMode = "backpressure"
	OutputPrometheusPqModeError        OutputPrometheusPqMode = "error"
)

// Defines values for OutputPrometheusPqOnBackpressure.
const (
	OutputPrometheusPqOnBackpressureBlock OutputPrometheusPqOnBackpressure = "block"
	OutputPrometheusPqOnBackpressureDrop  OutputPrometheusPqOnBackpressure = "drop"
)

// Defines values for OutputPrometheusSendMetadata.
const (
	OutputPrometheusSendMetadataFalse OutputPrometheusSendMetadata = false
	OutputPrometheusSendMetadataTrue  OutputPrometheusSendMetadata = true
)

// Defines values for OutputPrometheusTimeoutRetrySettingsTimeoutRetry.
const (
	OutputPrometheusTimeoutRetrySettingsTimeoutRetryFalse OutputPrometheusTimeoutRetrySettingsTimeoutRetry = false
	OutputPrometheusTimeoutRetrySettingsTimeoutRetryTrue  OutputPrometheusTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputPrometheusType.
const (
	OutputPrometheusTypePrometheus OutputPrometheusType = "prometheus"
)

// Defines values for OutputRingCompress.
const (
	OutputRingCompressGzip OutputRingCompress = "gzip"
	OutputRingCompressNone OutputRingCompress = "none"
)

// Defines values for OutputRingFormat.
const (
	OutputRingFormatJson OutputRingFormat = "json"
	OutputRingFormatRaw  OutputRingFormat = "raw"
)

// Defines values for OutputRingOnBackpressure.
const (
	OutputRingOnBackpressureBlock OutputRingOnBackpressure = "block"
	OutputRingOnBackpressureDrop  OutputRingOnBackpressure = "drop"
)

// Defines values for OutputRingType.
const (
	Ring OutputRingType = "ring"
)

// Defines values for OutputRouterType.
const (
	Router OutputRouterType = "router"
)

// Defines values for OutputS3AwsAuthenticationMethod.
const (
	OutputS3AwsAuthenticationMethodAuto   OutputS3AwsAuthenticationMethod = "auto"
	OutputS3AwsAuthenticationMethodManual OutputS3AwsAuthenticationMethod = "manual"
	OutputS3AwsAuthenticationMethodSecret OutputS3AwsAuthenticationMethod = "secret"
)

// Defines values for OutputS3Compress.
const (
	OutputS3CompressGzip OutputS3Compress = "gzip"
	OutputS3CompressNone OutputS3Compress = "none"
)

// Defines values for OutputS3CompressionLevel.
const (
	OutputS3CompressionLevelBestCompression OutputS3CompressionLevel = "best_compression"
	OutputS3CompressionLevelBestSpeed       OutputS3CompressionLevel = "best_speed"
	OutputS3CompressionLevelNormal          OutputS3CompressionLevel = "normal"
)

// Defines values for OutputS3DeadletterEnabled.
const (
	OutputS3DeadletterEnabledFalse OutputS3DeadletterEnabled = false
	OutputS3DeadletterEnabledTrue  OutputS3DeadletterEnabled = true
)

// Defines values for OutputS3Format.
const (
	OutputS3FormatJson    OutputS3Format = "json"
	OutputS3FormatParquet OutputS3Format = "parquet"
	OutputS3FormatRaw     OutputS3Format = "raw"
)

// Defines values for OutputS3ObjectACL.
const (
	OutputS3ObjectACLAuthenticatedRead      OutputS3ObjectACL = "authenticated-read"
	OutputS3ObjectACLAwsExecRead            OutputS3ObjectACL = "aws-exec-read"
	OutputS3ObjectACLBucketOwnerFullControl OutputS3ObjectACL = "bucket-owner-full-control"
	OutputS3ObjectACLBucketOwnerRead        OutputS3ObjectACL = "bucket-owner-read"
	OutputS3ObjectACLPrivate                OutputS3ObjectACL = "private"
	OutputS3ObjectACLPublicRead             OutputS3ObjectACL = "public-read"
	OutputS3ObjectACLPublicReadWrite        OutputS3ObjectACL = "public-read-write"
)

// Defines values for OutputS3OnBackpressure.
const (
	OutputS3OnBackpressureBlock OutputS3OnBackpressure = "block"
	OutputS3OnBackpressureDrop  OutputS3OnBackpressure = "drop"
)

// Defines values for OutputS3OnDiskFullBackpressure.
const (
	OutputS3OnDiskFullBackpressureBlock OutputS3OnDiskFullBackpressure = "block"
	OutputS3OnDiskFullBackpressureDrop  OutputS3OnDiskFullBackpressure = "drop"
)

// Defines values for OutputS3ParquetDataPageVersion.
const (
	OutputS3ParquetDataPageVersionDATAPAGEV1 OutputS3ParquetDataPageVersion = "DATA_PAGE_V1"
	OutputS3ParquetDataPageVersionDATAPAGEV2 OutputS3ParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputS3ParquetVersion.
const (
	OutputS3ParquetVersionPARQUET10 OutputS3ParquetVersion = "PARQUET_1_0"
	OutputS3ParquetVersionPARQUET24 OutputS3ParquetVersion = "PARQUET_2_4"
	OutputS3ParquetVersionPARQUET26 OutputS3ParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputS3RemoveEmptyDirs.
const (
	OutputS3RemoveEmptyDirsFalse OutputS3RemoveEmptyDirs = false
	OutputS3RemoveEmptyDirsTrue  OutputS3RemoveEmptyDirs = true
)

// Defines values for OutputS3ServerSideEncryption.
const (
	OutputS3ServerSideEncryptionAES256 OutputS3ServerSideEncryption = "AES256"
	OutputS3ServerSideEncryptionAwsKms OutputS3ServerSideEncryption = "aws:kms"
)

// Defines values for OutputS3SignatureVersion.
const (
	OutputS3SignatureVersionV2 OutputS3SignatureVersion = "v2"
	OutputS3SignatureVersionV4 OutputS3SignatureVersion = "v4"
)

// Defines values for OutputS3StorageClass.
const (
	OutputS3StorageClassDEEPARCHIVE        OutputS3StorageClass = "DEEP_ARCHIVE"
	OutputS3StorageClassGLACIER            OutputS3StorageClass = "GLACIER"
	OutputS3StorageClassGLACIERIR          OutputS3StorageClass = "GLACIER_IR"
	OutputS3StorageClassINTELLIGENTTIERING OutputS3StorageClass = "INTELLIGENT_TIERING"
	OutputS3StorageClassONEZONEIA          OutputS3StorageClass = "ONEZONE_IA"
	OutputS3StorageClassREDUCEDREDUNDANCY  OutputS3StorageClass = "REDUCED_REDUNDANCY"
	OutputS3StorageClassSTANDARD           OutputS3StorageClass = "STANDARD"
	OutputS3StorageClassSTANDARDIA         OutputS3StorageClass = "STANDARD_IA"
)

// Defines values for OutputS3Type.
const (
	OutputS3TypeS3 OutputS3Type = "s3"
)

// Defines values for OutputSecurityLakeAutomaticSchema.
const (
	OutputSecurityLakeAutomaticSchemaFalse OutputSecurityLakeAutomaticSchema = false
	OutputSecurityLakeAutomaticSchemaTrue  OutputSecurityLakeAutomaticSchema = true
)

// Defines values for OutputSecurityLakeAwsAuthenticationMethod.
const (
	OutputSecurityLakeAwsAuthenticationMethodAuto   OutputSecurityLakeAwsAuthenticationMethod = "auto"
	OutputSecurityLakeAwsAuthenticationMethodManual OutputSecurityLakeAwsAuthenticationMethod = "manual"
	OutputSecurityLakeAwsAuthenticationMethodSecret OutputSecurityLakeAwsAuthenticationMethod = "secret"
)

// Defines values for OutputSecurityLakeDeadletterEnabled.
const (
	OutputSecurityLakeDeadletterEnabledFalse OutputSecurityLakeDeadletterEnabled = false
	OutputSecurityLakeDeadletterEnabledTrue  OutputSecurityLakeDeadletterEnabled = true
)

// Defines values for OutputSecurityLakeObjectACL.
const (
	AuthenticatedRead      OutputSecurityLakeObjectACL = "authenticated-read"
	AwsExecRead            OutputSecurityLakeObjectACL = "aws-exec-read"
	BucketOwnerFullControl OutputSecurityLakeObjectACL = "bucket-owner-full-control"
	BucketOwnerRead        OutputSecurityLakeObjectACL = "bucket-owner-read"
	Private                OutputSecurityLakeObjectACL = "private"
	PublicRead             OutputSecurityLakeObjectACL = "public-read"
	PublicReadWrite        OutputSecurityLakeObjectACL = "public-read-write"
)

// Defines values for OutputSecurityLakeOnBackpressure.
const (
	OutputSecurityLakeOnBackpressureBlock OutputSecurityLakeOnBackpressure = "block"
	OutputSecurityLakeOnBackpressureDrop  OutputSecurityLakeOnBackpressure = "drop"
)

// Defines values for OutputSecurityLakeOnDiskFullBackpressure.
const (
	OutputSecurityLakeOnDiskFullBackpressureBlock OutputSecurityLakeOnDiskFullBackpressure = "block"
	OutputSecurityLakeOnDiskFullBackpressureDrop  OutputSecurityLakeOnDiskFullBackpressure = "drop"
)

// Defines values for OutputSecurityLakeParquetDataPageVersion.
const (
	DATAPAGEV1 OutputSecurityLakeParquetDataPageVersion = "DATA_PAGE_V1"
	DATAPAGEV2 OutputSecurityLakeParquetDataPageVersion = "DATA_PAGE_V2"
)

// Defines values for OutputSecurityLakeParquetVersion.
const (
	PARQUET10 OutputSecurityLakeParquetVersion = "PARQUET_1_0"
	PARQUET24 OutputSecurityLakeParquetVersion = "PARQUET_2_4"
	PARQUET26 OutputSecurityLakeParquetVersion = "PARQUET_2_6"
)

// Defines values for OutputSecurityLakeRemoveEmptyDirs.
const (
	OutputSecurityLakeRemoveEmptyDirsFalse OutputSecurityLakeRemoveEmptyDirs = false
	OutputSecurityLakeRemoveEmptyDirsTrue  OutputSecurityLakeRemoveEmptyDirs = true
)

// Defines values for OutputSecurityLakeServerSideEncryption.
const (
	AES256 OutputSecurityLakeServerSideEncryption = "AES256"
	AwsKms OutputSecurityLakeServerSideEncryption = "aws:kms"
)

// Defines values for OutputSecurityLakeSignatureVersion.
const (
	OutputSecurityLakeSignatureVersionV2 OutputSecurityLakeSignatureVersion = "v2"
	OutputSecurityLakeSignatureVersionV4 OutputSecurityLakeSignatureVersion = "v4"
)

// Defines values for OutputSecurityLakeStorageClass.
const (
	DEEPARCHIVE        OutputSecurityLakeStorageClass = "DEEP_ARCHIVE"
	GLACIER            OutputSecurityLakeStorageClass = "GLACIER"
	GLACIERIR          OutputSecurityLakeStorageClass = "GLACIER_IR"
	INTELLIGENTTIERING OutputSecurityLakeStorageClass = "INTELLIGENT_TIERING"
	ONEZONEIA          OutputSecurityLakeStorageClass = "ONEZONE_IA"
	REDUCEDREDUNDANCY  OutputSecurityLakeStorageClass = "REDUCED_REDUNDANCY"
	STANDARD           OutputSecurityLakeStorageClass = "STANDARD"
	STANDARDIA         OutputSecurityLakeStorageClass = "STANDARD_IA"
)

// Defines values for OutputSecurityLakeType.
const (
	OutputSecurityLakeTypeSecurityLake OutputSecurityLakeType = "security_lake"
)

// Defines values for OutputSentinelEndpointURLConfiguration.
const (
	ID  OutputSentinelEndpointURLConfiguration = "ID"
	Url OutputSentinelEndpointURLConfiguration = "url"
)

// Defines values for OutputSentinelFailedRequestLoggingMode.
const (
	OutputSentinelFailedRequestLoggingModeNone              OutputSentinelFailedRequestLoggingMode = "none"
	OutputSentinelFailedRequestLoggingModePayload           OutputSentinelFailedRequestLoggingMode = "payload"
	OutputSentinelFailedRequestLoggingModePayloadAndHeaders OutputSentinelFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputSentinelOnBackpressure.
const (
	OutputSentinelOnBackpressureBlock OutputSentinelOnBackpressure = "block"
	OutputSentinelOnBackpressureDrop  OutputSentinelOnBackpressure = "drop"
	OutputSentinelOnBackpressureQueue OutputSentinelOnBackpressure = "queue"
)

// Defines values for OutputSentinelPqCompress.
const (
	OutputSentinelPqCompressGzip OutputSentinelPqCompress = "gzip"
	OutputSentinelPqCompressNone OutputSentinelPqCompress = "none"
)

// Defines values for OutputSentinelPqMode.
const (
	OutputSentinelPqModeAlways       OutputSentinelPqMode = "always"
	OutputSentinelPqModeBackpressure OutputSentinelPqMode = "backpressure"
	OutputSentinelPqModeError        OutputSentinelPqMode = "error"
)

// Defines values for OutputSentinelPqOnBackpressure.
const (
	OutputSentinelPqOnBackpressureBlock OutputSentinelPqOnBackpressure = "block"
	OutputSentinelPqOnBackpressureDrop  OutputSentinelPqOnBackpressure = "drop"
)

// Defines values for OutputSentinelTimeoutRetrySettingsTimeoutRetry.
const (
	OutputSentinelTimeoutRetrySettingsTimeoutRetryFalse OutputSentinelTimeoutRetrySettingsTimeoutRetry = false
	OutputSentinelTimeoutRetrySettingsTimeoutRetryTrue  OutputSentinelTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputSentinelType.
const (
	OutputSentinelTypeSentinel OutputSentinelType = "sentinel"
)

// Defines values for OutputServiceNowCompress.
const (
	OutputServiceNowCompressDeflate OutputServiceNowCompress = "deflate"
	OutputServiceNowCompressGzip    OutputServiceNowCompress = "gzip"
	OutputServiceNowCompressNone    OutputServiceNowCompress = "none"
)

// Defines values for OutputServiceNowFailedRequestLoggingMode.
const (
	OutputServiceNowFailedRequestLoggingModeNone              OutputServiceNowFailedRequestLoggingMode = "none"
	OutputServiceNowFailedRequestLoggingModePayload           OutputServiceNowFailedRequestLoggingMode = "payload"
	OutputServiceNowFailedRequestLoggingModePayloadAndHeaders OutputServiceNowFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputServiceNowHttpCompress.
const (
	OutputServiceNowHttpCompressGzip OutputServiceNowHttpCompress = "gzip"
	OutputServiceNowHttpCompressNone OutputServiceNowHttpCompress = "none"
)

// Defines values for OutputServiceNowOnBackpressure.
const (
	OutputServiceNowOnBackpressureBlock OutputServiceNowOnBackpressure = "block"
	OutputServiceNowOnBackpressureDrop  OutputServiceNowOnBackpressure = "drop"
	OutputServiceNowOnBackpressureQueue OutputServiceNowOnBackpressure = "queue"
)

// Defines values for OutputServiceNowOtlpVersion.
const (
	OutputServiceNowOtlpVersionN131 OutputServiceNowOtlpVersion = "1.3.1"
)

// Defines values for OutputServiceNowPqCompress.
const (
	OutputServiceNowPqCompressGzip OutputServiceNowPqCompress = "gzip"
	OutputServiceNowPqCompressNone OutputServiceNowPqCompress = "none"
)

// Defines values for OutputServiceNowPqMode.
const (
	OutputServiceNowPqModeAlways       OutputServiceNowPqMode = "always"
	OutputServiceNowPqModeBackpressure OutputServiceNowPqMode = "backpressure"
	OutputServiceNowPqModeError        OutputServiceNowPqMode = "error"
)

// Defines values for OutputServiceNowPqOnBackpressure.
const (
	OutputServiceNowPqOnBackpressureBlock OutputServiceNowPqOnBackpressure = "block"
	OutputServiceNowPqOnBackpressureDrop  OutputServiceNowPqOnBackpressure = "drop"
)

// Defines values for OutputServiceNowProtocol.
const (
	OutputServiceNowProtocolGrpc OutputServiceNowProtocol = "grpc"
	OutputServiceNowProtocolHttp OutputServiceNowProtocol = "http"
)

// Defines values for OutputServiceNowTimeoutRetrySettingsTimeoutRetry.
const (
	OutputServiceNowTimeoutRetrySettingsTimeoutRetryFalse OutputServiceNowTimeoutRetrySettingsTimeoutRetry = false
	OutputServiceNowTimeoutRetrySettingsTimeoutRetryTrue  OutputServiceNowTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputServiceNowTlsDisabled.
const (
	OutputServiceNowTlsDisabledFalse OutputServiceNowTlsDisabled = false
	OutputServiceNowTlsDisabledTrue  OutputServiceNowTlsDisabled = true
)

// Defines values for OutputServiceNowTlsMaxVersion.
const (
	OutputServiceNowTlsMaxVersionTLSv1  OutputServiceNowTlsMaxVersion = "TLSv1"
	OutputServiceNowTlsMaxVersionTLSv11 OutputServiceNowTlsMaxVersion = "TLSv1.1"
	OutputServiceNowTlsMaxVersionTLSv12 OutputServiceNowTlsMaxVersion = "TLSv1.2"
	OutputServiceNowTlsMaxVersionTLSv13 OutputServiceNowTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputServiceNowTlsMinVersion.
const (
	OutputServiceNowTlsMinVersionTLSv1  OutputServiceNowTlsMinVersion = "TLSv1"
	OutputServiceNowTlsMinVersionTLSv11 OutputServiceNowTlsMinVersion = "TLSv1.1"
	OutputServiceNowTlsMinVersionTLSv12 OutputServiceNowTlsMinVersion = "TLSv1.2"
	OutputServiceNowTlsMinVersionTLSv13 OutputServiceNowTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputServiceNowType.
const (
	ServiceNow OutputServiceNowType = "service_now"
)

// Defines values for OutputSignalfxAuthType.
const (
	OutputSignalfxAuthTypeManual OutputSignalfxAuthType = "manual"
	OutputSignalfxAuthTypeSecret OutputSignalfxAuthType = "secret"
)

// Defines values for OutputSignalfxFailedRequestLoggingMode.
const (
	OutputSignalfxFailedRequestLoggingModeNone              OutputSignalfxFailedRequestLoggingMode = "none"
	OutputSignalfxFailedRequestLoggingModePayload           OutputSignalfxFailedRequestLoggingMode = "payload"
	OutputSignalfxFailedRequestLoggingModePayloadAndHeaders OutputSignalfxFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputSignalfxOnBackpressure.
const (
	OutputSignalfxOnBackpressureBlock OutputSignalfxOnBackpressure = "block"
	OutputSignalfxOnBackpressureDrop  OutputSignalfxOnBackpressure = "drop"
	OutputSignalfxOnBackpressureQueue OutputSignalfxOnBackpressure = "queue"
)

// Defines values for OutputSignalfxPqCompress.
const (
	OutputSignalfxPqCompressGzip OutputSignalfxPqCompress = "gzip"
	OutputSignalfxPqCompressNone OutputSignalfxPqCompress = "none"
)

// Defines values for OutputSignalfxPqMode.
const (
	OutputSignalfxPqModeAlways       OutputSignalfxPqMode = "always"
	OutputSignalfxPqModeBackpressure OutputSignalfxPqMode = "backpressure"
	OutputSignalfxPqModeError        OutputSignalfxPqMode = "error"
)

// Defines values for OutputSignalfxPqOnBackpressure.
const (
	OutputSignalfxPqOnBackpressureBlock OutputSignalfxPqOnBackpressure = "block"
	OutputSignalfxPqOnBackpressureDrop  OutputSignalfxPqOnBackpressure = "drop"
)

// Defines values for OutputSignalfxTimeoutRetrySettingsTimeoutRetry.
const (
	OutputSignalfxTimeoutRetrySettingsTimeoutRetryFalse OutputSignalfxTimeoutRetrySettingsTimeoutRetry = false
	OutputSignalfxTimeoutRetrySettingsTimeoutRetryTrue  OutputSignalfxTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputSignalfxType.
const (
	Signalfx OutputSignalfxType = "signalfx"
)

// Defines values for OutputSnmpType.
const (
	OutputSnmpTypeSnmp OutputSnmpType = "snmp"
)

// Defines values for OutputSnsAwsAuthenticationMethod.
const (
	OutputSnsAwsAuthenticationMethodAuto   OutputSnsAwsAuthenticationMethod = "auto"
	OutputSnsAwsAuthenticationMethodManual OutputSnsAwsAuthenticationMethod = "manual"
	OutputSnsAwsAuthenticationMethodSecret OutputSnsAwsAuthenticationMethod = "secret"
)

// Defines values for OutputSnsOnBackpressure.
const (
	OutputSnsOnBackpressureBlock OutputSnsOnBackpressure = "block"
	OutputSnsOnBackpressureDrop  OutputSnsOnBackpressure = "drop"
	OutputSnsOnBackpressureQueue OutputSnsOnBackpressure = "queue"
)

// Defines values for OutputSnsPqCompress.
const (
	OutputSnsPqCompressGzip OutputSnsPqCompress = "gzip"
	OutputSnsPqCompressNone OutputSnsPqCompress = "none"
)

// Defines values for OutputSnsPqMode.
const (
	OutputSnsPqModeAlways       OutputSnsPqMode = "always"
	OutputSnsPqModeBackpressure OutputSnsPqMode = "backpressure"
	OutputSnsPqModeError        OutputSnsPqMode = "error"
)

// Defines values for OutputSnsPqOnBackpressure.
const (
	OutputSnsPqOnBackpressureBlock OutputSnsPqOnBackpressure = "block"
	OutputSnsPqOnBackpressureDrop  OutputSnsPqOnBackpressure = "drop"
)

// Defines values for OutputSnsSignatureVersion.
const (
	OutputSnsSignatureVersionV2 OutputSnsSignatureVersion = "v2"
	OutputSnsSignatureVersionV4 OutputSnsSignatureVersion = "v4"
)

// Defines values for OutputSnsType.
const (
	Sns OutputSnsType = "sns"
)

// Defines values for OutputSplunkAuthType.
const (
	OutputSplunkAuthTypeManual OutputSplunkAuthType = "manual"
	OutputSplunkAuthTypeSecret OutputSplunkAuthType = "secret"
)

// Defines values for OutputSplunkEnableACK.
const (
	OutputSplunkEnableACKFalse OutputSplunkEnableACK = false
	OutputSplunkEnableACKTrue  OutputSplunkEnableACK = true
)

// Defines values for OutputSplunkMaxS2Sversion.
const (
	OutputSplunkMaxS2SversionV3 OutputSplunkMaxS2Sversion = "v3"
	OutputSplunkMaxS2SversionV4 OutputSplunkMaxS2Sversion = "v4"
)

// Defines values for OutputSplunkNestedFields.
const (
	OutputSplunkNestedFieldsJson OutputSplunkNestedFields = "json"
	OutputSplunkNestedFieldsNone OutputSplunkNestedFields = "none"
)

// Defines values for OutputSplunkOnBackpressure.
const (
	OutputSplunkOnBackpressureBlock OutputSplunkOnBackpressure = "block"
	OutputSplunkOnBackpressureDrop  OutputSplunkOnBackpressure = "drop"
	OutputSplunkOnBackpressureQueue OutputSplunkOnBackpressure = "queue"
)

// Defines values for OutputSplunkPqCompress.
const (
	OutputSplunkPqCompressGzip OutputSplunkPqCompress = "gzip"
	OutputSplunkPqCompressNone OutputSplunkPqCompress = "none"
)

// Defines values for OutputSplunkPqMode.
const (
	OutputSplunkPqModeAlways       OutputSplunkPqMode = "always"
	OutputSplunkPqModeBackpressure OutputSplunkPqMode = "backpressure"
	OutputSplunkPqModeError        OutputSplunkPqMode = "error"
)

// Defines values for OutputSplunkPqOnBackpressure.
const (
	OutputSplunkPqOnBackpressureBlock OutputSplunkPqOnBackpressure = "block"
	OutputSplunkPqOnBackpressureDrop  OutputSplunkPqOnBackpressure = "drop"
)

// Defines values for OutputSplunkTlsDisabled.
const (
	OutputSplunkTlsDisabledFalse OutputSplunkTlsDisabled = false
	OutputSplunkTlsDisabledTrue  OutputSplunkTlsDisabled = true
)

// Defines values for OutputSplunkTlsMaxVersion.
const (
	OutputSplunkTlsMaxVersionTLSv1  OutputSplunkTlsMaxVersion = "TLSv1"
	OutputSplunkTlsMaxVersionTLSv11 OutputSplunkTlsMaxVersion = "TLSv1.1"
	OutputSplunkTlsMaxVersionTLSv12 OutputSplunkTlsMaxVersion = "TLSv1.2"
	OutputSplunkTlsMaxVersionTLSv13 OutputSplunkTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputSplunkTlsMinVersion.
const (
	OutputSplunkTlsMinVersionTLSv1  OutputSplunkTlsMinVersion = "TLSv1"
	OutputSplunkTlsMinVersionTLSv11 OutputSplunkTlsMinVersion = "TLSv1.1"
	OutputSplunkTlsMinVersionTLSv12 OutputSplunkTlsMinVersion = "TLSv1.2"
	OutputSplunkTlsMinVersionTLSv13 OutputSplunkTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputSplunkType.
const (
	OutputSplunkTypeSplunk OutputSplunkType = "splunk"
)

// Defines values for OutputSplunkHecAuthType.
const (
	OutputSplunkHecAuthTypeManual OutputSplunkHecAuthType = "manual"
	OutputSplunkHecAuthTypeSecret OutputSplunkHecAuthType = "secret"
)

// Defines values for OutputSplunkHecFailedRequestLoggingMode.
const (
	OutputSplunkHecFailedRequestLoggingModeNone              OutputSplunkHecFailedRequestLoggingMode = "none"
	OutputSplunkHecFailedRequestLoggingModePayload           OutputSplunkHecFailedRequestLoggingMode = "payload"
	OutputSplunkHecFailedRequestLoggingModePayloadAndHeaders OutputSplunkHecFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputSplunkHecLoadBalanced.
const (
	OutputSplunkHecLoadBalancedFalse OutputSplunkHecLoadBalanced = false
	OutputSplunkHecLoadBalancedTrue  OutputSplunkHecLoadBalanced = true
)

// Defines values for OutputSplunkHecOnBackpressure.
const (
	OutputSplunkHecOnBackpressureBlock OutputSplunkHecOnBackpressure = "block"
	OutputSplunkHecOnBackpressureDrop  OutputSplunkHecOnBackpressure = "drop"
	OutputSplunkHecOnBackpressureQueue OutputSplunkHecOnBackpressure = "queue"
)

// Defines values for OutputSplunkHecPqCompress.
const (
	OutputSplunkHecPqCompressGzip OutputSplunkHecPqCompress = "gzip"
	OutputSplunkHecPqCompressNone OutputSplunkHecPqCompress = "none"
)

// Defines values for OutputSplunkHecPqMode.
const (
	OutputSplunkHecPqModeAlways       OutputSplunkHecPqMode = "always"
	OutputSplunkHecPqModeBackpressure OutputSplunkHecPqMode = "backpressure"
	OutputSplunkHecPqModeError        OutputSplunkHecPqMode = "error"
)

// Defines values for OutputSplunkHecPqOnBackpressure.
const (
	OutputSplunkHecPqOnBackpressureBlock OutputSplunkHecPqOnBackpressure = "block"
	OutputSplunkHecPqOnBackpressureDrop  OutputSplunkHecPqOnBackpressure = "drop"
)

// Defines values for OutputSplunkHecTimeoutRetrySettingsTimeoutRetry.
const (
	OutputSplunkHecTimeoutRetrySettingsTimeoutRetryFalse OutputSplunkHecTimeoutRetrySettingsTimeoutRetry = false
	OutputSplunkHecTimeoutRetrySettingsTimeoutRetryTrue  OutputSplunkHecTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputSplunkHecType.
const (
	OutputSplunkHecTypeSplunkHec OutputSplunkHecType = "splunk_hec"
)

// Defines values for OutputSplunkLbAuthType.
const (
	OutputSplunkLbAuthTypeManual OutputSplunkLbAuthType = "manual"
	OutputSplunkLbAuthTypeSecret OutputSplunkLbAuthType = "secret"
)

// Defines values for OutputSplunkLbEnableACK.
const (
	OutputSplunkLbEnableACKFalse OutputSplunkLbEnableACK = false
	OutputSplunkLbEnableACKTrue  OutputSplunkLbEnableACK = true
)

// Defines values for OutputSplunkLbHostsTls.
const (
	OutputSplunkLbHostsTlsInherit OutputSplunkLbHostsTls = "inherit"
	OutputSplunkLbHostsTlsOff     OutputSplunkLbHostsTls = "off"
)

// Defines values for OutputSplunkLbIndexerDiscovery.
const (
	OutputSplunkLbIndexerDiscoveryFalse OutputSplunkLbIndexerDiscovery = false
	OutputSplunkLbIndexerDiscoveryTrue  OutputSplunkLbIndexerDiscovery = true
)

// Defines values for OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType.
const (
	OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthTypeManual OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType = "manual"
	OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthTypeSecret OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType = "secret"
)

// Defines values for OutputSplunkLbIndexerDiscoveryConfigsAuthType.
const (
	OutputSplunkLbIndexerDiscoveryConfigsAuthTypeManual OutputSplunkLbIndexerDiscoveryConfigsAuthType = "manual"
	OutputSplunkLbIndexerDiscoveryConfigsAuthTypeSecret OutputSplunkLbIndexerDiscoveryConfigsAuthType = "secret"
)

// Defines values for OutputSplunkLbMaxS2Sversion.
const (
	OutputSplunkLbMaxS2SversionV3 OutputSplunkLbMaxS2Sversion = "v3"
	OutputSplunkLbMaxS2SversionV4 OutputSplunkLbMaxS2Sversion = "v4"
)

// Defines values for OutputSplunkLbNestedFields.
const (
	OutputSplunkLbNestedFieldsJson OutputSplunkLbNestedFields = "json"
	OutputSplunkLbNestedFieldsNone OutputSplunkLbNestedFields = "none"
)

// Defines values for OutputSplunkLbOnBackpressure.
const (
	OutputSplunkLbOnBackpressureBlock OutputSplunkLbOnBackpressure = "block"
	OutputSplunkLbOnBackpressureDrop  OutputSplunkLbOnBackpressure = "drop"
	OutputSplunkLbOnBackpressureQueue OutputSplunkLbOnBackpressure = "queue"
)

// Defines values for OutputSplunkLbPqCompress.
const (
	OutputSplunkLbPqCompressGzip OutputSplunkLbPqCompress = "gzip"
	OutputSplunkLbPqCompressNone OutputSplunkLbPqCompress = "none"
)

// Defines values for OutputSplunkLbPqMode.
const (
	OutputSplunkLbPqModeAlways       OutputSplunkLbPqMode = "always"
	OutputSplunkLbPqModeBackpressure OutputSplunkLbPqMode = "backpressure"
	OutputSplunkLbPqModeError        OutputSplunkLbPqMode = "error"
)

// Defines values for OutputSplunkLbPqOnBackpressure.
const (
	OutputSplunkLbPqOnBackpressureBlock OutputSplunkLbPqOnBackpressure = "block"
	OutputSplunkLbPqOnBackpressureDrop  OutputSplunkLbPqOnBackpressure = "drop"
)

// Defines values for OutputSplunkLbTlsDisabled.
const (
	OutputSplunkLbTlsDisabledFalse OutputSplunkLbTlsDisabled = false
	OutputSplunkLbTlsDisabledTrue  OutputSplunkLbTlsDisabled = true
)

// Defines values for OutputSplunkLbTlsMaxVersion.
const (
	OutputSplunkLbTlsMaxVersionTLSv1  OutputSplunkLbTlsMaxVersion = "TLSv1"
	OutputSplunkLbTlsMaxVersionTLSv11 OutputSplunkLbTlsMaxVersion = "TLSv1.1"
	OutputSplunkLbTlsMaxVersionTLSv12 OutputSplunkLbTlsMaxVersion = "TLSv1.2"
	OutputSplunkLbTlsMaxVersionTLSv13 OutputSplunkLbTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputSplunkLbTlsMinVersion.
const (
	OutputSplunkLbTlsMinVersionTLSv1  OutputSplunkLbTlsMinVersion = "TLSv1"
	OutputSplunkLbTlsMinVersionTLSv11 OutputSplunkLbTlsMinVersion = "TLSv1.1"
	OutputSplunkLbTlsMinVersionTLSv12 OutputSplunkLbTlsMinVersion = "TLSv1.2"
	OutputSplunkLbTlsMinVersionTLSv13 OutputSplunkLbTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputSplunkLbType.
const (
	SplunkLb OutputSplunkLbType = "splunk_lb"
)

// Defines values for OutputSqsAwsAuthenticationMethod.
const (
	OutputSqsAwsAuthenticationMethodAuto   OutputSqsAwsAuthenticationMethod = "auto"
	OutputSqsAwsAuthenticationMethodManual OutputSqsAwsAuthenticationMethod = "manual"
	OutputSqsAwsAuthenticationMethodSecret OutputSqsAwsAuthenticationMethod = "secret"
)

// Defines values for OutputSqsOnBackpressure.
const (
	OutputSqsOnBackpressureBlock OutputSqsOnBackpressure = "block"
	OutputSqsOnBackpressureDrop  OutputSqsOnBackpressure = "drop"
	OutputSqsOnBackpressureQueue OutputSqsOnBackpressure = "queue"
)

// Defines values for OutputSqsPqCompress.
const (
	OutputSqsPqCompressGzip OutputSqsPqCompress = "gzip"
	OutputSqsPqCompressNone OutputSqsPqCompress = "none"
)

// Defines values for OutputSqsPqMode.
const (
	OutputSqsPqModeAlways       OutputSqsPqMode = "always"
	OutputSqsPqModeBackpressure OutputSqsPqMode = "backpressure"
	OutputSqsPqModeError        OutputSqsPqMode = "error"
)

// Defines values for OutputSqsPqOnBackpressure.
const (
	OutputSqsPqOnBackpressureBlock OutputSqsPqOnBackpressure = "block"
	OutputSqsPqOnBackpressureDrop  OutputSqsPqOnBackpressure = "drop"
)

// Defines values for OutputSqsQueueType.
const (
	OutputSqsQueueTypeFifo     OutputSqsQueueType = "fifo"
	OutputSqsQueueTypeStandard OutputSqsQueueType = "standard"
)

// Defines values for OutputSqsSignatureVersion.
const (
	OutputSqsSignatureVersionV2 OutputSqsSignatureVersion = "v2"
	OutputSqsSignatureVersionV4 OutputSqsSignatureVersion = "v4"
)

// Defines values for OutputSqsType.
const (
	OutputSqsTypeSqs OutputSqsType = "sqs"
)

// Defines values for OutputStatsdOnBackpressure.
const (
	OutputStatsdOnBackpressureBlock OutputStatsdOnBackpressure = "block"
	OutputStatsdOnBackpressureDrop  OutputStatsdOnBackpressure = "drop"
	OutputStatsdOnBackpressureQueue OutputStatsdOnBackpressure = "queue"
)

// Defines values for OutputStatsdPqCompress.
const (
	OutputStatsdPqCompressGzip OutputStatsdPqCompress = "gzip"
	OutputStatsdPqCompressNone OutputStatsdPqCompress = "none"
)

// Defines values for OutputStatsdPqMode.
const (
	OutputStatsdPqModeAlways       OutputStatsdPqMode = "always"
	OutputStatsdPqModeBackpressure OutputStatsdPqMode = "backpressure"
	OutputStatsdPqModeError        OutputStatsdPqMode = "error"
)

// Defines values for OutputStatsdPqOnBackpressure.
const (
	OutputStatsdPqOnBackpressureBlock OutputStatsdPqOnBackpressure = "block"
	OutputStatsdPqOnBackpressureDrop  OutputStatsdPqOnBackpressure = "drop"
)

// Defines values for OutputStatsdProtocol.
const (
	OutputStatsdProtocolTcp OutputStatsdProtocol = "tcp"
	OutputStatsdProtocolUdp OutputStatsdProtocol = "udp"
)

// Defines values for OutputStatsdType.
const (
	Statsd OutputStatsdType = "statsd"
)

// Defines values for OutputStatsdExtOnBackpressure.
const (
	OutputStatsdExtOnBackpressureBlock OutputStatsdExtOnBackpressure = "block"
	OutputStatsdExtOnBackpressureDrop  OutputStatsdExtOnBackpressure = "drop"
	OutputStatsdExtOnBackpressureQueue OutputStatsdExtOnBackpressure = "queue"
)

// Defines values for OutputStatsdExtPqCompress.
const (
	OutputStatsdExtPqCompressGzip OutputStatsdExtPqCompress = "gzip"
	OutputStatsdExtPqCompressNone OutputStatsdExtPqCompress = "none"
)

// Defines values for OutputStatsdExtPqMode.
const (
	OutputStatsdExtPqModeAlways       OutputStatsdExtPqMode = "always"
	OutputStatsdExtPqModeBackpressure OutputStatsdExtPqMode = "backpressure"
	OutputStatsdExtPqModeError        OutputStatsdExtPqMode = "error"
)

// Defines values for OutputStatsdExtPqOnBackpressure.
const (
	OutputStatsdExtPqOnBackpressureBlock OutputStatsdExtPqOnBackpressure = "block"
	OutputStatsdExtPqOnBackpressureDrop  OutputStatsdExtPqOnBackpressure = "drop"
)

// Defines values for OutputStatsdExtProtocol.
const (
	OutputStatsdExtProtocolTcp OutputStatsdExtProtocol = "tcp"
	OutputStatsdExtProtocolUdp OutputStatsdExtProtocol = "udp"
)

// Defines values for OutputStatsdExtType.
const (
	StatsdExt OutputStatsdExtType = "statsd_ext"
)

// Defines values for OutputStatusStatusHealth.
const (
	OutputStatusStatusHealthGreen  OutputStatusStatusHealth = "Green"
	OutputStatusStatusHealthRed    OutputStatusStatusHealth = "Red"
	OutputStatusStatusHealthYellow OutputStatusStatusHealth = "Yellow"
)

// Defines values for OutputSumoLogicFailedRequestLoggingMode.
const (
	OutputSumoLogicFailedRequestLoggingModeNone              OutputSumoLogicFailedRequestLoggingMode = "none"
	OutputSumoLogicFailedRequestLoggingModePayload           OutputSumoLogicFailedRequestLoggingMode = "payload"
	OutputSumoLogicFailedRequestLoggingModePayloadAndHeaders OutputSumoLogicFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputSumoLogicFormat.
const (
	Json OutputSumoLogicFormat = "json"
	Raw  OutputSumoLogicFormat = "raw"
)

// Defines values for OutputSumoLogicOnBackpressure.
const (
	OutputSumoLogicOnBackpressureBlock OutputSumoLogicOnBackpressure = "block"
	OutputSumoLogicOnBackpressureDrop  OutputSumoLogicOnBackpressure = "drop"
	OutputSumoLogicOnBackpressureQueue OutputSumoLogicOnBackpressure = "queue"
)

// Defines values for OutputSumoLogicPqCompress.
const (
	OutputSumoLogicPqCompressGzip OutputSumoLogicPqCompress = "gzip"
	OutputSumoLogicPqCompressNone OutputSumoLogicPqCompress = "none"
)

// Defines values for OutputSumoLogicPqMode.
const (
	OutputSumoLogicPqModeAlways       OutputSumoLogicPqMode = "always"
	OutputSumoLogicPqModeBackpressure OutputSumoLogicPqMode = "backpressure"
	OutputSumoLogicPqModeError        OutputSumoLogicPqMode = "error"
)

// Defines values for OutputSumoLogicPqOnBackpressure.
const (
	OutputSumoLogicPqOnBackpressureBlock OutputSumoLogicPqOnBackpressure = "block"
	OutputSumoLogicPqOnBackpressureDrop  OutputSumoLogicPqOnBackpressure = "drop"
)

// Defines values for OutputSumoLogicTimeoutRetrySettingsTimeoutRetry.
const (
	OutputSumoLogicTimeoutRetrySettingsTimeoutRetryFalse OutputSumoLogicTimeoutRetrySettingsTimeoutRetry = false
	OutputSumoLogicTimeoutRetrySettingsTimeoutRetryTrue  OutputSumoLogicTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputSumoLogicType.
const (
	SumoLogic OutputSumoLogicType = "sumo_logic"
)

// Defines values for OutputSyslogFacility.
const (
	OutputSyslogFacilityN0  OutputSyslogFacility = 0
	OutputSyslogFacilityN1  OutputSyslogFacility = 1
	OutputSyslogFacilityN10 OutputSyslogFacility = 10
	OutputSyslogFacilityN11 OutputSyslogFacility = 11
	OutputSyslogFacilityN12 OutputSyslogFacility = 12
	OutputSyslogFacilityN13 OutputSyslogFacility = 13
	OutputSyslogFacilityN14 OutputSyslogFacility = 14
	OutputSyslogFacilityN15 OutputSyslogFacility = 15
	OutputSyslogFacilityN16 OutputSyslogFacility = 16
	OutputSyslogFacilityN17 OutputSyslogFacility = 17
	OutputSyslogFacilityN18 OutputSyslogFacility = 18
	OutputSyslogFacilityN19 OutputSyslogFacility = 19
	OutputSyslogFacilityN2  OutputSyslogFacility = 2
	OutputSyslogFacilityN20 OutputSyslogFacility = 20
	OutputSyslogFacilityN21 OutputSyslogFacility = 21
	OutputSyslogFacilityN3  OutputSyslogFacility = 3
	OutputSyslogFacilityN4  OutputSyslogFacility = 4
	OutputSyslogFacilityN5  OutputSyslogFacility = 5
	OutputSyslogFacilityN6  OutputSyslogFacility = 6
	OutputSyslogFacilityN7  OutputSyslogFacility = 7
	OutputSyslogFacilityN8  OutputSyslogFacility = 8
	OutputSyslogFacilityN9  OutputSyslogFacility = 9
)

// Defines values for OutputSyslogMessageFormat.
const (
	Rfc3164 OutputSyslogMessageFormat = "rfc3164"
	Rfc5424 OutputSyslogMessageFormat = "rfc5424"
)

// Defines values for OutputSyslogOnBackpressure.
const (
	OutputSyslogOnBackpressureBlock OutputSyslogOnBackpressure = "block"
	OutputSyslogOnBackpressureDrop  OutputSyslogOnBackpressure = "drop"
	OutputSyslogOnBackpressureQueue OutputSyslogOnBackpressure = "queue"
)

// Defines values for OutputSyslogPqCompress.
const (
	OutputSyslogPqCompressGzip OutputSyslogPqCompress = "gzip"
	OutputSyslogPqCompressNone OutputSyslogPqCompress = "none"
)

// Defines values for OutputSyslogPqMode.
const (
	OutputSyslogPqModeAlways       OutputSyslogPqMode = "always"
	OutputSyslogPqModeBackpressure OutputSyslogPqMode = "backpressure"
	OutputSyslogPqModeError        OutputSyslogPqMode = "error"
)

// Defines values for OutputSyslogPqOnBackpressure.
const (
	OutputSyslogPqOnBackpressureBlock OutputSyslogPqOnBackpressure = "block"
	OutputSyslogPqOnBackpressureDrop  OutputSyslogPqOnBackpressure = "drop"
)

// Defines values for OutputSyslogProtocol.
const (
	Tcp OutputSyslogProtocol = "tcp"
	Udp OutputSyslogProtocol = "udp"
)

// Defines values for OutputSyslogSeverity.
const (
	OutputSyslogSeverityN0 OutputSyslogSeverity = 0
	OutputSyslogSeverityN1 OutputSyslogSeverity = 1
	OutputSyslogSeverityN2 OutputSyslogSeverity = 2
	OutputSyslogSeverityN3 OutputSyslogSeverity = 3
	OutputSyslogSeverityN4 OutputSyslogSeverity = 4
	OutputSyslogSeverityN5 OutputSyslogSeverity = 5
	OutputSyslogSeverityN6 OutputSyslogSeverity = 6
	OutputSyslogSeverityN7 OutputSyslogSeverity = 7
)

// Defines values for OutputSyslogTimestampFormat.
const (
	OutputSyslogTimestampFormatIso8601 OutputSyslogTimestampFormat = "iso8601"
	OutputSyslogTimestampFormatSyslog  OutputSyslogTimestampFormat = "syslog"
)

// Defines values for OutputSyslogTlsDisabled.
const (
	OutputSyslogTlsDisabledFalse OutputSyslogTlsDisabled = false
	OutputSyslogTlsDisabledTrue  OutputSyslogTlsDisabled = true
)

// Defines values for OutputSyslogTlsMaxVersion.
const (
	OutputSyslogTlsMaxVersionTLSv1  OutputSyslogTlsMaxVersion = "TLSv1"
	OutputSyslogTlsMaxVersionTLSv11 OutputSyslogTlsMaxVersion = "TLSv1.1"
	OutputSyslogTlsMaxVersionTLSv12 OutputSyslogTlsMaxVersion = "TLSv1.2"
	OutputSyslogTlsMaxVersionTLSv13 OutputSyslogTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputSyslogTlsMinVersion.
const (
	OutputSyslogTlsMinVersionTLSv1  OutputSyslogTlsMinVersion = "TLSv1"
	OutputSyslogTlsMinVersionTLSv11 OutputSyslogTlsMinVersion = "TLSv1.1"
	OutputSyslogTlsMinVersionTLSv12 OutputSyslogTlsMinVersion = "TLSv1.2"
	OutputSyslogTlsMinVersionTLSv13 OutputSyslogTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputSyslogType.
const (
	Syslog OutputSyslogType = "syslog"
)

// Defines values for OutputTcpjsonAuthType.
const (
	OutputTcpjsonAuthTypeManual OutputTcpjsonAuthType = "manual"
	OutputTcpjsonAuthTypeSecret OutputTcpjsonAuthType = "secret"
)

// Defines values for OutputTcpjsonCompression.
const (
	OutputTcpjsonCompressionGzip OutputTcpjsonCompression = "gzip"
	OutputTcpjsonCompressionNone OutputTcpjsonCompression = "none"
)

// Defines values for OutputTcpjsonHostsTls.
const (
	Inherit OutputTcpjsonHostsTls = "inherit"
	Off     OutputTcpjsonHostsTls = "off"
)

// Defines values for OutputTcpjsonLoadBalanced.
const (
	OutputTcpjsonLoadBalancedFalse OutputTcpjsonLoadBalanced = false
	OutputTcpjsonLoadBalancedTrue  OutputTcpjsonLoadBalanced = true
)

// Defines values for OutputTcpjsonOnBackpressure.
const (
	OutputTcpjsonOnBackpressureBlock OutputTcpjsonOnBackpressure = "block"
	OutputTcpjsonOnBackpressureDrop  OutputTcpjsonOnBackpressure = "drop"
	OutputTcpjsonOnBackpressureQueue OutputTcpjsonOnBackpressure = "queue"
)

// Defines values for OutputTcpjsonPqCompress.
const (
	OutputTcpjsonPqCompressGzip OutputTcpjsonPqCompress = "gzip"
	OutputTcpjsonPqCompressNone OutputTcpjsonPqCompress = "none"
)

// Defines values for OutputTcpjsonPqMode.
const (
	OutputTcpjsonPqModeAlways       OutputTcpjsonPqMode = "always"
	OutputTcpjsonPqModeBackpressure OutputTcpjsonPqMode = "backpressure"
	OutputTcpjsonPqModeError        OutputTcpjsonPqMode = "error"
)

// Defines values for OutputTcpjsonPqOnBackpressure.
const (
	OutputTcpjsonPqOnBackpressureBlock OutputTcpjsonPqOnBackpressure = "block"
	OutputTcpjsonPqOnBackpressureDrop  OutputTcpjsonPqOnBackpressure = "drop"
)

// Defines values for OutputTcpjsonTlsDisabled.
const (
	OutputTcpjsonTlsDisabledFalse OutputTcpjsonTlsDisabled = false
	OutputTcpjsonTlsDisabledTrue  OutputTcpjsonTlsDisabled = true
)

// Defines values for OutputTcpjsonTlsMaxVersion.
const (
	OutputTcpjsonTlsMaxVersionTLSv1  OutputTcpjsonTlsMaxVersion = "TLSv1"
	OutputTcpjsonTlsMaxVersionTLSv11 OutputTcpjsonTlsMaxVersion = "TLSv1.1"
	OutputTcpjsonTlsMaxVersionTLSv12 OutputTcpjsonTlsMaxVersion = "TLSv1.2"
	OutputTcpjsonTlsMaxVersionTLSv13 OutputTcpjsonTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputTcpjsonTlsMinVersion.
const (
	OutputTcpjsonTlsMinVersionTLSv1  OutputTcpjsonTlsMinVersion = "TLSv1"
	OutputTcpjsonTlsMinVersionTLSv11 OutputTcpjsonTlsMinVersion = "TLSv1.1"
	OutputTcpjsonTlsMinVersionTLSv12 OutputTcpjsonTlsMinVersion = "TLSv1.2"
	OutputTcpjsonTlsMinVersionTLSv13 OutputTcpjsonTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputTcpjsonType.
const (
	OutputTcpjsonTypeTcpjson OutputTcpjsonType = "tcpjson"
)

// Defines values for OutputWavefrontAuthType.
const (
	Manual OutputWavefrontAuthType = "manual"
	Secret OutputWavefrontAuthType = "secret"
)

// Defines values for OutputWavefrontFailedRequestLoggingMode.
const (
	OutputWavefrontFailedRequestLoggingModeNone              OutputWavefrontFailedRequestLoggingMode = "none"
	OutputWavefrontFailedRequestLoggingModePayload           OutputWavefrontFailedRequestLoggingMode = "payload"
	OutputWavefrontFailedRequestLoggingModePayloadAndHeaders OutputWavefrontFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputWavefrontOnBackpressure.
const (
	OutputWavefrontOnBackpressureBlock OutputWavefrontOnBackpressure = "block"
	OutputWavefrontOnBackpressureDrop  OutputWavefrontOnBackpressure = "drop"
	OutputWavefrontOnBackpressureQueue OutputWavefrontOnBackpressure = "queue"
)

// Defines values for OutputWavefrontPqCompress.
const (
	OutputWavefrontPqCompressGzip OutputWavefrontPqCompress = "gzip"
	OutputWavefrontPqCompressNone OutputWavefrontPqCompress = "none"
)

// Defines values for OutputWavefrontPqMode.
const (
	OutputWavefrontPqModeAlways       OutputWavefrontPqMode = "always"
	OutputWavefrontPqModeBackpressure OutputWavefrontPqMode = "backpressure"
	OutputWavefrontPqModeError        OutputWavefrontPqMode = "error"
)

// Defines values for OutputWavefrontPqOnBackpressure.
const (
	OutputWavefrontPqOnBackpressureBlock OutputWavefrontPqOnBackpressure = "block"
	OutputWavefrontPqOnBackpressureDrop  OutputWavefrontPqOnBackpressure = "drop"
)

// Defines values for OutputWavefrontTimeoutRetrySettingsTimeoutRetry.
const (
	OutputWavefrontTimeoutRetrySettingsTimeoutRetryFalse OutputWavefrontTimeoutRetrySettingsTimeoutRetry = false
	OutputWavefrontTimeoutRetrySettingsTimeoutRetryTrue  OutputWavefrontTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputWavefrontType.
const (
	Wavefront OutputWavefrontType = "wavefront"
)

// Defines values for OutputWebhookAuthType.
const (
	OutputWebhookAuthTypeBasic             OutputWebhookAuthType = "basic"
	OutputWebhookAuthTypeCredentialsSecret OutputWebhookAuthType = "credentialsSecret"
	OutputWebhookAuthTypeNone              OutputWebhookAuthType = "none"
	OutputWebhookAuthTypeOauth             OutputWebhookAuthType = "oauth"
	OutputWebhookAuthTypeTextSecret        OutputWebhookAuthType = "textSecret"
	OutputWebhookAuthTypeToken             OutputWebhookAuthType = "token"
)

// Defines values for OutputWebhookFailedRequestLoggingMode.
const (
	OutputWebhookFailedRequestLoggingModeNone              OutputWebhookFailedRequestLoggingMode = "none"
	OutputWebhookFailedRequestLoggingModePayload           OutputWebhookFailedRequestLoggingMode = "payload"
	OutputWebhookFailedRequestLoggingModePayloadAndHeaders OutputWebhookFailedRequestLoggingMode = "payloadAndHeaders"
)

// Defines values for OutputWebhookFormat.
const (
	OutputWebhookFormatAdvanced  OutputWebhookFormat = "advanced"
	OutputWebhookFormatCustom    OutputWebhookFormat = "custom"
	OutputWebhookFormatJsonArray OutputWebhookFormat = "json_array"
	OutputWebhookFormatNdjson    OutputWebhookFormat = "ndjson"
)

// Defines values for OutputWebhookLoadBalanced.
const (
	OutputWebhookLoadBalancedFalse OutputWebhookLoadBalanced = false
	OutputWebhookLoadBalancedTrue  OutputWebhookLoadBalanced = true
)

// Defines values for OutputWebhookMethod.
const (
	OutputWebhookMethodPATCH OutputWebhookMethod = "PATCH"
	OutputWebhookMethodPOST  OutputWebhookMethod = "POST"
	OutputWebhookMethodPUT   OutputWebhookMethod = "PUT"
)

// Defines values for OutputWebhookOnBackpressure.
const (
	OutputWebhookOnBackpressureBlock OutputWebhookOnBackpressure = "block"
	OutputWebhookOnBackpressureDrop  OutputWebhookOnBackpressure = "drop"
	OutputWebhookOnBackpressureQueue OutputWebhookOnBackpressure = "queue"
)

// Defines values for OutputWebhookPqCompress.
const (
	Gzip OutputWebhookPqCompress = "gzip"
	None OutputWebhookPqCompress = "none"
)

// Defines values for OutputWebhookPqMode.
const (
	OutputWebhookPqModeAlways       OutputWebhookPqMode = "always"
	OutputWebhookPqModeBackpressure OutputWebhookPqMode = "backpressure"
	OutputWebhookPqModeError        OutputWebhookPqMode = "error"
)

// Defines values for OutputWebhookPqOnBackpressure.
const (
	Block OutputWebhookPqOnBackpressure = "block"
	Drop  OutputWebhookPqOnBackpressure = "drop"
)

// Defines values for OutputWebhookTimeoutRetrySettingsTimeoutRetry.
const (
	OutputWebhookTimeoutRetrySettingsTimeoutRetryFalse OutputWebhookTimeoutRetrySettingsTimeoutRetry = false
	OutputWebhookTimeoutRetrySettingsTimeoutRetryTrue  OutputWebhookTimeoutRetrySettingsTimeoutRetry = true
)

// Defines values for OutputWebhookTlsDisabled.
const (
	OutputWebhookTlsDisabledFalse OutputWebhookTlsDisabled = false
	OutputWebhookTlsDisabledTrue  OutputWebhookTlsDisabled = true
)

// Defines values for OutputWebhookTlsMaxVersion.
const (
	OutputWebhookTlsMaxVersionTLSv1  OutputWebhookTlsMaxVersion = "TLSv1"
	OutputWebhookTlsMaxVersionTLSv11 OutputWebhookTlsMaxVersion = "TLSv1.1"
	OutputWebhookTlsMaxVersionTLSv12 OutputWebhookTlsMaxVersion = "TLSv1.2"
	OutputWebhookTlsMaxVersionTLSv13 OutputWebhookTlsMaxVersion = "TLSv1.3"
)

// Defines values for OutputWebhookTlsMinVersion.
const (
	OutputWebhookTlsMinVersionTLSv1  OutputWebhookTlsMinVersion = "TLSv1"
	OutputWebhookTlsMinVersionTLSv11 OutputWebhookTlsMinVersion = "TLSv1.1"
	OutputWebhookTlsMinVersionTLSv12 OutputWebhookTlsMinVersion = "TLSv1.2"
	OutputWebhookTlsMinVersionTLSv13 OutputWebhookTlsMinVersion = "TLSv1.3"
)

// Defines values for OutputWebhookType.
const (
	DynatraceHttp OutputWebhookType = "dynatrace_http"
	Sentinel      OutputWebhookType = "sentinel"
	Webhook       OutputWebhookType = "webhook"
)

// Defines values for ParserLibEntryType.
const (
	ParserLibEntryTypeClf   ParserLibEntryType = "clf"
	ParserLibEntryTypeCsv   ParserLibEntryType = "csv"
	ParserLibEntryTypeDelim ParserLibEntryType = "delim"
	ParserLibEntryTypeElff  ParserLibEntryType = "elff"
	ParserLibEntryTypeGrok  ParserLibEntryType = "grok"
	ParserLibEntryTypeJson  ParserLibEntryType = "json"
	ParserLibEntryTypeKvp   ParserLibEntryType = "kvp"
	ParserLibEntryTypeRegex ParserLibEntryType = "regex"
)

// Defines values for ParserMode.
const (
	Extract     ParserMode = "extract"
	Reserialize ParserMode = "reserialize"
)

// Defines values for PreviewDataParamsMode.
const (
	Pipe         PreviewDataParamsMode = "pipe"
	Route        PreviewDataParamsMode = "route"
	RouteAndSend PreviewDataParamsMode = "routeAndSend"
)

// Defines values for ProtobufBytesConversion.
const (
	ProtobufBytesConversionArray  ProtobufBytesConversion = "array"
	ProtobufBytesConversionBuffer ProtobufBytesConversion = "buffer"
	ProtobufBytesConversionString ProtobufBytesConversion = "string"
)

// Defines values for ProtobufEncodingConfigWrappingWrapperFieldType.
const (
	Array  ProtobufEncodingConfigWrappingWrapperFieldType = "array"
	Single ProtobufEncodingConfigWrappingWrapperFieldType = "single"
)

// Defines values for ProtobufEnumConversion.
const (
	ProtobufEnumConversionNumber ProtobufEnumConversion = "number"
	ProtobufEnumConversionString ProtobufEnumConversion = "string"
)

// Defines values for ProtobufLongConversion.
const (
	ProtobufLongConversionNumber ProtobufLongConversion = "number"
	ProtobufLongConversionObject ProtobufLongConversion = "object"
	ProtobufLongConversionString ProtobufLongConversion = "string"
)

// Defines values for RbacResource.
const (
	RbacResourceDashboards       RbacResource = "dashboards"
	RbacResourceDatasetProviders RbacResource = "dataset-providers"
	RbacResourceDatasets         RbacResource = "datasets"
	RbacResourceGroups           RbacResource = "groups"
	RbacResourceMacros           RbacResource = "macros"
	RbacResourceProjects         RbacResource = "projects"
)

// Defines values for RestartResponseStatus.
const (
	RestartResponseStatusError      RestartResponseStatus = "Error"
	RestartResponseStatusRestarting RestartResponseStatus = "Restarting"
)

// Defines values for RunnableJobCollectionInputPreprocessDisabled.
const (
	RunnableJobCollectionInputPreprocessDisabledFalse RunnableJobCollectionInputPreprocessDisabled = false
	RunnableJobCollectionInputPreprocessDisabledTrue  RunnableJobCollectionInputPreprocessDisabled = true
)

// Defines values for RunnableJobCollectionInputSendToRoutes.
const (
	RunnableJobCollectionInputSendToRoutesFalse RunnableJobCollectionInputSendToRoutes = false
	RunnableJobCollectionInputSendToRoutesTrue  RunnableJobCollectionInputSendToRoutes = true
)

// Defines values for RunnableJobCollectionInputType.
const (
	RunnableJobCollectionInputTypeCollection RunnableJobCollectionInputType = "collection"
)

// Defines values for RunnableJobCollectionRunCaptureLevel.
const (
	RunnableJobCollectionRunCaptureLevelN0 RunnableJobCollectionRunCaptureLevel = "0"
	RunnableJobCollectionRunCaptureLevelN1 RunnableJobCollectionRunCaptureLevel = "1"
	RunnableJobCollectionRunCaptureLevelN2 RunnableJobCollectionRunCaptureLevel = "2"
	RunnableJobCollectionRunCaptureLevelN3 RunnableJobCollectionRunCaptureLevel = "3"
)

// Defines values for RunnableJobCollectionRunLogLevel.
const (
	RunnableJobCollectionRunLogLevelDebug RunnableJobCollectionRunLogLevel = "debug"
	RunnableJobCollectionRunLogLevelError RunnableJobCollectionRunLogLevel = "error"
	RunnableJobCollectionRunLogLevelInfo  RunnableJobCollectionRunLogLevel = "info"
	RunnableJobCollectionRunLogLevelSilly RunnableJobCollectionRunLogLevel = "silly"
	RunnableJobCollectionRunLogLevelWarn  RunnableJobCollectionRunLogLevel = "warn"
)

// Defines values for RunnableJobCollectionRunMode.
const (
	List    RunnableJobCollectionRunMode = "list"
	Preview RunnableJobCollectionRunMode = "preview"
	Run     RunnableJobCollectionRunMode = "run"
)

// Defines values for RunnableJobCollectionRunTimeRangeType.
const (
	Absolute RunnableJobCollectionRunTimeRangeType = "absolute"
	Relative RunnableJobCollectionRunTimeRangeType = "relative"
)

// Defines values for RunnableJobCollectionScheduleEnabled.
const (
	RunnableJobCollectionScheduleEnabledFalse RunnableJobCollectionScheduleEnabled = false
	RunnableJobCollectionScheduleEnabledTrue  RunnableJobCollectionScheduleEnabled = true
)

// Defines values for RunnableJobCollectionType.
const (
	RunnableJobCollectionTypeCollection      RunnableJobCollectionType = "collection"
	RunnableJobCollectionTypeExecutor        RunnableJobCollectionType = "executor"
	RunnableJobCollectionTypeScheduledSearch RunnableJobCollectionType = "scheduledSearch"
)

// Defines values for RunnableJobExecutorRunLogLevel.
const (
	RunnableJobExecutorRunLogLevelDebug RunnableJobExecutorRunLogLevel = "debug"
	RunnableJobExecutorRunLogLevelError RunnableJobExecutorRunLogLevel = "error"
	RunnableJobExecutorRunLogLevelInfo  RunnableJobExecutorRunLogLevel = "info"
	RunnableJobExecutorRunLogLevelSilly RunnableJobExecutorRunLogLevel = "silly"
	RunnableJobExecutorRunLogLevelWarn  RunnableJobExecutorRunLogLevel = "warn"
)

// Defines values for RunnableJobExecutorScheduleEnabled.
const (
	RunnableJobExecutorScheduleEnabledFalse RunnableJobExecutorScheduleEnabled = false
	RunnableJobExecutorScheduleEnabledTrue  RunnableJobExecutorScheduleEnabled = true
)

// Defines values for RunnableJobExecutorType.
const (
	RunnableJobExecutorTypeCollection      RunnableJobExecutorType = "collection"
	RunnableJobExecutorTypeExecutor        RunnableJobExecutorType = "executor"
	RunnableJobExecutorTypeScheduledSearch RunnableJobExecutorType = "scheduledSearch"
)

// Defines values for RunnableJobScheduledSearchScheduleEnabled.
const (
	RunnableJobScheduledSearchScheduleEnabledFalse RunnableJobScheduledSearchScheduleEnabled = false
	RunnableJobScheduledSearchScheduleEnabledTrue  RunnableJobScheduledSearchScheduleEnabled = true
)

// Defines values for RunnableJobScheduledSearchType.
const (
	RunnableJobScheduledSearchTypeCollection      RunnableJobScheduledSearchType = "collection"
	RunnableJobScheduledSearchTypeExecutor        RunnableJobScheduledSearchType = "executor"
	RunnableJobScheduledSearchTypeScheduledSearch RunnableJobScheduledSearchType = "scheduledSearch"
)

// Defines values for SECRETPROVIDER.
const (
	SECRETPROVIDERAwsKms SECRETPROVIDER = "aws-kms"
	SECRETPROVIDERLocal  SECRETPROVIDER = "local"
	SECRETPROVIDERVault  SECRETPROVIDER = "vault"
)

// Defines values for SavedJobCollectionInputPreprocessDisabled.
const (
	SavedJobCollectionInputPreprocessDisabledFalse SavedJobCollectionInputPreprocessDisabled = false
	SavedJobCollectionInputPreprocessDisabledTrue  SavedJobCollectionInputPreprocessDisabled = true
)

// Defines values for SavedJobCollectionInputSendToRoutes.
const (
	SavedJobCollectionInputSendToRoutesFalse SavedJobCollectionInputSendToRoutes = false
	SavedJobCollectionInputSendToRoutesTrue  SavedJobCollectionInputSendToRoutes = true
)

// Defines values for SavedJobCollectionInputType.
const (
	SavedJobCollectionInputTypeCollection SavedJobCollectionInputType = "collection"
)

// Defines values for SavedJobCollectionScheduleEnabled.
const (
	SavedJobCollectionScheduleEnabledFalse SavedJobCollectionScheduleEnabled = false
	SavedJobCollectionScheduleEnabledTrue  SavedJobCollectionScheduleEnabled = true
)

// Defines values for SavedJobCollectionType.
const (
	SavedJobCollectionTypeCollection      SavedJobCollectionType = "collection"
	SavedJobCollectionTypeExecutor        SavedJobCollectionType = "executor"
	SavedJobCollectionTypeScheduledSearch SavedJobCollectionType = "scheduledSearch"
)

// Defines values for SavedJobExecutorScheduleEnabled.
const (
	SavedJobExecutorScheduleEnabledFalse SavedJobExecutorScheduleEnabled = false
	SavedJobExecutorScheduleEnabledTrue  SavedJobExecutorScheduleEnabled = true
)

// Defines values for SavedJobExecutorType.
const (
	SavedJobExecutorTypeCollection      SavedJobExecutorType = "collection"
	SavedJobExecutorTypeExecutor        SavedJobExecutorType = "executor"
	SavedJobExecutorTypeScheduledSearch SavedJobExecutorType = "scheduledSearch"
)

// Defines values for SavedJobScheduledSearchScheduleEnabled.
const (
	False SavedJobScheduledSearchScheduleEnabled = false
	True  SavedJobScheduledSearchScheduleEnabled = true
)

// Defines values for SavedJobScheduledSearchType.
const (
	SavedJobScheduledSearchTypeCollection      SavedJobScheduledSearchType = "collection"
	SavedJobScheduledSearchTypeExecutor        SavedJobScheduledSearchType = "executor"
	SavedJobScheduledSearchTypeScheduledSearch SavedJobScheduledSearchType = "scheduledSearch"
)

// Defines values for SavesSearchRunMode.
const (
	LastRun   SavesSearchRunMode = "lastRun"
	NewSearch SavesSearchRunMode = "newSearch"
)

// Defines values for SearchAggMode.
const (
	Coordinated                           SearchAggMode = "Coordinated"
	CoordinatedSuppressPreview            SearchAggMode = "CoordinatedSuppressPreview"
	DistributedCoordinated                SearchAggMode = "DistributedCoordinated"
	DistributedCoordinatedSuppressPreview SearchAggMode = "DistributedCoordinatedSuppressPreview"
	Federated                             SearchAggMode = "Federated"
	LessThannil                           SearchAggMode = "<nil>"
)

// Defines values for SearchDashboardElements1Type.
const (
	MarkdownDefault SearchDashboardElements1Type = "markdown.default"
)

// Defines values for SearchDashboardElements1Variant.
const (
	Markdown SearchDashboardElements1Variant = "markdown"
)

// Defines values for SearchHealthCheckStatusStatus.
const (
	Green SearchHealthCheckStatusStatus = "green"
	Red   SearchHealthCheckStatusStatus = "red"
)

// Defines values for SearchJobStatus.
const (
	SearchJobStatusCanceled  SearchJobStatus = "canceled"
	SearchJobStatusCompleted SearchJobStatus = "completed"
	SearchJobStatusFailed    SearchJobStatus = "failed"
	SearchJobStatusNew       SearchJobStatus = "new"
	SearchJobStatusQueued    SearchJobStatus = "queued"
	SearchJobStatusRunning   SearchJobStatus = "running"
)

// Defines values for SearchJobType.
const (
	SearchJobTypeCommand         SearchJobType = "command"
	SearchJobTypeDashboard       SearchJobType = "dashboard"
	SearchJobTypeDatatypePreview SearchJobType = "datatypePreview"
	SearchJobTypeScheduled       SearchJobType = "scheduled"
	SearchJobTypeStandard        SearchJobType = "standard"
)

// Defines values for SearchJobStageConfigStatus.
const (
	SearchJobStageConfigStatusCanceled  SearchJobStageConfigStatus = "canceled"
	SearchJobStageConfigStatusCompleted SearchJobStageConfigStatus = "completed"
	SearchJobStageConfigStatusFailed    SearchJobStageConfigStatus = "failed"
	SearchJobStageConfigStatusNew       SearchJobStageConfigStatus = "new"
	SearchJobStageConfigStatusQueued    SearchJobStageConfigStatus = "queued"
	SearchJobStageConfigStatusRunning   SearchJobStageConfigStatus = "running"
)

// Defines values for SearchParameterType.
const (
	Boolean SearchParameterType = "boolean"
	Number  SearchParameterType = "number"
	String  SearchParameterType = "string"
)

// Defines values for SearchQuery0Type.
const (
	Saved SearchQuery0Type = "saved"
)

// Defines values for SearchQuery1Type.
const (
	Inline SearchQuery1Type = "inline"
)

// Defines values for SearchQuery2Type.
const (
	Values SearchQuery2Type = "values"
)

// Defines values for SecretType.
const (
	Credentials SecretType = "credentials"
	Keypair     SecretType = "keypair"
	Text        SecretType = "text"
)

// Defines values for ServiceHealthStatusStatus.
const (
	Healthy      ServiceHealthStatusStatus = "healthy"
	ShuttingDown ServiceHealthStatusStatus = "shutting down"
)

// Defines values for SortByFieldDirection.
const (
	Ascending  SortByFieldDirection = "ascending"
	Descending SortByFieldDirection = "descending"
)

// Defines values for SortByFieldNullPosition.
const (
	NullsFirst SortByFieldNullPosition = "nullsFirst"
	NullsLast  SortByFieldNullPosition = "nullsLast"
)

// Defines values for UiStatePatchOp.
const (
	PushRecent UiStatePatchOp = "push-recent"
	Set        UiStatePatchOp = "set"
)

// Defines values for Unknown.
const (
	N8 Unknown = 8
)

// Defines values for GetCluiParamsContext.
const (
	GetCluiParamsContextEdge   GetCluiParamsContext = "edge"
	GetCluiParamsContextStream GetCluiParamsContext = "stream"
)

// Defines values for GetJobsParamsRunType.
const (
	GetJobsParamsRunTypeAdhoc     GetJobsParamsRunType = "adhoc"
	GetJobsParamsRunTypeScheduled GetJobsParamsRunType = "scheduled"
	GetJobsParamsRunTypeSystem    GetJobsParamsRunType = "system"
)

// Defines values for GetMasterGroupsIdAclParamsType.
const (
	GetMasterGroupsIdAclParamsTypeDashboards       GetMasterGroupsIdAclParamsType = "dashboards"
	GetMasterGroupsIdAclParamsTypeDatasetProviders GetMasterGroupsIdAclParamsType = "dataset-providers"
	GetMasterGroupsIdAclParamsTypeDatasets         GetMasterGroupsIdAclParamsType = "datasets"
	GetMasterGroupsIdAclParamsTypeGroups           GetMasterGroupsIdAclParamsType = "groups"
	GetMasterGroupsIdAclParamsTypeMacros           GetMasterGroupsIdAclParamsType = "macros"
	GetMasterGroupsIdAclParamsTypeProjects         GetMasterGroupsIdAclParamsType = "projects"
)

// Defines values for GetMasterSummaryParamsMode.
const (
	ManagedEdge GetMasterSummaryParamsMode = "managed-edge"
	Worker      GetMasterSummaryParamsMode = "worker"
)

// Defines values for GetPacksIdExportParamsMode.
const (
	DefaultOnly GetPacksIdExportParamsMode = "default_only"
	Merge       GetPacksIdExportParamsMode = "merge"
	MergeSafe   GetPacksIdExportParamsMode = "merge_safe"
)

// Defines values for GetProductsProductGroupsParamsProduct.
const (
	GetProductsProductGroupsParamsProductEdge   GetProductsProductGroupsParamsProduct = "edge"
	GetProductsProductGroupsParamsProductStream GetProductsProductGroupsParamsProduct = "stream"
)

// Defines values for PostProductsProductGroupsParamsProduct.
const (
	PostProductsProductGroupsParamsProductEdge   PostProductsProductGroupsParamsProduct = "edge"
	PostProductsProductGroupsParamsProductStream PostProductsProductGroupsParamsProduct = "stream"
)

// Defines values for GetProductsProductGroupsIdAclTeamsParamsType.
const (
	GetProductsProductGroupsIdAclTeamsParamsTypeDashboards       GetProductsProductGroupsIdAclTeamsParamsType = "dashboards"
	GetProductsProductGroupsIdAclTeamsParamsTypeDatasetProviders GetProductsProductGroupsIdAclTeamsParamsType = "dataset-providers"
	GetProductsProductGroupsIdAclTeamsParamsTypeDatasets         GetProductsProductGroupsIdAclTeamsParamsType = "datasets"
	GetProductsProductGroupsIdAclTeamsParamsTypeGroups           GetProductsProductGroupsIdAclTeamsParamsType = "groups"
	GetProductsProductGroupsIdAclTeamsParamsTypeMacros           GetProductsProductGroupsIdAclTeamsParamsType = "macros"
	GetProductsProductGroupsIdAclTeamsParamsTypeProjects         GetProductsProductGroupsIdAclTeamsParamsType = "projects"
)

// Defines values for GetProductsProductGroupsIdAclTeamsParamsProduct.
const (
	GetProductsProductGroupsIdAclTeamsParamsProductEdge   GetProductsProductGroupsIdAclTeamsParamsProduct = "edge"
	GetProductsProductGroupsIdAclTeamsParamsProductStream GetProductsProductGroupsIdAclTeamsParamsProduct = "stream"
)

// Defines values for GetProductsProductUsersParamsProduct.
const (
	GetProductsProductUsersParamsProductEdge   GetProductsProductUsersParamsProduct = "edge"
	GetProductsProductUsersParamsProductLake   GetProductsProductUsersParamsProduct = "lake"
	GetProductsProductUsersParamsProductSearch GetProductsProductUsersParamsProduct = "search"
	GetProductsProductUsersParamsProductStream GetProductsProductUsersParamsProduct = "stream"
)

// Defines values for DeleteProductsProductUsersCacheParamsProduct.
const (
	DeleteProductsProductUsersCacheParamsProductEdge   DeleteProductsProductUsersCacheParamsProduct = "edge"
	DeleteProductsProductUsersCacheParamsProductLake   DeleteProductsProductUsersCacheParamsProduct = "lake"
	DeleteProductsProductUsersCacheParamsProductSearch DeleteProductsProductUsersCacheParamsProduct = "search"
	DeleteProductsProductUsersCacheParamsProductStream DeleteProductsProductUsersCacheParamsProduct = "stream"
)

// Defines values for GetProductsProductUsersIdAclParamsType.
const (
	GetProductsProductUsersIdAclParamsTypeDashboards       GetProductsProductUsersIdAclParamsType = "dashboards"
	GetProductsProductUsersIdAclParamsTypeDatasetProviders GetProductsProductUsersIdAclParamsType = "dataset-providers"
	GetProductsProductUsersIdAclParamsTypeDatasets         GetProductsProductUsersIdAclParamsType = "datasets"
	GetProductsProductUsersIdAclParamsTypeGroups           GetProductsProductUsersIdAclParamsType = "groups"
	GetProductsProductUsersIdAclParamsTypeMacros           GetProductsProductUsersIdAclParamsType = "macros"
	GetProductsProductUsersIdAclParamsTypeProjects         GetProductsProductUsersIdAclParamsType = "projects"
)

// Defines values for GetProductsProductUsersIdAclParamsProduct.
const (
	GetProductsProductUsersIdAclParamsProductEdge   GetProductsProductUsersIdAclParamsProduct = "edge"
	GetProductsProductUsersIdAclParamsProductLake   GetProductsProductUsersIdAclParamsProduct = "lake"
	GetProductsProductUsersIdAclParamsProductSearch GetProductsProductUsersIdAclParamsProduct = "search"
	GetProductsProductUsersIdAclParamsProductStream GetProductsProductUsersIdAclParamsProduct = "stream"
)

// Defines values for GetSystemTeamsParamsProduct.
const (
	GetSystemTeamsParamsProductEdge   GetSystemTeamsParamsProduct = "edge"
	GetSystemTeamsParamsProductSearch GetSystemTeamsParamsProduct = "search"
	GetSystemTeamsParamsProductStream GetSystemTeamsParamsProduct = "stream"
)

// Defines values for GetSystemTeamsIdAclParamsType.
const (
	Dashboards       GetSystemTeamsIdAclParamsType = "dashboards"
	DatasetProviders GetSystemTeamsIdAclParamsType = "dataset-providers"
	Datasets         GetSystemTeamsIdAclParamsType = "datasets"
	Groups           GetSystemTeamsIdAclParamsType = "groups"
	Macros           GetSystemTeamsIdAclParamsType = "macros"
	Projects         GetSystemTeamsIdAclParamsType = "projects"
)

// AMTrustPolicy defines model for AMTrustPolicy.
type AMTrustPolicy struct {
	Statement []struct {
		Action    AMTrustPolicy_Statement_Action `json:"Action"`
		Condition *struct {
			StringEquals *map[string]interface{} `json:"StringEquals,omitempty"`
		} `json:"Condition,omitempty"`
		Effect    string `json:"Effect"`
		Principal struct {
			AWS string `json:"AWS"`
		} `json:"Principal"`
	} `json:"Statement"`
	Version string `json:"Version"`
}

// AMTrustPolicyStatementAction0 defines model for .
type AMTrustPolicyStatementAction0 = string

// AMTrustPolicyStatementAction1 defines model for .
type AMTrustPolicyStatementAction1 = []string

// AMTrustPolicy_Statement_Action defines model for AMTrustPolicy.Statement.Action.
type AMTrustPolicy_Statement_Action struct {
	Union json.RawMessage
}

// AUTHPROVIDER defines model for AUTH_PROVIDER.
type AUTHPROVIDER string

// AWSKMSServiceConfig defines model for AWSKMSServiceConfig.
type AWSKMSServiceConfig struct {
	KmsKeyArn string `json:"kmsKeyArn"`
	Region    string `json:"region"`
}

// AccessControl defines model for AccessControl.
type AccessControl = map[string]interface{}

// AccessControlSchema defines model for AccessControlSchema.
type AccessControlSchema struct {
	Add *AccessControl `json:"add,omitempty"`
	Rm  *AccessControl `json:"rm,omitempty"`
}

// AddHecTokenRequest defines model for AddHecTokenRequest.
type AddHecTokenRequest struct {
	Description *string `json:"description,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Metadata    *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Token string `json:"token"`
}

// AggregationMgrOptions defines model for AggregationMgrOptions.
type AggregationMgrOptions struct {
	Aggregations             []string       `json:"aggregations"`
	Cumulative               bool           `json:"cumulative"`
	FlushEventLimit          float32        `json:"flushEventLimit"`
	FlushMemLimit            float32        `json:"flushMemLimit"`
	Hostname                 string         `json:"hostname"`
	IdleTimeLimitSeconds     *float32       `json:"idleTimeLimitSeconds,omitempty"`
	LagToleranceSeconds      *float32       `json:"lagToleranceSeconds,omitempty"`
	MetricsMode              bool           `json:"metricsMode"`
	Prefix                   *string        `json:"prefix,omitempty"`
	PreserveSplitByStructure *bool          `json:"preserveSplitByStructure,omitempty"`
	SearchAggMode            *SearchAggMode `json:"searchAggMode,omitempty"`
	SplitBys                 *[]string      `json:"splitBys,omitempty"`
	SufficientStatsOnly      bool           `json:"sufficientStatsOnly"`
	TimeWindowSeconds        float32        `json:"timeWindowSeconds"`
}

// AppMode defines model for AppMode.
type AppMode string

// AppScopeProcess defines model for AppScopeProcess.
type AppScopeProcess struct {
	Cfg        *AppscopeConfigWithCustom `json:"cfg,omitempty"`
	ConfigId   *string                   `json:"config_id,omitempty"`
	Id         string                    `json:"id"`
	Interfaces *[]struct {
		Config    *string `json:"config,omitempty"`
		Connected *bool   `json:"connected,omitempty"`
		Name      *string `json:"name,omitempty"`
	} `json:"interfaces,omitempty"`
	LastError *string `json:"lastError,omitempty"`
	Process   *struct {
		HostPid   *float32 `json:"hostPid,omitempty"`
		Id        *string  `json:"id,omitempty"`
		MachineId *string  `json:"machine_id,omitempty"`
		Pid       float32  `json:"pid"`
		Uuid      *string  `json:"uuid,omitempty"`
	} `json:"process,omitempty"`
	ProcessingStatus *AppScopeProcessingStatus `json:"processingStatus,omitempty"`
	SourceId         *string                   `json:"source_id,omitempty"`
	Status           *AppScopeProcessStatus    `json:"status,omitempty"`
}

// AppScopeProcessStatus defines model for AppScopeProcessStatus.
type AppScopeProcessStatus string

// AppScopeProcessingStatus defines model for AppScopeProcessingStatus.
type AppScopeProcessingStatus string

// AppscopeConfig defines model for AppscopeConfig.
type AppscopeConfig struct {
	Cribl *struct {
		Authtoken               *string            `json:"authtoken,omitempty"`
		Enable                  *bool              `json:"enable,omitempty"`
		Transport               *AppscopeTransport `json:"transport,omitempty"`
		UseScopeSourceTransport *bool              `json:"useScopeSourceTransport,omitempty"`
	} `json:"cribl,omitempty"`
	Event *struct {
		Enable bool `json:"enable"`
		Format struct {
			Enhancefs      bool    `json:"enhancefs"`
			Maxeventpersec float32 `json:"maxeventpersec"`
		} `json:"format"`
		Transport AppscopeTransport       `json:"transport"`
		Type      AppscopeConfigEventType `json:"type"`
		Watch     []struct {
			Allowbinary *bool   `json:"allowbinary,omitempty"`
			Enabled     *bool   `json:"enabled,omitempty"`
			Field       *string `json:"field,omitempty"`
			Headers     *string `json:"headers,omitempty"`
			Name        *string `json:"name,omitempty"`
			Type        string  `json:"type"`
			Value       *string `json:"value,omitempty"`
		} `json:"watch"`
	} `json:"event,omitempty"`
	Libscope *struct {
		Commanddir  *string `json:"commanddir,omitempty"`
		Configevent *bool   `json:"configevent,omitempty"`
		Log         *struct {
			Level     *AppscopeConfigLibscopeLogLevel `json:"level,omitempty"`
			Transport *AppscopeTransport              `json:"transport,omitempty"`
		} `json:"log,omitempty"`
		Summaryperiod *float32 `json:"summaryperiod,omitempty"`
	} `json:"libscope,omitempty"`
	Metric *struct {
		Enable bool `json:"enable"`
		Format struct {
			Statsdmaxlen *float32 `json:"statsdmaxlen,omitempty"`
			Statsdprefix *string  `json:"statsdprefix,omitempty"`
			Type         *string  `json:"type,omitempty"`
			Verbosity    *float32 `json:"verbosity,omitempty"`
		} `json:"format"`
		Transport AppscopeTransport `json:"transport"`
		Watch     []string          `json:"watch"`
	} `json:"metric,omitempty"`
	Payload *struct {
		Dir    string `json:"dir"`
		Enable bool   `json:"enable"`
	} `json:"payload,omitempty"`
	Protocol *[]struct {
		Binary  bool    `json:"binary"`
		Detect  bool    `json:"detect"`
		Len     float32 `json:"len"`
		Name    string  `json:"name"`
		Payload bool    `json:"payload"`
		Regex   string  `json:"regex"`
	} `json:"protocol,omitempty"`
	Tags *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"tags,omitempty"`
}

// AppscopeConfigEventType defines model for AppscopeConfig.Event.Type.
type AppscopeConfigEventType string

// AppscopeConfigLibscopeLogLevel defines model for AppscopeConfig.Libscope.Log.Level.
type AppscopeConfigLibscopeLogLevel string

// AppscopeConfigWithCustom defines model for AppscopeConfigWithCustom.
type AppscopeConfigWithCustom struct {
	Cribl *struct {
		Authtoken               *string            `json:"authtoken,omitempty"`
		Enable                  *bool              `json:"enable,omitempty"`
		Transport               *AppscopeTransport `json:"transport,omitempty"`
		UseScopeSourceTransport *bool              `json:"useScopeSourceTransport,omitempty"`
	} `json:"cribl,omitempty"`
	Custom *[]AppscopeCustom `json:"custom,omitempty"`
	Event  *struct {
		Enable bool `json:"enable"`
		Format struct {
			Enhancefs      bool    `json:"enhancefs"`
			Maxeventpersec float32 `json:"maxeventpersec"`
		} `json:"format"`
		Transport AppscopeTransport                 `json:"transport"`
		Type      AppscopeConfigWithCustomEventType `json:"type"`
		Watch     []struct {
			Allowbinary *bool   `json:"allowbinary,omitempty"`
			Enabled     *bool   `json:"enabled,omitempty"`
			Field       *string `json:"field,omitempty"`
			Headers     *string `json:"headers,omitempty"`
			Name        *string `json:"name,omitempty"`
			Type        string  `json:"type"`
			Value       *string `json:"value,omitempty"`
		} `json:"watch"`
	} `json:"event,omitempty"`
	Libscope *struct {
		Commanddir  *string `json:"commanddir,omitempty"`
		Configevent *bool   `json:"configevent,omitempty"`
		Log         *struct {
			Level     *AppscopeConfigWithCustomLibscopeLogLevel `json:"level,omitempty"`
			Transport *AppscopeTransport                        `json:"transport,omitempty"`
		} `json:"log,omitempty"`
		Summaryperiod *float32 `json:"summaryperiod,omitempty"`
	} `json:"libscope,omitempty"`
	Metric *struct {
		Enable bool `json:"enable"`
		Format struct {
			Statsdmaxlen *float32 `json:"statsdmaxlen,omitempty"`
			Statsdprefix *string  `json:"statsdprefix,omitempty"`
			Type         *string  `json:"type,omitempty"`
			Verbosity    *float32 `json:"verbosity,omitempty"`
		} `json:"format"`
		Transport AppscopeTransport `json:"transport"`
		Watch     []string          `json:"watch"`
	} `json:"metric,omitempty"`
	Payload *struct {
		Dir    string `json:"dir"`
		Enable bool   `json:"enable"`
	} `json:"payload,omitempty"`
	Protocol *[]struct {
		Binary  bool    `json:"binary"`
		Detect  bool    `json:"detect"`
		Len     float32 `json:"len"`
		Name    string  `json:"name"`
		Payload bool    `json:"payload"`
		Regex   string  `json:"regex"`
	} `json:"protocol,omitempty"`
	Tags *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"tags,omitempty"`
}

// AppscopeConfigWithCustomEventType defines model for AppscopeConfigWithCustom.Event.Type.
type AppscopeConfigWithCustomEventType string

// AppscopeConfigWithCustomLibscopeLogLevel defines model for AppscopeConfigWithCustom.Libscope.Log.Level.
type AppscopeConfigWithCustomLibscopeLogLevel string

// AppscopeCustom defines model for AppscopeCustom.
type AppscopeCustom struct {
	Ancestor *string        `json:"ancestor,omitempty"`
	Arg      *string        `json:"arg,omitempty"`
	Config   AppscopeConfig `json:"config"`
	Env      *string        `json:"env,omitempty"`
	Hostname *string        `json:"hostname,omitempty"`
	Procname *string        `json:"procname,omitempty"`
	Username *string        `json:"username,omitempty"`
}

// AppscopeLibEntry defines model for AppscopeLibEntry.
type AppscopeLibEntry struct {
	Config      AppscopeConfigWithCustom `json:"config"`
	Description string                   `json:"description"`
	Id          string                   `json:"id"`
	Lib         CriblLib                 `json:"lib"`
	Tags        *string                  `json:"tags,omitempty"`
}

// AppscopeTransport defines model for AppscopeTransport.
type AppscopeTransport struct {
	Buffer *AppscopeTransportBuffer `json:"buffer,omitempty"`
	Host   *string                  `json:"host,omitempty"`
	Path   *string                  `json:"path,omitempty"`
	Port   *float32                 `json:"port,omitempty"`
	Tls    *struct {
		Cacertpath     *string `json:"cacertpath,omitempty"`
		Enable         *bool   `json:"enable,omitempty"`
		Validateserver *bool   `json:"validateserver,omitempty"`
	} `json:"tls,omitempty"`
	Type *string `json:"type,omitempty"`
}

// AppscopeTransportBuffer defines model for AppscopeTransport.Buffer.
type AppscopeTransportBuffer string

// AuthConfig defines model for AuthConfig.
type AuthConfig struct {
	Fallback         bool           `json:"fallback"`
	FallbackBadLogin bool           `json:"fallbackBadLogin"`
	FilterType       *string        `json:"filter_type,omitempty"`
	Host             string         `json:"host"`
	Port             float32        `json:"port"`
	Ssl              bool           `json:"ssl"`
	Type             AuthConfigType `json:"type"`
}

// AuthConfigType defines model for AuthConfig.Type.
type AuthConfigType string

// AuthPolicyEntry defines model for AuthPolicyEntry.
type AuthPolicyEntry struct {
	Actions []string `json:"actions"`
	Object  string   `json:"object"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	Token string `json:"token"`
}

// AwsMetadata defines model for AwsMetadata.
type AwsMetadata struct {
	Hostname       *string                 `json:"hostname,omitempty"`
	Identity       *map[string]interface{} `json:"identity,omitempty"`
	PublicIpv4     *string                 `json:"public_ipv4,omitempty"`
	Roles          *[]string               `json:"roles,omitempty"`
	SecurityGroups *[]string               `json:"security_groups,omitempty"`
	Tags           *map[string]interface{} `json:"tags,omitempty"`
	Version        float32                 `json:"version"`
}

// BannerMessage defines model for BannerMessage.
type BannerMessage struct {
	// Created Time created
	Created      *float32  `json:"created,omitempty"`
	CustomThemes *[]string `json:"customThemes,omitempty"`

	// Enabled Show a banner on top of all pages
	Enabled         bool    `json:"enabled"`
	Id              *string `json:"id,omitempty"`
	InvertFontColor *bool   `json:"invertFontColor,omitempty"`

	// Link Optionally, provide a URL to append to the message
	Link *string `json:"link,omitempty"`

	// LinkDisplay Optionally, display your link with a short text label instead of the raw URL (100-character limit)
	LinkDisplay *string `json:"linkDisplay,omitempty"`

	// Message Enter a message to display to all your Organization's users, across all Cribl products. Limited to one line and 100 characters; will be truncated as needed.
	Message string            `json:"message"`
	Theme   string            `json:"theme"`
	Type    BannerMessageType `json:"type"`
}

// BannerMessageType defines model for BannerMessage.Type.
type BannerMessageType string

// BulletinMessage defines model for BulletinMessage.
type BulletinMessage struct {
	Group    *string                   `json:"group,omitempty"`
	Id       string                    `json:"id"`
	Metadata *[]map[string]interface{} `json:"metadata,omitempty"`
	Severity *BulletinMessageSeverity  `json:"severity,omitempty"`
	Text     string                    `json:"text"`
	Time     *float32                  `json:"time,omitempty"`
	Title    *string                   `json:"title,omitempty"`
}

// BulletinMessageSeverity defines model for BulletinMessage.Severity.
type BulletinMessageSeverity string

// CHOutConfig defines model for CHOutConfig.
type CHOutConfig struct {
	AsyncInserts   bool                 `json:"asyncInserts"`
	Auth           *HTTPOutAuthConfig   `json:"auth,omitempty"`
	AuthType       *CHOutConfigAuthType `json:"authType,omitempty"`
	ColumnMappings *[]struct {
		ColumnName            string `json:"columnName"`
		ColumnType            string `json:"columnType"`
		ColumnValueExpression string `json:"columnValueExpression"`
	} `json:"columnMappings,omitempty"`
	Compress                      *bool                         `json:"compress,omitempty"`
	Concurrency                   *float32                      `json:"concurrency,omitempty"`
	Database                      string                        `json:"database"`
	ExcludeMappingFields          *[]string                     `json:"excludeMappingFields,omitempty"`
	ExtraParams                   *[]HTTPOutExtraParamConfig    `json:"extraParams,omitempty"`
	FailedRequestLoggingMode      *string                       `json:"failedRequestLoggingMode,omitempty"`
	FlushPeriodSec                float32                       `json:"flushPeriodSec"`
	Format                        Format                        `json:"format"`
	KeepAlive                     *bool                         `json:"keepAlive,omitempty"`
	LoadBalanced                  bool                          `json:"loadBalanced"`
	MappingType                   MappingType                   `json:"mappingType"`
	MaxConnectionReuseSec         *float32                      `json:"maxConnectionReuseSec,omitempty"`
	MaxPayloadEvents              *float32                      `json:"maxPayloadEvents,omitempty"`
	MaxPayloadSizeKB              *float32                      `json:"maxPayloadSizeKB,omitempty"`
	MaxSockets                    *float32                      `json:"maxSockets,omitempty"`
	Method                        *string                       `json:"method,omitempty"`
	Password                      *string                       `json:"password,omitempty"`
	RejectUnauthorized            *bool                         `json:"rejectUnauthorized,omitempty"`
	ResponseHonorRetryAfterHeader *bool                         `json:"responseHonorRetryAfterHeader,omitempty"`
	ResponseRetrySettings         *[]HTTPOutResponseRetryConfig `json:"responseRetrySettings,omitempty"`
	SafeHeaders                   *[]string                     `json:"safeHeaders,omitempty"`
	SqlUsername                   *string                       `json:"sqlUsername,omitempty"`
	TableName                     string                        `json:"tableName"`
	TableNameExpression           *string                       `json:"tableNameExpression,omitempty"`
	TimeoutRetrySettings          *RetryBackoffOptions          `json:"timeoutRetrySettings,omitempty"`
	TimeoutSec                    *float32                      `json:"timeoutSec,omitempty"`
	Tls                           *TLSClientParams              `json:"tls,omitempty"`
	Token                         *string                       `json:"token,omitempty"`
	TotalMemoryLimitKB            *float32                      `json:"totalMemoryLimitKB,omitempty"`
	Url                           string                        `json:"url"`
	Urls                          *[]interface{}                `json:"urls,omitempty"`
	UseRoundRobinDns              *bool                         `json:"useRoundRobinDns,omitempty"`
	Username                      *string                       `json:"username,omitempty"`
	WaitForAsyncInserts           *bool                         `json:"waitForAsyncInserts,omitempty"`
}

// CHOutConfigAuthType defines model for CHOutConfig.AuthType.
type CHOutConfigAuthType string

// CPUTimeMetric defines model for CPUTimeMetric.
type CPUTimeMetric struct {
	TotalCPUSeconds     float32 `json:"totalCPUSeconds"`
	TotalExecCPUSeconds float32 `json:"totalExecCPUSeconds"`
}

// CacheConnection defines model for CacheConnection.
type CacheConnection struct {
	CacheRef        string  `json:"cacheRef"`
	CreatedAt       float32 `json:"createdAt"`
	RetentionInDays float32 `json:"retentionInDays"`
}

// CacheStatusByDatasetId defines model for CacheStatusByDatasetId.
type CacheStatusByDatasetId = interface{}

// CaptureParams defines model for CaptureParams.
type CaptureParams struct {
	Filter          string   `json:"filter"`
	Level           float32  `json:"level"`
	MaxEvents       float32  `json:"maxEvents"`
	StepDuration    *float32 `json:"stepDuration,omitempty"`
	WorkerId        *string  `json:"workerId,omitempty"`
	WorkerThreshold *float32 `json:"workerThreshold,omitempty"`
}

// Certificate defines model for Certificate.
type Certificate struct {
	// Ca Optionally, drag/drop or upload all CA certificates in PEM/Base64 format. Or, paste certificate contents here. Certificates can be used for client and/or server authentication.
	Ca *string `json:"ca,omitempty"`

	// Cert Drag/drop or upload host certificate in PEM/Base64 format, or paste its contents here
	Cert        string  `json:"cert"`
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// InUse List of configurations that reference this certificate
	InUse      *[]string `json:"inUse,omitempty"`
	Passphrase *string   `json:"passphrase,omitempty"`
	PrivKey    string    `json:"privKey"`
}

// ChangelogState defines model for ChangelogState.
type ChangelogState struct {
	LastViewedCurrent *string `json:"lastViewedCurrent,omitempty"`
	LastViewedUpgrade *string `json:"lastViewedUpgrade,omitempty"`
}

// ChartConfig defines model for ChartConfig.
type ChartConfig struct {
	ApplyThreshold *bool `json:"applyThreshold,omitempty"`
	Axis           *struct {
		XAxis         *string   `json:"xAxis,omitempty"`
		YAxis         *[]string `json:"yAxis,omitempty"`
		YAxisExcluded *[]string `json:"yAxisExcluded,omitempty"`
	} `json:"axis,omitempty"`
	Color                *string `json:"color,omitempty"`
	ColorPalette         float32 `json:"colorPalette"`
	ColorPaletteReversed *bool   `json:"colorPaletteReversed,omitempty"`
	ColorThresholds      *struct {
		Thresholds []struct {
			Color     string  `json:"color"`
			Threshold float32 `json:"threshold"`
		} `json:"thresholds"`
	} `json:"colorThresholds,omitempty"`
	CustomData *struct {
		ConnectNulls              *string                            `json:"connectNulls,omitempty"`
		DataFields                *[]string                          `json:"dataFields,omitempty"`
		IsPointColor              *bool                              `json:"isPointColor,omitempty"`
		LimitToTopN               *float32                           `json:"limitToTopN,omitempty"`
		Lines                     *bool                              `json:"lines,omitempty"`
		NameField                 *string                            `json:"nameField,omitempty"`
		PointColorPalette         *float32                           `json:"pointColorPalette,omitempty"`
		PointColorPaletteReversed *bool                              `json:"pointColorPaletteReversed,omitempty"`
		PointScale                *ChartConfig_CustomData_PointScale `json:"pointScale,omitempty"`
		PointScaleDataField       *string                            `json:"pointScaleDataField,omitempty"`
		SeriesCount               *float32                           `json:"seriesCount,omitempty"`
		SplitBy                   *string                            `json:"splitBy,omitempty"`
		Stack                     *bool                              `json:"stack,omitempty"`
		SummarizeOthers           *bool                              `json:"summarizeOthers,omitempty"`
		Trellis                   *bool                              `json:"trellis,omitempty"`
	} `json:"customData,omitempty"`
	Decimals *float32 `json:"decimals,omitempty"`
	Label    *string  `json:"label,omitempty"`
	Legend   *struct {
		Position *string `json:"position,omitempty"`
		Truncate *bool   `json:"truncate,omitempty"`
	} `json:"legend,omitempty"`
	MapDetails *struct {
		LatitudeField  *string                            `json:"latitudeField,omitempty"`
		LongitudeField *string                            `json:"longitudeField,omitempty"`
		MapSourceID    *string                            `json:"mapSourceID,omitempty"`
		MapType        *string                            `json:"mapType,omitempty"`
		NameField      *string                            `json:"nameField,omitempty"`
		PointScale     *ChartConfig_MapDetails_PointScale `json:"pointScale,omitempty"`
		ValueField     *string                            `json:"valueField,omitempty"`
	} `json:"mapDetails,omitempty"`
	OnClickAction *struct {
		Search                   *string `json:"search,omitempty"`
		SelectedDashboardId      *string `json:"selectedDashboardId,omitempty"`
		SelectedInputId          *string `json:"selectedInputId,omitempty"`
		SelectedTimerangeInputId *string `json:"selectedTimerangeInputId,omitempty"`
		Type                     *string `json:"type,omitempty"`
	} `json:"onClickAction,omitempty"`
	Prefix                       *string        `json:"prefix,omitempty"`
	Separator                    *bool          `json:"separator,omitempty"`
	Series                       *[]ChartSeries `json:"series,omitempty"`
	ShouldApplyUserChartSettings *bool          `json:"shouldApplyUserChartSettings,omitempty"`
	Style                        *bool          `json:"style,omitempty"`
	Suffix                       *string        `json:"suffix,omitempty"`
	Type                         string         `json:"type"`
	XAxis                        *struct {
		DataField        *string  `json:"dataField,omitempty"`
		Inverse          *bool    `json:"inverse,omitempty"`
		LabelInterval    *string  `json:"labelInterval,omitempty"`
		LabelOrientation *float32 `json:"labelOrientation,omitempty"`
		Name             *string  `json:"name,omitempty"`
		Offset           *float32 `json:"offset,omitempty"`
		Position         *string  `json:"position,omitempty"`
		Type             *string  `json:"type,omitempty"`
	} `json:"xAxis,omitempty"`
	YAxis *struct {
		DataField *[]string `json:"dataField,omitempty"`
		Interval  *float32  `json:"interval,omitempty"`
		Max       *float32  `json:"max,omitempty"`
		Min       *float32  `json:"min,omitempty"`
		Position  *string   `json:"position,omitempty"`
		Scale     *string   `json:"scale,omitempty"`
		SplitLine *bool     `json:"splitLine,omitempty"`
		Type      *string   `json:"type,omitempty"`
	} `json:"yAxis,omitempty"`
}

// ChartConfigCustomDataPointScale0 defines model for .
type ChartConfigCustomDataPointScale0 = string

// ChartConfigCustomDataPointScale1 defines model for .
type ChartConfigCustomDataPointScale1 = float32

// ChartConfig_CustomData_PointScale defines model for ChartConfig.CustomData.PointScale.
type ChartConfig_CustomData_PointScale struct {
	Union json.RawMessage
}

// ChartConfigMapDetailsPointScale0 defines model for .
type ChartConfigMapDetailsPointScale0 = string

// ChartConfigMapDetailsPointScale1 defines model for .
type ChartConfigMapDetailsPointScale1 = float32

// ChartConfig_MapDetails_PointScale defines model for ChartConfig.MapDetails.PointScale.
type ChartConfig_MapDetails_PointScale struct {
	Union json.RawMessage
}

// ChartSeries defines model for ChartSeries.
type ChartSeries struct {
	Color      *string        `json:"color,omitempty"`
	Data       *[]interface{} `json:"data,omitempty"`
	Map        *string        `json:"map,omitempty"`
	Name       string         `json:"name"`
	Type       *ChartType     `json:"type,omitempty"`
	YAxisField *string        `json:"yAxisField,omitempty"`
}

// ChartType defines model for ChartType.
type ChartType string

// ClickHouseDescriptionColumn defines model for ClickHouseDescriptionColumn.
type ClickHouseDescriptionColumn struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// ClickHouseDescriptionResult defines model for ClickHouseDescriptionResult.
type ClickHouseDescriptionResult struct {
	Description *[]ClickHouseDescriptionColumn `json:"description,omitempty"`
	ErrorMsg    *string                        `json:"errorMsg,omitempty"`
	Success     bool                           `json:"success"`
}

// CluiItem defines model for CluiItem.
type CluiItem struct {
	Category CluiItemCategory `json:"category"`
	GroupId  *string          `json:"groupId,omitempty"`
	Id       *string          `json:"id,omitempty"`
	Name     *string          `json:"name,omitempty"`
	PackId   *string          `json:"packId,omitempty"`
	SubType  *string          `json:"subType,omitempty"`
	Type     CluiType         `json:"type"`
}

// CluiItemCategory defines model for CluiItem.Category.
type CluiItemCategory string

// CluiType defines model for CluiType.
type CluiType string

// Collector defines model for Collector.
type Collector = Function

// ColumnFilterSettings defines model for ColumnFilterSettings.
type ColumnFilterSettings struct {
	Contains ColumnSetting `json:"contains"`
}

// ColumnFormatSettings defines model for ColumnFormatSettings.
type ColumnFormatSettings struct {
	Palette   ColumnSetting `json:"palette"`
	Precision ColumnSetting `json:"precision"`
	Prefix    ColumnSetting `json:"prefix"`
	Suffix    ColumnSetting `json:"suffix"`
}

// ColumnOrderSettings defines model for ColumnOrderSettings.
type ColumnOrderSettings struct {
	Order ColumnSetting `json:"order"`
}

// ColumnSetting defines model for ColumnSetting.
type ColumnSetting = interface{}

// ColumnSortSettings defines model for ColumnSortSettings.
type ColumnSortSettings struct {
	Sort ColumnSetting `json:"sort"`
}

// CommonServiceLimitConfigs defines model for CommonServiceLimitConfigs.
type CommonServiceLimitConfigs struct {
	MemoryLimit string `json:"memoryLimit"`
}

// Condition defines model for Condition.
type Condition = Function

// ConfigGroup defines model for ConfigGroup.
type ConfigGroup struct {
	ConfigVersion        string   `json:"configVersion"`
	DeployingWorkerCount *float32 `json:"deployingWorkerCount,omitempty"`
	Description          *string  `json:"description,omitempty"`
	EstimatedIngestRate  *float32 `json:"estimatedIngestRate,omitempty"`
	Git                  *struct {
		Commit       *string        `json:"commit,omitempty"`
		LocalChanges *float32       `json:"localChanges,omitempty"`
		Log          *[]interface{} `json:"log,omitempty"`
	} `json:"git,omitempty"`
	Id                      string    `json:"id"`
	IncompatibleWorkerCount *float32  `json:"incompatibleWorkerCount,omitempty"`
	Inherits                *string   `json:"inherits,omitempty"`
	IsFleet                 *bool     `json:"isFleet,omitempty"`
	IsSearch                *bool     `json:"isSearch,omitempty"`
	Name                    *string   `json:"name,omitempty"`
	OnPrem                  *bool     `json:"onPrem,omitempty"`
	Provisioned             *bool     `json:"provisioned,omitempty"`
	Streamtags              *[]string `json:"streamtags,omitempty"`
	Tags                    *string   `json:"tags,omitempty"`
	UpgradeVersion          *string   `json:"upgradeVersion,omitempty"`
	WorkerCount             *float32  `json:"workerCount,omitempty"`
	WorkerRemoteAccess      *bool     `json:"workerRemoteAccess,omitempty"`
}

// Connection defines model for Connection.
type Connection struct {
	Output   string  `json:"output"`
	Pipeline *string `json:"pipeline,omitempty"`
}

// Container defines model for Container.
type Container struct {
	Command    Container_Command `json:"command"`
	Containerd *ContainerdInfo   `json:"containerd,omitempty"`
	Created    float32           `json:"created"`
	Docker     *DockerInfo       `json:"docker,omitempty"`
	Id         string            `json:"id"`
	Image      string            `json:"image"`
	Ips        *[]string         `json:"ips,omitempty"`
	Name       string            `json:"name"`
	Ports      *[]ContainerPort  `json:"ports,omitempty"`
	Status     string            `json:"status"`
	Type       ContainerType     `json:"type"`
}

// ContainerCommand0 defines model for .
type ContainerCommand0 = string

// ContainerCommand1 defines model for .
type ContainerCommand1 = []string

// Container_Command defines model for Container.Command.
type Container_Command struct {
	Union json.RawMessage
}

// ContainerType defines model for Container.Type.
type ContainerType string

// ContainerPort defines model for ContainerPort.
type ContainerPort struct {
	PrivatePort float32 `json:"privatePort"`
	PublicPort  float32 `json:"publicPort"`
}

// ContainerdContainer defines model for ContainerdContainer.
type ContainerdContainer struct {
	Mounts []ContainerdMount `json:"mounts"`
	Root   ContainerdRoot    `json:"root"`
}

// ContainerdInfo defines model for ContainerdInfo.
type ContainerdInfo struct {
	Container ContainerdContainer     `json:"container"`
	Image     *map[string]interface{} `json:"image,omitempty"`
	Metrics   *map[string]interface{} `json:"metrics,omitempty"`
	Namespace *map[string]interface{} `json:"namespace,omitempty"`
	Task      *ContainerdTask         `json:"task,omitempty"`
}

// ContainerdMount defines model for ContainerdMount.
type ContainerdMount struct {
	Destination string `json:"destination"`
	Source      string `json:"source"`
}

// ContainerdRoot defines model for ContainerdRoot.
type ContainerdRoot struct {
	Path string `json:"path"`
}

// ContainerdTask defines model for ContainerdTask.
type ContainerdTask struct {
	Process *map[string]interface{} `json:"process,omitempty"`
}

// CriblEvent defines model for CriblEvent.
type CriblEvent struct {
	Raw string `json:"_raw"`
}

// CriblLakeDataset defines model for CriblLakeDataset.
type CriblLakeDataset struct {
	AcceleratedFields     *[]string                `json:"acceleratedFields,omitempty"`
	BucketName            string                   `json:"bucketName"`
	CacheConnection       *CacheConnection         `json:"cacheConnection,omitempty"`
	DeletionStartedAt     *float32                 `json:"deletionStartedAt,omitempty"`
	Description           *string                  `json:"description,omitempty"`
	Format                *CriblLakeDatasetFormat  `json:"format,omitempty"`
	Id                    string                   `json:"id"`
	RetentionPeriodInDays *float32                 `json:"retentionPeriodInDays,omitempty"`
	SearchConfig          *LakeDatasetSearchConfig `json:"searchConfig,omitempty"`
	ViewName              *string                  `json:"viewName,omitempty"`
}

// CriblLakeDatasetFormat defines model for CriblLakeDataset.Format.
type CriblLakeDatasetFormat string

// CriblLib defines model for CriblLib.
type CriblLib string

// CriblMetadata defines model for CriblMetadata.
type CriblMetadata struct {
	ConfigVersion *string   `json:"config_version,omitempty"`
	Group         *string   `json:"group,omitempty"`
	InstallType   *string   `json:"install_type,omitempty"`
	Mode          string    `json:"mode"`
	Tags          *[]string `json:"tags,omitempty"`
	Version       string    `json:"version"`
}

// CrudEntityBase defines model for CrudEntityBase.
type CrudEntityBase struct {
	Id string `json:"id"`
}

// DailyUsageMetrics defines model for DailyUsageMetrics.
type DailyUsageMetrics struct {
	DroppedBytes           *float32 `json:"droppedBytes,omitempty"`
	EndTime                float32  `json:"endTime"`
	ExemptedLicenseInBytes float32  `json:"exemptedLicenseInBytes"`
	InBytes                float32  `json:"inBytes"`
	InEvents               float32  `json:"inEvents"`
	InMetricsEvents        *float32 `json:"inMetricsEvents,omitempty"`
	OutBytes               float32  `json:"outBytes"`
	OutEvents              float32  `json:"outEvents"`
	StartTime              float32  `json:"startTime"`
}

// DashboardCategory defines model for DashboardCategory.
type DashboardCategory struct {
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`
	IsPack      *bool   `json:"isPack,omitempty"`
	Name        string  `json:"name"`
}

// DashboardElementType defines model for DashboardElementType.
type DashboardElementType string

// DashboardElementVariant defines model for DashboardElementVariant.
type DashboardElementVariant string

// DashboardLayout defines model for DashboardLayout.
type DashboardLayout struct {
	H float32 `json:"h"`
	W float32 `json:"w"`
	X float32 `json:"x"`
	Y float32 `json:"y"`
}

// DataSample defines model for DataSample.
type DataSample struct {
	// Description Brief description of this sample file. Optional.
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// PipelineId Select a pipeline to associate with sample with. Select GLOBAL if not sure. Deprecated.
	PipelineId *string `json:"pipelineId,omitempty"`
	SampleName string  `json:"sampleName"`

	// Tags One or more tags related to this sample file. Optional.
	Tags *string `json:"tags,omitempty"`

	// Ttl Time to live (TTL) for the sample; reset after each use. Leave empty to never expire.
	Ttl                  *float32               `json:"ttl,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DatabaseConnectionConfig defines model for DatabaseConnectionConfig.
type DatabaseConnectionConfig struct {
	AuthType          string                 `json:"authType"`
	ConfigObj         *string                `json:"configObj,omitempty"`
	ConnectionString  *string                `json:"connectionString,omitempty"`
	ConnectionTimeout *float32               `json:"connectionTimeout,omitempty"`
	DatabaseType      DatabaseConnectionType `json:"databaseType"`
	Description       string                 `json:"description"`
	Id                string                 `json:"id"`
	Password          *string                `json:"password,omitempty"`
	RequestTimeout    *float32               `json:"requestTimeout,omitempty"`
	Tags              *string                `json:"tags,omitempty"`
	User              *string                `json:"user,omitempty"`
}

// DatabaseConnectionTest defines model for DatabaseConnectionTest.
type DatabaseConnectionTest struct {
	AuthType          string   `json:"authType"`
	ConfigObj         *string  `json:"configObj,omitempty"`
	ConnectionString  *string  `json:"connectionString,omitempty"`
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	DatabaseType      string   `json:"databaseType"`
	Password          *string  `json:"password,omitempty"`
	TextSecret        *string  `json:"textSecret,omitempty"`
	User              *string  `json:"user,omitempty"`
}

// DatabaseConnectionTestResult defines model for DatabaseConnectionTestResult.
type DatabaseConnectionTestResult struct {
	ErrorMsg *string `json:"errorMsg,omitempty"`
	Success  bool    `json:"success"`
}

// DatabaseConnectionType defines model for DatabaseConnectionType.
type DatabaseConnectionType string

// Dataset defines model for Dataset.
type Dataset = interface{}

// DatasetMetadata defines model for DatasetMetadata.
type DatasetMetadata struct {
	Earliest           string                  `json:"earliest"`
	EnableAcceleration bool                    `json:"enableAcceleration"`
	FieldList          []string                `json:"fieldList"`
	LatestRunInfo      *DatasetMetadataRunInfo `json:"latestRunInfo,omitempty"`
	ScanMode           DatasetMetadataScanMode `json:"scanMode"`
}

// DatasetMetadataScanMode defines model for DatasetMetadata.ScanMode.
type DatasetMetadataScanMode string

// DatasetMetadataRunInfo defines model for DatasetMetadataRunInfo.
type DatasetMetadataRunInfo struct {
	EarliestScannedTime *float32 `json:"earliestScannedTime,omitempty"`
	FinishedAt          *float32 `json:"finishedAt,omitempty"`
	LatestScannedTime   *float32 `json:"latestScannedTime,omitempty"`
	ObjectCount         *float32 `json:"objectCount,omitempty"`
}

// DatasetOrigin defines model for DatasetOrigin.
type DatasetOrigin string

// DatasetProvider defines model for DatasetProvider.
type DatasetProvider = interface{}

// DatasetProviderType defines model for DatasetProviderType.
type DatasetProviderType struct {
	Description *string               `json:"description,omitempty"`
	Id          DatasetProviderTypeId `json:"id"`
	Locality    *OriginConfig         `json:"locality,omitempty"`
}

// DatasetProviderTypeId defines model for DatasetProviderType.Id.
type DatasetProviderTypeId string

// DatatypeOverrides defines model for DatatypeOverrides.
type DatatypeOverrides struct {
	BreakerRulesets *[]EventBreakerRuleset `json:"breakerRulesets,omitempty"`
	DisableBreakers bool                   `json:"disableBreakers"`
}

// DatatypePreviewInput defines model for DatatypePreviewInput.
type DatatypePreviewInput struct {
	Union json.RawMessage
}

// DatatypePreviewInput0 defines model for .
type DatatypePreviewInput0 struct {
	Dataset string                    `json:"dataset"`
	Type    DatatypePreviewInput0Type `json:"type"`
}

// DatatypePreviewInput0Type defines model for DatatypePreviewInput.0.Type.
type DatatypePreviewInput0Type string

// DatatypePreviewInput1 defines model for .
type DatatypePreviewInput1 struct {
	RawData string                    `json:"rawData"`
	Type    DatatypePreviewInput1Type `json:"type"`
}

// DatatypePreviewInput1Type defines model for DatatypePreviewInput.1.Type.
type DatatypePreviewInput1Type string

// DatatypePreviewRequestBody defines model for DatatypePreviewRequestBody.
type DatatypePreviewRequestBody struct {
	EventBreakerRule *EventBreakerRule    `json:"eventBreakerRule,omitempty"`
	Input            DatatypePreviewInput `json:"input"`
}

// DeployRequest defines model for DeployRequest.
type DeployRequest struct {
	Version string `json:"version"`
}

// Diag defines model for Diag.
type Diag struct {
	Id      string   `json:"id"`
	ModTime *float32 `json:"modTime,omitempty"`
	Path    string   `json:"path"`
	Size    *float32 `json:"size,omitempty"`
}

// DistributedSummary defines model for DistributedSummary.
type DistributedSummary struct {
	Groups struct {
		Count        float32 `json:"count"`
		Destinations float32 `json:"destinations"`
		Pipelines    float32 `json:"pipelines"`
		Routes       float32 `json:"routes"`
		Sources      float32 `json:"sources"`
	} `json:"groups"`
	Workers struct {
		Alive            float32 `json:"alive"`
		ConfVersions     float32 `json:"confVersions"`
		Count            float32 `json:"count"`
		Groups           float32 `json:"groups"`
		SoftwareVersions float32 `json:"softwareVersions"`
		Unhealthy        float32 `json:"unhealthy"`
	} `json:"workers"`
}

// DistributedUpgradeRequest defines model for DistributedUpgradeRequest.
type DistributedUpgradeRequest struct {
	// PackageUrls Provide your own URLs or local paths for platform-specific Cribl packages
	PackageUrls *[]struct {
		// PackageHashUrl Package's MD5 or SHA256 hash HTTP URL or local path
		PackageHashUrl *string `json:"packageHashUrl,omitempty"`

		// PackageUrl Package HTTP URL or local path
		PackageUrl string `json:"packageUrl"`
	} `json:"packageUrls,omitempty"`
	UpgradeMode *DistributedUpgradeRequestUpgradeMode `json:"upgradeMode,omitempty"`

	// UpgradePercentage Percentage of the total worker nodes on the group to run the upgrade on
	UpgradePercentage *float32 `json:"upgradePercentage,omitempty"`
	VersionTo         *string  `json:"versionTo,omitempty"`

	// WorkerRetries Number of times to retry conncecting to a worker node before marking the upgrade as failed.
	WorkerRetries *float32 `json:"workerRetries,omitempty"`

	// WorkerRetryDelay Delay between retries
	WorkerRetryDelay *float32 `json:"workerRetryDelay,omitempty"`
}

// DistributedUpgradeRequestUpgradeMode defines model for DistributedUpgradeRequest.UpgradeMode.
type DistributedUpgradeRequestUpgradeMode string

// DockerGraphDriver defines model for DockerGraphDriver.
type DockerGraphDriver struct {
	Data *DockerGraphDriverData `json:"Data,omitempty"`
}

// DockerGraphDriverData defines model for DockerGraphDriverData.
type DockerGraphDriverData struct {
	MergedDir string `json:"MergedDir"`
}

// DockerInfo defines model for DockerInfo.
type DockerInfo struct {
	Config          *map[string]interface{} `json:"Config,omitempty"`
	GraphDriver     *DockerGraphDriver      `json:"GraphDriver,omitempty"`
	LogPath         *string                 `json:"LogPath,omitempty"`
	Mounts          *[]DockerMount          `json:"Mounts,omitempty"`
	NetworkSettings *map[string]interface{} `json:"NetworkSettings,omitempty"`
	Path            *string                 `json:"Path,omitempty"`
	State           *map[string]interface{} `json:"State,omitempty"`
	Stats           *map[string]interface{} `json:"Stats,omitempty"`
}

// DockerMount defines model for DockerMount.
type DockerMount struct {
	Destination string `json:"Destination"`
	Source      string `json:"Source"`
}

// EdgeFile defines model for EdgeFile.
type EdgeFile struct {
	FilePath    string             `json:"filePath"`
	Id          string             `json:"id"`
	ModTime     float32            `json:"modTime"`
	Mode        string             `json:"mode"`
	Owner       float32            `json:"owner"`
	ProcessInfo *[]FileProcessInfo `json:"processInfo,omitempty"`
	Size        float32            `json:"size"`
}

// EdgeFileInspectResponse defines model for EdgeFileInspectResponse.
type EdgeFileInspectResponse = map[string]interface{}

// EdgeHeartbeatMetricsMode defines model for EdgeHeartbeatMetricsMode.
type EdgeHeartbeatMetricsMode string

// EdgeMapQueryResult defines model for EdgeMapQueryResult.
type EdgeMapQueryResult struct {
	WorkerInfo struct {
		Hostname string `json:"hostname"`
	} `json:"__worker_info"`
	WorkerNode string `json:"__worker_node"`
}

// EnvMetadata defines model for EnvMetadata.
type EnvMetadata = map[string]interface{}

// Error defines model for Error.
type Error struct {
	// Message Error message
	Message *string `json:"message,omitempty"`
}

// EventBreakerRule defines model for EventBreakerRule.
type EventBreakerRule struct {
	CleanFields       *bool                     `json:"cleanFields,omitempty"`
	Condition         string                    `json:"condition"`
	Delimiter         *string                   `json:"delimiter,omitempty"`
	DelimiterRegex    *string                   `json:"delimiterRegex,omitempty"`
	Disabled          *bool                     `json:"disabled,omitempty"`
	EscapeChar        *string                   `json:"escapeChar,omitempty"`
	EventBreakerRegex *string                   `json:"eventBreakerRegex,omitempty"`
	Fields            *[]EventBreakerRuleFields `json:"fields,omitempty"`
	FieldsLineRegex   *string                   `json:"fieldsLineRegex,omitempty"`
	HeaderLineRegex   *string                   `json:"headerLineRegex,omitempty"`
	JsonArrayField    *string                   `json:"jsonArrayField,omitempty"`
	JsonExtractAll    *bool                     `json:"jsonExtractAll,omitempty"`
	JsonTimeField     *string                   `json:"jsonTimeField,omitempty"`
	MaxEventBytes     float32                   `json:"maxEventBytes"`
	Name              string                    `json:"name"`
	NullFieldVal      *string                   `json:"nullFieldVal,omitempty"`
	Parser            *EventBreakerRule_Parser  `json:"parser,omitempty"`
	ParserEnabled     *bool                     `json:"parserEnabled,omitempty"`
	QuoteChar         *string                   `json:"quoteChar,omitempty"`
	ShouldUseDataRaw  *bool                     `json:"shouldUseDataRaw,omitempty"`
	TimeField         *string                   `json:"timeField,omitempty"`
	Timestamp         struct {
		Format *string                       `json:"format,omitempty"`
		Length *float32                      `json:"length,omitempty"`
		Type   EventBreakerRuleTimestampType `json:"type"`
	} `json:"timestamp"`
	TimestampAnchorRegex string                             `json:"timestampAnchorRegex"`
	TimestampEarliest    *string                            `json:"timestampEarliest,omitempty"`
	TimestampLatest      *string                            `json:"timestampLatest,omitempty"`
	TimestampTimezone    EventBreakerRule_TimestampTimezone `json:"timestampTimezone"`
	Type                 *EventBreakerRuleType              `json:"type,omitempty"`
}

// EventBreakerRuleParser0 defines model for .
type EventBreakerRuleParser0 struct {
	AllowedKeyChars   *bool                       `json:"allowedKeyChars,omitempty"`
	AllowedValueChars *[]string                   `json:"allowedValueChars,omitempty"`
	CleanFields       *[]string                   `json:"cleanFields,omitempty"`
	DelimChar         *string                     `json:"delimChar,omitempty"`
	DstField          *string                     `json:"dstField,omitempty"`
	EscapeChar        *string                     `json:"escapeChar,omitempty"`
	FieldFilterExpr   *string                     `json:"fieldFilterExpr,omitempty"`
	Fields            *[]string                   `json:"fields,omitempty"`
	Keep              *[]string                   `json:"keep,omitempty"`
	Mode              ParserMode                  `json:"mode"`
	NullValue         *string                     `json:"nullValue,omitempty"`
	QuoteChar         *string                     `json:"quoteChar,omitempty"`
	Remove            *[]string                   `json:"remove,omitempty"`
	SrcField          string                      `json:"srcField"`
	Type              EventBreakerRuleParser0Type `json:"type"`
}

// EventBreakerRuleParser0Type defines model for EventBreakerRule.Parser.0.Type.
type EventBreakerRuleParser0Type string

// EventBreakerRuleParser1 defines model for .
type EventBreakerRuleParser1 struct {
	DstField    *string    `json:"dstField,omitempty"`
	Mode        ParserMode `json:"mode"`
	Pattern     *string    `json:"pattern,omitempty"`
	PatternList *[]struct {
		Pattern string `json:"pattern"`
	} `json:"patternList,omitempty"`
	Source   *string                     `json:"source,omitempty"`
	SrcField string                      `json:"srcField"`
	Type     EventBreakerRuleParser1Type `json:"type"`
}

// EventBreakerRuleParser1Type defines model for EventBreakerRule.Parser.1.Type.
type EventBreakerRuleParser1Type string

// EventBreakerRuleParser2 defines model for .
type EventBreakerRuleParser2 struct {
	CleanFields     *[]string                   `json:"cleanFields,omitempty"`
	DstField        *string                     `json:"dstField,omitempty"`
	FieldFilterExpr *string                     `json:"fieldFilterExpr,omitempty"`
	Fields          *[]string                   `json:"fields,omitempty"`
	Keep            *[]string                   `json:"keep,omitempty"`
	Mode            ParserMode                  `json:"mode"`
	Remove          *[]string                   `json:"remove,omitempty"`
	SrcField        string                      `json:"srcField"`
	Type            EventBreakerRuleParser2Type `json:"type"`
}

// EventBreakerRuleParser2Type defines model for EventBreakerRule.Parser.2.Type.
type EventBreakerRuleParser2Type string

// EventBreakerRuleParser3 defines model for .
type EventBreakerRuleParser3 struct {
	AllowedKeyChars   *bool                       `json:"allowedKeyChars,omitempty"`
	AllowedValueChars *[]string                   `json:"allowedValueChars,omitempty"`
	CleanFields       *[]string                   `json:"cleanFields,omitempty"`
	DelimChar         *string                     `json:"delimChar,omitempty"`
	DstField          *string                     `json:"dstField,omitempty"`
	EscapeChar        *string                     `json:"escapeChar,omitempty"`
	FieldFilterExpr   *string                     `json:"fieldFilterExpr,omitempty"`
	Fields            *[]string                   `json:"fields,omitempty"`
	Keep              *[]string                   `json:"keep,omitempty"`
	Mode              ParserMode                  `json:"mode"`
	NullValue         *string                     `json:"nullValue,omitempty"`
	QuoteChar         *string                     `json:"quoteChar,omitempty"`
	Remove            *[]string                   `json:"remove,omitempty"`
	SrcField          string                      `json:"srcField"`
	Type              EventBreakerRuleParser3Type `json:"type"`
}

// EventBreakerRuleParser3Type defines model for EventBreakerRule.Parser.3.Type.
type EventBreakerRuleParser3Type string

// EventBreakerRule_Parser defines model for EventBreakerRule.Parser.
type EventBreakerRule_Parser struct {
	Union json.RawMessage
}

// EventBreakerRuleTimestampType defines model for EventBreakerRule.Timestamp.Type.
type EventBreakerRuleTimestampType string

// EventBreakerRuleTimestampTimezone0 defines model for .
type EventBreakerRuleTimestampTimezone0 = string

// EventBreakerRuleTimestampTimezone1 defines model for .
type EventBreakerRuleTimestampTimezone1 struct {
	Name    string    `json:"name"`
	Offsets []float32 `json:"offsets"`
	Untils  []float32 `json:"untils"`
}

// EventBreakerRule_TimestampTimezone defines model for EventBreakerRule.TimestampTimezone.
type EventBreakerRule_TimestampTimezone struct {
	Union json.RawMessage
}

// EventBreakerRuleType defines model for EventBreakerRule.Type.
type EventBreakerRuleType string

// EventBreakerRuleFields defines model for EventBreakerRuleFields.
type EventBreakerRuleFields struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// EventBreakerRuleset defines model for EventBreakerRuleset.
type EventBreakerRuleset struct {
	Description *string                 `json:"description,omitempty"`
	Id          string                  `json:"id"`
	Lib         *EventBreakerRulesetLib `json:"lib,omitempty"`

	// MinRawLength The  minimum number of characters in _raw to determine which rule to use
	MinRawLength *float32 `json:"minRawLength,omitempty"`

	// Rules A list of rules that will be applied, in order, to the input data stream
	Rules *[]struct {
		// Condition The JavaScript filter expression used to match the data to apply the rule to
		Condition string `json:"condition"`

		// Disabled Disable this breaker rule (enabled by default)
		Disabled *bool `json:"disabled,omitempty"`

		// Fields Key-value pairs to be added to each event
		Fields *[]struct {
			Name *string `json:"name,omitempty"`

			// Value The JavaScript expression used to compute the field's value (can be constant)
			Value string `json:"value"`
		} `json:"fields,omitempty"`

		// MaxEventBytes The maximum number of bytes in an event before it is flushed to the pipelines
		MaxEventBytes *float32 `json:"maxEventBytes,omitempty"`
		Name          string   `json:"name"`
		ParserEnabled *bool    `json:"parserEnabled,omitempty"`

		// ShouldUseDataRaw Enable to set an internal field on events indicating that the field in the data called _raw should be used. This can be useful for post processors that want to use that field for event._raw, instead of replacing it with the actual raw event.
		ShouldUseDataRaw *bool `json:"shouldUseDataRaw,omitempty"`

		// Timestamp Auto, manual format (strptime), or current time
		Timestamp struct {
			Format *string                               `json:"format,omitempty"`
			Length *float32                              `json:"length,omitempty"`
			Type   EventBreakerRulesetRulesTimestampType `json:"type"`
		} `json:"timestamp"`

		// TimestampAnchorRegex The regex to match before attempting timestamp extraction. Use $ (end-of-string anchor) to prevent extraction.
		TimestampAnchorRegex string `json:"timestampAnchorRegex"`

		// TimestampEarliest The earliest timestamp value allowed relative to now. Example: -42years. Parsed values prior to this date will be set to current time.
		TimestampEarliest *string `json:"timestampEarliest,omitempty"`

		// TimestampLatest The latest timestamp value allowed relative to now. Example: +42days. Parsed values after this date will be set to current time.
		TimestampLatest *string `json:"timestampLatest,omitempty"`

		// TimestampTimezone Timezone to assign to timestamps without timezone info
		TimestampTimezone *string                      `json:"timestampTimezone,omitempty"`
		Type              EventBreakerRulesetRulesType `json:"type"`
	} `json:"rules,omitempty"`
	Tags *string `json:"tags,omitempty"`
}

// EventBreakerRulesetLib defines model for EventBreakerRuleset.Lib.
type EventBreakerRulesetLib string

// EventBreakerRulesetRulesTimestampType defines model for EventBreakerRuleset.Rules.Timestamp.Type.
type EventBreakerRulesetRulesTimestampType string

// EventBreakerRulesetRulesType defines model for EventBreakerRuleset.Rules.Type.
type EventBreakerRulesetRulesType string

// Executor defines model for Executor.
type Executor = Function

// ExprLibEntry defines model for ExprLibEntry.
type ExprLibEntry struct {
	Context  *map[string]interface{} `json:"context,omitempty"`
	EvalType *string                 `json:"evalType,omitempty"`

	// Expr JavaScript expression to evaluate
	Expr        string                  `json:"expr"`
	Id          string                  `json:"id"`
	Pack        *string                 `json:"pack,omitempty"`
	Result      *map[string]interface{} `json:"result,omitempty"`
	Unprotected *bool                   `json:"unprotected,omitempty"`
}

// FeaturesEntry defines model for FeaturesEntry.
type FeaturesEntry struct {
	Disabled bool   `json:"disabled"`
	Id       string `json:"id"`
}

// FileProcessInfo defines model for FileProcessInfo.
type FileProcessInfo struct {
	Pid     float32 `json:"pid"`
	Process string  `json:"process"`
}

// FilesystemEntry defines model for FilesystemEntry.
type FilesystemEntry struct {
	Mode        *string                 `json:"mode,omitempty"`
	Name        string                  `json:"name"`
	Stats       *map[string]interface{} `json:"stats,omitempty"`
	SymLinkInfo *SymLinkInfo            `json:"symLinkInfo,omitempty"`
	Type        string                  `json:"type"`
}

// Filter defines model for Filter.
type Filter float32

// Format defines model for Format.
type Format string

// Function defines model for Function.
type Function struct {
	Conf     map[string]interface{} `json:"__conf"`
	Filename string                 `json:"__filename"`
	Disabled bool                   `json:"disabled"`
	Group    string                 `json:"group"`
	Id       string                 `json:"id"`
	InitTime float32                `json:"initTime"`
	LoadTime float32                `json:"loadTime"`
	ModTime  float32                `json:"modTime"`
	Name     string                 `json:"name"`
	Uischema map[string]interface{} `json:"uischema"`
	Version  string                 `json:"version"`
}

// GetNamesOpts defines model for GetNamesOpts.
type GetNamesOpts struct {
	DimKeyFilter     *Filter  `json:"dimKeyFilter,omitempty"`
	DimValueFilter   *Filter  `json:"dimValueFilter,omitempty"`
	Earliest         *float32 `json:"earliest,omitempty"`
	FilterExpr       *Default `json:"filterExpr,omitempty"`
	MaxValues        *float32 `json:"maxValues,omitempty"`
	MetricNameFilter *Filter  `json:"metricNameFilter,omitempty"`
}

// GitCommitParams defines model for GitCommitParams.
type GitCommitParams struct {
	Effective *bool     `json:"effective,omitempty"`
	Files     *[]string `json:"files,omitempty"`
	Group     *string   `json:"group,omitempty"`
	Message   string    `json:"message"`
}

// GitCommitSummary defines model for GitCommitSummary.
type GitCommitSummary struct {
	Author struct {
		Email string `json:"email"`
		Name  string `json:"name"`
	} `json:"author"`
	Branch string `json:"branch"`
	Commit string `json:"commit"`
	Files  struct {
		Created  *[]string `json:"created,omitempty"`
		Deleted  *[]string `json:"deleted,omitempty"`
		Modified *[]string `json:"modified,omitempty"`
		Renamed  *[]string `json:"renamed,omitempty"`
	} `json:"files"`
	Summary struct {
		Changes    float32 `json:"changes"`
		Deletions  float32 `json:"deletions"`
		Insertions float32 `json:"insertions"`
	} `json:"summary"`
}

// GitFile defines model for GitFile.
type GitFile struct {
	Children *[]GitFile `json:"children,omitempty"`
	Name     string     `json:"name"`
	State    *string    `json:"state,omitempty"`
}

// GitFilesResponse defines model for GitFilesResponse.
type GitFilesResponse struct {
	CommitMessage map[string]interface{} `json:"commitMessage"`
	Count         float32                `json:"count"`
	Items         []GitFile              `json:"items"`
}

// GitInfo defines model for GitInfo.
type GitInfo struct {
	Remote     GitInfo_Remote `json:"remote"`
	Versioning bool           `json:"versioning"`
}

// GitInfoRemote0 defines model for .
type GitInfoRemote0 = string

// GitInfoRemote1 defines model for .
type GitInfoRemote1 = bool

// GitInfo_Remote defines model for GitInfo.Remote.
type GitInfo_Remote struct {
	Union json.RawMessage
}

// GitOpsType defines model for GitOpsType.
type GitOpsType string

// GitRevertParams defines model for GitRevertParams.
type GitRevertParams struct {
	Commit  string `json:"commit"`
	Force   *bool  `json:"force,omitempty"`
	Message string `json:"message"`
}

// GitRevertResult defines model for GitRevertResult.
type GitRevertResult struct {
	Audit struct {
		Files struct {
			Created  *[]string `json:"created,omitempty"`
			Deleted  *[]string `json:"deleted,omitempty"`
			Modified *[]string `json:"modified,omitempty"`
			Renamed  *[]string `json:"renamed,omitempty"`
		} `json:"files"`
		Group string `json:"group"`
		Id    string `json:"id"`
	} `json:"audit"`
	Reverted bool `json:"reverted"`
}

// GitSettings defines model for GitSettings.
type GitSettings struct {
	AuthType                 *string     `json:"authType,omitempty"`
	AutoAction               *string     `json:"autoAction,omitempty"`
	AutoActionMessage        *string     `json:"autoActionMessage,omitempty"`
	AutoActionSchedule       *string     `json:"autoActionSchedule,omitempty"`
	Branch                   *string     `json:"branch,omitempty"`
	CommitDeploySingleAction *bool       `json:"commitDeploySingleAction,omitempty"`
	DefaultCommitMessage     *string     `json:"defaultCommitMessage,omitempty"`
	GitOps                   *GitOpsType `json:"gitOps,omitempty"`
	Password                 *string     `json:"password,omitempty"`
	Remote                   *string     `json:"remote,omitempty"`
	SshKey                   *string     `json:"sshKey,omitempty"`
	StrictHostKeyChecking    *bool       `json:"strictHostKeyChecking,omitempty"`
	Timeout                  *float32    `json:"timeout,omitempty"`
	User                     *string     `json:"user,omitempty"`
}

// GitStatusResult defines model for GitStatusResult.
type GitStatusResult struct {
	Ahead      float32  `json:"ahead"`
	Behind     float32  `json:"behind"`
	Conflicted []string `json:"conflicted"`
	Created    []string `json:"created"`
	Current    string   `json:"current"`
	Deleted    []string `json:"deleted"`
	Files      []struct {
		Index      string `json:"index"`
		Path       string `json:"path"`
		WorkingDir string `json:"working_dir"`
	} `json:"files"`
	Modified []string `json:"modified"`
	NotAdded []string `json:"not_added"`
	Renamed  []struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"renamed"`
	Staged   []string `json:"staged"`
	Tracking string   `json:"tracking"`
}

// GlobalVar defines model for GlobalVar.
type GlobalVar struct {
	// Description Brief description of this variable. Optional.
	Description *string `json:"description,omitempty"`

	// Id Global variable name.
	Id  string  `json:"id"`
	Lib *string `json:"lib,omitempty"`

	// Tags One or more tags related to this variable. Optional.
	Tags *string `json:"tags,omitempty"`

	// Type Type of variable
	Type GlobalVarType `json:"type"`

	// Value Value of variable
	Value string `json:"value"`
}

// GlobalVarType Type of variable
type GlobalVarType string

// GrokFile defines model for GrokFile.
type GrokFile struct {
	Content string  `json:"content"`
	Id      string  `json:"id"`
	Size    float32 `json:"size"`
	Tags    *string `json:"tags,omitempty"`
}

// HBCriblInfo defines model for HBCriblInfo.
type HBCriblInfo struct {
	Config struct {
		FeaturesRev     *string  `json:"featuresRev,omitempty"`
		HbPeriodSeconds *float32 `json:"hbPeriodSeconds,omitempty"`
		LogStreamEnv    *string  `json:"logStreamEnv,omitempty"`
		PolicyRev       *string  `json:"policyRev,omitempty"`
		Version         *string  `json:"version,omitempty"`
	} `json:"config"`
	DeploymentId *string       `json:"deploymentId,omitempty"`
	DistMode     AppMode       `json:"distMode"`
	EdgeNodes    *float32      `json:"edgeNodes,omitempty"`
	Group        string        `json:"group"`
	Guid         string        `json:"guid"`
	InstallType  *string       `json:"installType,omitempty"`
	Master       *HBLeaderInfo `json:"master,omitempty"`
	Pid          *float32      `json:"pid,omitempty"`
	StartTime    float32       `json:"startTime"`
	Tags         []string      `json:"tags"`
	Version      *string       `json:"version,omitempty"`
}

// HBLeaderInfo defines model for HBLeaderInfo.
type HBLeaderInfo struct {
	Host       string  `json:"host"`
	Port       float32 `json:"port"`
	Servername *string `json:"servername,omitempty"`
	Tls        *bool   `json:"tls,omitempty"`
}

// HTTPOutAuthConfig defines model for HTTPOutAuthConfig.
type HTTPOutAuthConfig struct {
	Disabled *bool   `json:"disabled,omitempty"`
	Password *string `json:"password,omitempty"`
	Token    *string `json:"token,omitempty"`
	Username *string `json:"username,omitempty"`
}

// HTTPOutExtraParamConfig defines model for HTTPOutExtraParamConfig.
type HTTPOutExtraParamConfig struct {
	Name  string  `json:"name"`
	Value Unknown `json:"value"`
}

// HTTPOutResponseRetryConfig defines model for HTTPOutResponseRetryConfig.
type HTTPOutResponseRetryConfig struct {
	BackoffRate    *float32 `json:"backoffRate,omitempty"`
	HttpStatus     *float32 `json:"httpStatus,omitempty"`
	InitialBackoff *float32 `json:"initialBackoff,omitempty"`
	MaxBackoff     *float32 `json:"maxBackoff,omitempty"`
}

// HeartbeatMetadata defines model for HeartbeatMetadata.
type HeartbeatMetadata struct {
	Aws *struct {
		Enabled bool                    `json:"enabled"`
		Region  string                  `json:"region"`
		Tags    *map[string]interface{} `json:"tags,omitempty"`
		Type    string                  `json:"type"`
		Zone    string                  `json:"zone"`
	} `json:"aws,omitempty"`
	HostOs *struct {
		Addresses []string `json:"addresses"`
		Enabled   bool     `json:"enabled"`
		Id        string   `json:"id"`
		Version   string   `json:"version"`
	} `json:"hostOs,omitempty"`
	Kube *struct {
		Enabled   bool   `json:"enabled"`
		Namespace string `json:"namespace"`
		Node      string `json:"node"`
		Owner     *struct {
			Kind string `json:"kind"`
			Name string `json:"name"`
		} `json:"owner,omitempty"`
		Pod    string `json:"pod"`
		Source string `json:"source"`
	} `json:"kube,omitempty"`
	Os *struct {
		Addresses []string `json:"addresses"`
		Enabled   bool     `json:"enabled"`
		Id        string   `json:"id"`
		Version   string   `json:"version"`
	} `json:"os,omitempty"`
}

// HmacFunction defines model for HmacFunction.
type HmacFunction struct {
	Description      *string  `json:"description,omitempty"`
	HeaderExpression string   `json:"headerExpression"`
	HeaderName       string   `json:"headerName"`
	Id               string   `json:"id"`
	Lib              CriblLib `json:"lib"`
	StringBuilders   []string `json:"stringBuilders"`
	StringDelim      *string  `json:"stringDelim,omitempty"`
}

// Input defines model for Input.
type Input struct {
	Union json.RawMessage
}

// InputAppscope defines model for InputAppscope.
type InputAppscope struct {
	// AuthToken Shared secret to be provided by any client (in authToken header field). If empty, unauthed access is permitted.
	AuthToken *string `json:"authToken,omitempty"`

	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *InputAppscopeAuthType `json:"authType,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// EnableUnixPath Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
	EnableUnixPath *InputAppscopeEnableUnixPath `json:"enableUnixPath,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Filter      *struct {
		// Allow Specify processes that AppScope should be loaded into, and the config to use.
		Allow *[]struct {
			// Arg Specify a string to substring-match against process command-line.
			Arg *string `json:"arg,omitempty"`

			// Config Choose a config to apply to processes that match the process name and/or argument.
			Config string `json:"config"`

			// Procname Specify the name of a process or family of processes.
			Procname string `json:"procname"`
		} `json:"allow,omitempty"`

		// TransportURL To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
		TransportURL *string `json:"transportURL,omitempty"`
	} `json:"filter,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host *string `json:"host,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to establish a connection.
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Select data compression format. Optional.
		Compress *InputAppscopePersistenceCompress `json:"compress,omitempty"`

		// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope
		DestPath *string `json:"destPath,omitempty"`

		// Enable Spool events and metrics on disk for Cribl Edge and Search
		Enable *InputAppscopePersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time span for each file bucket
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port *float32 `json:"port,omitempty"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputAppscopePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputAppscopePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputAppscopePqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputAppscopeSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                   `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}              `json:"commonNameRegex,omitempty"`
		Disabled        *InputAppscopeTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputAppscopeTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputAppscopeTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type InputAppscopeType `json:"type"`

	// UnixSocketPath Path to the UNIX domain socket to listen on.
	UnixSocketPath *string `json:"unixSocketPath,omitempty"`

	// UnixSocketPerms Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
	UnixSocketPerms *string `json:"unixSocketPerms,omitempty"`
}

// InputAppscopeAuthType Enter a token directly, or provide a secret referencing a token
type InputAppscopeAuthType string

// InputAppscopeEnableUnixPath Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
type InputAppscopeEnableUnixPath bool

// InputAppscopePersistenceCompress Select data compression format. Optional.
type InputAppscopePersistenceCompress string

// InputAppscopePersistenceEnable Spool events and metrics on disk for Cribl Edge and Search
type InputAppscopePersistenceEnable bool

// InputAppscopePqCompress Codec to use to compress the persisted data.
type InputAppscopePqCompress string

// InputAppscopePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputAppscopePqMode string

// InputAppscopePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputAppscopePqEnabled bool

// InputAppscopeSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputAppscopeSendToRoutes bool

// InputAppscopeTlsDisabled defines model for InputAppscope.Tls.Disabled.
type InputAppscopeTlsDisabled bool

// InputAppscopeTlsMaxVersion Maximum TLS version to accept from connections
type InputAppscopeTlsMaxVersion string

// InputAppscopeTlsMinVersion Minimum TLS version to accept from connections
type InputAppscopeTlsMinVersion string

// InputAppscopeType defines model for InputAppscope.Type.
type InputAppscopeType string

// InputAzureBlob defines model for InputAzureBlob.
type InputAzureBlob struct {
	// AuthType Enter connection string directly, or select a stored secret
	AuthType *InputAzureBlobAuthType `json:"authType,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`
	Certificate     *struct {
		// CertificateName The certificate you registered as credentials for your app in the Azure portal
		CertificateName string `json:"certificateName"`
	} `json:"certificate,omitempty"`

	// ClientId The service principal's client ID
	ClientId *string `json:"clientId,omitempty"`

	// ClientTextSecret Select or create a stored text secret
	ClientTextSecret *string `json:"clientTextSecret,omitempty"`

	// ConnectionString Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileFilter Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxMessages The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// ParquetChunkDownloadTimeout The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float32 `json:"parquetChunkDownloadTimeout,omitempty"`

	// ParquetChunkSizeMB Maximum file size for each Parquet chunk.
	ParquetChunkSizeMB *float32 `json:"parquetChunkSizeMB,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputAzureBlobPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputAzureBlobPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputAzureBlobPqEnabled `json:"pqEnabled,omitempty"`

	// QueueName The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myQueue-${C.vars.myVar}`
	QueueName string `json:"queueName"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputAzureBlobSendToRoutes `json:"sendToRoutes,omitempty"`

	// ServicePeriodSecs The duration (in seconds) which pollers should be validated and restarted if exited
	ServicePeriodSecs *float32 `json:"servicePeriodSecs,omitempty"`

	// SkipOnError Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// StorageAccountName The name of your Azure storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TenantId The service principal's tenant ID
	TenantId *string `json:"tenantId,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string            `json:"textSecret,omitempty"`
	Type       InputAzureBlobType `json:"type"`

	// VisibilityTimeout The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputAzureBlobAuthType Enter connection string directly, or select a stored secret
type InputAzureBlobAuthType string

// InputAzureBlobPqCompress Codec to use to compress the persisted data.
type InputAzureBlobPqCompress string

// InputAzureBlobPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputAzureBlobPqMode string

// InputAzureBlobPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputAzureBlobPqEnabled bool

// InputAzureBlobSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputAzureBlobSendToRoutes bool

// InputAzureBlobType defines model for InputAzureBlob.Type.
type InputAzureBlobType string

// InputCollection defines model for InputCollection.
type InputCollection struct {
	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Disabled *bool `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Output Destination to send results to
	Output *string `json:"output,omitempty"`

	// Pipeline Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCollectionPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCollectionPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputCollectionPqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputCollectionPreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// SendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
	SendToRoutes *InputCollectionSendToRoutes `json:"sendToRoutes,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string             `json:"throttleRatePerSec,omitempty"`
	Type               InputCollectionType `json:"type"`
}

// InputCollectionPqCompress Codec to use to compress the persisted data.
type InputCollectionPqCompress string

// InputCollectionPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCollectionPqMode string

// InputCollectionPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCollectionPqEnabled bool

// InputCollectionPreprocessDisabled Enable Custom Command
type InputCollectionPreprocessDisabled bool

// InputCollectionSendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
type InputCollectionSendToRoutes bool

// InputCollectionType defines model for InputCollection.Type.
type InputCollectionType string

// InputConfluentCloud defines model for InputConfluentCloud.
type InputConfluentCloud struct {
	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// AutoCommitInterval How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float32 `json:"autoCommitInterval,omitempty"`

	// AutoCommitThreshold How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float32 `json:"autoCommitThreshold,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
	Brokers []string `json:"brokers"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FromBeginning Leave toggled to 'Yes' if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`

	// GroupId Specifies the consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupId *string `json:"groupId,omitempty"`

	// HeartbeatInterval
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities.
	//       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms).
	HeartbeatInterval *float32 `json:"heartbeatInterval,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled InputConfluentCloudKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// Disabled Enable Schema Registry
		Disabled InputConfluentCloudKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                            `json:"certificateName,omitempty"`
			Disabled        *InputConfluentCloudKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *InputConfluentCloudKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxBytes Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float32 `json:"maxBytes,omitempty"`

	// MaxBytesPerPartition Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float32 `json:"maxBytesPerPartition,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// MaxSocketErrors Maximum number of network errors before the consumer recreates a socket.
	MaxSocketErrors *float32 `json:"maxSocketErrors,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputConfluentCloudPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputConfluentCloudPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputConfluentCloudPqEnabled `json:"pqEnabled,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RebalanceTimeout
	//       Maximum allowed time for each worker to join the group after a rebalance has begun.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See details [here](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms).
	RebalanceTimeout *float32 `json:"rebalanceTimeout,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable Authentication
		Disabled InputConfluentCloudSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use.
		Mechanism *InputConfluentCloudSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputConfluentCloudSendToRoutes `json:"sendToRoutes,omitempty"`

	// SessionTimeout
	//       Timeout used to detect client failures when using Kafka's group management facilities.
	//       If the client sends the broker no heartbeats before this timeout expires,
	//       the broker will remove this client from the group, and will initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms).
	SessionTimeout *float32 `json:"sessionTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                         `json:"certificateName,omitempty"`
		Disabled        *InputConfluentCloudTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *InputConfluentCloudTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *InputConfluentCloudTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topics Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to only a single topic.
	Topics []string                 `json:"topics"`
	Type   *InputConfluentCloudType `json:"type,omitempty"`
}

// InputConfluentCloudKafkaSchemaRegistryAuthDisabled Enable authentication
type InputConfluentCloudKafkaSchemaRegistryAuthDisabled bool

// InputConfluentCloudKafkaSchemaRegistryDisabled Enable Schema Registry
type InputConfluentCloudKafkaSchemaRegistryDisabled bool

// InputConfluentCloudKafkaSchemaRegistryTlsDisabled defines model for InputConfluentCloud.KafkaSchemaRegistry.Tls.Disabled.
type InputConfluentCloudKafkaSchemaRegistryTlsDisabled bool

// InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type InputConfluentCloudKafkaSchemaRegistryTlsMaxVersion string

// InputConfluentCloudKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type InputConfluentCloudKafkaSchemaRegistryTlsMinVersion string

// InputConfluentCloudPqCompress Codec to use to compress the persisted data.
type InputConfluentCloudPqCompress string

// InputConfluentCloudPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputConfluentCloudPqMode string

// InputConfluentCloudPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputConfluentCloudPqEnabled bool

// InputConfluentCloudSaslDisabled Enable Authentication
type InputConfluentCloudSaslDisabled bool

// InputConfluentCloudSaslMechanism SASL authentication mechanism to use.
type InputConfluentCloudSaslMechanism string

// InputConfluentCloudSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputConfluentCloudSendToRoutes bool

// InputConfluentCloudTlsDisabled defines model for InputConfluentCloud.Tls.Disabled.
type InputConfluentCloudTlsDisabled bool

// InputConfluentCloudTlsMaxVersion Maximum TLS version to use when connecting
type InputConfluentCloudTlsMaxVersion string

// InputConfluentCloudTlsMinVersion Minimum TLS version to use when connecting
type InputConfluentCloudTlsMinVersion string

// InputConfluentCloudType defines model for InputConfluentCloud.Type.
type InputConfluentCloudType string

// InputCribl defines model for InputCribl.
type InputCribl struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Filter      *string `json:"filter,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCriblPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCriblPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputCriblPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputCriblSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string      `json:"streamtags,omitempty"`
	Type       InputCriblType `json:"type"`
}

// InputCriblPqCompress Codec to use to compress the persisted data.
type InputCriblPqCompress string

// InputCriblPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCriblPqMode string

// InputCriblPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCriblPqEnabled bool

// InputCriblSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputCriblSendToRoutes bool

// InputCriblType defines model for InputCribl.Type.
type InputCriblType string

// InputCriblHttp defines model for InputCriblHttp.
type InputCriblHttp struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthed access is permitted.
	AuthTokens *[]string `json:"authTokens,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCriblHttpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCriblHttpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputCriblHttpPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputCriblHttpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                    `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}               `json:"commonNameRegex,omitempty"`
		Disabled        *InputCriblHttpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputCriblHttpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputCriblHttpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputCriblHttpType `json:"type,omitempty"`
}

// InputCriblHttpPqCompress Codec to use to compress the persisted data.
type InputCriblHttpPqCompress string

// InputCriblHttpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCriblHttpPqMode string

// InputCriblHttpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCriblHttpPqEnabled bool

// InputCriblHttpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputCriblHttpSendToRoutes bool

// InputCriblHttpTlsDisabled defines model for InputCriblHttp.Tls.Disabled.
type InputCriblHttpTlsDisabled bool

// InputCriblHttpTlsMaxVersion Maximum TLS version to accept from connections
type InputCriblHttpTlsMaxVersion string

// InputCriblHttpTlsMinVersion Minimum TLS version to accept from connections
type InputCriblHttpTlsMinVersion string

// InputCriblHttpType defines model for InputCriblHttp.Type.
type InputCriblHttpType string

// InputCriblTcp defines model for InputCriblTcp.
type InputCriblTcp struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableLoadBalancing Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCriblTcpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCriblTcpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputCriblTcpPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputCriblTcpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                   `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}              `json:"commonNameRegex,omitempty"`
		Disabled        *InputCriblTcpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputCriblTcpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputCriblTcpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputCriblTcpType `json:"type,omitempty"`
}

// InputCriblTcpPqCompress Codec to use to compress the persisted data.
type InputCriblTcpPqCompress string

// InputCriblTcpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCriblTcpPqMode string

// InputCriblTcpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCriblTcpPqEnabled bool

// InputCriblTcpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputCriblTcpSendToRoutes bool

// InputCriblTcpTlsDisabled defines model for InputCriblTcp.Tls.Disabled.
type InputCriblTcpTlsDisabled bool

// InputCriblTcpTlsMaxVersion Maximum TLS version to accept from connections
type InputCriblTcpTlsMaxVersion string

// InputCriblTcpTlsMinVersion Minimum TLS version to accept from connections
type InputCriblTcpTlsMinVersion string

// InputCriblTcpType defines model for InputCriblTcp.Type.
type InputCriblTcpType string

// InputCriblmetrics defines model for InputCriblmetrics.
type InputCriblmetrics struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FullFidelity Include granular metrics.  Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
	FullFidelity *bool `json:"fullFidelity,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCriblmetricsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCriblmetricsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputCriblmetricsPqEnabled `json:"pqEnabled,omitempty"`

	// Prefix A prefix that is applied to the metrics provided by Cribl Stream
	Prefix *string `json:"prefix,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputCriblmetricsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string             `json:"streamtags,omitempty"`
	Type       InputCriblmetricsType `json:"type"`
}

// InputCriblmetricsPqCompress Codec to use to compress the persisted data.
type InputCriblmetricsPqCompress string

// InputCriblmetricsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCriblmetricsPqMode string

// InputCriblmetricsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCriblmetricsPqEnabled bool

// InputCriblmetricsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputCriblmetricsSendToRoutes bool

// InputCriblmetricsType defines model for InputCriblmetrics.Type.
type InputCriblmetricsType string

// InputCrowdstrike defines model for InputCrowdstrike.
type InputCrowdstrike struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputCrowdstrikeAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`
	Checkpointing   *struct {
		// Enabled Enable checkpointing to resume processing files after an interruption.
		Enabled InputCrowdstrikeCheckpointingEnabled `json:"enabled"`

		// Retries If checkpointing is enabled, the number of times to retry processing when a processing error occurs. If skip file on error is enabled, this setting is ignored.
		Retries *float32 `json:"retries,omitempty"`
	} `json:"checkpointing,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnableSQSAssumeRole Use Assume Role credentials when accessing SQS.
	EnableSQSAssumeRole *bool `json:"enableSQSAssumeRole,omitempty"`

	// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileFilter Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxMessages The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PollTimeout The amount of time to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float32 `json:"pollTimeout,omitempty"`
	Pq          *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputCrowdstrikePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputCrowdstrikePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputCrowdstrikePqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputCrowdstrikePreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// Region AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputCrowdstrikeSendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *InputCrowdstrikeSignatureVersion `json:"signatureVersion,omitempty"`

	// SkipOnError Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`

	// SocketTimeout Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string            `json:"streamtags,omitempty"`
	Type       InputCrowdstrikeType `json:"type"`

	// VisibilityTimeout After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputCrowdstrikeAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputCrowdstrikeAwsAuthenticationMethod string

// InputCrowdstrikeCheckpointingEnabled Enable checkpointing to resume processing files after an interruption.
type InputCrowdstrikeCheckpointingEnabled bool

// InputCrowdstrikePqCompress Codec to use to compress the persisted data.
type InputCrowdstrikePqCompress string

// InputCrowdstrikePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputCrowdstrikePqMode string

// InputCrowdstrikePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputCrowdstrikePqEnabled bool

// InputCrowdstrikePreprocessDisabled Enable Custom Command
type InputCrowdstrikePreprocessDisabled bool

// InputCrowdstrikeSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputCrowdstrikeSendToRoutes bool

// InputCrowdstrikeSignatureVersion Signature version to use for signing S3 requests
type InputCrowdstrikeSignatureVersion string

// InputCrowdstrikeType defines model for InputCrowdstrike.Type.
type InputCrowdstrikeType string

// InputDatadogAgent defines model for InputDatadogAgent.
type InputDatadogAgent struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtractMetrics Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputDatadogAgentPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputDatadogAgentPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputDatadogAgentPqEnabled `json:"pqEnabled,omitempty"`
	ProxyMode *struct {
		// Enabled Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
		Enabled InputDatadogAgentProxyModeEnabled `json:"enabled"`

		// RejectUnauthorized Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	} `json:"proxyMode,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputDatadogAgentSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                       `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}                  `json:"commonNameRegex,omitempty"`
		Disabled        *InputDatadogAgentTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputDatadogAgentTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputDatadogAgentTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputDatadogAgentType `json:"type,omitempty"`
}

// InputDatadogAgentPqCompress Codec to use to compress the persisted data.
type InputDatadogAgentPqCompress string

// InputDatadogAgentPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputDatadogAgentPqMode string

// InputDatadogAgentPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputDatadogAgentPqEnabled bool

// InputDatadogAgentProxyModeEnabled Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
type InputDatadogAgentProxyModeEnabled bool

// InputDatadogAgentSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputDatadogAgentSendToRoutes bool

// InputDatadogAgentTlsDisabled defines model for InputDatadogAgent.Tls.Disabled.
type InputDatadogAgentTlsDisabled bool

// InputDatadogAgentTlsMaxVersion Maximum TLS version to accept from connections
type InputDatadogAgentTlsMaxVersion string

// InputDatadogAgentTlsMinVersion Minimum TLS version to accept from connections
type InputDatadogAgentTlsMinVersion string

// InputDatadogAgentType defines model for InputDatadogAgent.Type.
type InputDatadogAgentType string

// InputDatagen defines model for InputDatagen.
type InputDatagen struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputDatagenPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputDatagenPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputDatagenPqEnabled `json:"pqEnabled,omitempty"`

	// Samples List of datagens
	Samples []struct {
		// EventsPerSec Maximum no. of events to generate per second per worker node. Defaults to 10.
		EventsPerSec float32 `json:"eventsPerSec"`

		// Sample Name of the datagen file
		Sample string `json:"sample"`
	} `json:"samples"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputDatagenSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string        `json:"streamtags,omitempty"`
	Type       InputDatagenType `json:"type"`
}

// InputDatagenPqCompress Codec to use to compress the persisted data.
type InputDatagenPqCompress string

// InputDatagenPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputDatagenPqMode string

// InputDatagenPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputDatagenPqEnabled bool

// InputDatagenSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputDatagenSendToRoutes bool

// InputDatagenType defines model for InputDatagen.Type.
type InputDatagenType string

// InputEdgePrometheus defines model for InputEdgePrometheus.
type InputEdgePrometheus struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AuthType Enter credentials directly, or select a stored secret
	AuthType *InputEdgePrometheusAuthType `json:"authType,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputEdgePrometheusAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// DimensionList Other dimensions to include in events
	DimensionList *[]string `json:"dimensionList,omitempty"`
	Disabled      *bool     `json:"disabled,omitempty"`

	// DiscoveryType Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType InputEdgePrometheusDiscoveryType `json:"discoveryType"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint EC2 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval How often in seconds to scrape targets for metrics.
	Interval float32 `json:"interval"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NameList List of DNS names to resolve
	NameList *[]string `json:"nameList,omitempty"`

	// Password Password for Prometheus Basic authentication
	Password    *string `json:"password,omitempty"`
	Persistence *struct {
		// Compress Data compression format. Default is gzip.
		Compress *InputEdgePrometheusPersistenceCompress `json:"compress,omitempty"`

		// Enable Spool events on disk for Cribl Edge and Search. Default is disabled.
		Enable *InputEdgePrometheusPersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time period for grouping spooled events. Default is 10m.
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PodFilter
	//   Add rules to decide which pods to discover for metrics.
	//   Pods are searched if no rules are given or of all the rules'
	//   expressions evaluate to true.
	PodFilter *[]struct {
		// Description Optional description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression applied to pods objects. Return 'true' to include it.
		Filter string `json:"filter"`
	} `json:"podFilter,omitempty"`
	Pq *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputEdgePrometheusPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputEdgePrometheusPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputEdgePrometheusPqEnabled `json:"pqEnabled,omitempty"`

	// RecordType DNS Record type to resolve
	RecordType *InputEdgePrometheusRecordType `json:"recordType,omitempty"`

	// Region Region where the EC2 is located
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ScrapePath Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`

	// ScrapePathExpr Path to use when collecting metrics from discovered targets
	ScrapePathExpr *string `json:"scrapePathExpr,omitempty"`

	// ScrapePort The port number in the metrics URL for discovered targets.
	ScrapePort *float32 `json:"scrapePort,omitempty"`

	// ScrapePortExpr The port number in the metrics URL for discovered targets.
	ScrapePortExpr *string `json:"scrapePortExpr,omitempty"`

	// ScrapeProtocol Protocol to use when collecting metrics
	ScrapeProtocol *InputEdgePrometheusScrapeProtocol `json:"scrapeProtocol,omitempty"`

	// ScrapeProtocolExpr Protocol to use when collecting metrics
	ScrapeProtocolExpr *string `json:"scrapeProtocolExpr,omitempty"`

	// SearchFilter EC2 Instance Search Filter
	SearchFilter *[]struct {
		// Name Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
		Name string `json:"Name"`

		// Values Search Filter Values, if empty only "running" EC2 instances will be returned
		Values []string `json:"Values"`
	} `json:"searchFilter,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputEdgePrometheusSendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing EC2 requests
	SignatureVersion *InputEdgePrometheusSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Targets    *[]struct {
		// Host Name of host from which to pull metrics.
		Host string `json:"host"`

		// Path Path to use when collecting metrics from discovered targets
		Path *string `json:"path,omitempty"`

		// Port The port number in the metrics URL for discovered targets.
		Port *float32 `json:"port,omitempty"`

		// Protocol Protocol to use when collecting metrics
		Protocol *InputEdgePrometheusTargetsProtocol `json:"protocol,omitempty"`
	} `json:"targets,omitempty"`

	// Timeout Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
	Timeout *float32                 `json:"timeout,omitempty"`
	Type    *InputEdgePrometheusType `json:"type,omitempty"`

	// UsePublicIp Use public IP address for discovered targets. Set to false if the private IP address should be used.
	UsePublicIp *bool `json:"usePublicIp,omitempty"`

	// Username Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputEdgePrometheusAuthType Enter credentials directly, or select a stored secret
type InputEdgePrometheusAuthType string

// InputEdgePrometheusAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputEdgePrometheusAwsAuthenticationMethod string

// InputEdgePrometheusDiscoveryType Target discovery mechanism. Use static to manually enter a list of targets.
type InputEdgePrometheusDiscoveryType string

// InputEdgePrometheusPersistenceCompress Data compression format. Default is gzip.
type InputEdgePrometheusPersistenceCompress string

// InputEdgePrometheusPersistenceEnable Spool events on disk for Cribl Edge and Search. Default is disabled.
type InputEdgePrometheusPersistenceEnable bool

// InputEdgePrometheusPqCompress Codec to use to compress the persisted data.
type InputEdgePrometheusPqCompress string

// InputEdgePrometheusPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputEdgePrometheusPqMode string

// InputEdgePrometheusPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputEdgePrometheusPqEnabled bool

// InputEdgePrometheusRecordType DNS Record type to resolve
type InputEdgePrometheusRecordType string

// InputEdgePrometheusScrapeProtocol Protocol to use when collecting metrics
type InputEdgePrometheusScrapeProtocol string

// InputEdgePrometheusSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputEdgePrometheusSendToRoutes bool

// InputEdgePrometheusSignatureVersion Signature version to use for signing EC2 requests
type InputEdgePrometheusSignatureVersion string

// InputEdgePrometheusTargetsProtocol Protocol to use when collecting metrics
type InputEdgePrometheusTargetsProtocol string

// InputEdgePrometheusType defines model for InputEdgePrometheus.Type.
type InputEdgePrometheusType string

// InputElastic defines model for InputElastic.
type InputElastic struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// ApiVersion The API version to use for communicating with the server.
	ApiVersion *InputElasticApiVersion `json:"apiVersion,omitempty"`

	// AuthTokens Bearer tokens to include in the authorization header
	AuthTokens *[]string `json:"authTokens,omitempty"`

	// AuthType Elastic authentication type
	AuthType *InputElasticAuthType `json:"authType,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`

	// CustomAPIVersion Custom version information to respond to requests
	CustomAPIVersion *string `json:"customAPIVersion,omitempty"`
	Description      *string `json:"description,omitempty"`
	Disabled         *bool   `json:"disabled,omitempty"`

	// ElasticAPI Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically, e.g., /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
	ElasticAPI string `json:"elasticAPI"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IgnoreStandardHeaders Whether to ignore extra HTTP headers that don't start with X- or x-
	IgnoreStandardHeaders *bool `json:"ignoreStandardHeaders,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputElasticPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputElasticPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputElasticPqEnabled `json:"pqEnabled,omitempty"`
	ProxyMode *struct {
		// AuthType Enter credentials directly, or select a stored secret
		AuthType *InputElasticProxyModeAuthType `json:"authType,omitempty"`

		// Enabled Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications; see docs for more details.
		Enabled InputElasticProxyModeEnabled `json:"enabled"`

		// RejectUnauthorized Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// RemoveHeaders List of headers to remove from the request to proxy
		RemoveHeaders *[]string `json:"removeHeaders,omitempty"`

		// TimeoutSec Amount of time, in seconds, to wait for a proxy request to complete before canceling it.
		TimeoutSec *float32 `json:"timeoutSec,omitempty"`

		// Url URL of the Elastic server to proxy non-bulk requests to, e.g., http://elastic:9200
		Url *string `json:"url,omitempty"`
	} `json:"proxyMode,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputElasticSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}             `json:"commonNameRegex,omitempty"`
		Disabled        *InputElasticTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputElasticTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputElasticTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputElasticType `json:"type,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputElasticApiVersion The API version to use for communicating with the server.
type InputElasticApiVersion string

// InputElasticAuthType Elastic authentication type
type InputElasticAuthType string

// InputElasticPqCompress Codec to use to compress the persisted data.
type InputElasticPqCompress string

// InputElasticPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputElasticPqMode string

// InputElasticPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputElasticPqEnabled bool

// InputElasticProxyModeAuthType Enter credentials directly, or select a stored secret
type InputElasticProxyModeAuthType string

// InputElasticProxyModeEnabled Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications; see docs for more details.
type InputElasticProxyModeEnabled bool

// InputElasticSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputElasticSendToRoutes bool

// InputElasticTlsDisabled defines model for InputElastic.Tls.Disabled.
type InputElasticTlsDisabled bool

// InputElasticTlsMaxVersion Maximum TLS version to accept from connections
type InputElasticTlsMaxVersion string

// InputElasticTlsMinVersion Minimum TLS version to accept from connections
type InputElasticTlsMinVersion string

// InputElasticType defines model for InputElastic.Type.
type InputElasticType string

// InputEventhub defines model for InputEventhub.
type InputEventhub struct {
	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// AutoCommitInterval How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float32 `json:"autoCommitInterval,omitempty"`

	// AutoCommitThreshold How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float32 `json:"autoCommitThreshold,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers List of Event Hubs Kafka brokers to connect to, e.g., yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FromBeginning Whether to start reading from earliest available data, relevant only during initial subscription.
	FromBeginning *bool `json:"fromBeginning,omitempty"`

	// GroupId Specifies the consumer group this instance belongs to, default is 'Cribl'.
	GroupId *string `json:"groupId,omitempty"`

	// HeartbeatInterval
	//       Expected time (a.k.a heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group management facilities.
	//       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	HeartbeatInterval *float32 `json:"heartbeatInterval,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float32 `json:"initialBackoff,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxBytes Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float32 `json:"maxBytes,omitempty"`

	// MaxBytesPerPartition Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float32 `json:"maxBytesPerPartition,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// MaxSocketErrors Maximum number of network errors before the consumer recreates a socket.
	MaxSocketErrors *float32 `json:"maxSocketErrors,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// MinimizeDuplicates Enable feature to minimize duplicate events by only starting one consumer for each topic partition.
	MinimizeDuplicates *bool `json:"minimizeDuplicates,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputEventhubPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputEventhubPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputEventhubPqEnabled `json:"pqEnabled,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RebalanceTimeout
	//       Maximum allowed time (a.k.a rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance has begun.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	RebalanceTimeout *float32 `json:"rebalanceTimeout,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable authentication.
		Disabled InputEventhubSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use
		Mechanism *InputEventhubSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputEventhubSendToRoutes `json:"sendToRoutes,omitempty"`

	// SessionTimeout
	//       Timeout (a.k.a session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group management facilities.
	//       If the client sends the broker no heartbeats before this timeout expires, the broker will remove this client from the group, and will initiate a rebalance.
	//       Value must be lower than rebalanceTimeout.
	//       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
	SessionTimeout *float32 `json:"sessionTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		Disabled InputEventhubTlsDisabled `json:"disabled"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA).
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	} `json:"tls,omitempty"`

	// Topics The name of the Event Hub (a.k.a. Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
	Topics []string           `json:"topics"`
	Type   *InputEventhubType `json:"type,omitempty"`
}

// InputEventhubPqCompress Codec to use to compress the persisted data.
type InputEventhubPqCompress string

// InputEventhubPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputEventhubPqMode string

// InputEventhubPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputEventhubPqEnabled bool

// InputEventhubSaslDisabled Enable authentication.
type InputEventhubSaslDisabled bool

// InputEventhubSaslMechanism SASL authentication mechanism to use
type InputEventhubSaslMechanism string

// InputEventhubSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputEventhubSendToRoutes bool

// InputEventhubTlsDisabled defines model for InputEventhub.Tls.Disabled.
type InputEventhubTlsDisabled bool

// InputEventhubType defines model for InputEventhub.Type.
type InputEventhubType string

// InputExec defines model for InputExec.
type InputExec struct {
	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Command Command to execute; supports Bourne shell (or CMD on Windows) syntax
	Command string `json:"command"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CronSchedule Cron schedule to execute the command on.
	CronSchedule *string `json:"cronSchedule,omitempty"`
	Description  *string `json:"description,omitempty"`
	Disabled     *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval Interval between command executions in seconds.
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputExecPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputExecPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputExecPqEnabled `json:"pqEnabled,omitempty"`

	// Retries Maximum number of retry attempts in the event that the command fails.
	Retries *float32 `json:"retries,omitempty"`

	// ScheduleType Select a schedule type; either an interval (in seconds) or a cron-style schedule.
	ScheduleType *InputExecScheduleType `json:"scheduleType,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputExecSendToRoutes `json:"sendToRoutes,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string   `json:"streamtags,omitempty"`
	Type       interface{} `json:"type"`
}

// InputExecPqCompress Codec to use to compress the persisted data.
type InputExecPqCompress string

// InputExecPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputExecPqMode string

// InputExecPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputExecPqEnabled bool

// InputExecScheduleType Select a schedule type; either an interval (in seconds) or a cron-style schedule.
type InputExecScheduleType string

// InputExecSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputExecSendToRoutes bool

// InputFile defines model for InputFile.
type InputFile struct {
	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// CheckFileModTime Skip files with modification times earlier than the maximum age duration
	CheckFileModTime *bool `json:"checkFileModTime,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// DeleteFiles Delete files after they have been collected
	DeleteFiles *bool `json:"deleteFiles,omitempty"`

	// Depth Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
	Depth       *float32 `json:"depth,omitempty"`
	Description *string  `json:"description,omitempty"`
	Disabled    *bool    `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Filenames The full path of discovered files are matched against this wildcard list
	Filenames *[]string `json:"filenames,omitempty"`

	// ForceText Forces files containing binary data to be streamed as text
	ForceText *InputFileForceText `json:"forceText,omitempty"`

	// HashLen Length of file header bytes to use in hash for unique file identification
	HashLen *float32 `json:"hashLen,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// IdleTimeout Time, in seconds, before an idle file is closed
	IdleTimeout *float32 `json:"idleTimeout,omitempty"`

	// IncludeUnidentifiableBinary Stream binary files as Base64-encoded chunks.
	IncludeUnidentifiableBinary *bool `json:"includeUnidentifiableBinary,omitempty"`

	// Interval Time, in seconds, between scanning for files
	Interval *float32 `json:"interval,omitempty"`

	// MaxAgeDur The maximum age of files to monitor. Format examples: 60s, 4h, 3d, 1w. Age is relative to file modification time. Leave empty to apply no age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Mode Choose how to discover files to monitor
	Mode *InputFileMode `json:"mode,omitempty"`

	// Path Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
	Path *string `json:"path,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputFilePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputFilePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputFilePqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputFileSendToRoutes `json:"sendToRoutes,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TailOnly Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
	TailOnly *bool       `json:"tailOnly,omitempty"`
	Type     interface{} `json:"type"`
}

// InputFileForceText Forces files containing binary data to be streamed as text
type InputFileForceText bool

// InputFileMode Choose how to discover files to monitor
type InputFileMode string

// InputFilePqCompress Codec to use to compress the persisted data.
type InputFilePqCompress string

// InputFilePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputFilePqMode string

// InputFilePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputFilePqEnabled bool

// InputFileSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputFileSendToRoutes bool

// InputFirehose defines model for InputFirehose.
type InputFirehose struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthed access is permitted.
	AuthTokens *[]string `json:"authTokens,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputFirehosePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputFirehosePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputFirehosePqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputFirehoseSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                   `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}              `json:"commonNameRegex,omitempty"`
		Disabled        *InputFirehoseTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputFirehoseTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputFirehoseTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputFirehoseType `json:"type,omitempty"`
}

// InputFirehosePqCompress Codec to use to compress the persisted data.
type InputFirehosePqCompress string

// InputFirehosePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputFirehosePqMode string

// InputFirehosePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputFirehosePqEnabled bool

// InputFirehoseSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputFirehoseSendToRoutes bool

// InputFirehoseTlsDisabled defines model for InputFirehose.Tls.Disabled.
type InputFirehoseTlsDisabled bool

// InputFirehoseTlsMaxVersion Maximum TLS version to accept from connections
type InputFirehoseTlsMaxVersion string

// InputFirehoseTlsMinVersion Minimum TLS version to accept from connections
type InputFirehoseTlsMinVersion string

// InputFirehoseType defines model for InputFirehose.Type.
type InputFirehoseType string

// InputGooglePubsub defines model for InputGooglePubsub.
type InputGooglePubsub struct {
	// Concurrency How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
	Concurrency *float32 `json:"concurrency,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CreateSubscription If enabled, create subscription if it does not exist
	CreateSubscription *InputGooglePubsubCreateSubscription `json:"createSubscription,omitempty"`

	// CreateTopic If enabled, create topic if it does not exist
	CreateTopic *bool   `json:"createTopic,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// GoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
	GoogleAuthMethod *InputGooglePubsubGoogleAuthMethod `json:"googleAuthMethod,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxBacklog If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events.
	MaxBacklog *float32 `json:"maxBacklog,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OrderedDelivery If enabled, receive events in the order they were added to the queue. For this to work correctly, the process sending events must have ordering enabled.
	OrderedDelivery *bool `json:"orderedDelivery,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputGooglePubsubPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputGooglePubsubPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputGooglePubsubPqEnabled `json:"pqEnabled,omitempty"`

	// Region Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`

	// RequestTimeout Pull request timeout, in milliseconds.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Secret Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputGooglePubsubSendToRoutes `json:"sendToRoutes,omitempty"`

	// ServiceAccountCredentials Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SubscriptionName ID of the subscription to use when receiving events.
	SubscriptionName string `json:"subscriptionName"`

	// TopicName ID of the topic to receive events from.
	TopicName string                 `json:"topicName"`
	Type      *InputGooglePubsubType `json:"type,omitempty"`
}

// InputGooglePubsubCreateSubscription If enabled, create subscription if it does not exist
type InputGooglePubsubCreateSubscription bool

// InputGooglePubsubGoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
type InputGooglePubsubGoogleAuthMethod string

// InputGooglePubsubPqCompress Codec to use to compress the persisted data.
type InputGooglePubsubPqCompress string

// InputGooglePubsubPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputGooglePubsubPqMode string

// InputGooglePubsubPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputGooglePubsubPqEnabled bool

// InputGooglePubsubSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputGooglePubsubSendToRoutes bool

// InputGooglePubsubType defines model for InputGooglePubsub.Type.
type InputGooglePubsubType string

// InputGrafana defines model for InputGrafana.
type InputGrafana struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// LokiAPI Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
	LokiAPI  *string `json:"lokiAPI,omitempty"`
	LokiAuth *struct {
		// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
		AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

		// AuthType Loki logs authentication type
		AuthType *InputGrafanaLokiAuthAuthType `json:"authType,omitempty"`

		// CredentialsSecret Select or create a secret that references your credentials
		CredentialsSecret *string `json:"credentialsSecret,omitempty"`

		// LoginUrl URL for OAuth
		LoginUrl *string `json:"loginUrl,omitempty"`

		// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
		OauthHeaders *[]struct {
			// Name OAuth header name
			Name string `json:"name"`

			// Value OAuth header value
			Value string `json:"value"`
		} `json:"oauthHeaders,omitempty"`

		// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
		OauthParams *[]struct {
			// Name OAuth parameter name
			Name string `json:"name"`

			// Value OAuth parameter value
			Value string `json:"value"`
		} `json:"oauthParams,omitempty"`

		// Password Password for Basic authentication
		Password *string `json:"password,omitempty"`

		// Secret Secret parameter value to pass in request body
		Secret *string `json:"secret,omitempty"`

		// SecretParamName Secret parameter name to pass in request body
		SecretParamName *string `json:"secretParamName,omitempty"`
		Spacer          *string `json:"spacer"`

		// TextSecret Select or create a stored text secret
		TextSecret *string `json:"textSecret,omitempty"`

		// Token Bearer token to include in the authorization header
		Token *string `json:"token,omitempty"`

		// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
		TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

		// TokenTimeoutSecs How often the OAuth token should be refreshed.
		TokenTimeoutSecs *float32 `json:"tokenTimeoutSecs,omitempty"`

		// Username Username for Basic authentication
		Username *string `json:"username,omitempty"`
	} `json:"lokiAuth,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputGrafanaPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputGrafanaPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputGrafanaPqEnabled `json:"pqEnabled,omitempty"`

	// PrometheusAPI Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
	PrometheusAPI  *string `json:"prometheusAPI,omitempty"`
	PrometheusAuth *struct {
		// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
		AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

		// AuthType Remote Write authentication type
		AuthType *InputGrafanaPrometheusAuthAuthType `json:"authType,omitempty"`

		// CredentialsSecret Select or create a secret that references your credentials
		CredentialsSecret *string `json:"credentialsSecret,omitempty"`

		// LoginUrl URL for OAuth
		LoginUrl *string `json:"loginUrl,omitempty"`

		// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
		OauthHeaders *[]struct {
			// Name OAuth header name
			Name string `json:"name"`

			// Value OAuth header value
			Value string `json:"value"`
		} `json:"oauthHeaders,omitempty"`

		// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
		OauthParams *[]struct {
			// Name OAuth parameter name
			Name string `json:"name"`

			// Value OAuth parameter value
			Value string `json:"value"`
		} `json:"oauthParams,omitempty"`

		// Password Password for Basic authentication
		Password *string `json:"password,omitempty"`

		// Secret Secret parameter value to pass in request body
		Secret *string `json:"secret,omitempty"`

		// SecretParamName Secret parameter name to pass in request body
		SecretParamName *string `json:"secretParamName,omitempty"`
		Spacer          *string `json:"spacer"`

		// TextSecret Select or create a stored text secret
		TextSecret *string `json:"textSecret,omitempty"`

		// Token Bearer token to include in the authorization header
		Token *string `json:"token,omitempty"`

		// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
		TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

		// TokenTimeoutSecs How often the OAuth token should be refreshed.
		TokenTimeoutSecs *float32 `json:"tokenTimeoutSecs,omitempty"`

		// Username Username for Basic authentication
		Username *string `json:"username,omitempty"`
	} `json:"prometheusAuth,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputGrafanaSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}             `json:"commonNameRegex,omitempty"`
		Disabled        *InputGrafanaTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputGrafanaTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputGrafanaTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type  *InputGrafanaType `json:"type,omitempty"`
	Union json.RawMessage
}

// InputGrafanaLokiAuthAuthType Loki logs authentication type
type InputGrafanaLokiAuthAuthType string

// InputGrafanaPqCompress Codec to use to compress the persisted data.
type InputGrafanaPqCompress string

// InputGrafanaPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputGrafanaPqMode string

// InputGrafanaPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputGrafanaPqEnabled bool

// InputGrafanaPrometheusAuthAuthType Remote Write authentication type
type InputGrafanaPrometheusAuthAuthType string

// InputGrafanaSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputGrafanaSendToRoutes bool

// InputGrafanaTlsDisabled defines model for InputGrafana.Tls.Disabled.
type InputGrafanaTlsDisabled bool

// InputGrafanaTlsMaxVersion Maximum TLS version to accept from connections
type InputGrafanaTlsMaxVersion string

// InputGrafanaTlsMinVersion Minimum TLS version to accept from connections
type InputGrafanaTlsMinVersion string

// InputGrafanaType defines model for InputGrafana.Type.
type InputGrafanaType string

// InputGrafana0 defines model for .
type InputGrafana0 = interface{}

// InputGrafana1 defines model for .
type InputGrafana1 = interface{}

// InputHttp defines model for InputHttp.
type InputHttp struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthed access is permitted.
	AuthTokens *[]string `json:"authTokens,omitempty"`

	// AuthTokensExt Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt *[]struct {
		Description *string `json:"description,omitempty"`

		// Metadata Fields to add to events referencing this token
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`

		// Token Shared secret to be provided by any client (Authorization: <token>).
		Token string `json:"token"`
	} `json:"authTokensExt,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CriblAPI Absolute path on which to listen for the Cribl HTTP API requests. At the moment, only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
	CriblAPI    *string `json:"criblAPI,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// ElasticAPI Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
	ElasticAPI *string `json:"elasticAPI,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputHttpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputHttpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputHttpPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputHttpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// SplunkHecAPI Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
	SplunkHecAPI  *string `json:"splunkHecAPI,omitempty"`
	SplunkHecAcks *bool   `json:"splunkHecAcks,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string               `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}          `json:"commonNameRegex,omitempty"`
		Disabled        *InputHttpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputHttpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputHttpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputHttpType `json:"type,omitempty"`
}

// InputHttpPqCompress Codec to use to compress the persisted data.
type InputHttpPqCompress string

// InputHttpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputHttpPqMode string

// InputHttpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputHttpPqEnabled bool

// InputHttpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputHttpSendToRoutes bool

// InputHttpTlsDisabled defines model for InputHttp.Tls.Disabled.
type InputHttpTlsDisabled bool

// InputHttpTlsMaxVersion Maximum TLS version to accept from connections
type InputHttpTlsMaxVersion string

// InputHttpTlsMinVersion Minimum TLS version to accept from connections
type InputHttpTlsMinVersion string

// InputHttpType defines model for InputHttp.Type.
type InputHttpType string

// InputHttpRaw defines model for InputHttpRaw.
type InputHttpRaw struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AllowedMethods List of HTTP methods accepted by this input, wildcards are supported, e.g. P*, GET. Defaults to allow all.
	AllowedMethods *[]string `json:"allowedMethods,omitempty"`

	// AllowedPaths List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all.
	AllowedPaths *[]string `json:"allowedPaths,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthed access is permitted.
	AuthTokens *[]string `json:"authTokens,omitempty"`

	// AuthTokensExt Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokensExt *[]struct {
		// Description Optional token description
		Description *string `json:"description,omitempty"`

		// Metadata Fields to add to events referencing this token
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`

		// Token Shared secret to be provided by any client (Authorization: <token>)
		Token string `json:"token"`
	} `json:"authTokensExt,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputHttpRawPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputHttpRawPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputHttpRawPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputHttpRawSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}             `json:"commonNameRegex,omitempty"`
		Disabled        *InputHttpRawTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputHttpRawTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputHttpRawTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputHttpRawType `json:"type,omitempty"`
}

// InputHttpRawPqCompress Codec to use to compress the persisted data.
type InputHttpRawPqCompress string

// InputHttpRawPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputHttpRawPqMode string

// InputHttpRawPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputHttpRawPqEnabled bool

// InputHttpRawSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputHttpRawSendToRoutes bool

// InputHttpRawTlsDisabled defines model for InputHttpRaw.Tls.Disabled.
type InputHttpRawTlsDisabled bool

// InputHttpRawTlsMaxVersion Maximum TLS version to accept from connections
type InputHttpRawTlsMaxVersion string

// InputHttpRawTlsMinVersion Minimum TLS version to accept from connections
type InputHttpRawTlsMinVersion string

// InputHttpRawType defines model for InputHttpRaw.Type.
type InputHttpRawType string

// InputJournalFiles defines model for InputJournalFiles.
type InputJournalFiles struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CurrentBoot Skip log messages that are not part of the current boot session.
	CurrentBoot *bool   `json:"currentBoot,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval Time, in seconds, between scanning for journals.
	Interval *float32 `json:"interval,omitempty"`

	// Journals The full path of discovered journals are matched against this wildcard list.
	Journals []string `json:"journals"`

	// MaxAgeDur The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
	MaxAgeDur *string `json:"maxAgeDur,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Path Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
	Path string `json:"path"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputJournalFilesPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputJournalFilesPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputJournalFilesPqEnabled `json:"pqEnabled,omitempty"`

	// Rules Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
	Rules *[]struct {
		// Description Optional description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression applied to Journal objects. Return 'true' to include it.
		Filter string `json:"filter"`
	} `json:"rules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputJournalFilesSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string    `json:"streamtags,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// InputJournalFilesPqCompress Codec to use to compress the persisted data.
type InputJournalFilesPqCompress string

// InputJournalFilesPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputJournalFilesPqMode string

// InputJournalFilesPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputJournalFilesPqEnabled bool

// InputJournalFilesSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputJournalFilesSendToRoutes bool

// InputKafka defines model for InputKafka.
type InputKafka struct {
	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// AutoCommitInterval How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float32 `json:"autoCommitInterval,omitempty"`

	// AutoCommitThreshold How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float32 `json:"autoCommitThreshold,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FromBeginning Leave toggled to 'Yes' if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`

	// GroupId Specifies the consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupId *string `json:"groupId,omitempty"`

	// HeartbeatInterval
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities.
	//       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms).
	HeartbeatInterval *float32 `json:"heartbeatInterval,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled InputKafkaKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// Disabled Enable Schema Registry
		Disabled InputKafkaKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                   `json:"certificateName,omitempty"`
			Disabled        *InputKafkaKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *InputKafkaKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *InputKafkaKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxBytes Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float32 `json:"maxBytes,omitempty"`

	// MaxBytesPerPartition Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float32 `json:"maxBytesPerPartition,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// MaxSocketErrors Maximum number of network errors before the consumer recreates a socket.
	MaxSocketErrors *float32 `json:"maxSocketErrors,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputKafkaPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputKafkaPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputKafkaPqEnabled `json:"pqEnabled,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RebalanceTimeout
	//       Maximum allowed time for each worker to join the group after a rebalance has begun.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See details [here](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms).
	RebalanceTimeout *float32 `json:"rebalanceTimeout,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable Authentication
		Disabled InputKafkaSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use.
		Mechanism *InputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputKafkaSendToRoutes `json:"sendToRoutes,omitempty"`

	// SessionTimeout
	//       Timeout used to detect client failures when using Kafka's group management facilities.
	//       If the client sends the broker no heartbeats before this timeout expires,
	//       the broker will remove this client from the group, and will initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms).
	SessionTimeout *float32 `json:"sessionTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                `json:"certificateName,omitempty"`
		Disabled        *InputKafkaTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *InputKafkaTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *InputKafkaTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topics Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to only a single topic.
	Topics []string        `json:"topics"`
	Type   *InputKafkaType `json:"type,omitempty"`
}

// InputKafkaKafkaSchemaRegistryAuthDisabled Enable authentication
type InputKafkaKafkaSchemaRegistryAuthDisabled bool

// InputKafkaKafkaSchemaRegistryDisabled Enable Schema Registry
type InputKafkaKafkaSchemaRegistryDisabled bool

// InputKafkaKafkaSchemaRegistryTlsDisabled defines model for InputKafka.KafkaSchemaRegistry.Tls.Disabled.
type InputKafkaKafkaSchemaRegistryTlsDisabled bool

// InputKafkaKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type InputKafkaKafkaSchemaRegistryTlsMaxVersion string

// InputKafkaKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type InputKafkaKafkaSchemaRegistryTlsMinVersion string

// InputKafkaPqCompress Codec to use to compress the persisted data.
type InputKafkaPqCompress string

// InputKafkaPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKafkaPqMode string

// InputKafkaPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputKafkaPqEnabled bool

// InputKafkaSaslDisabled Enable Authentication
type InputKafkaSaslDisabled bool

// InputKafkaSaslMechanism SASL authentication mechanism to use.
type InputKafkaSaslMechanism string

// InputKafkaSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputKafkaSendToRoutes bool

// InputKafkaTlsDisabled defines model for InputKafka.Tls.Disabled.
type InputKafkaTlsDisabled bool

// InputKafkaTlsMaxVersion Maximum TLS version to use when connecting
type InputKafkaTlsMaxVersion string

// InputKafkaTlsMinVersion Minimum TLS version to use when connecting
type InputKafkaTlsMinVersion string

// InputKafkaType defines model for InputKafka.Type.
type InputKafkaType string

// InputKinesis defines model for InputKinesis.
type InputKinesis struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AvoidDuplicates Yes means: when resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this can cause data loss after a Worker Node's unexpected shutdown or restart.
	AvoidDuplicates *bool `json:"avoidDuplicates,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputKinesisAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint Kinesis stream service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// GetRecordsLimit Maximum number of records per getRecords call
	GetRecordsLimit *float32 `json:"getRecordsLimit,omitempty"`

	// GetRecordsLimitTotal Maximum number of records, across all shards, to pull down at once per Worker Process
	GetRecordsLimitTotal *float32 `json:"getRecordsLimitTotal,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// LoadBalancingAlgorithm The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
	LoadBalancingAlgorithm *InputKinesisLoadBalancingAlgorithm `json:"loadBalancingAlgorithm,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// PayloadFormat Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
	PayloadFormat *InputKinesisPayloadFormat `json:"payloadFormat,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputKinesisPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputKinesisPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputKinesisPqEnabled `json:"pqEnabled,omitempty"`

	// Region Region where the Kinesis stream is located
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputKinesisSendToRoutes `json:"sendToRoutes,omitempty"`

	// ServiceInterval Time interval in minutes between consecutive service calls
	ServiceInterval *float32 `json:"serviceInterval,omitempty"`

	// ShardExpr A JS expression to be called with each shardId for the stream, if the expression evalutates to a truthy value the shard will be processed.
	ShardExpr *string `json:"shardExpr,omitempty"`

	// ShardIteratorType Location at which to start reading a shard for the first time.
	ShardIteratorType *InputKinesisShardIteratorType `json:"shardIteratorType,omitempty"`

	// SignatureVersion Signature version to use for signing Kinesis stream requests
	SignatureVersion *InputKinesisSignatureVersion `json:"signatureVersion,omitempty"`

	// StreamName Kinesis stream name to read data from.
	StreamName string `json:"streamName"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string         `json:"streamtags,omitempty"`
	Type       *InputKinesisType `json:"type,omitempty"`

	// VerifyKPLCheckSums Verify Kinesis Producer Library (KPL) event checksums
	VerifyKPLCheckSums *bool `json:"verifyKPLCheckSums,omitempty"`
}

// InputKinesisAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputKinesisAwsAuthenticationMethod string

// InputKinesisLoadBalancingAlgorithm The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
type InputKinesisLoadBalancingAlgorithm string

// InputKinesisPayloadFormat Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
type InputKinesisPayloadFormat string

// InputKinesisPqCompress Codec to use to compress the persisted data.
type InputKinesisPqCompress string

// InputKinesisPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKinesisPqMode string

// InputKinesisPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputKinesisPqEnabled bool

// InputKinesisSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputKinesisSendToRoutes bool

// InputKinesisShardIteratorType Location at which to start reading a shard for the first time.
type InputKinesisShardIteratorType string

// InputKinesisSignatureVersion Signature version to use for signing Kinesis stream requests
type InputKinesisSignatureVersion string

// InputKinesisType defines model for InputKinesis.Type.
type InputKinesisType string

// InputKubeEvents defines model for InputKubeEvents.
type InputKubeEvents struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputKubeEventsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputKubeEventsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputKubeEventsPqEnabled `json:"pqEnabled,omitempty"`

	// Rules Filtering on event fields
	Rules *[]struct {
		// Description Optional description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
		Filter string `json:"filter"`
	} `json:"rules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputKubeEventsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string           `json:"streamtags,omitempty"`
	Type       InputKubeEventsType `json:"type"`
}

// InputKubeEventsPqCompress Codec to use to compress the persisted data.
type InputKubeEventsPqCompress string

// InputKubeEventsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKubeEventsPqMode string

// InputKubeEventsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputKubeEventsPqEnabled bool

// InputKubeEventsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputKubeEventsSendToRoutes bool

// InputKubeEventsType defines model for InputKubeEvents.Type.
type InputKubeEventsType string

// InputKubeLogs defines model for InputKubeLogs.
type InputKubeLogs struct {
	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Interval Time, in seconds, between checks for new containers. Default is 15 secs.
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Data compression format. Default is gzip.
		Compress *InputKubeLogsPersistenceCompress `json:"compress,omitempty"`

		// Enable Spool events on disk for Cribl Edge and Search. Default is disabled.
		Enable *InputKubeLogsPersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time period for grouping spooled events. Default is 10m.
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputKubeLogsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputKubeLogsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputKubeLogsPqEnabled `json:"pqEnabled,omitempty"`

	// Rules Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
	Rules *[]struct {
		// Description Optional description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression applied to Pod objects. Return 'true' to include it.
		Filter string `json:"filter"`
	} `json:"rules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputKubeLogsSendToRoutes `json:"sendToRoutes,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Timestamps For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
	Timestamps *bool             `json:"timestamps,omitempty"`
	Type       InputKubeLogsType `json:"type"`
}

// InputKubeLogsPersistenceCompress Data compression format. Default is gzip.
type InputKubeLogsPersistenceCompress string

// InputKubeLogsPersistenceEnable Spool events on disk for Cribl Edge and Search. Default is disabled.
type InputKubeLogsPersistenceEnable bool

// InputKubeLogsPqCompress Codec to use to compress the persisted data.
type InputKubeLogsPqCompress string

// InputKubeLogsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKubeLogsPqMode string

// InputKubeLogsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputKubeLogsPqEnabled bool

// InputKubeLogsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputKubeLogsSendToRoutes bool

// InputKubeLogsType defines model for InputKubeLogs.Type.
type InputKubeLogsType string

// InputKubeMetrics defines model for InputKubeMetrics.
type InputKubeMetrics struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Interval Time, in seconds, between consecutive metrics collections. Default is 15 secs.
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Select data compression format. Optional.
		Compress *InputKubeMetricsPersistenceCompress `json:"compress,omitempty"`

		// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
		DestPath *string `json:"destPath,omitempty"`

		// Enable Spool metrics on disk for Cribl Search
		Enable *InputKubeMetricsPersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time span for each file bucket
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputKubeMetricsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputKubeMetricsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputKubeMetricsPqEnabled `json:"pqEnabled,omitempty"`

	// Rules Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
	Rules *[]struct {
		// Description Optional description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
		Filter string `json:"filter"`
	} `json:"rules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputKubeMetricsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string            `json:"streamtags,omitempty"`
	Type       InputKubeMetricsType `json:"type"`
}

// InputKubeMetricsPersistenceCompress Select data compression format. Optional.
type InputKubeMetricsPersistenceCompress string

// InputKubeMetricsPersistenceEnable Spool metrics on disk for Cribl Search
type InputKubeMetricsPersistenceEnable bool

// InputKubeMetricsPqCompress Codec to use to compress the persisted data.
type InputKubeMetricsPqCompress string

// InputKubeMetricsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputKubeMetricsPqMode string

// InputKubeMetricsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputKubeMetricsPqEnabled bool

// InputKubeMetricsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputKubeMetricsSendToRoutes bool

// InputKubeMetricsType defines model for InputKubeMetrics.Type.
type InputKubeMetricsType string

// InputLoki defines model for InputLoki.
type InputLoki struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType Loki logs authentication type
	AuthType *InputLokiAuthType `json:"authType,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`
	Disabled          *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// LokiAPI Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI string `json:"lokiAPI"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputLokiPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputLokiPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputLokiPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputLokiSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`
	Spacer        *string  `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string               `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}          `json:"commonNameRegex,omitempty"`
		Disabled        *InputLokiTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputLokiTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputLokiTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32       `json:"tokenTimeoutSecs,omitempty"`
	Type             *InputLokiType `json:"type,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputLokiAuthType Loki logs authentication type
type InputLokiAuthType string

// InputLokiPqCompress Codec to use to compress the persisted data.
type InputLokiPqCompress string

// InputLokiPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputLokiPqMode string

// InputLokiPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputLokiPqEnabled bool

// InputLokiSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputLokiSendToRoutes bool

// InputLokiTlsDisabled defines model for InputLoki.Tls.Disabled.
type InputLokiTlsDisabled bool

// InputLokiTlsMaxVersion Maximum TLS version to accept from connections
type InputLokiTlsMaxVersion string

// InputLokiTlsMinVersion Minimum TLS version to accept from connections
type InputLokiTlsMinVersion string

// InputLokiType defines model for InputLoki.Type.
type InputLokiType string

// InputMetrics defines model for InputMetrics.
type InputMetrics struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to send data
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxBufferSize Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputMetricsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputMetricsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputMetricsPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputMetricsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TcpPort Enter TCP port number to listen on. Not required if listening on UDP.
	TcpPort *float32 `json:"tcpPort,omitempty"`
	Tls     *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}             `json:"commonNameRegex,omitempty"`
		Disabled        *InputMetricsTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputMetricsTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputMetricsTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type InputMetricsType `json:"type"`

	// UdpPort Enter UDP port number to listen on. Not required if listening on TCP.
	UdpPort *float32 `json:"udpPort,omitempty"`

	// UdpSocketRxBufSize Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UdpSocketRxBufSize *float32 `json:"udpSocketRxBufSize,omitempty"`
}

// InputMetricsPqCompress Codec to use to compress the persisted data.
type InputMetricsPqCompress string

// InputMetricsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputMetricsPqMode string

// InputMetricsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputMetricsPqEnabled bool

// InputMetricsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputMetricsSendToRoutes bool

// InputMetricsTlsDisabled defines model for InputMetrics.Tls.Disabled.
type InputMetricsTlsDisabled bool

// InputMetricsTlsMaxVersion Maximum TLS version to accept from connections
type InputMetricsTlsMaxVersion string

// InputMetricsTlsMinVersion Minimum TLS version to accept from connections
type InputMetricsTlsMinVersion string

// InputMetricsType defines model for InputMetrics.Type.
type InputMetricsType string

// InputModelDrivenTelemetry defines model for InputModelDrivenTelemetry.
type InputModelDrivenTelemetry struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputModelDrivenTelemetryPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputModelDrivenTelemetryPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputModelDrivenTelemetryPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputModelDrivenTelemetrySendToRoutes `json:"sendToRoutes,omitempty"`

	// ShutdownTimeoutMs Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
	ShutdownTimeoutMs *float32 `json:"shutdownTimeoutMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                               `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}                          `json:"commonNameRegex,omitempty"`
		Disabled        *InputModelDrivenTelemetryTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputModelDrivenTelemetryTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputModelDrivenTelemetryTlsMinVersion `json:"minVersion,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputModelDrivenTelemetryType `json:"type,omitempty"`
}

// InputModelDrivenTelemetryPqCompress Codec to use to compress the persisted data.
type InputModelDrivenTelemetryPqCompress string

// InputModelDrivenTelemetryPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputModelDrivenTelemetryPqMode string

// InputModelDrivenTelemetryPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputModelDrivenTelemetryPqEnabled bool

// InputModelDrivenTelemetrySendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputModelDrivenTelemetrySendToRoutes bool

// InputModelDrivenTelemetryTlsDisabled defines model for InputModelDrivenTelemetry.Tls.Disabled.
type InputModelDrivenTelemetryTlsDisabled bool

// InputModelDrivenTelemetryTlsMaxVersion Maximum TLS version to accept from connections
type InputModelDrivenTelemetryTlsMaxVersion string

// InputModelDrivenTelemetryTlsMinVersion Minimum TLS version to accept from connections
type InputModelDrivenTelemetryTlsMinVersion string

// InputModelDrivenTelemetryType defines model for InputModelDrivenTelemetry.Type.
type InputModelDrivenTelemetryType string

// InputMsk defines model for InputMsk.
type InputMsk struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// AutoCommitInterval How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *float32 `json:"autoCommitInterval,omitempty"`

	// AutoCommitThreshold How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *float32 `json:"autoCommitThreshold,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod InputMskAwsAuthenticationMethod `json:"awsAuthenticationMethod"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
	Brokers []string `json:"brokers"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint MSK cluster service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FromBeginning Leave toggled to 'Yes' if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`

	// GroupId Specifies the consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupId *string `json:"groupId,omitempty"`

	// HeartbeatInterval
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities.
	//       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms).
	HeartbeatInterval *float32 `json:"heartbeatInterval,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled InputMskKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// Disabled Enable Schema Registry
		Disabled InputMskKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                 `json:"certificateName,omitempty"`
			Disabled        *InputMskKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *InputMskKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *InputMskKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxBytes Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *float32 `json:"maxBytes,omitempty"`

	// MaxBytesPerPartition Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *float32 `json:"maxBytesPerPartition,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// MaxSocketErrors Maximum number of network errors before the consumer recreates a socket.
	MaxSocketErrors *float32 `json:"maxSocketErrors,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputMskPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputMskPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputMskPqEnabled `json:"pqEnabled,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RebalanceTimeout
	//       Maximum allowed time for each worker to join the group after a rebalance has begun.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See details [here](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms).
	RebalanceTimeout *float32 `json:"rebalanceTimeout,omitempty"`

	// Region Region where the MSK cluster is located
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputMskSendToRoutes `json:"sendToRoutes,omitempty"`

	// SessionTimeout
	//       Timeout used to detect client failures when using Kafka's group management facilities.
	//       If the client sends the broker no heartbeats before this timeout expires,
	//       the broker will remove this client from the group, and will initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms).
	SessionTimeout *float32 `json:"sessionTimeout,omitempty"`

	// SignatureVersion Signature version to use for signing MSK cluster requests
	SignatureVersion *InputMskSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string              `json:"certificateName,omitempty"`
		Disabled        *InputMskTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *InputMskTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *InputMskTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topics Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to only a single topic.
	Topics []string      `json:"topics"`
	Type   *InputMskType `json:"type,omitempty"`
}

// InputMskAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputMskAwsAuthenticationMethod string

// InputMskKafkaSchemaRegistryAuthDisabled Enable authentication
type InputMskKafkaSchemaRegistryAuthDisabled bool

// InputMskKafkaSchemaRegistryDisabled Enable Schema Registry
type InputMskKafkaSchemaRegistryDisabled bool

// InputMskKafkaSchemaRegistryTlsDisabled defines model for InputMsk.KafkaSchemaRegistry.Tls.Disabled.
type InputMskKafkaSchemaRegistryTlsDisabled bool

// InputMskKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type InputMskKafkaSchemaRegistryTlsMaxVersion string

// InputMskKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type InputMskKafkaSchemaRegistryTlsMinVersion string

// InputMskPqCompress Codec to use to compress the persisted data.
type InputMskPqCompress string

// InputMskPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputMskPqMode string

// InputMskPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputMskPqEnabled bool

// InputMskSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputMskSendToRoutes bool

// InputMskSignatureVersion Signature version to use for signing MSK cluster requests
type InputMskSignatureVersion string

// InputMskTlsDisabled defines model for InputMsk.Tls.Disabled.
type InputMskTlsDisabled bool

// InputMskTlsMaxVersion Maximum TLS version to use when connecting
type InputMskTlsMaxVersion string

// InputMskTlsMinVersion Minimum TLS version to use when connecting
type InputMskTlsMinVersion string

// InputMskType defines model for InputMsk.Type.
type InputMskType string

// InputNetflow defines model for InputNetflow.
type InputNetflow struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnablePassThrough Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
	EnablePassThrough *bool `json:"enablePassThrough,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// IpfixEnabled Accept messages in IPFIX format.
	IpfixEnabled *bool `json:"ipfixEnabled,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputNetflowPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputNetflowPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputNetflowPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputNetflowSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TemplateCacheMinutes Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
	TemplateCacheMinutes *float32          `json:"templateCacheMinutes,omitempty"`
	Type                 *InputNetflowType `json:"type,omitempty"`

	// UdpSocketRxBufSize Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UdpSocketRxBufSize *float32 `json:"udpSocketRxBufSize,omitempty"`

	// V5Enabled Accept messages in Netflow V5 format.
	V5Enabled *bool `json:"v5Enabled,omitempty"`

	// V9Enabled Accept messages in Netflow V9 format.
	V9Enabled *bool `json:"v9Enabled,omitempty"`
}

// InputNetflowPqCompress Codec to use to compress the persisted data.
type InputNetflowPqCompress string

// InputNetflowPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputNetflowPqMode string

// InputNetflowPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputNetflowPqEnabled bool

// InputNetflowSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputNetflowSendToRoutes bool

// InputNetflowType defines model for InputNetflow.Type.
type InputNetflowType string

// InputOffice365Mgmt defines model for InputOffice365Mgmt.
type InputOffice365Mgmt struct {
	// AppId Office 365 Azure Application ID
	AppId string `json:"appId"`

	// AuthType Enter client secret directly, or select a stored secret
	AuthType *InputOffice365MgmtAuthType `json:"authType,omitempty"`

	// ClientSecret Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// ContentConfig Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig *[]struct {
		// ContentType Office 365 Management Activity API Content Type
		ContentType *string `json:"contentType,omitempty"`

		// Description If interval type is minutes the value entered must evenly divisible by 60 or save will fail
		Description *string  `json:"description,omitempty"`
		Enabled     *bool    `json:"enabled,omitempty"`
		Interval    *float32 `json:"interval,omitempty"`

		// LogLevel Collector runtime Log Level
		LogLevel *InputOffice365MgmtContentConfigLogLevel `json:"logLevel,omitempty"`
	} `json:"contentConfig,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IngestionLag Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
	IngestionLag *float32 `json:"ingestionLag,omitempty"`

	// JobTimeout Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType InputOffice365MgmtPlanType `json:"planType"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputOffice365MgmtPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputOffice365MgmtPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputOffice365MgmtPqEnabled `json:"pqEnabled,omitempty"`

	// PublisherIdentifier Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
	PublisherIdentifier *string `json:"publisherIdentifier,omitempty"`
	RetryRules          *struct {
		// Codes List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
		Codes *[]float32 `json:"codes,omitempty"`

		// EnableHeader Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
		EnableHeader *bool `json:"enableHeader,omitempty"`

		// Interval Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
		Interval *float32 `json:"interval,omitempty"`

		// Limit The maximum number of times to retry a failed HTTP request
		Limit *float32 `json:"limit,omitempty"`

		// Multiplier Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
		Multiplier *float32 `json:"multiplier,omitempty"`

		// RetryConnectReset When toggled to Yes, the request will be retried when a connection reset (ECONNRESET) error occurs
		RetryConnectReset *bool `json:"retryConnectReset,omitempty"`

		// RetryConnectTimeout When toggled to Yes, a single retry attempt will be made when a connection timeout (ETIMEDOUT) error occurs
		RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`

		// Type The algorithm to use when performing HTTP retries
		Type InputOffice365MgmtRetryRulesType `json:"type"`
	} `json:"retryRules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputOffice365MgmtSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TenantId Office 365 Azure Tenant ID
	TenantId string `json:"tenantId"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// Timeout HTTP request inactivity timeout, use 0 to disable
	Timeout *float32 `json:"timeout,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                 `json:"ttl,omitempty"`
	Type *InputOffice365MgmtType `json:"type,omitempty"`
}

// InputOffice365MgmtAuthType Enter client secret directly, or select a stored secret
type InputOffice365MgmtAuthType string

// InputOffice365MgmtContentConfigLogLevel Collector runtime Log Level
type InputOffice365MgmtContentConfigLogLevel string

// InputOffice365MgmtPlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
type InputOffice365MgmtPlanType string

// InputOffice365MgmtPqCompress Codec to use to compress the persisted data.
type InputOffice365MgmtPqCompress string

// InputOffice365MgmtPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputOffice365MgmtPqMode string

// InputOffice365MgmtPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputOffice365MgmtPqEnabled bool

// InputOffice365MgmtRetryRulesType The algorithm to use when performing HTTP retries
type InputOffice365MgmtRetryRulesType string

// InputOffice365MgmtSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputOffice365MgmtSendToRoutes bool

// InputOffice365MgmtType defines model for InputOffice365Mgmt.Type.
type InputOffice365MgmtType string

// InputOffice365MsgTrace defines model for InputOffice365MsgTrace.
type InputOffice365MsgTrace struct {
	// AuthType Select authentication method.
	AuthType    *InputOffice365MsgTraceAuthType `json:"authType,omitempty"`
	CertOptions *struct {
		// CertPath Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
		CertPath string `json:"certPath"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string `json:"certificateName,omitempty"`

		// Passphrase Passphrase to use to decrypt the private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
		PrivKeyPath string `json:"privKeyPath"`
	} `json:"certOptions,omitempty"`

	// ClientId client_id to pass in the OAuth request parameter.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret client_secret to pass in the OAuth request parameter.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials.
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// DisableTimeFilter Disables time filtering of events when a date range is specified.
	DisableTimeFilter *bool `json:"disableTimeFilter,omitempty"`
	Disabled          *bool `json:"disabled,omitempty"`

	// EndDate Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
	EndDate *string `json:"endDate,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
	Interval float32 `json:"interval"`

	// JobTimeout Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// LogLevel Log Level (verbosity) for collection runtime behavior.
	LogLevel *InputOffice365MsgTraceLogLevel `json:"logLevel,omitempty"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// MaxTaskReschedule Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float32 `json:"maxTaskReschedule,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Password Password to run Message Trace API call.
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *InputOffice365MsgTracePlanType `json:"planType,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputOffice365MsgTracePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputOffice365MsgTracePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputOffice365MsgTracePqEnabled `json:"pqEnabled,omitempty"`

	// RescheduleDroppedTasks Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `json:"rescheduleDroppedTasks,omitempty"`

	// Resource Resource to pass in the OAuth request parameter.
	Resource   *string `json:"resource,omitempty"`
	RetryRules *struct {
		// Codes List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
		Codes *[]float32 `json:"codes,omitempty"`

		// EnableHeader Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
		EnableHeader *bool `json:"enableHeader,omitempty"`

		// Interval Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
		Interval *float32 `json:"interval,omitempty"`

		// Limit The maximum number of times to retry a failed HTTP request
		Limit *float32 `json:"limit,omitempty"`

		// Multiplier Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
		Multiplier *float32 `json:"multiplier,omitempty"`

		// RetryConnectReset When toggled to Yes, the request will be retried when a connection reset (ECONNRESET) error occurs
		RetryConnectReset *bool `json:"retryConnectReset,omitempty"`

		// RetryConnectTimeout When toggled to Yes, a single retry attempt will be made when a connection timeout (ETIMEDOUT) error occurs
		RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`

		// Type The algorithm to use when performing HTTP retries
		Type InputOffice365MsgTraceRetryRulesType `json:"type"`
	} `json:"retryRules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputOffice365MsgTraceSendToRoutes `json:"sendToRoutes,omitempty"`

	// StartDate Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
	StartDate *string `json:"startDate,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TenantId Directory ID (tenant identifier) in Azure Active Directory.
	TenantId *string `json:"tenantId,omitempty"`

	// TextSecret Select or create a secret that references your client_secret to pass in the OAuth request parameter.
	TextSecret *string `json:"textSecret,omitempty"`

	// Timeout HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
	Timeout *float32 `json:"timeout,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                     `json:"ttl,omitempty"`
	Type *InputOffice365MsgTraceType `json:"type,omitempty"`

	// Url URL to use when retrieving report data.
	Url string `json:"url"`

	// Username Username to run Message Trace API call.
	Username *string `json:"username,omitempty"`
}

// InputOffice365MsgTraceAuthType Select authentication method.
type InputOffice365MsgTraceAuthType string

// InputOffice365MsgTraceLogLevel Log Level (verbosity) for collection runtime behavior.
type InputOffice365MsgTraceLogLevel string

// InputOffice365MsgTracePlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
type InputOffice365MsgTracePlanType string

// InputOffice365MsgTracePqCompress Codec to use to compress the persisted data.
type InputOffice365MsgTracePqCompress string

// InputOffice365MsgTracePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputOffice365MsgTracePqMode string

// InputOffice365MsgTracePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputOffice365MsgTracePqEnabled bool

// InputOffice365MsgTraceRetryRulesType The algorithm to use when performing HTTP retries
type InputOffice365MsgTraceRetryRulesType string

// InputOffice365MsgTraceSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputOffice365MsgTraceSendToRoutes bool

// InputOffice365MsgTraceType defines model for InputOffice365MsgTrace.Type.
type InputOffice365MsgTraceType string

// InputOffice365Service defines model for InputOffice365Service.
type InputOffice365Service struct {
	// AppId Office 365 Azure Application ID
	AppId string `json:"appId"`

	// AuthType Enter client secret directly, or select a stored secret
	AuthType *InputOffice365ServiceAuthType `json:"authType,omitempty"`

	// ClientSecret Office 365 Azure client secret
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// ContentConfig Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
	ContentConfig *[]struct {
		// ContentType Office 365 Services API Content Type
		ContentType *string `json:"contentType,omitempty"`

		// Description If interval type is minutes the value entered must evenly divisible by 60 or save will fail
		Description *string  `json:"description,omitempty"`
		Enabled     *bool    `json:"enabled,omitempty"`
		Interval    *float32 `json:"interval,omitempty"`

		// LogLevel Collector runtime Log Level
		LogLevel *InputOffice365ServiceContentConfigLogLevel `json:"logLevel,omitempty"`
	} `json:"contentConfig,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// JobTimeout Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
	PlanType *InputOffice365ServicePlanType `json:"planType,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputOffice365ServicePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputOffice365ServicePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputOffice365ServicePqEnabled `json:"pqEnabled,omitempty"`
	RetryRules *struct {
		// Codes List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
		Codes *[]float32 `json:"codes,omitempty"`

		// EnableHeader Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
		EnableHeader *bool `json:"enableHeader,omitempty"`

		// Interval Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
		Interval *float32 `json:"interval,omitempty"`

		// Limit The maximum number of times to retry a failed HTTP request
		Limit *float32 `json:"limit,omitempty"`

		// Multiplier Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
		Multiplier *float32 `json:"multiplier,omitempty"`

		// RetryConnectReset When toggled to Yes, the request will be retried when a connection reset (ECONNRESET) error occurs
		RetryConnectReset *bool `json:"retryConnectReset,omitempty"`

		// RetryConnectTimeout When toggled to Yes, a single retry attempt will be made when a connection timeout (ETIMEDOUT) error occurs
		RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`

		// Type The algorithm to use when performing HTTP retries
		Type InputOffice365ServiceRetryRulesType `json:"type"`
	} `json:"retryRules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputOffice365ServiceSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TenantId Office 365 Azure Tenant ID
	TenantId string `json:"tenantId"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// Timeout HTTP request inactivity timeout, use 0 to disable
	Timeout *float32 `json:"timeout,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                    `json:"ttl,omitempty"`
	Type *InputOffice365ServiceType `json:"type,omitempty"`
}

// InputOffice365ServiceAuthType Enter client secret directly, or select a stored secret
type InputOffice365ServiceAuthType string

// InputOffice365ServiceContentConfigLogLevel Collector runtime Log Level
type InputOffice365ServiceContentConfigLogLevel string

// InputOffice365ServicePlanType Office 365 subscription plan for your organization, typically Office 365 Enterprise
type InputOffice365ServicePlanType string

// InputOffice365ServicePqCompress Codec to use to compress the persisted data.
type InputOffice365ServicePqCompress string

// InputOffice365ServicePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputOffice365ServicePqMode string

// InputOffice365ServicePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputOffice365ServicePqEnabled bool

// InputOffice365ServiceRetryRulesType The algorithm to use when performing HTTP retries
type InputOffice365ServiceRetryRulesType string

// InputOffice365ServiceSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputOffice365ServiceSendToRoutes bool

// InputOffice365ServiceType defines model for InputOffice365Service.Type.
type InputOffice365ServiceType string

// InputOpenTelemetry defines model for InputOpenTelemetry.
type InputOpenTelemetry struct {
	ActivityLogSampleRate *interface{} `json:"activityLogSampleRate,omitempty"`

	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType OpenTelemetry authentication type
	AuthType       *InputOpenTelemetryAuthType `json:"authType,omitempty"`
	CaptureHeaders *interface{}                `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`
	Disabled          *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool        `json:"enableHealthCheck,omitempty"`
	EnableProxyHeader *interface{} `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtractLogs Enable to extract each incoming log record to a separate event
	ExtractLogs *bool `json:"extractLogs,omitempty"`

	// ExtractMetrics Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`

	// ExtractSpans Enable to extract each incoming span to a separate event
	ExtractSpans *bool `json:"extractSpans,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OtlpVersion The version of OTLP Protobuf definitions to use when interpreting received data
	OtlpVersion *InputOpenTelemetryOtlpVersion `json:"otlpVersion,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputOpenTelemetryPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputOpenTelemetryPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputOpenTelemetryPqEnabled `json:"pqEnabled,omitempty"`

	// Protocol Select whether to leverage gRPC or HTTP for OpenTelemetry
	Protocol *InputOpenTelemetryProtocol `json:"protocol,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputOpenTelemetrySendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`
	Spacer        *string  `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                        `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}                   `json:"commonNameRegex,omitempty"`
		Disabled        *InputOpenTelemetryTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputOpenTelemetryTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputOpenTelemetryTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32                `json:"tokenTimeoutSecs,omitempty"`
	Type             *InputOpenTelemetryType `json:"type,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputOpenTelemetryAuthType OpenTelemetry authentication type
type InputOpenTelemetryAuthType string

// InputOpenTelemetryOtlpVersion The version of OTLP Protobuf definitions to use when interpreting received data
type InputOpenTelemetryOtlpVersion string

// InputOpenTelemetryPqCompress Codec to use to compress the persisted data.
type InputOpenTelemetryPqCompress string

// InputOpenTelemetryPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputOpenTelemetryPqMode string

// InputOpenTelemetryPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputOpenTelemetryPqEnabled bool

// InputOpenTelemetryProtocol Select whether to leverage gRPC or HTTP for OpenTelemetry
type InputOpenTelemetryProtocol string

// InputOpenTelemetrySendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputOpenTelemetrySendToRoutes bool

// InputOpenTelemetryTlsDisabled defines model for InputOpenTelemetry.Tls.Disabled.
type InputOpenTelemetryTlsDisabled bool

// InputOpenTelemetryTlsMaxVersion Maximum TLS version to accept from connections
type InputOpenTelemetryTlsMaxVersion string

// InputOpenTelemetryTlsMinVersion Minimum TLS version to accept from connections
type InputOpenTelemetryTlsMinVersion string

// InputOpenTelemetryType defines model for InputOpenTelemetry.Type.
type InputOpenTelemetryType string

// InputPrometheus defines model for InputPrometheus.
type InputPrometheus struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AuthType Enter credentials directly, or select a stored secret
	AuthType *InputPrometheusAuthType `json:"authType,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputPrometheusAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// DimensionList Other dimensions to include in events
	DimensionList *[]string `json:"dimensionList,omitempty"`
	Disabled      *bool     `json:"disabled,omitempty"`

	// DiscoveryType Target discovery mechanism. Use static to manually enter a list of targets.
	DiscoveryType *InputPrometheusDiscoveryType `json:"discoveryType,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access EC2
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint EC2 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
	Interval float32 `json:"interval"`

	// JobTimeout Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// LogLevel Collector runtime Log Level
	LogLevel InputPrometheusLogLevel `json:"logLevel"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NameList List of DNS names to resolve
	NameList *[]string `json:"nameList,omitempty"`

	// Password Password for Prometheus Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputPrometheusPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputPrometheusPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputPrometheusPqEnabled `json:"pqEnabled,omitempty"`

	// RecordType DNS Record type to resolve
	RecordType *InputPrometheusRecordType `json:"recordType,omitempty"`

	// Region Region where the EC2 is located
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ScrapePath Path to use when collecting metrics from discovered targets
	ScrapePath *string `json:"scrapePath,omitempty"`

	// ScrapePort The port number in the metrics URL for discovered targets.
	ScrapePort *float32 `json:"scrapePort,omitempty"`

	// ScrapeProtocol Protocol to use when collecting metrics
	ScrapeProtocol *InputPrometheusScrapeProtocol `json:"scrapeProtocol,omitempty"`

	// SearchFilter EC2 Instance Search Filter
	SearchFilter *[]struct {
		// Name Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
		Name string `json:"Name"`

		// Values Search Filter Values, if empty only "running" EC2 instances will be returned
		Values []string `json:"Values"`
	} `json:"searchFilter,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputPrometheusSendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing EC2 requests
	SignatureVersion *InputPrometheusSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TargetList List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
	TargetList *[]string `json:"targetList,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string              `json:"ttl,omitempty"`
	Type *InputPrometheusType `json:"type,omitempty"`

	// UsePublicIp Use public IP address for discovered targets. Set to false if the private IP address should be used.
	UsePublicIp *bool `json:"usePublicIp,omitempty"`

	// Username Username for Prometheus Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputPrometheusAuthType Enter credentials directly, or select a stored secret
type InputPrometheusAuthType string

// InputPrometheusAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputPrometheusAwsAuthenticationMethod string

// InputPrometheusDiscoveryType Target discovery mechanism. Use static to manually enter a list of targets.
type InputPrometheusDiscoveryType string

// InputPrometheusLogLevel Collector runtime Log Level
type InputPrometheusLogLevel string

// InputPrometheusPqCompress Codec to use to compress the persisted data.
type InputPrometheusPqCompress string

// InputPrometheusPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputPrometheusPqMode string

// InputPrometheusPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputPrometheusPqEnabled bool

// InputPrometheusRecordType DNS Record type to resolve
type InputPrometheusRecordType string

// InputPrometheusScrapeProtocol Protocol to use when collecting metrics
type InputPrometheusScrapeProtocol string

// InputPrometheusSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputPrometheusSendToRoutes bool

// InputPrometheusSignatureVersion Signature version to use for signing EC2 requests
type InputPrometheusSignatureVersion string

// InputPrometheusType defines model for InputPrometheus.Type.
type InputPrometheusType string

// InputPrometheusRw defines model for InputPrometheusRw.
type InputPrometheusRw struct {
	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType Remote Write authentication type
	AuthType *InputPrometheusRwAuthType `json:"authType,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`
	Disabled          *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputPrometheusRwPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputPrometheusRwPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputPrometheusRwPqEnabled `json:"pqEnabled,omitempty"`

	// PrometheusAPI Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<your‑upstream‑URL>:<your‑port>/write.
	PrometheusAPI string `json:"prometheusAPI"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputPrometheusRwSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`
	Spacer        *string  `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                       `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}                  `json:"commonNameRegex,omitempty"`
		Disabled        *InputPrometheusRwTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputPrometheusRwTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputPrometheusRwTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32               `json:"tokenTimeoutSecs,omitempty"`
	Type             *InputPrometheusRwType `json:"type,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputPrometheusRwAuthType Remote Write authentication type
type InputPrometheusRwAuthType string

// InputPrometheusRwPqCompress Codec to use to compress the persisted data.
type InputPrometheusRwPqCompress string

// InputPrometheusRwPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputPrometheusRwPqMode string

// InputPrometheusRwPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputPrometheusRwPqEnabled bool

// InputPrometheusRwSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputPrometheusRwSendToRoutes bool

// InputPrometheusRwTlsDisabled defines model for InputPrometheusRw.Tls.Disabled.
type InputPrometheusRwTlsDisabled bool

// InputPrometheusRwTlsMaxVersion Maximum TLS version to accept from connections
type InputPrometheusRwTlsMaxVersion string

// InputPrometheusRwTlsMinVersion Minimum TLS version to accept from connections
type InputPrometheusRwTlsMinVersion string

// InputPrometheusRwType defines model for InputPrometheusRw.Type.
type InputPrometheusRwType string

// InputRawUdp defines model for InputRawUdp.
type InputRawUdp struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IngestRawBytes If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
	IngestRawBytes *bool `json:"ingestRawBytes,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to send data
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxBufferSize Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputRawUdpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputRawUdpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputRawUdpPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputRawUdpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SingleMsgUdpPackets If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
	SingleMsgUdpPackets *bool `json:"singleMsgUdpPackets,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string        `json:"streamtags,omitempty"`
	Type       *InputRawUdpType `json:"type,omitempty"`

	// UdpSocketRxBufSize Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UdpSocketRxBufSize *float32 `json:"udpSocketRxBufSize,omitempty"`
}

// InputRawUdpPqCompress Codec to use to compress the persisted data.
type InputRawUdpPqCompress string

// InputRawUdpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputRawUdpPqMode string

// InputRawUdpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputRawUdpPqEnabled bool

// InputRawUdpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputRawUdpSendToRoutes bool

// InputRawUdpType defines model for InputRawUdp.Type.
type InputRawUdpType string

// InputS3 defines model for InputS3.
type InputS3 struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputS3AwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`
	Checkpointing   *struct {
		// Enabled Enable checkpointing to resume processing files after an interruption.
		Enabled InputS3CheckpointingEnabled `json:"enabled"`

		// Retries If checkpointing is enabled, the number of times to retry processing when a processing error occurs. If skip file on error is enabled, this setting is ignored.
		Retries *float32 `json:"retries,omitempty"`
	} `json:"checkpointing,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnableSQSAssumeRole Use Assume Role credentials when accessing SQS.
	EnableSQSAssumeRole *bool `json:"enableSQSAssumeRole,omitempty"`

	// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileFilter Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxMessages The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// ParquetChunkDownloadTimeout The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float32 `json:"parquetChunkDownloadTimeout,omitempty"`

	// ParquetChunkSizeMB Maximum file size for each Parquet chunk.
	ParquetChunkSizeMB *float32 `json:"parquetChunkSizeMB,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PollTimeout The amount of time to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float32 `json:"pollTimeout,omitempty"`
	Pq          *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputS3PqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputS3PqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputS3PqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputS3PreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// Region AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputS3SendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *InputS3SignatureVersion `json:"signatureVersion,omitempty"`

	// SkipOnError Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`

	// SocketTimeout Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string   `json:"streamtags,omitempty"`
	Type       InputS3Type `json:"type"`

	// VisibilityTimeout After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputS3AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputS3AwsAuthenticationMethod string

// InputS3CheckpointingEnabled Enable checkpointing to resume processing files after an interruption.
type InputS3CheckpointingEnabled bool

// InputS3PqCompress Codec to use to compress the persisted data.
type InputS3PqCompress string

// InputS3PqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputS3PqMode string

// InputS3PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputS3PqEnabled bool

// InputS3PreprocessDisabled Enable Custom Command
type InputS3PreprocessDisabled bool

// InputS3SendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputS3SendToRoutes bool

// InputS3SignatureVersion Signature version to use for signing S3 requests
type InputS3SignatureVersion string

// InputS3Type defines model for InputS3.Type.
type InputS3Type string

// InputS3Inventory defines model for InputS3Inventory.
type InputS3Inventory struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputS3InventoryAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`
	Checkpointing   *struct {
		// Enabled Enable checkpointing to resume processing files after an interruption.
		Enabled InputS3InventoryCheckpointingEnabled `json:"enabled"`

		// Retries If checkpointing is enabled, the number of times to retry processing when a processing error occurs. If skip file on error is enabled, this setting is ignored.
		Retries *float32 `json:"retries,omitempty"`
	} `json:"checkpointing,omitempty"`

	// ChecksumSuffix Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
	ChecksumSuffix *string `json:"checksumSuffix,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnableSQSAssumeRole Use Assume Role credentials when accessing SQS.
	EnableSQSAssumeRole *bool `json:"enableSQSAssumeRole,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileFilter Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxManifestSizeKB Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
	MaxManifestSizeKB *int `json:"maxManifestSizeKB,omitempty"`

	// MaxMessages The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// ParquetChunkDownloadTimeout The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float32 `json:"parquetChunkDownloadTimeout,omitempty"`

	// ParquetChunkSizeMB Maximum file size for each Parquet chunk.
	ParquetChunkSizeMB *float32 `json:"parquetChunkSizeMB,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PollTimeout The amount of time to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float32 `json:"pollTimeout,omitempty"`
	Pq          *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputS3InventoryPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputS3InventoryPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputS3InventoryPqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputS3InventoryPreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// Region AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputS3InventorySendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *InputS3InventorySignatureVersion `json:"signatureVersion,omitempty"`

	// SkipOnError Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`

	// SocketTimeout Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string            `json:"streamtags,omitempty"`
	Type       InputS3InventoryType `json:"type"`

	// ValidateInventoryFiles If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
	ValidateInventoryFiles *bool `json:"validateInventoryFiles,omitempty"`

	// VisibilityTimeout After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputS3InventoryAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputS3InventoryAwsAuthenticationMethod string

// InputS3InventoryCheckpointingEnabled Enable checkpointing to resume processing files after an interruption.
type InputS3InventoryCheckpointingEnabled bool

// InputS3InventoryPqCompress Codec to use to compress the persisted data.
type InputS3InventoryPqCompress string

// InputS3InventoryPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputS3InventoryPqMode string

// InputS3InventoryPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputS3InventoryPqEnabled bool

// InputS3InventoryPreprocessDisabled Enable Custom Command
type InputS3InventoryPreprocessDisabled bool

// InputS3InventorySendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputS3InventorySendToRoutes bool

// InputS3InventorySignatureVersion Signature version to use for signing S3 requests
type InputS3InventorySignatureVersion string

// InputS3InventoryType defines model for InputS3Inventory.Type.
type InputS3InventoryType string

// InputSecurityLake defines model for InputSecurityLake.
type InputSecurityLake struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputSecurityLakeAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`
	Checkpointing   *struct {
		// Enabled Enable checkpointing to resume processing files after an interruption.
		Enabled InputSecurityLakeCheckpointingEnabled `json:"enabled"`

		// Retries If checkpointing is enabled, the number of times to retry processing when a processing error occurs. If skip file on error is enabled, this setting is ignored.
		Retries *float32 `json:"retries,omitempty"`
	} `json:"checkpointing,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnableSQSAssumeRole Use Assume Role credentials when accessing SQS.
	EnableSQSAssumeRole *bool `json:"enableSQSAssumeRole,omitempty"`

	// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileFilter Regex matching file names to download and process. Defaults to: .*
	FileFilter *string `json:"fileFilter,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxMessages The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// ParquetChunkDownloadTimeout The maximum time allowed for downloading a Parquet chunk. Processing will abort if a chunk cannot be downloaded within the time specified.
	ParquetChunkDownloadTimeout *float32 `json:"parquetChunkDownloadTimeout,omitempty"`

	// ParquetChunkSizeMB Maximum file size for each Parquet chunk.
	ParquetChunkSizeMB *float32 `json:"parquetChunkSizeMB,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PollTimeout The amount of time to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float32 `json:"pollTimeout,omitempty"`
	Pq          *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSecurityLakePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSecurityLakePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputSecurityLakePqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputSecurityLakePreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// Region AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSecurityLakeSendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *InputSecurityLakeSignatureVersion `json:"signatureVersion,omitempty"`

	// SkipOnError Toggle to Yes to skip files that trigger a processing error. Defaults to No, which enables retries after processing errors.
	SkipOnError *bool `json:"skipOnError,omitempty"`

	// SocketTimeout Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string             `json:"streamtags,omitempty"`
	Type       InputSecurityLakeType `json:"type"`

	// VisibilityTimeout After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputSecurityLakeAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputSecurityLakeAwsAuthenticationMethod string

// InputSecurityLakeCheckpointingEnabled Enable checkpointing to resume processing files after an interruption.
type InputSecurityLakeCheckpointingEnabled bool

// InputSecurityLakePqCompress Codec to use to compress the persisted data.
type InputSecurityLakePqCompress string

// InputSecurityLakePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSecurityLakePqMode string

// InputSecurityLakePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSecurityLakePqEnabled bool

// InputSecurityLakePreprocessDisabled Enable Custom Command
type InputSecurityLakePreprocessDisabled bool

// InputSecurityLakeSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSecurityLakeSendToRoutes bool

// InputSecurityLakeSignatureVersion Signature version to use for signing S3 requests
type InputSecurityLakeSignatureVersion string

// InputSecurityLakeType defines model for InputSecurityLake.Type.
type InputSecurityLakeType string

// InputSnmp defines model for InputSnmp.
type InputSnmp struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to send data
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxBufferSize Maximum number of events to buffer when downstream is blocking.
	MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port UDP port to receive SNMP traps on. Defaults to 162.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSnmpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSnmpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSnmpPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSnmpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SnmpV3Auth Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
	SnmpV3Auth *struct {
		// AllowUnmatchedTrap Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
		AllowUnmatchedTrap *bool                            `json:"allowUnmatchedTrap,omitempty"`
		V3AuthEnabled      InputSnmpSnmpV3AuthV3AuthEnabled `json:"v3AuthEnabled"`

		// V3Users User credentials for receiving v3 traps
		V3Users *[]struct {
			AuthKey      *interface{}                            `json:"authKey,omitempty"`
			AuthProtocol *InputSnmpSnmpV3AuthV3UsersAuthProtocol `json:"authProtocol,omitempty"`
			Name         string                                  `json:"name"`
			PrivProtocol *interface{}                            `json:"privProtocol,omitempty"`
		} `json:"v3Users,omitempty"`
	} `json:"snmpV3Auth,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string      `json:"streamtags,omitempty"`
	Type       *InputSnmpType `json:"type,omitempty"`

	// UdpSocketRxBufSize Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UdpSocketRxBufSize *float32 `json:"udpSocketRxBufSize,omitempty"`

	// VarbindsWithTypes If enabled, parses varbinds as an array of objects that include OID, value, and type
	VarbindsWithTypes *bool `json:"varbindsWithTypes,omitempty"`
}

// InputSnmpPqCompress Codec to use to compress the persisted data.
type InputSnmpPqCompress string

// InputSnmpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSnmpPqMode string

// InputSnmpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSnmpPqEnabled bool

// InputSnmpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSnmpSendToRoutes bool

// InputSnmpSnmpV3AuthV3AuthEnabled defines model for InputSnmp.SnmpV3Auth.V3AuthEnabled.
type InputSnmpSnmpV3AuthV3AuthEnabled bool

// InputSnmpSnmpV3AuthV3UsersAuthProtocol defines model for InputSnmp.SnmpV3Auth.V3Users.AuthProtocol.
type InputSnmpSnmpV3AuthV3UsersAuthProtocol string

// InputSnmpType defines model for InputSnmp.Type.
type InputSnmpType string

// InputSplunk defines model for InputSplunk.
type InputSplunk struct {
	// AuthTokens Shared secrets to be provided by any Splunk forwarder. If empty, unauthed access is permitted.
	AuthTokens *[]struct {
		// Description Optional token description
		Description *string `json:"description,omitempty"`

		// Token Shared secrets to be provided by any Splunk forwarder. If empty, unauthed access is permitted.
		Token string `json:"token"`
	} `json:"authTokens,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DropControlFields Whether to drop Splunk control fields such as `crcSalt` and `_savedPort`. If false, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtractMetrics Enable to extract and process Splunk-generated metrics as Cribl metrics.
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to establish a connection.
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// MaxS2Sversion The highest S2S protocol version to advertise during handshake.
	MaxS2Sversion *InputSplunkMaxS2Sversion `json:"maxS2Sversion,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSplunkPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSplunkPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSplunkPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSplunkSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                 `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}            `json:"commonNameRegex,omitempty"`
		Disabled        *InputSplunkTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputSplunkTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputSplunkTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputSplunkType `json:"type,omitempty"`

	// UseFwdTimezone Enables Event Breakers to determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Toggle to 'No' to disable this fallback.
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
}

// InputSplunkMaxS2Sversion The highest S2S protocol version to advertise during handshake.
type InputSplunkMaxS2Sversion string

// InputSplunkPqCompress Codec to use to compress the persisted data.
type InputSplunkPqCompress string

// InputSplunkPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSplunkPqMode string

// InputSplunkPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSplunkPqEnabled bool

// InputSplunkSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSplunkSendToRoutes bool

// InputSplunkTlsDisabled defines model for InputSplunk.Tls.Disabled.
type InputSplunkTlsDisabled bool

// InputSplunkTlsMaxVersion Maximum TLS version to accept from connections
type InputSplunkTlsMaxVersion string

// InputSplunkTlsMinVersion Minimum TLS version to accept from connections
type InputSplunkTlsMinVersion string

// InputSplunkType defines model for InputSplunk.Type.
type InputSplunkType string

// InputSplunkHec defines model for InputSplunkHec.
type InputSplunkHec struct {
	// AccessControlAllowHeaders Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders *[]string `json:"accessControlAllowHeaders,omitempty"`

	// AccessControlAllowOrigin Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin *[]string `json:"accessControlAllowOrigin,omitempty"`

	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AllowedIndexes List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes *[]string `json:"allowedIndexes,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens *[]struct {
		// AllowedIndexesAtToken Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
		AllowedIndexesAtToken *[]string `json:"allowedIndexesAtToken,omitempty"`

		// AuthType Enter a token directly, or provide a secret referencing a token
		AuthType *InputSplunkHecAuthTokensAuthType `json:"authType,omitempty"`

		// Description Optional token description
		Description *string `json:"description,omitempty"`
		Enabled     *bool   `json:"enabled,omitempty"`

		// Metadata Fields to add to events referencing this token
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`
		Token       interface{}  `json:"token"`
		TokenSecret *interface{} `json:"tokenSecret,omitempty"`
	} `json:"authTokens,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DropControlFields Whether to drop Splunk control fields such as `crcSalt` and `_savedPort`. If false, control fields are stored in the internal field `__ctrlFields`.
	DropControlFields *bool `json:"dropControlFields,omitempty"`

	// EmitTokenMetrics Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics  *bool        `json:"emitTokenMetrics,omitempty"`
	EnableHealthCheck *interface{} `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtractMetrics Enable to extract and process Splunk-generated metrics as Cribl metrics.
	ExtractMetrics *bool `json:"extractMetrics,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSplunkHecPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSplunkHecPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSplunkHecPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSplunkHecSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// SplunkHecAPI Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
	SplunkHecAPI string `json:"splunkHecAPI"`

	// SplunkHecAcks Whether to enable Splunk HEC acknowledgements
	SplunkHecAcks *bool `json:"splunkHecAcks,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                    `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}               `json:"commonNameRegex,omitempty"`
		Disabled        *InputSplunkHecTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputSplunkHecTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputSplunkHecTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputSplunkHecType `json:"type,omitempty"`

	// UseFwdTimezone Enables Event Breakers to determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Toggle to 'No' to disable this fallback.
	UseFwdTimezone *bool `json:"useFwdTimezone,omitempty"`
}

// InputSplunkHecAuthTokensAuthType Enter a token directly, or provide a secret referencing a token
type InputSplunkHecAuthTokensAuthType string

// InputSplunkHecPqCompress Codec to use to compress the persisted data.
type InputSplunkHecPqCompress string

// InputSplunkHecPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSplunkHecPqMode string

// InputSplunkHecPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSplunkHecPqEnabled bool

// InputSplunkHecSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSplunkHecSendToRoutes bool

// InputSplunkHecTlsDisabled defines model for InputSplunkHec.Tls.Disabled.
type InputSplunkHecTlsDisabled bool

// InputSplunkHecTlsMaxVersion Maximum TLS version to accept from connections
type InputSplunkHecTlsMaxVersion string

// InputSplunkHecTlsMinVersion Minimum TLS version to accept from connections
type InputSplunkHecTlsMinVersion string

// InputSplunkHecType defines model for InputSplunkHec.Type.
type InputSplunkHecType string

// InputSplunkSearch defines model for InputSplunkSearch.
type InputSplunkSearch struct {
	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType Splunk Search authentication type
	AuthType *InputSplunkSearchAuthType `json:"authType,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`

	// CronSchedule A cron schedule on which to run this job.
	CronSchedule string  `json:"cronSchedule"`
	Description  *string `json:"description,omitempty"`
	Disabled     *bool   `json:"disabled,omitempty"`

	// Earliest The earliest time boundary for the search. Can be an exact or relative time. For example: '2022-01-14T12:00:00Z' or '-16m@m'
	Earliest *string `json:"earliest,omitempty"`

	// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
	Encoding *string `json:"encoding,omitempty"`

	// Endpoint REST API used to create a search.
	Endpoint string `json:"endpoint"`

	// EndpointHeaders Optional request headers to send to the endpoint.
	EndpointHeaders *[]struct {
		// Name Header Name
		Name string `json:"name"`

		// Value JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
		Value string `json:"value"`
	} `json:"endpointHeaders,omitempty"`

	// EndpointParams Optional request parameters to send to the endpoint.
	EndpointParams *[]struct {
		// Name Parameter name
		Name string `json:"name"`

		// Value JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
		Value string `json:"value"`
	} `json:"endpointParams,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// JobTimeout Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
	JobTimeout *string `json:"jobTimeout,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// Latest The latest time boundary for the search. Can be an exact or relative time. For example: '2022-01-14T12:00:00Z' or '-1m@m'
	Latest *string `json:"latest,omitempty"`

	// LogLevel Collector runtime log Level (verbosity).
	LogLevel *InputSplunkSearchLogLevel `json:"logLevel,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OutputMode Format of the returned output
	OutputMode InputSplunkSearchOutputMode `json:"outputMode"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSplunkSearchPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSplunkSearchPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSplunkSearchPqEnabled `json:"pqEnabled,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RequestTimeout HTTP request inactivity timeout, use 0 to disable
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`
	RetryRules     *struct {
		// Codes List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
		Codes *[]float32 `json:"codes,omitempty"`

		// EnableHeader Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
		EnableHeader *bool `json:"enableHeader,omitempty"`

		// Interval Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
		Interval *float32 `json:"interval,omitempty"`

		// Limit The maximum number of times to retry a failed HTTP request
		Limit *float32 `json:"limit,omitempty"`

		// Multiplier Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
		Multiplier *float32 `json:"multiplier,omitempty"`

		// RetryConnectReset When toggled to Yes, the request will be retried when a connection reset (ECONNRESET) error occurs
		RetryConnectReset *bool `json:"retryConnectReset,omitempty"`

		// RetryConnectTimeout When toggled to Yes, a single retry attempt will be made when a connection timeout (ETIMEDOUT) error occurs
		RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`

		// Type The algorithm to use when performing HTTP retries
		Type InputSplunkSearchRetryRulesType `json:"type"`
	} `json:"retryRules,omitempty"`

	// Search Enter Splunk search here. For example: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
	Search string `json:"search"`

	// SearchHead Search head base URL, can be expression, default is https://localhost:8089.
	SearchHead string `json:"searchHead"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSplunkSearchSendToRoutes `json:"sendToRoutes,omitempty"`
	Spacer       *string                        `json:"spacer"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32 `json:"tokenTimeoutSecs,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                `json:"ttl,omitempty"`
	Type *InputSplunkSearchType `json:"type,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputSplunkSearchAuthType Splunk Search authentication type
type InputSplunkSearchAuthType string

// InputSplunkSearchLogLevel Collector runtime log Level (verbosity).
type InputSplunkSearchLogLevel string

// InputSplunkSearchOutputMode Format of the returned output
type InputSplunkSearchOutputMode string

// InputSplunkSearchPqCompress Codec to use to compress the persisted data.
type InputSplunkSearchPqCompress string

// InputSplunkSearchPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSplunkSearchPqMode string

// InputSplunkSearchPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSplunkSearchPqEnabled bool

// InputSplunkSearchRetryRulesType The algorithm to use when performing HTTP retries
type InputSplunkSearchRetryRulesType string

// InputSplunkSearchSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSplunkSearchSendToRoutes bool

// InputSplunkSearchType defines model for InputSplunkSearch.Type.
type InputSplunkSearchType string

// InputSqs defines model for InputSqs.
type InputSqs struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *InputSqsAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`

	// CreateQueue Create queue if it does not exist.
	CreateQueue *bool   `json:"createQueue,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint SQS service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// MaxMessages The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
	MaxMessages *float32 `json:"maxMessages,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// NumReceivers The Number of receiver processes to run, the higher the number the better throughput at the expense of CPU overhead
	NumReceivers *float32 `json:"numReceivers,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// PollTimeout The amount of time to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
	PollTimeout *float32 `json:"pollTimeout,omitempty"`
	Pq          *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSqsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSqsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSqsPqEnabled `json:"pqEnabled,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. E.g. referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// QueueType The queue type used (or created). Defaults to Standard
	QueueType InputSqsQueueType `json:"queueType"`

	// Region AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSqsSendToRoutes `json:"sendToRoutes,omitempty"`

	// SignatureVersion Signature version to use for signing SQS requests
	SignatureVersion *InputSqsSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string     `json:"streamtags,omitempty"`
	Type       *InputSqsType `json:"type,omitempty"`

	// VisibilityTimeout After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
	VisibilityTimeout *float32 `json:"visibilityTimeout,omitempty"`
}

// InputSqsAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type InputSqsAwsAuthenticationMethod string

// InputSqsPqCompress Codec to use to compress the persisted data.
type InputSqsPqCompress string

// InputSqsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSqsPqMode string

// InputSqsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSqsPqEnabled bool

// InputSqsQueueType The queue type used (or created). Defaults to Standard
type InputSqsQueueType string

// InputSqsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSqsSendToRoutes bool

// InputSqsSignatureVersion Signature version to use for signing SQS requests
type InputSqsSignatureVersion string

// InputSqsType defines model for InputSqs.Type.
type InputSqsType string

// InputStatus defines model for InputStatus.
type InputStatus struct {
	Id     string `json:"id"`
	Status struct {
		Health    InputStatusStatusHealth `json:"health"`
		Metrics   map[string]interface{}  `json:"metrics"`
		Timestamp float32                 `json:"timestamp"`
	} `json:"status"`
}

// InputStatusStatusHealth defines model for InputStatus.Status.Health.
type InputStatusStatusHealth string

// InputSyslog defines model for InputSyslog.
type InputSyslog struct {
	// AllowNonStandardAppName Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableLoadBalancing Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// InferFraming Enable if we should infer the syslog framing of the incoming messages.
	InferFraming *bool `json:"inferFraming,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to send data
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// KeepFieldsList Wildcard list of fields to keep from source data, * = ALL (default)
	KeepFieldsList *[]string `json:"keepFieldsList,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// MaxBufferSize Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OctetCounting Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting *bool `json:"octetCounting,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSyslogPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSyslogPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSyslogPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSyslogSendToRoutes `json:"sendToRoutes,omitempty"`

	// SingleMsgUdpPackets Whether to treat UDP packet data received as full syslog message
	SingleMsgUdpPackets *bool `json:"singleMsgUdpPackets,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// StrictlyInferOctetCounting Enable if we should infer octet counting only if the messages comply with RFC 5424.
	StrictlyInferOctetCounting *bool `json:"strictlyInferOctetCounting,omitempty"`

	// TcpPort Enter TCP port number to listen on. Not required if listening on UDP.
	TcpPort *float32 `json:"tcpPort,omitempty"`

	// TimestampTimezone Timezone to assign to timestamps without timezone info
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	Tls               *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                 `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}            `json:"commonNameRegex,omitempty"`
		Disabled        *InputSyslogTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputSyslogTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputSyslogTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type InputSyslogType `json:"type"`

	// UdpPort Enter UDP port number to listen on. Not required if listening on TCP.
	UdpPort *float32 `json:"udpPort,omitempty"`

	// UdpSocketRxBufSize Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
	UdpSocketRxBufSize *float32 `json:"udpSocketRxBufSize,omitempty"`
	Union              json.RawMessage
}

// InputSyslogPqCompress Codec to use to compress the persisted data.
type InputSyslogPqCompress string

// InputSyslogPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSyslogPqMode string

// InputSyslogPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSyslogPqEnabled bool

// InputSyslogSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSyslogSendToRoutes bool

// InputSyslogTlsDisabled defines model for InputSyslog.Tls.Disabled.
type InputSyslogTlsDisabled bool

// InputSyslogTlsMaxVersion Maximum TLS version to accept from connections
type InputSyslogTlsMaxVersion string

// InputSyslogTlsMinVersion Minimum TLS version to accept from connections
type InputSyslogTlsMinVersion string

// InputSyslogType defines model for InputSyslog.Type.
type InputSyslogType string

// InputSyslog0 defines model for .
type InputSyslog0 = interface{}

// InputSyslog1 defines model for .
type InputSyslog1 = interface{}

// InputSystemMetrics defines model for InputSystemMetrics.
type InputSystemMetrics struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Container *struct {
		// AllContainers Include stopped and paused containers
		AllContainers *bool `json:"allContainers,omitempty"`

		// Detail Generate full container metrics
		Detail *bool `json:"detail,omitempty"`

		// DockerSocket Full paths for Docker's UNIX-domain socket
		DockerSocket *[]string `json:"dockerSocket,omitempty"`

		// DockerTimeout Timeout, in seconds, for the Docker API
		DockerTimeout *float32 `json:"dockerTimeout,omitempty"`

		// Filters Containers matching any of these will be included. All are included if this is empty.
		Filters *[]struct {
			Expr string `json:"expr"`
		} `json:"filters,omitempty"`

		// Mode Select the level of detail for container metrics
		Mode *InputSystemMetricsContainerMode `json:"mode,omitempty"`

		// PerDevice Generate separate metrics for each device
		PerDevice *bool `json:"perDevice,omitempty"`
	} `json:"container,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Host        *struct {
		Custom *struct {
			Cpu *struct {
				// Detail Generate metrics for all CPU states
				Detail *bool `json:"detail,omitempty"`

				// Mode Select the level of details for CPU metrics
				Mode *InputSystemMetricsHostCustomCpuMode `json:"mode,omitempty"`

				// PerCpu Generate metrics for each CPU
				PerCpu *bool `json:"perCpu,omitempty"`

				// Time Generate raw, monotonic CPU time counters
				Time *bool `json:"time,omitempty"`
			} `json:"cpu,omitempty"`
			Disk *struct {
				// Detail Generate full disk metrics
				Detail *bool `json:"detail,omitempty"`

				// Devices Block devices to include/exclude. E.g.: sda*, !loop*, etc. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
				Devices *[]string `json:"devices,omitempty"`

				// Fstypes Filesystem types to include/exclude. E.g.: ext4, !*tmpfs, !squashfs, etc. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
				Fstypes *[]string `json:"fstypes,omitempty"`

				// Mode Select the level of details for disk metrics
				Mode *InputSystemMetricsHostCustomDiskMode `json:"mode,omitempty"`

				// Mountpoints Filesystem mountpoints to include/exclude. E.g.: /, /home, !/proc*, !/tmp, etc. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
				Mountpoints *[]string `json:"mountpoints,omitempty"`

				// PerDevice Generate separate metrics for each device
				PerDevice *bool `json:"perDevice,omitempty"`
			} `json:"disk,omitempty"`
			Memory *struct {
				// Detail Generate metrics for all memory states
				Detail *bool `json:"detail,omitempty"`

				// Mode Select the level of details for memory metrics
				Mode *InputSystemMetricsHostCustomMemoryMode `json:"mode,omitempty"`
			} `json:"memory,omitempty"`
			Network *struct {
				// Detail Generate full network metrics
				Detail *bool `json:"detail,omitempty"`

				// Devices Network interfaces to include/exclude. E.g.: eth0, !lo, etc. All interfaces are included if this list is empty.
				Devices *[]string `json:"devices,omitempty"`

				// Mode Select the level of details for network metrics
				Mode *InputSystemMetricsHostCustomNetworkMode `json:"mode,omitempty"`

				// PerInterface Generate separate metrics for each interface
				PerInterface *bool `json:"perInterface,omitempty"`
			} `json:"network,omitempty"`
			System *struct {
				// Mode Select the level of details for system metrics
				Mode *InputSystemMetricsHostCustomSystemMode `json:"mode,omitempty"`

				// Processes Generate metrics for the numbers of processes in various states
				Processes *bool `json:"processes,omitempty"`
			} `json:"system,omitempty"`
		} `json:"custom,omitempty"`

		// Mode Select level of detail for host metrics
		Mode *InputSystemMetricsHostMode `json:"mode,omitempty"`
	} `json:"host,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Interval Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Select data compression format. Optional.
		Compress *InputSystemMetricsPersistenceCompress `json:"compress,omitempty"`

		// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
		DestPath *string `json:"destPath,omitempty"`

		// Enable Spool metrics to disk for Cribl Edge and Search
		Enable *InputSystemMetricsPersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time span for each file bucket
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSystemMetricsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSystemMetricsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSystemMetricsPqEnabled `json:"pqEnabled,omitempty"`
	Process   *struct {
		// Sets Configure sets to collect process metrics
		Sets *[]struct {
			Filter          string `json:"filter"`
			IncludeChildren *bool  `json:"includeChildren,omitempty"`
			Name            string `json:"name"`
		} `json:"sets,omitempty"`
	} `json:"process,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSystemMetricsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string              `json:"streamtags,omitempty"`
	Type       InputSystemMetricsType `json:"type"`
}

// InputSystemMetricsContainerMode Select the level of detail for container metrics
type InputSystemMetricsContainerMode string

// InputSystemMetricsHostCustomCpuMode Select the level of details for CPU metrics
type InputSystemMetricsHostCustomCpuMode string

// InputSystemMetricsHostCustomDiskMode Select the level of details for disk metrics
type InputSystemMetricsHostCustomDiskMode string

// InputSystemMetricsHostCustomMemoryMode Select the level of details for memory metrics
type InputSystemMetricsHostCustomMemoryMode string

// InputSystemMetricsHostCustomNetworkMode Select the level of details for network metrics
type InputSystemMetricsHostCustomNetworkMode string

// InputSystemMetricsHostCustomSystemMode Select the level of details for system metrics
type InputSystemMetricsHostCustomSystemMode string

// InputSystemMetricsHostMode Select level of detail for host metrics
type InputSystemMetricsHostMode string

// InputSystemMetricsPersistenceCompress Select data compression format. Optional.
type InputSystemMetricsPersistenceCompress string

// InputSystemMetricsPersistenceEnable Spool metrics to disk for Cribl Edge and Search
type InputSystemMetricsPersistenceEnable bool

// InputSystemMetricsPqCompress Codec to use to compress the persisted data.
type InputSystemMetricsPqCompress string

// InputSystemMetricsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSystemMetricsPqMode string

// InputSystemMetricsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSystemMetricsPqEnabled bool

// InputSystemMetricsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSystemMetricsSendToRoutes bool

// InputSystemMetricsType defines model for InputSystemMetrics.Type.
type InputSystemMetricsType string

// InputSystemState defines model for InputSystemState.
type InputSystemState struct {
	Collectors *struct {
		// Disk Creates events for physical disks, partitions, and file systems
		Disk *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"disk,omitempty"`

		// Dns Creates events for DNS resolvers and search entries
		Dns *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"dns,omitempty"`

		// Firewall Creates events for Firewall rules entries
		Firewall *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"firewall,omitempty"`

		// Hostsfile Creates events based on entries collected from the hosts file
		Hostsfile *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"hostsfile,omitempty"`

		// Interfaces Creates events for each of the host’s network interfaces
		Interfaces *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"interfaces,omitempty"`

		// LoginUsers Creates events from list of logged in users
		LoginUsers *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"loginUsers,omitempty"`

		// Metadata Creates events based on the host system’s current state
		Metadata *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"metadata,omitempty"`

		// Ports Creates events from list of listening ports
		Ports *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"ports,omitempty"`

		// Routes Creates events based on entries collected from the host’s network routes
		Routes *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"routes,omitempty"`

		// Services Creates events from the list of services
		Services *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"services,omitempty"`

		// User Creates events for local users and groups
		User *struct {
			Enable *bool `json:"enable,omitempty"`
		} `json:"user,omitempty"`
	} `json:"collectors,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Interval Time, in seconds, between consecutive state collections. Default is 300 seconds. (i.e. 5 minutes)
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Select data compression format. Optional.
		Compress *InputSystemStatePersistenceCompress `json:"compress,omitempty"`

		// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
		DestPath *string `json:"destPath,omitempty"`

		// Enable Spool metrics to disk for Cribl Edge and Search
		Enable *InputSystemStatePersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time span for each file bucket
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputSystemStatePqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputSystemStatePqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputSystemStatePqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputSystemStateSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string            `json:"streamtags,omitempty"`
	Type       InputSystemStateType `json:"type"`
}

// InputSystemStatePersistenceCompress Select data compression format. Optional.
type InputSystemStatePersistenceCompress string

// InputSystemStatePersistenceEnable Spool metrics to disk for Cribl Edge and Search
type InputSystemStatePersistenceEnable bool

// InputSystemStatePqCompress Codec to use to compress the persisted data.
type InputSystemStatePqCompress string

// InputSystemStatePqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSystemStatePqMode string

// InputSystemStatePqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputSystemStatePqEnabled bool

// InputSystemStateSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputSystemStateSendToRoutes bool

// InputSystemStateType defines model for InputSystemState.Type.
type InputSystemStateType string

// InputTcp defines model for InputTcp.
type InputTcp struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *InputTcpAuthType `json:"authType,omitempty"`

	// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHeader If enabled, client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
	EnableHeader *InputTcpEnableHeader `json:"enableHeader,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to establish a connection.
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputTcpPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputTcpPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled  *InputTcpPqEnabled `json:"pqEnabled,omitempty"`
	Preprocess *struct {
		// Args Arguments to be added to the custom command
		Args *[]string `json:"args,omitempty"`

		// Command Command to feed the data through (via stdin) and process its output (stdout)
		Command *string `json:"command,omitempty"`

		// Disabled Enable Custom Command
		Disabled InputTcpPreprocessDisabled `json:"disabled"`
	} `json:"preprocess,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputTcpSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string              `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}         `json:"commonNameRegex,omitempty"`
		Disabled        *InputTcpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputTcpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputTcpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputTcpType `json:"type,omitempty"`
}

// InputTcpAuthType Enter a token directly, or provide a secret referencing a token
type InputTcpAuthType string

// InputTcpEnableHeader If enabled, client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
type InputTcpEnableHeader bool

// InputTcpPqCompress Codec to use to compress the persisted data.
type InputTcpPqCompress string

// InputTcpPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputTcpPqMode string

// InputTcpPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputTcpPqEnabled bool

// InputTcpPreprocessDisabled Enable Custom Command
type InputTcpPreprocessDisabled bool

// InputTcpSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputTcpSendToRoutes bool

// InputTcpTlsDisabled defines model for InputTcp.Tls.Disabled.
type InputTcpTlsDisabled bool

// InputTcpTlsMaxVersion Maximum TLS version to accept from connections
type InputTcpTlsMaxVersion string

// InputTcpTlsMinVersion Minimum TLS version to accept from connections
type InputTcpTlsMinVersion string

// InputTcpType defines model for InputTcp.Type.
type InputTcpType string

// InputTcpjson defines model for InputTcpjson.
type InputTcpjson struct {
	// AuthToken Shared secret to be provided by any client (in authToken header field). If empty, unauthed access is permitted.
	AuthToken *string `json:"authToken,omitempty"`

	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *InputTcpjsonAuthType `json:"authType,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableLoadBalancing Load balance traffic across all Worker Processes
	EnableLoadBalancing *bool `json:"enableLoadBalancing,omitempty"`

	// EnableProxyHeader Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpWhitelistRegex Regex matching IP addresses that are allowed to establish a connection.
	IpWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`

	// MaxActiveCxn Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
	MaxActiveCxn *float32 `json:"maxActiveCxn,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputTcpjsonPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputTcpjsonPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputTcpjsonPqEnabled `json:"pqEnabled,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputTcpjsonSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketEndingMaxWait How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
	SocketEndingMaxWait *float32 `json:"socketEndingMaxWait,omitempty"`

	// SocketIdleTimeout How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
	SocketIdleTimeout *float32 `json:"socketIdleTimeout,omitempty"`

	// SocketMaxLifespan The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
	SocketMaxLifespan *float32 `json:"socketMaxLifespan,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}             `json:"commonNameRegex,omitempty"`
		Disabled        *InputTcpjsonTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputTcpjsonTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputTcpjsonTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputTcpjsonType `json:"type,omitempty"`
}

// InputTcpjsonAuthType Enter a token directly, or provide a secret referencing a token
type InputTcpjsonAuthType string

// InputTcpjsonPqCompress Codec to use to compress the persisted data.
type InputTcpjsonPqCompress string

// InputTcpjsonPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputTcpjsonPqMode string

// InputTcpjsonPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputTcpjsonPqEnabled bool

// InputTcpjsonSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputTcpjsonSendToRoutes bool

// InputTcpjsonTlsDisabled defines model for InputTcpjson.Tls.Disabled.
type InputTcpjsonTlsDisabled bool

// InputTcpjsonTlsMaxVersion Maximum TLS version to accept from connections
type InputTcpjsonTlsMaxVersion string

// InputTcpjsonTlsMinVersion Minimum TLS version to accept from connections
type InputTcpjsonTlsMinVersion string

// InputTcpjsonType defines model for InputTcpjson.Type.
type InputTcpjsonType string

// InputWef defines model for InputWef.
type InputWef struct {
	// AllowMachineIdMismatch Allow events to be ingested even if their MachineID does not match the client certificate CN.
	AllowMachineIdMismatch *bool `json:"allowMachineIdMismatch,omitempty"`

	// AuthMethod Method by which to authenticate incoming client connections.
	AuthMethod *InputWefAuthMethod `json:"authMethod,omitempty"`

	// CaFingerprint SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EnableHealthCheck Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
	EnableHealthCheck *bool `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// Keytab Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputWefPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputWefPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputWefPqEnabled `json:"pqEnabled,omitempty"`

	// Principal Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>.
	Principal *string `json:"principal,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputWefSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Subscriptions Subscriptions to events on forwarding endpoints.
	Subscriptions []struct {
		// BatchTimeout Interval (in seconds) over which the endpoint should collect events before sending them to Stream.
		BatchTimeout float32 `json:"batchTimeout"`

		// Compress If toggled to Yes, Stream will receive compressed events from the source.
		Compress *bool `json:"compress,omitempty"`

		// ContentFormat Content format in which the endpoint should deliver events.
		ContentFormat InputWefSubscriptionsContentFormat `json:"contentFormat"`

		// HeartbeatInterval Max time (in seconds) between endpoint checkins before considering it unavailable.
		HeartbeatInterval float32 `json:"heartbeatInterval"`

		// Locale The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
		Locale *string `json:"locale,omitempty"`

		// Metadata Fields to add to events ingested under this subscription
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`

		// QuerySelector Select the query builder mode.
		QuerySelector *InputWefSubscriptionsQuerySelector `json:"querySelector,omitempty"`

		// ReadExistingEvents Set to Yes if a newly-subscribed endpoint should send previously existing events. Set to No to only receive new events
		ReadExistingEvents *bool `json:"readExistingEvents,omitempty"`

		// SendBookmarks If toggled to Yes, @{product} will keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events' -- see the documentation for details.
		SendBookmarks *bool `json:"sendBookmarks,omitempty"`

		// SubscriptionName Friendly name for this subscription.
		SubscriptionName string `json:"subscriptionName"`

		// Targets Enter the DNS names of the endpoints that should forward these events. You may use wildcards, for example: *.mydomain.com
		Targets []string `json:"targets"`

		// Version Version UUID for this subscription. If any subscription parameters are modified, this value will change.
		Version *string `json:"version,omitempty"`
	} `json:"subscriptions"`
	Tls *struct {
		// CaPath Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
		CaPath string `json:"caPath"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath string `json:"certPath"`

		// CertificateName Name of the predefined certificate.
		CertificateName *string `json:"certificateName,omitempty"`

		// CommonNameRegex Regex matching allowable common names in peer certificates' subject attribute.
		CommonNameRegex *string `json:"commonNameRegex,omitempty"`

		// Disabled Enable TLS
		Disabled *bool        `json:"disabled,omitempty"`
		Keytab   *interface{} `json:"keytab,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputWefTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections.
		MinVersion *InputWefTlsMinVersion `json:"minVersion,omitempty"`

		// OcspCheck Enable OCSP check of certificate
		OcspCheck *InputWefTlsOcspCheck `json:"ocspCheck,omitempty"`

		// OcspCheckFailClose If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
		OcspCheckFailClose *bool `json:"ocspCheckFailClose,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string      `json:"passphrase,omitempty"`
		Principal  *interface{} `json:"principal,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath string `json:"privKeyPath"`

		// RejectUnauthorized Required for WEF certificate authentication.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// RequestCert Required for WEF certificate authentication.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputWefType `json:"type,omitempty"`
}

// InputWefAuthMethod Method by which to authenticate incoming client connections.
type InputWefAuthMethod string

// InputWefPqCompress Codec to use to compress the persisted data.
type InputWefPqCompress string

// InputWefPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputWefPqMode string

// InputWefPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputWefPqEnabled bool

// InputWefSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputWefSendToRoutes bool

// InputWefSubscriptionsContentFormat Content format in which the endpoint should deliver events.
type InputWefSubscriptionsContentFormat string

// InputWefSubscriptionsQuerySelector Select the query builder mode.
type InputWefSubscriptionsQuerySelector string

// InputWefTlsMaxVersion Maximum TLS version to accept from connections
type InputWefTlsMaxVersion string

// InputWefTlsMinVersion Minimum TLS version to accept from connections.
type InputWefTlsMinVersion string

// InputWefTlsOcspCheck Enable OCSP check of certificate
type InputWefTlsOcspCheck bool

// InputWefType defines model for InputWef.Type.
type InputWefType string

// InputWinEventLogs defines model for InputWinEventLogs.
type InputWinEventLogs struct {
	// BatchSize The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
	BatchSize *float32 `json:"batchSize,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`

	// DisableNativeModule Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
	DisableNativeModule *InputWinEventLogsDisableNativeModule `json:"disableNativeModule,omitempty"`
	Disabled            *bool                                 `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// EventFormat Format of individual events
	EventFormat *InputWinEventLogsEventFormat `json:"eventFormat,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// Interval Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
	Interval *float32 `json:"interval,omitempty"`

	// LogNames Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
	LogNames []string `json:"logNames"`

	// MaxEventBytes The maximum number of bytes in an event before it is flushed to the pipelines
	MaxEventBytes *float32 `json:"maxEventBytes,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputWinEventLogsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputWinEventLogsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputWinEventLogsPqEnabled `json:"pqEnabled,omitempty"`

	// ReadMode Read all stored and future event logs, or only future events
	ReadMode *InputWinEventLogsReadMode `json:"readMode,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputWinEventLogsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string             `json:"streamtags,omitempty"`
	Type       InputWinEventLogsType `json:"type"`
}

// InputWinEventLogsDisableNativeModule Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
type InputWinEventLogsDisableNativeModule bool

// InputWinEventLogsEventFormat Format of individual events
type InputWinEventLogsEventFormat string

// InputWinEventLogsPqCompress Codec to use to compress the persisted data.
type InputWinEventLogsPqCompress string

// InputWinEventLogsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputWinEventLogsPqMode string

// InputWinEventLogsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputWinEventLogsPqEnabled bool

// InputWinEventLogsReadMode Read all stored and future event logs, or only future events
type InputWinEventLogsReadMode string

// InputWinEventLogsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputWinEventLogsSendToRoutes bool

// InputWinEventLogsType defines model for InputWinEventLogs.Type.
type InputWinEventLogsType string

// InputWindowsMetrics defines model for InputWindowsMetrics.
type InputWindowsMetrics struct {
	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`

	// DisableNativeModule Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
	DisableNativeModule *bool `json:"disableNativeModule,omitempty"`
	Disabled            *bool `json:"disabled,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Host        *struct {
		Custom *struct {
			Cpu *struct {
				// Detail Generate metrics for all CPU states
				Detail *bool `json:"detail,omitempty"`

				// Mode Select the level of details for CPU metrics
				Mode *InputWindowsMetricsHostCustomCpuMode `json:"mode,omitempty"`

				// PerCpu Generate metrics for each CPU
				PerCpu *bool `json:"perCpu,omitempty"`

				// Time Generate raw, monotonic CPU time counters
				Time *bool `json:"time,omitempty"`
			} `json:"cpu,omitempty"`
			Disk *struct {
				// Mode Select the level of details for disk metrics
				Mode *InputWindowsMetricsHostCustomDiskMode `json:"mode,omitempty"`

				// PerVolume Generate separate metrics for each volume
				PerVolume *bool `json:"perVolume,omitempty"`

				// Volumes Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
				Volumes *[]string `json:"volumes,omitempty"`
			} `json:"disk,omitempty"`
			Memory *struct {
				// Detail Generate metrics for all memory states
				Detail *bool `json:"detail,omitempty"`

				// Mode Select the level of details for memory metrics
				Mode *InputWindowsMetricsHostCustomMemoryMode `json:"mode,omitempty"`
			} `json:"memory,omitempty"`
			Network *struct {
				// Detail Generate full network metrics
				Detail *bool `json:"detail,omitempty"`

				// Devices Network interfaces to include/exclude. All interfaces are included if this list is empty.
				Devices *[]string `json:"devices,omitempty"`

				// Mode Select the level of details for network metrics
				Mode *InputWindowsMetricsHostCustomNetworkMode `json:"mode,omitempty"`

				// PerInterface Generate separate metrics for each interface
				PerInterface *bool `json:"perInterface,omitempty"`
			} `json:"network,omitempty"`
			System *struct {
				// Detail Generate metrics for all system information
				Detail *bool `json:"detail,omitempty"`

				// Mode Select the level of details for system metrics
				Mode *InputWindowsMetricsHostCustomSystemMode `json:"mode,omitempty"`
			} `json:"system,omitempty"`
		} `json:"custom,omitempty"`

		// Mode Select level of detail for host metrics
		Mode *InputWindowsMetricsHostMode `json:"mode,omitempty"`
	} `json:"host,omitempty"`

	// Id Unique ID for this input
	Id string `json:"id"`

	// Interval Time, in seconds, between consecutive metric collections. Default is 10 seconds.
	Interval *float32 `json:"interval,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	Persistence *struct {
		// Compress Select data compression format. Optional.
		Compress *InputWindowsMetricsPersistenceCompress `json:"compress,omitempty"`

		// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
		DestPath *string `json:"destPath,omitempty"`

		// Enable Spool metrics to disk for Cribl Edge and Search
		Enable *InputWindowsMetricsPersistenceEnable `json:"enable,omitempty"`

		// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
		MaxDataSize *string `json:"maxDataSize,omitempty"`

		// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
		MaxDataTime *string `json:"maxDataTime,omitempty"`

		// TimeWindow Time span for each file bucket
		TimeWindow *string `json:"timeWindow,omitempty"`
	} `json:"persistence,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputWindowsMetricsPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputWindowsMetricsPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputWindowsMetricsPqEnabled `json:"pqEnabled,omitempty"`
	Process   *struct {
		// Sets Configure sets to collect process metrics
		Sets *[]struct {
			Filter          string `json:"filter"`
			IncludeChildren *bool  `json:"includeChildren,omitempty"`
			Name            string `json:"name"`
		} `json:"sets,omitempty"`
	} `json:"process,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputWindowsMetricsSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string               `json:"streamtags,omitempty"`
	Type       InputWindowsMetricsType `json:"type"`
}

// InputWindowsMetricsHostCustomCpuMode Select the level of details for CPU metrics
type InputWindowsMetricsHostCustomCpuMode string

// InputWindowsMetricsHostCustomDiskMode Select the level of details for disk metrics
type InputWindowsMetricsHostCustomDiskMode string

// InputWindowsMetricsHostCustomMemoryMode Select the level of details for memory metrics
type InputWindowsMetricsHostCustomMemoryMode string

// InputWindowsMetricsHostCustomNetworkMode Select the level of details for network metrics
type InputWindowsMetricsHostCustomNetworkMode string

// InputWindowsMetricsHostCustomSystemMode Select the level of details for system metrics
type InputWindowsMetricsHostCustomSystemMode string

// InputWindowsMetricsHostMode Select level of detail for host metrics
type InputWindowsMetricsHostMode string

// InputWindowsMetricsPersistenceCompress Select data compression format. Optional.
type InputWindowsMetricsPersistenceCompress string

// InputWindowsMetricsPersistenceEnable Spool metrics to disk for Cribl Edge and Search
type InputWindowsMetricsPersistenceEnable bool

// InputWindowsMetricsPqCompress Codec to use to compress the persisted data.
type InputWindowsMetricsPqCompress string

// InputWindowsMetricsPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputWindowsMetricsPqMode string

// InputWindowsMetricsPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputWindowsMetricsPqEnabled bool

// InputWindowsMetricsSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputWindowsMetricsSendToRoutes bool

// InputWindowsMetricsType defines model for InputWindowsMetrics.Type.
type InputWindowsMetricsType string

// InputWiz defines model for InputWiz.
type InputWiz struct {
	// AuthAudienceOverride The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
	AuthAudienceOverride *string `json:"authAudienceOverride,omitempty"`

	// AuthType Enter client secret directly, or select a stored secret
	AuthType *InputWizAuthType `json:"authType,omitempty"`

	// AuthUrl The authentication URL to generate an OAuth token
	AuthUrl string `json:"authUrl"`

	// ClientId The client ID of the Wiz application
	ClientId string `json:"clientId"`

	// ClientSecret The client secret of the Wiz application
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	ContentConfig []struct {
		ContentDescription *string `json:"contentDescription,omitempty"`

		// ContentType The name of the Wiz query
		ContentType string `json:"contentType"`
		Enabled     *bool  `json:"enabled,omitempty"`
	} `json:"contentConfig"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// Endpoint The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// KeepAliveTime How often workers should check in with the scheduler to keep job subscription alive
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// MaxMissedKeepAlives The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
	MaxMissedKeepAlives *float32 `json:"maxMissedKeepAlives,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`
	Pq       *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputWizPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputWizPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputWizPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout HTTP request inactivity timeout. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`
	RetryRules     *struct {
		// Codes List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
		Codes *[]float32 `json:"codes,omitempty"`

		// EnableHeader Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
		EnableHeader *bool `json:"enableHeader,omitempty"`

		// Interval Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
		Interval *float32 `json:"interval,omitempty"`

		// Limit The maximum number of times to retry a failed HTTP request
		Limit *float32 `json:"limit,omitempty"`

		// Multiplier Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
		Multiplier *float32 `json:"multiplier,omitempty"`

		// RetryConnectReset When toggled to Yes, the request will be retried when a connection reset (ECONNRESET) error occurs
		RetryConnectReset *bool `json:"retryConnectReset,omitempty"`

		// RetryConnectTimeout When toggled to Yes, a single retry attempt will be made when a connection timeout (ETIMEDOUT) error occurs
		RetryConnectTimeout *bool `json:"retryConnectTimeout,omitempty"`

		// Type The algorithm to use when performing HTTP retries
		Type InputWizRetryRulesType `json:"type"`
	} `json:"retryRules,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputWizSendToRoutes `json:"sendToRoutes,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string       `json:"ttl,omitempty"`
	Type *InputWizType `json:"type,omitempty"`
}

// InputWizAuthType Enter client secret directly, or select a stored secret
type InputWizAuthType string

// InputWizPqCompress Codec to use to compress the persisted data.
type InputWizPqCompress string

// InputWizPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputWizPqMode string

// InputWizPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputWizPqEnabled bool

// InputWizRetryRulesType The algorithm to use when performing HTTP retries
type InputWizRetryRulesType string

// InputWizSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputWizSendToRoutes bool

// InputWizType defines model for InputWiz.Type.
type InputWizType string

// InputZscalerHec defines model for InputZscalerHec.
type InputZscalerHec struct {
	// AccessControlAllowHeaders Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
	AccessControlAllowHeaders *[]string `json:"accessControlAllowHeaders,omitempty"`

	// AccessControlAllowOrigin Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
	AccessControlAllowOrigin *[]string `json:"accessControlAllowOrigin,omitempty"`

	// ActivityLogSampleRate How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *float32 `json:"activityLogSampleRate,omitempty"`

	// AllowedIndexes List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
	AllowedIndexes *[]string `json:"allowedIndexes,omitempty"`

	// AuthTokens Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
	AuthTokens *[]struct {
		// AllowedIndexesAtToken Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
		AllowedIndexesAtToken *[]string `json:"allowedIndexesAtToken,omitempty"`

		// AuthType Enter a token directly, or provide a secret referencing a token
		AuthType *InputZscalerHecAuthTokensAuthType `json:"authType,omitempty"`

		// Description Optional token description
		Description *string `json:"description,omitempty"`
		Enabled     *bool   `json:"enabled,omitempty"`

		// Metadata Fields to add to events referencing this token
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`
		Token       interface{}  `json:"token"`
		TokenSecret *interface{} `json:"tokenSecret,omitempty"`
	} `json:"authTokens,omitempty"`

	// CaptureHeaders Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`

	// Connections Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections *[]struct {
		// Output Select a Destination.
		Output string `json:"output"`

		// Pipeline Select Pipeline or Pack. Optional.
		Pipeline *string `json:"pipeline,omitempty"`
	} `json:"connections,omitempty"`
	Description *string `json:"description,omitempty"`
	Disabled    *bool   `json:"disabled,omitempty"`

	// EmitTokenMetrics Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
	EmitTokenMetrics  *bool        `json:"emitTokenMetrics,omitempty"`
	EnableHealthCheck *interface{} `json:"enableHealthCheck,omitempty"`

	// EnableProxyHeader Enable when clients are connecting through a proxy that supports the x-forwarded-for header to keep the client's original IP address on the event instead of the proxy's IP address
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// HecAPI Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
	HecAPI string `json:"hecAPI"`

	// HecAcks Whether to enable zscaler HEC acknowledgements
	HecAcks *bool `json:"hecAcks,omitempty"`

	// Host Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`

	// Id Unique ID for this input
	Id *string `json:"id,omitempty"`

	// IpAllowlistRegex Messages from matched IP addresses will be processed, unless also matched by the denylist.
	IpAllowlistRegex *string `json:"ipAllowlistRegex,omitempty"`

	// IpDenylistRegex Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
	IpDenylistRegex *string `json:"ipDenylistRegex,omitempty"`

	// KeepAliveTimeout After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`

	// MaxActiveReq Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *float32 `json:"maxActiveReq,omitempty"`

	// MaxRequestsPerSocket Max number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
	MaxRequestsPerSocket *int `json:"maxRequestsPerSocket,omitempty"`

	// Metadata Fields to add to every event. May be overridden by fields added at the token or request level.
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// Pipeline Pipeline to process data from this Source before sending it through the Routes
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Port to listen on.
	Port float32 `json:"port"`
	Pq   *struct {
		// CommitFrequency The number of events to send downstream before committing that Stream has read them.
		CommitFrequency *float32 `json:"commitFrequency,omitempty"`

		// Compress Codec to use to compress the persisted data.
		Compress *InputZscalerHecPqCompress `json:"compress,omitempty"`

		// MaxBufferSize The maximum number of events to hold in memory before writing the events to disk.
		MaxBufferSize *float32 `json:"maxBufferSize,omitempty"`

		// MaxFileSize The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
		MaxFileSize *string `json:"maxFileSize,omitempty"`

		// MaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
		MaxSize *string `json:"maxSize,omitempty"`

		// Mode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
		Mode *InputZscalerHecPqMode `json:"mode,omitempty"`

		// Path The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
		Path *string `json:"path,omitempty"`
	} `json:"pq,omitempty"`

	// PqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
	PqEnabled *InputZscalerHecPqEnabled `json:"pqEnabled,omitempty"`

	// RequestTimeout How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// SendToRoutes Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *InputZscalerHecSendToRoutes `json:"sendToRoutes,omitempty"`

	// SocketTimeout How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *float32 `json:"socketTimeout,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`
	Tls        *struct {
		// CaPath Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                     `json:"certificateName,omitempty"`
		CommonNameRegex *interface{}                `json:"commonNameRegex,omitempty"`
		Disabled        *InputZscalerHecTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to accept from connections
		MaxVersion *InputZscalerHecTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to accept from connections
		MinVersion *InputZscalerHecTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath        *string      `json:"privKeyPath,omitempty"`
		RejectUnauthorized *interface{} `json:"rejectUnauthorized,omitempty"`

		// RequestCert Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
		RequestCert *bool `json:"requestCert,omitempty"`
	} `json:"tls,omitempty"`
	Type *InputZscalerHecType `json:"type,omitempty"`
}

// InputZscalerHecAuthTokensAuthType Enter a token directly, or provide a secret referencing a token
type InputZscalerHecAuthTokensAuthType string

// InputZscalerHecPqCompress Codec to use to compress the persisted data.
type InputZscalerHecPqCompress string

// InputZscalerHecPqMode With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputZscalerHecPqMode string

// InputZscalerHecPqEnabled Use a disk queue to minimize data loss when connected services block. See [Cribl's docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
type InputZscalerHecPqEnabled bool

// InputZscalerHecSendToRoutes Select whether to send data to Routes, or directly to Destinations.
type InputZscalerHecSendToRoutes bool

// InputZscalerHecTlsDisabled defines model for InputZscalerHec.Tls.Disabled.
type InputZscalerHecTlsDisabled bool

// InputZscalerHecTlsMaxVersion Maximum TLS version to accept from connections
type InputZscalerHecTlsMaxVersion string

// InputZscalerHecTlsMinVersion Minimum TLS version to accept from connections
type InputZscalerHecTlsMinVersion string

// InputZscalerHecType defines model for InputZscalerHec.Type.
type InputZscalerHecType string

// JobExecutionWarning defines model for JobExecutionWarning.
type JobExecutionWarning struct {
	Text *string `json:"text,omitempty"`
	Type string  `json:"type"`
}

// JobInfo defines model for JobInfo.
type JobInfo struct {
	Args   RunnableJob `json:"args"`
	Id     string      `json:"id"`
	Keep   *bool       `json:"keep,omitempty"`
	Status JobStatus   `json:"status"`
}

// JobSettings defines model for JobSettings.
type JobSettings struct {
	ConcurrentJobLimit          float32 `json:"concurrentJobLimit"`
	ConcurrentScheduledJobLimit float32 `json:"concurrentScheduledJobLimit"`
	ConcurrentSystemJobLimit    float32 `json:"concurrentSystemJobLimit"`
	ConcurrentSystemTaskLimit   float32 `json:"concurrentSystemTaskLimit"`
	ConcurrentTaskLimit         float32 `json:"concurrentTaskLimit"`
	DisableTasks                *bool   `json:"disableTasks,omitempty"`
	FinishedJobArtifactsLimit   float32 `json:"finishedJobArtifactsLimit"`
	FinishedTaskArtifactsLimit  float32 `json:"finishedTaskArtifactsLimit"`
	JobArtifactsReaperPeriod    string  `json:"jobArtifactsReaperPeriod"`
	JobTimeout                  string  `json:"jobTimeout"`
	MaxTaskPerc                 float32 `json:"maxTaskPerc"`
	SchedulingPolicy            string  `json:"schedulingPolicy"`
	TaskHeartbeatPeriod         float32 `json:"taskHeartbeatPeriod"`
	TaskManifestFlushPeriodMs   float32 `json:"taskManifestFlushPeriodMs"`
	TaskManifestMaxBufferSize   float32 `json:"taskManifestMaxBufferSize"`
	TaskManifestReadBufferSize  string  `json:"taskManifestReadBufferSize"`
	TaskPollTimeoutMs           float32 `json:"taskPollTimeoutMs"`
}

// JobState defines model for JobState.
type JobState struct {
	Id    string `json:"id"`
	State string `json:"state"`
}

// JobStatus defines model for JobStatus.
type JobStatus struct {
	Reason *map[string]interface{} `json:"reason,omitempty"`
	State  State                   `json:"state"`
}

// KMSHealth defines model for KMSHealth.
type KMSHealth struct {
	Auth       KMSHealthTest `json:"auth"`
	Connection KMSHealthTest `json:"connection"`
	System     KMSHealthTest `json:"system"`
}

// KMSHealthStatus defines model for KMSHealthStatus.
type KMSHealthStatus float32

// KMSHealthTest defines model for KMSHealthTest.
type KMSHealthTest struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Status  KMSHealthStatus         `json:"status"`
}

// KMSProviderConfig defines model for KMSProviderConfig.
type KMSProviderConfig struct {
	Auth                *KMSProviderConfig_Auth  `json:"auth,omitempty"`
	EnableHealthCheck   bool                     `json:"enableHealthCheck"`
	HealthCheckEndpoint *string                  `json:"healthCheckEndpoint,omitempty"`
	Namespace           *string                  `json:"namespace,omitempty"`
	Provider            SECRETPROVIDER           `json:"provider"`
	SecretDir           *string                  `json:"secretDir,omitempty"`
	Service             *AWSKMSServiceConfig     `json:"service,omitempty"`
	Tls                 *VaultKMSTlsClientConfig `json:"tls,omitempty"`
	Url                 *string                  `json:"url,omitempty"`
}

// KMSProviderConfigAuth0 defines model for .
type KMSProviderConfigAuth0 struct {
	AssumeRoleArn           *string      `json:"assumeRoleArn,omitempty"`
	AssumeRoleExternalId    *string      `json:"assumeRoleExternalId,omitempty"`
	AwsApiKey               *string      `json:"awsApiKey,omitempty"`
	AwsAuthenticationMethod *string      `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string      `json:"awsSecretKey,omitempty"`
	EnableAssumeRole        *bool        `json:"enableAssumeRole,omitempty"`
	Provider                AUTHPROVIDER `json:"provider"`
	Token                   *string      `json:"token,omitempty"`
	VaultAWSIAMServerID     string       `json:"vaultAWSIAMServerID"`
	VaultRole               *string      `json:"vaultRole,omitempty"`
}

// KMSProviderConfigAuth1 defines model for .
type KMSProviderConfigAuth1 struct {
	AssumeRoleArn           *string `json:"assumeRoleArn,omitempty"`
	AssumeRoleExternalId    *string `json:"assumeRoleExternalId,omitempty"`
	AwsApiKey               *string `json:"awsApiKey,omitempty"`
	AwsAuthenticationMethod *string `json:"awsAuthenticationMethod,omitempty"`
	AwsSecretKey            *string `json:"awsSecretKey,omitempty"`
	EnableAssumeRole        *bool   `json:"enableAssumeRole,omitempty"`
}

// KMSProviderConfig_Auth defines model for KMSProviderConfig.Auth.
type KMSProviderConfig_Auth struct {
	Union json.RawMessage
}

// KeyMetadataEntity defines model for KeyMetadataEntity.
type KeyMetadataEntity struct {
	Algorithm   KeyMetadataEntityAlgorithm `json:"algorithm"`
	CipherKey   *string                    `json:"cipherKey,omitempty"`
	Created     *float32                   `json:"created,omitempty"`
	Description *string                    `json:"description,omitempty"`
	Expires     *float32                   `json:"expires,omitempty"`

	// IvSize Length of the initialization vector, in bytes
	IvSize   *KeyMetadataEntityIvSize `json:"ivSize,omitempty"`
	KeyId    string                   `json:"keyId"`
	Keyclass float32                  `json:"keyclass"`
	Kms      KeyMetadataEntityKms     `json:"kms"`
	PlainKey *string                  `json:"plainKey,omitempty"`

	// UseIV Seed encryption with a [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) to make the key more random and unique. Must be enabled with the aes-256-gcm algorithm.
	UseIV *bool `json:"useIV,omitempty"`
}

// KeyMetadataEntityAlgorithm defines model for KeyMetadataEntity.Algorithm.
type KeyMetadataEntityAlgorithm string

// KeyMetadataEntityIvSize Length of the initialization vector, in bytes
type KeyMetadataEntityIvSize float32

// KeyMetadataEntityKms defines model for KeyMetadataEntity.Kms.
type KeyMetadataEntityKms string

// KubeMetadata defines model for KubeMetadata.
type KubeMetadata struct {
	Cluster   *map[string]interface{} `json:"cluster,omitempty"`
	Container *map[string]interface{} `json:"container,omitempty"`
	Namespace string                  `json:"namespace"`
	Node      *map[string]interface{} `json:"node,omitempty"`
	Pod       *map[string]interface{} `json:"pod,omitempty"`
	Source    string                  `json:"source"`
}

// LakeDatasetSearchConfig defines model for LakeDatasetSearchConfig.
type LakeDatasetSearchConfig struct {
	Datatypes *[]string        `json:"datatypes,omitempty"`
	Metadata  *DatasetMetadata `json:"metadata,omitempty"`
}

// License defines model for License.
type License struct {
	Cls     LicenseCls `json:"cls"`
	Email   string     `json:"email"`
	Exp     float32    `json:"exp"`
	FPh     float32    `json:"f_ph"`
	FPhg    float32    `json:"f_phg"`
	Guid    string     `json:"guid"`
	Iat     float32    `json:"iat"`
	Id      string     `json:"id"`
	Iss     string     `json:"iss"`
	License string     `json:"license"`
	Quota   float32    `json:"quota"`
	Sub     *string    `json:"sub,omitempty"`
	Title   string     `json:"title"`
}

// LicenseCls defines model for License.Cls.
type LicenseCls string

// LicenseInfo defines model for LicenseInfo.
type LicenseInfo struct {
	Email        *string         `json:"email,omitempty"`
	IsRegistered bool            `json:"isRegistered"`
	IsSplunkApp  *bool           `json:"isSplunkApp,omitempty"`
	Limits       LicenseLimits   `json:"limits"`
	Type         LicenseInfoType `json:"type"`
}

// LicenseInfoType defines model for LicenseInfo.Type.
type LicenseInfoType string

// LicenseLimits defines model for LicenseLimits.
type LicenseLimits struct {
	EdgeGroups            *float32 `json:"edge_groups,omitempty"`
	EdgeProcs             *float32 `json:"edge_procs,omitempty"`
	Kms                   *float32 `json:"kms,omitempty"`
	LeaderResiliency      *float32 `json:"leader_resiliency,omitempty"`
	MaxExecutorsPerSearch *float32 `json:"max_executors_per_search,omitempty"`
	Notifications         *float32 `json:"notifications,omitempty"`
	PersistentQueue       *float32 `json:"persistent_queue,omitempty"`
	Projects              *float32 `json:"projects,omitempty"`
	Rbac                  float32  `json:"rbac"`
	RemoteAuth            float32  `json:"remote_auth"`
	RemoteGit             float32  `json:"remote_git"`
	S3Bundle              *float32 `json:"s3_bundle,omitempty"`
	SearchAcceleration    *float32 `json:"search_acceleration,omitempty"`
	SearchGroups          *float32 `json:"search_groups,omitempty"`
	SystemEmail           *float32 `json:"system_email,omitempty"`
	WorkerGroups          float32  `json:"worker_groups"`
	WorkerProcs           float32  `json:"worker_procs"`
}

// LicenseRequest defines model for LicenseRequest.
type LicenseRequest struct {
	License string `json:"license"`
}

// LimitRuleDefinitions defines model for LimitRuleDefinitions.
type LimitRuleDefinitions = interface{}

// Limits defines model for Limits.
type Limits struct {
	CpuProfileTTL               string                    `json:"cpuProfileTTL"`
	EdgeMetricsCustomExpression *string                   `json:"edgeMetricsCustomExpression,omitempty"`
	EdgeMetricsMode             *EdgeHeartbeatMetricsMode `json:"edgeMetricsMode,omitempty"`
	EdgeNodesCount              *float32                  `json:"edgeNodesCount,omitempty"`
	EnableMetricsPersistence    bool                      `json:"enableMetricsPersistence"`
	EventsMetadataSources       *[]string                 `json:"eventsMetadataSources,omitempty"`
	MaxMetrics                  *float32                  `json:"maxMetrics,omitempty"`
	MaxPQSize                   *string                   `json:"maxPQSize,omitempty"`
	MetricsDirectory            string                    `json:"metricsDirectory"`
	MetricsDropList             *[]string                 `json:"metricsDropList,omitempty"`
	MetricsFieldsBlacklist      []string                  `json:"metricsFieldsBlacklist"`
	MetricsGCPeriod             string                    `json:"metricsGCPeriod"`
	MetricsMaxCardinality       *float32                  `json:"metricsMaxCardinality,omitempty"`
	MetricsMaxDiskSpace         *string                   `json:"metricsMaxDiskSpace,omitempty"`
	MetricsNeverDropList        []string                  `json:"metricsNeverDropList"`
	MetricsWorkerIdBlacklist    []string                  `json:"metricsWorkerIdBlacklist"`
	MinFreeSpace                string                    `json:"minFreeSpace"`
	Samples                     struct {
		MaxSize string `json:"maxSize"`
	} `json:"samples"`
}

// LogFileInfo defines model for LogFileInfo.
type LogFileInfo struct {
	Id   string `json:"id"`
	Path string `json:"path"`
}

// LoggerConfig defines model for LoggerConfig.
type LoggerConfig struct {
	Channels            []LoggerEntry `json:"channels"`
	DefaultRedactFields *[]string     `json:"defaultRedactFields,omitempty"`
	Id                  string        `json:"id"`
	LimitRate           float32       `json:"limitRate"`
	MaxSizeBytes        float32       `json:"maxSizeBytes"`
	RedactFields        []string      `json:"redactFields"`
	RedactLabel         string        `json:"redactLabel"`
}

// LoggerEntry defines model for LoggerEntry.
type LoggerEntry struct {
	CanDelete *bool  `json:"canDelete,omitempty"`
	Id        string `json:"id"`
	Level     string `json:"level"`
}

// LoginInfo defines model for LoginInfo.
type LoginInfo struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// LookupFile defines model for LookupFile.
type LookupFile struct {
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// Size File size. Optional.
	Size *float32 `json:"size,omitempty"`

	// Tags One or more tags related to this lookup. Optional.
	Tags  *string `json:"tags,omitempty"`
	Union json.RawMessage
}

// LookupFile0 defines model for .
type LookupFile0 struct {
	FileInfo *struct {
		Filename string `json:"filename"`
	} `json:"fileInfo,omitempty"`
}

// LookupFile1 defines model for .
type LookupFile1 struct {
	// Content File content.
	Content *string `json:"content,omitempty"`
}

// LookupFileInfoResponse defines model for LookupFileInfoResponse.
type LookupFileInfoResponse struct {
	Filename string  `json:"filename"`
	Rows     float32 `json:"rows"`
	Size     float32 `json:"size"`
}

// MappingType defines model for MappingType.
type MappingType string

// MasterWorkerEntry defines model for MasterWorkerEntry.
type MasterWorkerEntry struct {
	Deployable        *bool                   `json:"deployable,omitempty"`
	FirstMsgTime      float32                 `json:"firstMsgTime"`
	Group             string                  `json:"group"`
	Id                string                  `json:"id"`
	Info              NodeProvidedInfo        `json:"info"`
	LastMetrics       *map[string]interface{} `json:"lastMetrics,omitempty"`
	LastMsgTime       float32                 `json:"lastMsgTime"`
	Metadata          *HeartbeatMetadata      `json:"metadata,omitempty"`
	NodeUpgradeStatus *NodeUpgradeStatus      `json:"nodeUpgradeStatus,omitempty"`
	Status            *string                 `json:"status,omitempty"`
	Type              *MasterWorkerEntryType  `json:"type,omitempty"`
	WorkerProcesses   float32                 `json:"workerProcesses"`
	Workers           *struct {
		Count float32 `json:"count"`
	} `json:"workers,omitempty"`
}

// MasterWorkerEntryType defines model for MasterWorkerEntry.Type.
type MasterWorkerEntryType string

// MaxConcurrentSearchesType defines model for MaxConcurrentSearchesType.
type MaxConcurrentSearchesType struct {
	Union json.RawMessage
}

// MaxConcurrentSearchesType0 defines model for .
type MaxConcurrentSearchesType0 = float32

// MembershipSchema defines model for MembershipSchema.
type MembershipSchema struct {
	Add *[]string `json:"add,omitempty"`
	Rm  *[]string `json:"rm,omitempty"`
}

// Metadata defines model for Metadata.
type Metadata struct {
	Aws       *AwsMetadata   `json:"aws,omitempty"`
	Cribl     *CriblMetadata `json:"cribl,omitempty"`
	Env       *EnvMetadata   `json:"env,omitempty"`
	HostOs    *OsMetadata    `json:"hostOs,omitempty"`
	Kube      *KubeMetadata  `json:"kube,omitempty"`
	Os        *OsMetadata    `json:"os,omitempty"`
	Timestamp float32        `json:"timestamp"`
}

// MetricNameInfo defines model for MetricNameInfo.
type MetricNameInfo struct {
	Dims []struct {
		Count  float32  `json:"count"`
		Name   string   `json:"name"`
		Values []string `json:"values"`
	} `json:"dims"`
	Name string `json:"name"`
}

// MetricsAggOpts defines model for MetricsAggOpts.
type MetricsAggOpts struct {
	Aggs         AggregationMgrOptions    `json:"aggs"`
	AlwaysBounds *bool                    `json:"alwaysBounds,omitempty"`
	Earliest     *MetricsAggOpts_Earliest `json:"earliest,omitempty"`
	Latest       *MetricsAggOpts_Latest   `json:"latest,omitempty"`
	Metrics      *MetricsStore            `json:"metrics,omitempty"`
	Where        *string                  `json:"where,omitempty"`
}

// MetricsAggOptsEarliest0 defines model for .
type MetricsAggOptsEarliest0 = string

// MetricsAggOptsEarliest1 defines model for .
type MetricsAggOptsEarliest1 = float32

// MetricsAggOpts_Earliest defines model for MetricsAggOpts.Earliest.
type MetricsAggOpts_Earliest struct {
	Union json.RawMessage
}

// MetricsAggOptsLatest0 defines model for .
type MetricsAggOptsLatest0 = string

// MetricsAggOptsLatest1 defines model for .
type MetricsAggOptsLatest1 = float32

// MetricsAggOpts_Latest defines model for MetricsAggOpts.Latest.
type MetricsAggOpts_Latest struct {
	Union json.RawMessage
}

// MetricsStore defines model for MetricsStore.
type MetricsStore = map[string]interface{}

// MultiFactorAuthSchema defines model for MultiFactorAuthSchema.
type MultiFactorAuthSchema struct {
	AccessControlAllowOrigin string                    `json:"accessControlAllowOrigin"`
	AllowLogin               bool                      `json:"allowLogin"`
	ApiServerUrl             string                    `json:"apiServerUrl"`
	Disabled                 bool                      `json:"disabled"`
	Type                     MultiFactorAuthSchemaType `json:"type"`
	UsernameField            string                    `json:"usernameField"`
	UsernameRegex            string                    `json:"usernameRegex"`
}

// MultiFactorAuthSchemaType defines model for MultiFactorAuthSchema.Type.
type MultiFactorAuthSchemaType string

// NetworkInterfaces defines model for NetworkInterfaces.
type NetworkInterfaces = map[string]interface{}

// NodeActiveUpgradeStatus defines model for NodeActiveUpgradeStatus.
type NodeActiveUpgradeStatus float32

// NodeFailedUpgradeStatus defines model for NodeFailedUpgradeStatus.
type NodeFailedUpgradeStatus float32

// NodeProvidedInfo defines model for NodeProvidedInfo.
type NodeProvidedInfo struct {
	Architecture string `json:"architecture"`
	Aws          *struct {
		Enabled bool                    `json:"enabled"`
		Region  string                  `json:"region"`
		Tags    *map[string]interface{} `json:"tags,omitempty"`
		Type    string                  `json:"type"`
		Zone    string                  `json:"zone"`
	} `json:"aws,omitempty"`
	ConnIp        *string     `json:"conn_ip,omitempty"`
	Cpus          float32     `json:"cpus"`
	Cribl         HBCriblInfo `json:"cribl"`
	FreeDiskSpace float32     `json:"freeDiskSpace"`
	HostOs        *struct {
		Addresses []string `json:"addresses"`
		Enabled   bool     `json:"enabled"`
		Id        string   `json:"id"`
		Version   string   `json:"version"`
	} `json:"hostOs,omitempty"`
	Hostname     string `json:"hostname"`
	IsSaasWorker *bool  `json:"isSaasWorker,omitempty"`
	Kube         *struct {
		Enabled   bool   `json:"enabled"`
		Namespace string `json:"namespace"`
		Node      string `json:"node"`
		Owner     *struct {
			Kind string `json:"kind"`
			Name string `json:"name"`
		} `json:"owner,omitempty"`
		Pod    string `json:"pod"`
		Source string `json:"source"`
	} `json:"kube,omitempty"`
	LocalTime      *float32             `json:"localTime,omitempty"`
	Metadata       *HeartbeatMetadata   `json:"metadata,omitempty"`
	Node           string               `json:"node"`
	Os             *NodeProvidedInfo_Os `json:"os,omitempty"`
	Platform       string               `json:"platform"`
	Release        string               `json:"release"`
	TotalDiskSpace float32              `json:"totalDiskSpace"`
	Totalmem       float32              `json:"totalmem"`
}

// NodeProvidedInfoOs0 defines model for .
type NodeProvidedInfoOs0 struct {
	Addresses []string `json:"addresses"`
	Enabled   bool     `json:"enabled"`
	Id        string   `json:"id"`
	Version   string   `json:"version"`
}

// NodeProvidedInfoOs1 defines model for .
type NodeProvidedInfoOs1 struct {
	Addresses []string `json:"addresses"`
}

// NodeProvidedInfo_Os defines model for NodeProvidedInfo.Os.
type NodeProvidedInfo_Os struct {
	Union json.RawMessage
}

// NodeSkippedUpgradeStatus defines model for NodeSkippedUpgradeStatus.
type NodeSkippedUpgradeStatus float32

// NodeUpgradeState defines model for NodeUpgradeState.
type NodeUpgradeState float32

// NodeUpgradeStatus defines model for NodeUpgradeStatus.
type NodeUpgradeStatus struct {
	Active    *NodeActiveUpgradeStatus  `json:"active,omitempty"`
	Failed    *NodeFailedUpgradeStatus  `json:"failed,omitempty"`
	Skipped   *NodeSkippedUpgradeStatus `json:"skipped,omitempty"`
	State     NodeUpgradeState          `json:"state"`
	Timestamp float32                   `json:"timestamp"`
}

// Notification defines model for Notification.
type Notification struct {
	Condition string                  `json:"condition"`
	Conf      *map[string]interface{} `json:"conf,omitempty"`
	Disabled  *bool                   `json:"disabled,omitempty"`
	Id        string                  `json:"id"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
	TargetConfigs *[]Notification_TargetConfigs_Item `json:"targetConfigs,omitempty"`

	// Targets Targets to send any Notifications to
	Targets *[]string `json:"targets,omitempty"`
}

// NotificationTargetConfigs0 defines model for .
type NotificationTargetConfigs0 struct {
	Conf *struct {
		// Body Email body
		Body           *string `json:"body,omitempty"`
		EmailRecipient *struct {
			// Bcc Bcc: Recipients' email addresses
			Bcc *string `json:"bcc,omitempty"`

			// Cc Cc: Recipients' email addresses
			Cc *string `json:"cc,omitempty"`

			// To Recipients' email addresses
			To string `json:"to"`
		} `json:"emailRecipient,omitempty"`

		// Subject Email subject
		Subject *string `json:"subject,omitempty"`
	} `json:"conf,omitempty"`
}

// Notification_TargetConfigs_Item defines model for Notification.targetConfigs.Item.
type Notification_TargetConfigs_Item struct {
	Id    string `json:"id"`
	Union json.RawMessage
}

// NotificationTarget defines model for NotificationTarget.
type NotificationTarget struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// OriginConfig defines model for OriginConfig.
type OriginConfig struct {
	FilterExpression *string       `json:"filterExpression,omitempty"`
	Origin           DatasetOrigin `json:"origin"`
}

// OsMetadata defines model for OsMetadata.
type OsMetadata struct {
	Arch           string            `json:"arch"`
	CpuCount       float32           `json:"cpu_count"`
	CpuSpeedMhz    float32           `json:"cpu_speed_mhz"`
	CpuType        string            `json:"cpu_type"`
	Gid            float32           `json:"gid"`
	Homedir        string            `json:"homedir"`
	Hostname       string            `json:"hostname"`
	Interfaces     NetworkInterfaces `json:"interfaces"`
	MachineId      string            `json:"machine_id"`
	Memory         float32           `json:"memory"`
	OsId           string            `json:"os_id"`
	OsName         string            `json:"os_name"`
	OsVersion      string            `json:"os_version"`
	OsVersionId    string            `json:"os_version_id"`
	Platform       string            `json:"platform"`
	Release        string            `json:"release"`
	Timezone       string            `json:"timezone"`
	TimezoneOffset string            `json:"timezone_offset"`
	Uid            float32           `json:"uid"`
	Username       string            `json:"username"`
}

// Output defines model for Output.
type Output struct {
	Union json.RawMessage
}

// OutputAzureBlob defines model for OutputAzureBlob.
type OutputAzureBlob struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AuthType Enter connection string directly, or select a stored secret
	AuthType *OutputAzureBlobAuthType `json:"authType,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`
	Certificate  *struct {
		// CertificateName The certificate you registered as credentials for your app in the Azure portal
		CertificateName string `json:"certificateName"`
	} `json:"certificate,omitempty"`

	// ClientId The service principal's client ID
	ClientId *string `json:"clientId,omitempty"`

	// ClientTextSecret Select or create a stored text secret
	ClientTextSecret *string `json:"clientTextSecret,omitempty"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputAzureBlobCompress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputAzureBlobCompressionLevel `json:"compressionLevel,omitempty"`

	// ConnectionString Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
	ConnectionString *string `json:"connectionString,omitempty"`

	// ContainerName A container organizes a set of blobs, similar to a directory in a file system. Value can be a JavaScript expression enclosed in quotes or backticks. @{product} evaluates the expression at init time. The expression can evaluate to a constant value, and can reference Global Variables, e.g., `myContainer-${C.env["CRIBL_WORKER_ID"]}`
	ContainerName string `json:"containerName"`

	// CreateContainer Creates the configured container in Azure Blob Storage if it does not already exist.
	CreateContainer *bool `json:"createContainer,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputAzureBlobDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks. @{product} evaluates the expression at init time. The expression can evaluate to a constant value, and can reference Global Variables, e.g., `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`
	DestPath *string `json:"destPath,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputAzureBlobFormat `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputAzureBlobOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputAzureBlobOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputAzureBlobParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputAzureBlobParquetVersion `json:"parquetVersion,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputAzureBlobRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageAccountName The name of your Azure storage account
	StorageAccountName *string                      `json:"storageAccountName,omitempty"`
	StorageClass       *OutputAzureBlobStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TenantId The service principal's tenant ID
	TenantId *string `json:"tenantId,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string              `json:"textSecret,omitempty"`
	Type       *OutputAzureBlobType `json:"type,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputAzureBlobAuthType Enter connection string directly, or select a stored secret
type OutputAzureBlobAuthType string

// OutputAzureBlobCompress Choose data compression format to apply before moving files to final destination
type OutputAzureBlobCompress string

// OutputAzureBlobCompressionLevel Compression level to apply before moving files to final destination
type OutputAzureBlobCompressionLevel string

// OutputAzureBlobDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputAzureBlobDeadletterEnabled bool

// OutputAzureBlobFormat Format of the output data
type OutputAzureBlobFormat string

// OutputAzureBlobOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputAzureBlobOnBackpressure string

// OutputAzureBlobOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputAzureBlobOnDiskFullBackpressure string

// OutputAzureBlobParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputAzureBlobParquetDataPageVersion string

// OutputAzureBlobParquetVersion Determines which data types are supported and how they are represented
type OutputAzureBlobParquetVersion string

// OutputAzureBlobRemoveEmptyDirs Remove empty staging directories after moving files
type OutputAzureBlobRemoveEmptyDirs bool

// OutputAzureBlobStorageClass defines model for OutputAzureBlob.StorageClass.
type OutputAzureBlobStorageClass string

// OutputAzureBlobType defines model for OutputAzureBlob.Type.
type OutputAzureBlobType string

// OutputAzureDataExplorer defines model for OutputAzureDataExplorer.
type OutputAzureDataExplorer struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AdditionalProperties Optionally, enter additional configuration properties to send to the ingestion service.
	AdditionalProperties *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"additionalProperties,omitempty"`
	AdvancedSettingsNote *string `json:"advancedSettingsNote,omitempty"`
	Certificate          *struct {
		// CertificateName The certificate you registered as credentials for your app in the Azure portal.
		CertificateName *string `json:"certificateName,omitempty"`
	} `json:"certificate,omitempty"`

	// ClientId client_id to pass in the OAuth request parameter.
	ClientId string `json:"clientId"`

	// ClientSecret The client secret that you generated for your app in the Azure portal.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// ClusterUrl The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
	ClusterUrl string `json:"clusterUrl"`

	// Compress Choose data compression format to apply to HTTP content before it is delivered.
	Compress OutputAzureDataExplorerCompress `json:"compress"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// Database Name of the database containing the table where data will be ingested.
	Database string `json:"database"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputAzureDataExplorerDeadletterEnabled `json:"deadletterEnabled,omitempty"`
	Description       *string                                   `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtentTags Strings or tags associated with the extent (ingested data shard).
	ExtentTags *[]struct {
		Prefix *OutputAzureDataExplorerExtentTagsPrefix `json:"prefix,omitempty"`
		Value  string                                   `json:"value"`
	} `json:"extentTags,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// FlushImmediately Enable to bypass the data management service's aggregation mechanism.
	FlushImmediately *bool `json:"flushImmediately,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Format of the output data
	Format *OutputAzureDataExplorerFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// IngestIfNotExists Prevents duplicate ingestion by checking if an extent with the specified ingest-by tag already exists.
	IngestIfNotExists *[]struct {
		Value string `json:"value"`
	} `json:"ingestIfNotExists,omitempty"`

	// IngestMode Method to use for ingesting data.
	IngestMode *OutputAzureDataExplorerIngestMode `json:"ingestMode,omitempty"`

	// IngestUrl The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
	IngestUrl *string `json:"ingestUrl,omitempty"`

	// IsMappingObj Enable if you want to send a (JSON) mapping object instead of specifying an existing named data mapping.
	IsMappingObj *bool `json:"isMappingObj,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request.
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// MappingRef Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
	MappingRef *string `json:"mappingRef,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OauthEndpoint Endpoint used to acquire authentication tokens from Azure.
	OauthEndpoint OutputAzureDataExplorerOauthEndpoint `json:"oauthEndpoint"`

	// OauthType The type of OAuth 2.0 client credentials grant flow to use.
	OauthType OutputAzureDataExplorerOauthType `json:"oauthType"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputAzureDataExplorerOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputAzureDataExplorerOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputAzureDataExplorerPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}            `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputAzureDataExplorerPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputAzureDataExplorerPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputAzureDataExplorerRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReportLevel Level of ingestion status reporting. Defaults to FailuresOnly.
	ReportLevel *OutputAzureDataExplorerReportLevel `json:"reportLevel,omitempty"`

	// ReportMethod Target of the ingestion status reporting. Defaults to Queue.
	ReportMethod *OutputAzureDataExplorerReportMethod `json:"reportMethod,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// RetainBlobOnSuccess Enable to prevent blob deletion after ingestion is complete.
	RetainBlobOnSuccess *bool `json:"retainBlobOnSuccess,omitempty"`

	// Scope Scope to pass in the OAuth request parameter.
	Scope string `json:"scope"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath *string `json:"stagePath,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// Table Name of the table to ingest data into.
	Table string `json:"table"`

	// TenantId Directory ID (tenant identifier) in Azure Active Directory.
	TenantId string `json:"tenantId"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32                     `json:"timeoutSec,omitempty"`
	Type       *OutputAzureDataExplorerType `json:"type,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// ValidateDatabaseSettings When you save or start the Destination, validates database name and credentials; also validates table name except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role.
	ValidateDatabaseSettings *bool `json:"validateDatabaseSettings,omitempty"`
}

// OutputAzureDataExplorerCompress Choose data compression format to apply to HTTP content before it is delivered.
type OutputAzureDataExplorerCompress string

// OutputAzureDataExplorerDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputAzureDataExplorerDeadletterEnabled bool

// OutputAzureDataExplorerExtentTagsPrefix defines model for OutputAzureDataExplorer.ExtentTags.Prefix.
type OutputAzureDataExplorerExtentTagsPrefix string

// OutputAzureDataExplorerFormat Format of the output data
type OutputAzureDataExplorerFormat string

// OutputAzureDataExplorerIngestMode Method to use for ingesting data.
type OutputAzureDataExplorerIngestMode string

// OutputAzureDataExplorerOauthEndpoint Endpoint used to acquire authentication tokens from Azure.
type OutputAzureDataExplorerOauthEndpoint string

// OutputAzureDataExplorerOauthType The type of OAuth 2.0 client credentials grant flow to use.
type OutputAzureDataExplorerOauthType string

// OutputAzureDataExplorerOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputAzureDataExplorerOnBackpressure string

// OutputAzureDataExplorerOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputAzureDataExplorerOnDiskFullBackpressure string

// OutputAzureDataExplorerPqCompress Codec to use to compress the persisted data.
type OutputAzureDataExplorerPqCompress string

// OutputAzureDataExplorerPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputAzureDataExplorerPqMode string

// OutputAzureDataExplorerPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputAzureDataExplorerPqOnBackpressure string

// OutputAzureDataExplorerRemoveEmptyDirs Remove empty staging directories after moving files
type OutputAzureDataExplorerRemoveEmptyDirs bool

// OutputAzureDataExplorerReportLevel Level of ingestion status reporting. Defaults to FailuresOnly.
type OutputAzureDataExplorerReportLevel string

// OutputAzureDataExplorerReportMethod Target of the ingestion status reporting. Defaults to Queue.
type OutputAzureDataExplorerReportMethod string

// OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputAzureDataExplorerTimeoutRetrySettingsTimeoutRetry bool

// OutputAzureDataExplorerType defines model for OutputAzureDataExplorer.Type.
type OutputAzureDataExplorerType string

// OutputAzureEventhub defines model for OutputAzureEventhub.
type OutputAzureEventhub struct {
	// Ack Control the number of required acknowledgments
	Ack *OutputAzureEventhubAck `json:"ack,omitempty"`

	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
	Brokers []string `json:"brokers"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushEventCount Maximum number of events in a batch before forcing a flush.
	FlushEventCount *float32 `json:"flushEventCount,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Format to use to serialize events before writing to the Event Hubs Kafka brokers.
	Format *OutputAzureEventhubFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff *float32 `json:"initialBackoff,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxRecordSizeKB Maximum size (KB) of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputAzureEventhubOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputAzureEventhubPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}        `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputAzureEventhubPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputAzureEventhubPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable authentication.
		Disabled OutputAzureEventhubSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use
		Mechanism *OutputAzureEventhubSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`
	Tls          *struct {
		Disabled OutputAzureEventhubTlsDisabled `json:"disabled"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA).
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	} `json:"tls,omitempty"`

	// Topic The name of the Event Hub (a.k.a. Kafka Topic) to publish events. Can be overwritten using field __topicOut.
	Topic string                   `json:"topic"`
	Type  *OutputAzureEventhubType `json:"type,omitempty"`
}

// OutputAzureEventhubAck Control the number of required acknowledgments
type OutputAzureEventhubAck float32

// OutputAzureEventhubFormat Format to use to serialize events before writing to the Event Hubs Kafka brokers.
type OutputAzureEventhubFormat string

// OutputAzureEventhubOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputAzureEventhubOnBackpressure string

// OutputAzureEventhubPqCompress Codec to use to compress the persisted data.
type OutputAzureEventhubPqCompress string

// OutputAzureEventhubPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputAzureEventhubPqMode string

// OutputAzureEventhubPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputAzureEventhubPqOnBackpressure string

// OutputAzureEventhubSaslDisabled Enable authentication.
type OutputAzureEventhubSaslDisabled bool

// OutputAzureEventhubSaslMechanism SASL authentication mechanism to use
type OutputAzureEventhubSaslMechanism string

// OutputAzureEventhubTlsDisabled defines model for OutputAzureEventhub.Tls.Disabled.
type OutputAzureEventhubTlsDisabled bool

// OutputAzureEventhubType defines model for OutputAzureEventhub.Type.
type OutputAzureEventhubType string

// OutputAzureLogs defines model for OutputAzureLogs.
type OutputAzureLogs struct {
	// ApiUrl Enter the DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix around this DNS name to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>.
	ApiUrl *string `json:"apiUrl,omitempty"`

	// AuthType Enter workspace ID and workspace key directly, or select a stored secret
	AuthType *OutputAzureLogsAuthType `json:"authType,omitempty"`
	Compress *bool                    `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputAzureLogsFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeypairSecret Select or create a stored secret that references your access key and secret key.
	KeypairSecret *string `json:"keypairSecret,omitempty"`

	// LogType The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType.
	LogType string `json:"logType"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputAzureLogsOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputAzureLogsPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputAzureLogsPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputAzureLogsPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResourceId Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputAzureLogsTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32            `json:"timeoutSec,omitempty"`
	Type       OutputAzureLogsType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// WorkspaceId Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceKey Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
	WorkspaceKey *string `json:"workspaceKey,omitempty"`
}

// OutputAzureLogsAuthType Enter workspace ID and workspace key directly, or select a stored secret
type OutputAzureLogsAuthType string

// OutputAzureLogsFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputAzureLogsFailedRequestLoggingMode string

// OutputAzureLogsOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputAzureLogsOnBackpressure string

// OutputAzureLogsPqCompress Codec to use to compress the persisted data.
type OutputAzureLogsPqCompress string

// OutputAzureLogsPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputAzureLogsPqMode string

// OutputAzureLogsPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputAzureLogsPqOnBackpressure string

// OutputAzureLogsTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputAzureLogsTimeoutRetrySettingsTimeoutRetry bool

// OutputAzureLogsType defines model for OutputAzureLogs.Type.
type OutputAzureLogsType string

// OutputClickHouse defines model for OutputClickHouse.
type OutputClickHouse struct {
	// AsyncInserts Collect data into batches for later processing. Disable to write to a ClickHouse table immediately.
	AsyncInserts *OutputClickHouseAsyncInserts `json:"asyncInserts,omitempty"`

	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string                   `json:"authHeaderExpr,omitempty"`
	AuthType       *OutputClickHouseAuthType `json:"authType,omitempty"`
	ColumnMappings *[]struct {
		// ColumnName Name of the column in ClickHouse that will store field value
		ColumnName string `json:"columnName"`

		// ColumnType Type of the column in the ClickHouse database
		ColumnType *string `json:"columnType,omitempty"`

		// ColumnValueExpression JavaScript expression to compute value to be inserted into ClickHouse table
		ColumnValueExpression string `json:"columnValueExpression"`
	} `json:"columnMappings,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Database          string  `json:"database"`

	// DescribeTable Retrieves the table schema from ClickHouse and populates the Column Mapping table
	DescribeTable *string `json:"describeTable,omitempty"`
	Description   *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeMappingFields Fields to exclude from sending to ClickHouse
	ExcludeMappingFields *[]string `json:"excludeMappingFields,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputClickHouseFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
	Format *OutputClickHouseFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MappingType How event fields are mapped to ClickHouse columns.
	MappingType *OutputClickHouseMappingType `json:"mappingType,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputClickHouseOnBackpressure `json:"onBackpressure,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputClickHousePqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}     `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputClickHousePqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputClickHousePqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer"`

	// SqlUsername Username for certificate authentication
	SqlUsername *string `json:"sqlUsername,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TableName Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_".
	TableName string `json:"tableName"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputClickHouseTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                      `json:"certificateName,omitempty"`
		Disabled        *OutputClickHouseTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputClickHouseTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputClickHouseTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32              `json:"tokenTimeoutSecs,omitempty"`
	Type             *OutputClickHouseType `json:"type,omitempty"`

	// Url URL of the ClickHouse instance. Example: http://localhost:8123/
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`

	// WaitForAsyncInserts Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted.
	WaitForAsyncInserts *bool `json:"waitForAsyncInserts,omitempty"`
}

// OutputClickHouseAsyncInserts Collect data into batches for later processing. Disable to write to a ClickHouse table immediately.
type OutputClickHouseAsyncInserts bool

// OutputClickHouseAuthType defines model for OutputClickHouse.AuthType.
type OutputClickHouseAuthType string

// OutputClickHouseFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputClickHouseFailedRequestLoggingMode string

// OutputClickHouseFormat Data format to use when sending data to ClickHouse. Defaults to JSON Compact.
type OutputClickHouseFormat string

// OutputClickHouseMappingType How event fields are mapped to ClickHouse columns.
type OutputClickHouseMappingType string

// OutputClickHouseOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputClickHouseOnBackpressure string

// OutputClickHousePqCompress Codec to use to compress the persisted data.
type OutputClickHousePqCompress string

// OutputClickHousePqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputClickHousePqMode string

// OutputClickHousePqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputClickHousePqOnBackpressure string

// OutputClickHouseTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputClickHouseTimeoutRetrySettingsTimeoutRetry bool

// OutputClickHouseTlsDisabled defines model for OutputClickHouse.Tls.Disabled.
type OutputClickHouseTlsDisabled bool

// OutputClickHouseTlsMaxVersion Maximum TLS version to use when connecting
type OutputClickHouseTlsMaxVersion string

// OutputClickHouseTlsMinVersion Minimum TLS version to use when connecting
type OutputClickHouseTlsMinVersion string

// OutputClickHouseType defines model for OutputClickHouse.Type.
type OutputClickHouseType string

// OutputCloudwatch defines model for OutputCloudwatch.
type OutputCloudwatch struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputCloudwatchAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	Description  *string `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access CloudWatchLogs
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint CloudWatchLogs service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// LogGroupName CloudWatch log group to associate events with
	LogGroupName string `json:"logGroupName"`

	// LogStreamName Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
	LogStreamName string `json:"logStreamName"`

	// MaxQueueSize Maximum number of queued batches before blocking
	MaxQueueSize *float32 `json:"maxQueueSize,omitempty"`

	// MaxRecordSizeKB Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputCloudwatchOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputCloudwatchPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}     `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputCloudwatchPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputCloudwatchPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Region where the CloudWatchLogs is located
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string             `json:"systemFields,omitempty"`
	Type         *OutputCloudwatchType `json:"type,omitempty"`
}

// OutputCloudwatchAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputCloudwatchAwsAuthenticationMethod string

// OutputCloudwatchOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputCloudwatchOnBackpressure string

// OutputCloudwatchPqCompress Codec to use to compress the persisted data.
type OutputCloudwatchPqCompress string

// OutputCloudwatchPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputCloudwatchPqMode string

// OutputCloudwatchPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputCloudwatchPqOnBackpressure string

// OutputCloudwatchType defines model for OutputCloudwatch.Type.
type OutputCloudwatchType string

// OutputConfluentCloud defines model for OutputConfluentCloud.
type OutputConfluentCloud struct {
	// Ack Control the number of required acknowledgments.
	Ack *OutputConfluentCloudAck `json:"ack,omitempty"`

	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092.
	Brokers []string `json:"brokers"`

	// Compression Codec to use to compress the data before sending to Kafka
	Compression *OutputConfluentCloudCompression `json:"compression,omitempty"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushEventCount The maximum number of events you want the Destination to allow in a batch before forcing a flush
	FlushEventCount *float32 `json:"flushEventCount,omitempty"`

	// FlushPeriodSec The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Format to use to serialize events before writing to Kafka.
	Format *OutputConfluentCloudFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled OutputConfluentCloudKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// DefaultKeySchemaId Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
		DefaultKeySchemaId *float32 `json:"defaultKeySchemaId,omitempty"`

		// DefaultValueSchemaId Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
		DefaultValueSchemaId *float32 `json:"defaultValueSchemaId,omitempty"`

		// Disabled Enable Schema Registry
		Disabled OutputConfluentCloudKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                             `json:"certificateName,omitempty"`
			Disabled        *OutputConfluentCloudKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxRecordSizeKB Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputConfluentCloudOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputConfluentCloudPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}         `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputConfluentCloudPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputConfluentCloudPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// ProtobufLibraryId Select a set of Protobuf definitions for the events you want to send
	ProtobufLibraryId *string `json:"protobufLibraryId,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable Authentication
		Disabled OutputConfluentCloudSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use.
		Mechanism *OutputConfluentCloudSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`
	Tls          *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                          `json:"certificateName,omitempty"`
		Disabled        *OutputConfluentCloudTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputConfluentCloudTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputConfluentCloudTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topic The topic to publish events to. Can be overridden using the __topicOut field.
	Topic string                    `json:"topic"`
	Type  *OutputConfluentCloudType `json:"type,omitempty"`
}

// OutputConfluentCloudAck Control the number of required acknowledgments.
type OutputConfluentCloudAck float32

// OutputConfluentCloudCompression Codec to use to compress the data before sending to Kafka
type OutputConfluentCloudCompression string

// OutputConfluentCloudFormat Format to use to serialize events before writing to Kafka.
type OutputConfluentCloudFormat string

// OutputConfluentCloudKafkaSchemaRegistryAuthDisabled Enable authentication
type OutputConfluentCloudKafkaSchemaRegistryAuthDisabled bool

// OutputConfluentCloudKafkaSchemaRegistryDisabled Enable Schema Registry
type OutputConfluentCloudKafkaSchemaRegistryDisabled bool

// OutputConfluentCloudKafkaSchemaRegistryTlsDisabled defines model for OutputConfluentCloud.KafkaSchemaRegistry.Tls.Disabled.
type OutputConfluentCloudKafkaSchemaRegistryTlsDisabled bool

// OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type OutputConfluentCloudKafkaSchemaRegistryTlsMaxVersion string

// OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type OutputConfluentCloudKafkaSchemaRegistryTlsMinVersion string

// OutputConfluentCloudOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputConfluentCloudOnBackpressure string

// OutputConfluentCloudPqCompress Codec to use to compress the persisted data.
type OutputConfluentCloudPqCompress string

// OutputConfluentCloudPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputConfluentCloudPqMode string

// OutputConfluentCloudPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputConfluentCloudPqOnBackpressure string

// OutputConfluentCloudSaslDisabled Enable Authentication
type OutputConfluentCloudSaslDisabled bool

// OutputConfluentCloudSaslMechanism SASL authentication mechanism to use.
type OutputConfluentCloudSaslMechanism string

// OutputConfluentCloudTlsDisabled defines model for OutputConfluentCloud.Tls.Disabled.
type OutputConfluentCloudTlsDisabled bool

// OutputConfluentCloudTlsMaxVersion Maximum TLS version to use when connecting
type OutputConfluentCloudTlsMaxVersion string

// OutputConfluentCloudTlsMinVersion Minimum TLS version to use when connecting
type OutputConfluentCloudTlsMinVersion string

// OutputConfluentCloudType defines model for OutputConfluentCloud.Type.
type OutputConfluentCloudType string

// OutputCriblHttp defines model for OutputCriblHttp.
type OutputCriblHttp struct {
	// Compression Codec to use to compress the data before sending.
	Compression *OutputCriblHttpCompression `json:"compression,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeFields Fields to exclude from the event. By default, all internal fields except `__output` are sent. E.g.: `cribl_pipe`, `c*`. Wildcards supported.
	ExcludeFields *[]string `json:"excludeFields,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputCriblHttpFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs. If this setting is disabled, consider enabling round-robin DNS.
	LoadBalanced *OutputCriblHttpLoadBalanced `json:"loadBalanced,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputCriblHttpOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputCriblHttpPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputCriblHttpPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputCriblHttpPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputCriblHttpTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                     `json:"certificateName,omitempty"`
		Disabled        *OutputCriblHttpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputCriblHttpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputCriblHttpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// TokenTTLMinutes The number of minutes before the internally generated authentication token expires, valid values between 1 and 60.
	TokenTTLMinutes *float32            `json:"tokenTTLMinutes,omitempty"`
	Type            OutputCriblHttpType `json:"type"`

	// Url URL of a Cribl Worker to send events to, e.g., http://localhost:10200
	Url  *string `json:"url,omitempty"`
	Urls *[]struct {
		// Url URL of a Cribl Worker to send events to, e.g., http://localhost:10200
		Url string `json:"url"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"urls,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputCriblHttpCompression Codec to use to compress the data before sending.
type OutputCriblHttpCompression string

// OutputCriblHttpFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputCriblHttpFailedRequestLoggingMode string

// OutputCriblHttpLoadBalanced For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs. If this setting is disabled, consider enabling round-robin DNS.
type OutputCriblHttpLoadBalanced bool

// OutputCriblHttpOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputCriblHttpOnBackpressure string

// OutputCriblHttpPqCompress Codec to use to compress the persisted data.
type OutputCriblHttpPqCompress string

// OutputCriblHttpPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputCriblHttpPqMode string

// OutputCriblHttpPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputCriblHttpPqOnBackpressure string

// OutputCriblHttpTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputCriblHttpTimeoutRetrySettingsTimeoutRetry bool

// OutputCriblHttpTlsDisabled defines model for OutputCriblHttp.Tls.Disabled.
type OutputCriblHttpTlsDisabled bool

// OutputCriblHttpTlsMaxVersion Maximum TLS version to use when connecting
type OutputCriblHttpTlsMaxVersion string

// OutputCriblHttpTlsMinVersion Minimum TLS version to use when connecting
type OutputCriblHttpTlsMinVersion string

// OutputCriblHttpType defines model for OutputCriblHttp.Type.
type OutputCriblHttpType string

// OutputCriblLake defines model for OutputCriblLake.
type OutputCriblLake struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId    *string                                 `json:"assumeRoleExternalId,omitempty"`
	AwsAuthenticationMethod *OutputCriblLakeAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecretKey Secret key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_SECRET}`).
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket *string `json:"bucket,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputCriblLakeDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Lake dataset to send the data to.
	DestPath string `json:"destPath"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string                `json:"fileNameSuffix,omitempty"`
	Format         *OutputCriblLakeFormat `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KmsKeyId ID or ARN of the KMS customer-managed key to use for encryption
	KmsKeyId *string `json:"kmsKeyId,omitempty"`

	// MaxClosingFilesToBackpressure Maximum number of files that can be waiting for upload before backpressure is applied
	MaxClosingFilesToBackpressure *float32 `json:"maxClosingFilesToBackpressure,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputCriblLakeObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputCriblLakeOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputCriblLakeOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the S3 bucket is located.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputCriblLakeRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ServerSideEncryption Server-side encryption for uploaded objects.
	ServerSideEncryption *OutputCriblLakeServerSideEncryption `json:"serverSideEncryption,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *OutputCriblLakeSignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath *string `json:"stagePath,omitempty"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputCriblLakeStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string           `json:"systemFields,omitempty"`
	Type         OutputCriblLakeType `json:"type"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputCriblLakeAwsAuthenticationMethod defines model for OutputCriblLake.AwsAuthenticationMethod.
type OutputCriblLakeAwsAuthenticationMethod string

// OutputCriblLakeDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputCriblLakeDeadletterEnabled bool

// OutputCriblLakeFormat defines model for OutputCriblLake.Format.
type OutputCriblLakeFormat string

// OutputCriblLakeObjectACL Object ACL to assign to uploaded objects.
type OutputCriblLakeObjectACL string

// OutputCriblLakeOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputCriblLakeOnBackpressure string

// OutputCriblLakeOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputCriblLakeOnDiskFullBackpressure string

// OutputCriblLakeRemoveEmptyDirs Remove empty staging directories after moving files
type OutputCriblLakeRemoveEmptyDirs bool

// OutputCriblLakeServerSideEncryption Server-side encryption for uploaded objects.
type OutputCriblLakeServerSideEncryption string

// OutputCriblLakeSignatureVersion Signature version to use for signing S3 requests
type OutputCriblLakeSignatureVersion string

// OutputCriblLakeStorageClass Storage class to select for uploaded objects.
type OutputCriblLakeStorageClass string

// OutputCriblLakeType defines model for OutputCriblLake.Type.
type OutputCriblLakeType string

// OutputCriblTcp defines model for OutputCriblTcp.
type OutputCriblTcp struct {
	// Compression Codec to use to compress the data before sending
	Compression *OutputCriblTcpCompression `json:"compression,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeFields Fields to exclude from the event. By default, all internal fields except `__output` are sent. E.g.: `cribl_pipe`, `c*`. Wildcards supported.
	ExcludeFields *[]string `json:"excludeFields,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// Host The hostname of the receiver
	Host *string `json:"host,omitempty"`

	// Hosts Set of hosts to load-balance data to.
	Hosts *[]struct {
		// Host The hostname of the receiver.
		Host string `json:"host"`

		// Port The port to connect to on the provided host.
		Port float32 `json:"port"`

		// Servername Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings.
		Servername *string `json:"servername,omitempty"`

		// Tls Whether to inherit TLS configs from group setting or disable TLS.
		Tls *OutputCriblTcpHostsTls `json:"tls,omitempty"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"hosts,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced Use load-balanced destinations
	LoadBalanced *OutputCriblTcpLoadBalanced `json:"loadBalanced,omitempty"`

	// LogFailedRequests Use to troubleshoot issues with sending data
	LogFailedRequests *bool `json:"logFailedRequests,omitempty"`

	// MaxConcurrentSenders Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
	MaxConcurrentSenders *float32 `json:"maxConcurrentSenders,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputCriblTcpOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port The port to connect to on the provided host
	Port *float32 `json:"port,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputCriblTcpPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputCriblTcpPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputCriblTcpPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	Tls                *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                    `json:"certificateName,omitempty"`
		Disabled        *OutputCriblTcpTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputCriblTcpTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputCriblTcpTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// TokenTTLMinutes The number of minutes before the internally generated authentication token expires, valid values between 1 and 60
	TokenTTLMinutes *float32           `json:"tokenTTLMinutes,omitempty"`
	Type            OutputCriblTcpType `json:"type"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputCriblTcpCompression Codec to use to compress the data before sending
type OutputCriblTcpCompression string

// OutputCriblTcpHostsTls Whether to inherit TLS configs from group setting or disable TLS.
type OutputCriblTcpHostsTls string

// OutputCriblTcpLoadBalanced Use load-balanced destinations
type OutputCriblTcpLoadBalanced bool

// OutputCriblTcpOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputCriblTcpOnBackpressure string

// OutputCriblTcpPqCompress Codec to use to compress the persisted data.
type OutputCriblTcpPqCompress string

// OutputCriblTcpPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputCriblTcpPqMode string

// OutputCriblTcpPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputCriblTcpPqOnBackpressure string

// OutputCriblTcpTlsDisabled defines model for OutputCriblTcp.Tls.Disabled.
type OutputCriblTcpTlsDisabled bool

// OutputCriblTcpTlsMaxVersion Maximum TLS version to use when connecting
type OutputCriblTcpTlsMaxVersion string

// OutputCriblTcpTlsMinVersion Minimum TLS version to use when connecting
type OutputCriblTcpTlsMinVersion string

// OutputCriblTcpType defines model for OutputCriblTcp.Type.
type OutputCriblTcpType string

// OutputCrowdstrikeNextGenSiem defines model for OutputCrowdstrikeNextGenSiem.
type OutputCrowdstrikeNextGenSiem struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputCrowdstrikeNextGenSiemAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
	Format OutputCrowdstrikeNextGenSiemFormat `json:"format"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputCrowdstrikeNextGenSiemOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputCrowdstrikeNextGenSiemPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}                 `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputCrowdstrikeNextGenSiemPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputCrowdstrikeNextGenSiemPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token CrowdStrike Next-Gen SIEM authentication token
	Token *string                           `json:"token,omitempty"`
	Type  *OutputCrowdstrikeNextGenSiemType `json:"type,omitempty"`

	// Url URL provided from a CrowdStrike data connector, e.g. https://<your-api-key>.ingest.<your-region>.crowdstrike.com/services/collector
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputCrowdstrikeNextGenSiemAuthType Enter a token directly, or provide a secret referencing a token
type OutputCrowdstrikeNextGenSiemAuthType string

// OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputCrowdstrikeNextGenSiemFailedRequestLoggingMode string

// OutputCrowdstrikeNextGenSiemFormat When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
type OutputCrowdstrikeNextGenSiemFormat string

// OutputCrowdstrikeNextGenSiemOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputCrowdstrikeNextGenSiemOnBackpressure string

// OutputCrowdstrikeNextGenSiemPqCompress Codec to use to compress the persisted data.
type OutputCrowdstrikeNextGenSiemPqCompress string

// OutputCrowdstrikeNextGenSiemPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputCrowdstrikeNextGenSiemPqMode string

// OutputCrowdstrikeNextGenSiemPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputCrowdstrikeNextGenSiemPqOnBackpressure string

// OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputCrowdstrikeNextGenSiemTimeoutRetrySettingsTimeoutRetry bool

// OutputCrowdstrikeNextGenSiemType defines model for OutputCrowdstrikeNextGenSiem.Type.
type OutputCrowdstrikeNextGenSiemType string

// OutputDatadog defines model for OutputDatadog.
type OutputDatadog struct {
	// AllowApiKeyFromEvents If enabled, the API key can be set from the event's '__agent_api_key' field.
	AllowApiKeyFromEvents *bool `json:"allowApiKeyFromEvents,omitempty"`

	// ApiKey Organization's API key in Datadog
	ApiKey *string `json:"apiKey,omitempty"`

	// AuthType Enter API key directly, or select a stored secret
	AuthType *OutputDatadogAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// ContentType The content type to use when sending logs.
	ContentType *OutputDatadogContentType `json:"contentType,omitempty"`
	CustomUrl   *string                   `json:"customUrl,omitempty"`
	Description *string                   `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputDatadogFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Host Name of the host to send with logs. When you send logs as JSON objects, the event's 'host' field (if set) will override this value.
	Host *string `json:"host,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Message Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
	Message *string `json:"message,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputDatadogOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputDatadogPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputDatadogPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputDatadogPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// SendCountersAsCount If not enabled, Datadog will transform 'counter' metrics to 'gauge'. [Learn more about Datadog metrics types.](https://docs.datadoghq.com/metrics/types/?tab=count)
	SendCountersAsCount *bool `json:"sendCountersAsCount,omitempty"`

	// Service Name of the service to send with logs. When you send logs as JSON objects, the event's '__service' field (if set) will override this value.
	Service *string `json:"service,omitempty"`

	// Severity Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value.
	Severity *OutputDatadogSeverity `json:"severity,omitempty"`

	// Site Datadog site to which events should be sent
	Site *OutputDatadogSite `json:"site,omitempty"`

	// Source Name of the source to send with logs. When you send logs as JSON objects, the event's 'source' field (if set) will override this value.
	Source *string `json:"source,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// Tags List of tags to send with logs (e.g., 'env:prod', 'env_staging:east').
	Tags *[]string `json:"tags,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputDatadogTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32          `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputDatadogType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputDatadogAuthType Enter API key directly, or select a stored secret
type OutputDatadogAuthType string

// OutputDatadogContentType The content type to use when sending logs.
type OutputDatadogContentType string

// OutputDatadogFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputDatadogFailedRequestLoggingMode string

// OutputDatadogOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputDatadogOnBackpressure string

// OutputDatadogPqCompress Codec to use to compress the persisted data.
type OutputDatadogPqCompress string

// OutputDatadogPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputDatadogPqMode string

// OutputDatadogPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputDatadogPqOnBackpressure string

// OutputDatadogSeverity Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value.
type OutputDatadogSeverity string

// OutputDatadogSite Datadog site to which events should be sent
type OutputDatadogSite string

// OutputDatadogTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputDatadogTimeoutRetrySettingsTimeoutRetry bool

// OutputDatadogType defines model for OutputDatadog.Type.
type OutputDatadogType string

// OutputDataset defines model for OutputDataset.
type OutputDataset struct {
	// ApiKey A 'Log Write Access' API key for the DataSet account
	ApiKey *string `json:"apiKey,omitempty"`

	// AuthType Enter API key directly, or select a stored secret
	AuthType *OutputDatasetAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	CustomUrl   *string  `json:"customUrl,omitempty"`

	// DefaultSeverity Default value for event severity. If the `sev` or `__severity` fields are set on an event, the first one matching will override this value.
	DefaultSeverity *OutputDatasetDefaultSeverity `json:"defaultSeverity,omitempty"`
	Description     *string                       `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeFields Fields to exclude from the event if the Message field is either unspecified or refers to an object. Ignored if the Message field is a string. If empty, we send all non-internal fields.
	ExcludeFields *[]string `json:"excludeFields,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputDatasetFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// MessageField Name of the event field that contains the message or attributes to send. If not specified, all of the event's non-internal fields will be sent as attributes.
	MessageField *string `json:"messageField,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputDatasetOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputDatasetPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputDatasetPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputDatasetPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// ServerHostField Name of the event field that contains the `serverHost` identifier. If not specified, defaults to `cribl_<outputId>`.
	ServerHostField *string `json:"serverHostField,omitempty"`

	// Site DataSet site to which events should be sent
	Site *OutputDatasetSite `json:"site,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputDatasetTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TimestampField Name of the event field that contains the timestamp. If not specified, defaults to `ts`, `_time`, or `Date.now()`, in that order.
	TimestampField *string `json:"timestampField,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32          `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputDatasetType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputDatasetAuthType Enter API key directly, or select a stored secret
type OutputDatasetAuthType string

// OutputDatasetDefaultSeverity Default value for event severity. If the `sev` or `__severity` fields are set on an event, the first one matching will override this value.
type OutputDatasetDefaultSeverity string

// OutputDatasetFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputDatasetFailedRequestLoggingMode string

// OutputDatasetOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputDatasetOnBackpressure string

// OutputDatasetPqCompress Codec to use to compress the persisted data.
type OutputDatasetPqCompress string

// OutputDatasetPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputDatasetPqMode string

// OutputDatasetPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputDatasetPqOnBackpressure string

// OutputDatasetSite DataSet site to which events should be sent
type OutputDatasetSite string

// OutputDatasetTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputDatasetTimeoutRetrySettingsTimeoutRetry bool

// OutputDatasetType defines model for OutputDataset.Type.
type OutputDatasetType string

// OutputDefault defines model for OutputDefault.
type OutputDefault struct {
	// DefaultId ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
	DefaultId string `json:"defaultId"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string         `json:"systemFields,omitempty"`
	Type         OutputDefaultType `json:"type"`
}

// OutputDefaultType defines model for OutputDefault.Type.
type OutputDefaultType string

// OutputDevnull defines model for OutputDevnull.
type OutputDevnull struct {
	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string         `json:"systemFields,omitempty"`
	Type         OutputDevnullType `json:"type"`
}

// OutputDevnullType defines model for OutputDevnull.Type.
type OutputDevnullType string

// OutputDiskSpool defines model for OutputDiskSpool.
type OutputDiskSpool struct {
	// Compress Data compression format. Default is gzip.
	Compress    *OutputDiskSpoolCompress `json:"compress,omitempty"`
	Description *string                  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// MaxDataSize Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB.
	MaxDataSize *string `json:"maxDataSize,omitempty"`

	// MaxDataTime Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h.
	MaxDataTime *string `json:"maxDataTime,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized within the time-buckets. If blank, the event's __partition property is used and otherwise, events go directly into the time-bucket directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TimeWindow Time period for grouping spooled events. Default is 10m.
	TimeWindow *string             `json:"timeWindow,omitempty"`
	Type       OutputDiskSpoolType `json:"type"`
}

// OutputDiskSpoolCompress Data compression format. Default is gzip.
type OutputDiskSpoolCompress string

// OutputDiskSpoolType defines model for OutputDiskSpool.Type.
type OutputDiskSpoolType string

// OutputDlS3 defines model for OutputDlS3.
type OutputDlS3 struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// AwsApiKey Access key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_ACCESS_KEY}`).
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputDlS3AwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_SECRET}`).
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputDlS3Compress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputDlS3CompressionLevel `json:"compressionLevel,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputDlS3DeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`.
	DestPath *string `json:"destPath,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputDlS3Format `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// KmsKeyId ID or ARN of the KMS customer-managed key to use for encryption
	KmsKeyId *string `json:"kmsKeyId,omitempty"`

	// MaxClosingFilesToBackpressure Maximum number of files that can be waiting for upload before backpressure is applied
	MaxClosingFilesToBackpressure *float32 `json:"maxClosingFilesToBackpressure,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputDlS3ObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputDlS3OnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputDlS3OnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputDlS3ParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputDlS3ParquetVersion `json:"parquetVersion,omitempty"`

	// PartitioningFields List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>.
	PartitioningFields *[]string `json:"partitioningFields,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the S3 bucket is located.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputDlS3RemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ServerSideEncryption Server-side encryption for uploaded objects.
	ServerSideEncryption *OutputDlS3ServerSideEncryption `json:"serverSideEncryption,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *OutputDlS3SignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputDlS3StorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string       `json:"systemFields,omitempty"`
	Type         *OutputDlS3Type `json:"type,omitempty"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputDlS3AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputDlS3AwsAuthenticationMethod string

// OutputDlS3Compress Choose data compression format to apply before moving files to final destination
type OutputDlS3Compress string

// OutputDlS3CompressionLevel Compression level to apply before moving files to final destination
type OutputDlS3CompressionLevel string

// OutputDlS3DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputDlS3DeadletterEnabled bool

// OutputDlS3Format Format of the output data
type OutputDlS3Format string

// OutputDlS3ObjectACL Object ACL to assign to uploaded objects.
type OutputDlS3ObjectACL string

// OutputDlS3OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputDlS3OnBackpressure string

// OutputDlS3OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputDlS3OnDiskFullBackpressure string

// OutputDlS3ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputDlS3ParquetDataPageVersion string

// OutputDlS3ParquetVersion Determines which data types are supported and how they are represented
type OutputDlS3ParquetVersion string

// OutputDlS3RemoveEmptyDirs Remove empty staging directories after moving files
type OutputDlS3RemoveEmptyDirs bool

// OutputDlS3ServerSideEncryption Server-side encryption for uploaded objects.
type OutputDlS3ServerSideEncryption string

// OutputDlS3SignatureVersion Signature version to use for signing S3 requests
type OutputDlS3SignatureVersion string

// OutputDlS3StorageClass Storage class to select for uploaded objects.
type OutputDlS3StorageClass string

// OutputDlS3Type defines model for OutputDlS3.Type.
type OutputDlS3Type string

// OutputDynatraceHttp defines model for OutputDynatraceHttp.
type OutputDynatraceHttp struct {
	// ActiveGateDomain ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest.
	ActiveGateDomain *string                      `json:"activeGateDomain,omitempty"`
	AuthType         *OutputDynatraceHttpAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32                    `json:"concurrency,omitempty"`
	Description *string                     `json:"description,omitempty"`
	Endpoint    OutputDynatraceHttpEndpoint `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// EnvironmentId ID of the environment to send to
	EnvironmentId *string `json:"environmentId,omitempty"`

	// ExtraHttpHeaders Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputDynatraceHttpFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
	Format OutputDynatraceHttpFormat `json:"format"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Method The method to use when sending events. Defaults to POST.
	Method *OutputDynatraceHttpMethod `json:"method,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputDynatraceHttpOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputDynatraceHttpPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}        `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputDynatraceHttpPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputDynatraceHttpPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields  *[]string                        `json:"systemFields,omitempty"`
	TelemetryType OutputDynatraceHttpTelemetryType `json:"telemetryType"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32                 `json:"totalMemoryLimitKB,omitempty"`
	Type               *OutputDynatraceHttpType `json:"type,omitempty"`

	// Url URL to send events to. Can be overwritten by an event's __url field.
	Url *string `json:"url,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputDynatraceHttpAuthType defines model for OutputDynatraceHttp.AuthType.
type OutputDynatraceHttpAuthType string

// OutputDynatraceHttpEndpoint defines model for OutputDynatraceHttp.Endpoint.
type OutputDynatraceHttpEndpoint string

// OutputDynatraceHttpFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputDynatraceHttpFailedRequestLoggingMode string

// OutputDynatraceHttpFormat How to format events before sending. Defaults to JSON. Plaintext is not currently supported.
type OutputDynatraceHttpFormat string

// OutputDynatraceHttpMethod The method to use when sending events. Defaults to POST.
type OutputDynatraceHttpMethod string

// OutputDynatraceHttpOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputDynatraceHttpOnBackpressure string

// OutputDynatraceHttpPqCompress Codec to use to compress the persisted data.
type OutputDynatraceHttpPqCompress string

// OutputDynatraceHttpPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputDynatraceHttpPqMode string

// OutputDynatraceHttpPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputDynatraceHttpPqOnBackpressure string

// OutputDynatraceHttpTelemetryType defines model for OutputDynatraceHttp.TelemetryType.
type OutputDynatraceHttpTelemetryType string

// OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputDynatraceHttpTimeoutRetrySettingsTimeoutRetry bool

// OutputDynatraceHttpType defines model for OutputDynatraceHttp.Type.
type OutputDynatraceHttpType string

// OutputDynatraceOtlp defines model for OutputDynatraceOtlp.
type OutputDynatraceOtlp struct {
	AuthTokenName *string `json:"authTokenName,omitempty"`

	// Compress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	Compress *OutputDynatraceOtlpCompress `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Endpoint The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
	Endpoint string `json:"endpoint"`

	// EndpointType Select the type of Dynatrace endpoint configured
	EndpointType OutputDynatraceOtlpEndpointType `json:"endpointType"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputDynatraceOtlpFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// HttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	HttpCompress *OutputDynatraceOtlpHttpCompress `json:"httpCompress,omitempty"`

	// HttpLogsEndpointOverride If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpLogsEndpointOverride *string `json:"httpLogsEndpointOverride,omitempty"`

	// HttpMetricsEndpointOverride If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpMetricsEndpointOverride *string `json:"httpMetricsEndpointOverride,omitempty"`

	// HttpTracesEndpointOverride If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpTracesEndpointOverride *string `json:"httpTracesEndpointOverride,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// KeepAliveTime How often the sender should ping the peer to keep the connection open
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// MaxPayloadSizeKB Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Metadata List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
	Metadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputDynatraceOtlpOnBackpressure `json:"onBackpressure,omitempty"`

	// OtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
	OtlpVersion OutputDynatraceOtlpOtlpVersion `json:"otlpVersion"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputDynatraceOtlpPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}        `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputDynatraceOtlpPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputDynatraceOtlpPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Select a transport option for Dynatrace
	Protocol OutputDynatraceOtlpProtocol `json:"protocol"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TokenSecret Select or create a stored text secret
	TokenSecret string                   `json:"tokenSecret"`
	Type        *OutputDynatraceOtlpType `json:"type,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputDynatraceOtlpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputDynatraceOtlpCompress string

// OutputDynatraceOtlpEndpointType Select the type of Dynatrace endpoint configured
type OutputDynatraceOtlpEndpointType string

// OutputDynatraceOtlpFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputDynatraceOtlpFailedRequestLoggingMode string

// OutputDynatraceOtlpHttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputDynatraceOtlpHttpCompress string

// OutputDynatraceOtlpOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputDynatraceOtlpOnBackpressure string

// OutputDynatraceOtlpOtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
type OutputDynatraceOtlpOtlpVersion string

// OutputDynatraceOtlpPqCompress Codec to use to compress the persisted data.
type OutputDynatraceOtlpPqCompress string

// OutputDynatraceOtlpPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputDynatraceOtlpPqMode string

// OutputDynatraceOtlpPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputDynatraceOtlpPqOnBackpressure string

// OutputDynatraceOtlpProtocol Select a transport option for Dynatrace
type OutputDynatraceOtlpProtocol string

// OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputDynatraceOtlpTimeoutRetrySettingsTimeoutRetry bool

// OutputDynatraceOtlpType defines model for OutputDynatraceOtlp.Type.
type OutputDynatraceOtlpType string

// OutputElastic defines model for OutputElastic.
type OutputElastic struct {
	Auth *struct {
		// AuthType Enter credentials directly, or select a stored secret
		AuthType *OutputElasticAuthAuthType `json:"authType,omitempty"`
		Disabled OutputElasticAuthDisabled  `json:"disabled"`
	} `json:"auth,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// DocType Document type to use for events. Can be overwritten by an event's __type field
	DocType *string `json:"docType,omitempty"`

	// ElasticPipeline Optional Elasticsearch destination pipeline
	ElasticPipeline *string `json:"elasticPipeline,omitempty"`

	// ElasticVersion Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
	ElasticVersion *OutputElasticElasticVersion `json:"elasticVersion,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// ExtraParams Extra Parameters.
	ExtraParams *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraParams,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputElasticFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// IncludeDocId Toggle this off when sending events to an Elastic TSDS (time series data stream) or to allow Elastic to generate document IDs
	IncludeDocId *bool `json:"includeDocId,omitempty"`

	// Index Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
	Index string `json:"index"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
	LoadBalanced *OutputElasticLoadBalanced `json:"loadBalanced,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputElasticOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputElasticPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputElasticPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputElasticPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// RetryPartialErrors Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch
	RetryPartialErrors *bool `json:"retryPartialErrors,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputElasticTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32          `json:"timeoutSec,omitempty"`
	Type       OutputElasticType `json:"type"`

	// Url The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk
	Url  *string `json:"url,omitempty"`
	Urls *[]struct {
		// Url The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk
		Url string `json:"url"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"urls,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// WriteAction Action to use when writing events. Must be set to `Create` when writing to a data stream.
	WriteAction *OutputElasticWriteAction `json:"writeAction,omitempty"`
}

// OutputElasticAuthAuthType Enter credentials directly, or select a stored secret
type OutputElasticAuthAuthType string

// OutputElasticAuthDisabled defines model for OutputElastic.Auth.Disabled.
type OutputElasticAuthDisabled bool

// OutputElasticElasticVersion Optional Elasticsearch version, used to format events. If not specified, will auto-discover version.
type OutputElasticElasticVersion string

// OutputElasticFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputElasticFailedRequestLoggingMode string

// OutputElasticLoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
type OutputElasticLoadBalanced bool

// OutputElasticOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputElasticOnBackpressure string

// OutputElasticPqCompress Codec to use to compress the persisted data.
type OutputElasticPqCompress string

// OutputElasticPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputElasticPqMode string

// OutputElasticPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputElasticPqOnBackpressure string

// OutputElasticTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputElasticTimeoutRetrySettingsTimeoutRetry bool

// OutputElasticType defines model for OutputElastic.Type.
type OutputElasticType string

// OutputElasticWriteAction Action to use when writing events. Must be set to `Create` when writing to a data stream.
type OutputElasticWriteAction string

// OutputElasticCloud defines model for OutputElasticCloud.
type OutputElasticCloud struct {
	Auth *struct {
		// AuthType Enter credentials directly, or select a stored secret
		AuthType *OutputElasticCloudAuthAuthType `json:"authType,omitempty"`
		Disabled OutputElasticCloudAuthDisabled  `json:"disabled"`
	} `json:"auth,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// ElasticPipeline Optional Elastic Cloud Destination pipeline
	ElasticPipeline *string `json:"elasticPipeline,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// ExtraParams Extra parameters to use in HTTP requests
	ExtraParams *[]struct {
		// Name Field name
		Name string `json:"name"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraParams,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputElasticCloudFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// IncludeDocId Toggle to No when sending events to an Elastic TSDS (time series data stream)
	IncludeDocId *bool `json:"includeDocId,omitempty"`

	// Index Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field
	Index string `json:"index"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputElasticCloudOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputElasticCloudPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}       `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputElasticCloudPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputElasticCloudPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputElasticCloudTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32                `json:"timeoutSec,omitempty"`
	Type       *OutputElasticCloudType `json:"type,omitempty"`

	// Url Enter Cloud ID of the Elastic Cloud environment to send events to
	Url string `json:"url"`
}

// OutputElasticCloudAuthAuthType Enter credentials directly, or select a stored secret
type OutputElasticCloudAuthAuthType string

// OutputElasticCloudAuthDisabled defines model for OutputElasticCloud.Auth.Disabled.
type OutputElasticCloudAuthDisabled bool

// OutputElasticCloudFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputElasticCloudFailedRequestLoggingMode string

// OutputElasticCloudOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputElasticCloudOnBackpressure string

// OutputElasticCloudPqCompress Codec to use to compress the persisted data.
type OutputElasticCloudPqCompress string

// OutputElasticCloudPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputElasticCloudPqMode string

// OutputElasticCloudPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputElasticCloudPqOnBackpressure string

// OutputElasticCloudTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputElasticCloudTimeoutRetrySettingsTimeoutRetry bool

// OutputElasticCloudType defines model for OutputElasticCloud.Type.
type OutputElasticCloudType string

// OutputExabeam defines model for OutputExabeam.
type OutputExabeam struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AwsApiKey HMAC access key. Can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsSecretKey HMAC secret. Can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Bucket Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// CollectorInstanceId ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888
	CollectorInstanceId string `json:"collectorInstanceId"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputExabeamDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EncodedConfiguration Enter an encoded string containing Exabeam configurations.
	EncodedConfiguration *string `json:"encodedConfiguration,omitempty"`

	// Endpoint Google Cloud Storage service endpoint.
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputExabeamObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputExabeamOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputExabeamOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the bucket is located
	Region string `json:"region"`

	// RejectUnauthorized Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputExabeamRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Whether to reuse connections between requests, which can improve performance.
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SignatureVersion Signature version to use for signing Google Cloud Storage requests.
	SignatureVersion *OutputExabeamSignatureVersion `json:"signatureVersion,omitempty"`

	// SiteId Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name.
	SiteId *string `json:"siteId,omitempty"`

	// SiteName Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants.
	SiteName *string `json:"siteName,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputExabeamStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TimezoneOffset Exabeam timezone offset.
	TimezoneOffset *string            `json:"timezoneOffset,omitempty"`
	Type           *OutputExabeamType `json:"type,omitempty"`
}

// OutputExabeamDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputExabeamDeadletterEnabled bool

// OutputExabeamObjectACL Object ACL to assign to uploaded objects.
type OutputExabeamObjectACL string

// OutputExabeamOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputExabeamOnBackpressure string

// OutputExabeamOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputExabeamOnDiskFullBackpressure string

// OutputExabeamRemoveEmptyDirs Remove empty staging directories after moving files
type OutputExabeamRemoveEmptyDirs bool

// OutputExabeamSignatureVersion Signature version to use for signing Google Cloud Storage requests.
type OutputExabeamSignatureVersion string

// OutputExabeamStorageClass Storage class to select for uploaded objects.
type OutputExabeamStorageClass string

// OutputExabeamType defines model for OutputExabeam.Type.
type OutputExabeamType string

// OutputFilesystem defines model for OutputFilesystem.
type OutputFilesystem struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputFilesystemCompress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputFilesystemCompressionLevel `json:"compressionLevel,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputFilesystemDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Final destination for the output files
	DestPath string `json:"destPath"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputFilesystemFormat `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputFilesystemOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputFilesystemOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputFilesystemParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputFilesystemParquetVersion `json:"parquetVersion,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputFilesystemRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// StagePath Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
	StagePath *string `json:"stagePath,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string            `json:"systemFields,omitempty"`
	Type         OutputFilesystemType `json:"type"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputFilesystemCompress Choose data compression format to apply before moving files to final destination
type OutputFilesystemCompress string

// OutputFilesystemCompressionLevel Compression level to apply before moving files to final destination
type OutputFilesystemCompressionLevel string

// OutputFilesystemDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputFilesystemDeadletterEnabled bool

// OutputFilesystemFormat Format of the output data
type OutputFilesystemFormat string

// OutputFilesystemOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputFilesystemOnBackpressure string

// OutputFilesystemOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputFilesystemOnDiskFullBackpressure string

// OutputFilesystemParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputFilesystemParquetDataPageVersion string

// OutputFilesystemParquetVersion Determines which data types are supported and how they are represented
type OutputFilesystemParquetVersion string

// OutputFilesystemRemoveEmptyDirs Remove empty staging directories after moving files
type OutputFilesystemRemoveEmptyDirs bool

// OutputFilesystemType defines model for OutputFilesystem.Type.
type OutputFilesystemType string

// OutputGoogleChronicle defines model for OutputGoogleChronicle.
type OutputGoogleChronicle struct {
	// ApiKey Organization's API key in Google SecOps
	ApiKey *string `json:"apiKey,omitempty"`

	// ApiKeySecret Select or create a stored text secret
	ApiKeySecret         *string                                    `json:"apiKeySecret,omitempty"`
	ApiVersion           *OutputGoogleChronicleApiVersion           `json:"apiVersion,omitempty"`
	AuthenticationMethod *OutputGoogleChronicleAuthenticationMethod `json:"authenticationMethod,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CustomLabels Custom labels to be added to every batch.
	CustomLabels *[]struct {
		// Key Label key
		Key string `json:"key"`

		// Value Label value
		Value string `json:"value"`
	} `json:"customLabels,omitempty"`

	// CustomerId Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative.
	CustomerId  *string `json:"customerId,omitempty"`
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// ExtraLogTypes Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type.
	ExtraLogTypes *[]struct {
		// Description Log type description
		Description *string `json:"description,omitempty"`

		// LogType Log type
		LogType string `json:"logType"`
	} `json:"extraLogTypes,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputGoogleChronicleFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id            *string                            `json:"id,omitempty"`
	LogFormatType OutputGoogleChronicleLogFormatType `json:"logFormatType"`

	// LogTextField Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event.
	LogTextField *string `json:"logTextField,omitempty"`

	// LogType Default log type value to send to SecOps. Can be overwritten by event field __logType.
	LogType *string `json:"logType,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Namespace User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace.
	Namespace *string `json:"namespace,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputGoogleChronicleOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputGoogleChroniclePqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}          `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputGoogleChroniclePqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputGoogleChroniclePqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Regional endpoint to send events to
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// ServiceAccountCredentials Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`

	// ServiceAccountCredentialsSecret Select or create a stored text secret
	ServiceAccountCredentialsSecret *string `json:"serviceAccountCredentialsSecret,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32                  `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputGoogleChronicleType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputGoogleChronicleApiVersion defines model for OutputGoogleChronicle.ApiVersion.
type OutputGoogleChronicleApiVersion string

// OutputGoogleChronicleAuthenticationMethod defines model for OutputGoogleChronicle.AuthenticationMethod.
type OutputGoogleChronicleAuthenticationMethod string

// OutputGoogleChronicleFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputGoogleChronicleFailedRequestLoggingMode string

// OutputGoogleChronicleLogFormatType defines model for OutputGoogleChronicle.LogFormatType.
type OutputGoogleChronicleLogFormatType string

// OutputGoogleChronicleOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputGoogleChronicleOnBackpressure string

// OutputGoogleChroniclePqCompress Codec to use to compress the persisted data.
type OutputGoogleChroniclePqCompress string

// OutputGoogleChroniclePqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputGoogleChroniclePqMode string

// OutputGoogleChroniclePqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputGoogleChroniclePqOnBackpressure string

// OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputGoogleChronicleTimeoutRetrySettingsTimeoutRetry bool

// OutputGoogleChronicleType defines model for OutputGoogleChronicle.Type.
type OutputGoogleChronicleType string

// OutputGoogleCloudLogging defines model for OutputGoogleCloudLogging.
type OutputGoogleCloudLogging struct {
	// Concurrency Maximum number of ongoing requests before blocking.
	Concurrency *float32 `json:"concurrency,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// GoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
	GoogleAuthMethod *OutputGoogleCloudLoggingGoogleAuthMethod `json:"googleAuthMethod,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// InsertIdExpression JavaScript expression to compute the value of the insert ID field.
	InsertIdExpression *string `json:"insertIdExpression,omitempty"`

	// LogLabels Labels to apply to the log entry
	LogLabels *[]struct {
		// Label Label name
		Label string `json:"label"`

		// ValueExpression JavaScript expression to compute the label's value.
		ValueExpression string `json:"valueExpression"`
	} `json:"logLabels,omitempty"`

	// LogLocationExpression JavaScript expression to compute the value of the folder ID with which log entries should be associated.
	LogLocationExpression string                                  `json:"logLocationExpression"`
	LogLocationType       OutputGoogleCloudLoggingLogLocationType `json:"logLocationType"`

	// LogNameExpression JavaScript expression to compute the value of the log name.
	LogNameExpression string `json:"logNameExpression"`

	// MaxPayloadEvents Max number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body.
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputGoogleCloudLoggingOnBackpressure `json:"onBackpressure,omitempty"`

	// PayloadExpression JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event.
	PayloadExpression *string `json:"payloadExpression,omitempty"`

	// PayloadFormat Format to use when sending payload. Defaults to Text.
	PayloadFormat *OutputGoogleCloudLoggingPayloadFormat `json:"payloadFormat,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputGoogleCloudLoggingPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}             `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputGoogleCloudLoggingPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputGoogleCloudLoggingPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// ResourceTypeExpression JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global".
	ResourceTypeExpression *string `json:"resourceTypeExpression,omitempty"`

	// ResourceTypeLabels Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging.
	ResourceTypeLabels *[]struct {
		// Label Label name
		Label string `json:"label"`

		// ValueExpression JavaScript expression to compute the label's value.
		ValueExpression string `json:"valueExpression"`
	} `json:"resourceTypeLabels,omitempty"`

	// Secret Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`

	// ServiceAccountCredentials Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`

	// SeverityExpression JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT".
	SeverityExpression *string `json:"severityExpression,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRateReqPerSec Maximum number of requests to limit to per second.
	ThrottleRateReqPerSec *int `json:"throttleRateReqPerSec,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it.
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32                      `json:"totalMemoryLimitKB,omitempty"`
	Type               *OutputGoogleCloudLoggingType `json:"type,omitempty"`
}

// OutputGoogleCloudLoggingGoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
type OutputGoogleCloudLoggingGoogleAuthMethod string

// OutputGoogleCloudLoggingLogLocationType defines model for OutputGoogleCloudLogging.LogLocationType.
type OutputGoogleCloudLoggingLogLocationType string

// OutputGoogleCloudLoggingOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputGoogleCloudLoggingOnBackpressure string

// OutputGoogleCloudLoggingPayloadFormat Format to use when sending payload. Defaults to Text.
type OutputGoogleCloudLoggingPayloadFormat string

// OutputGoogleCloudLoggingPqCompress Codec to use to compress the persisted data.
type OutputGoogleCloudLoggingPqCompress string

// OutputGoogleCloudLoggingPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputGoogleCloudLoggingPqMode string

// OutputGoogleCloudLoggingPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputGoogleCloudLoggingPqOnBackpressure string

// OutputGoogleCloudLoggingType defines model for OutputGoogleCloudLogging.Type.
type OutputGoogleCloudLoggingType string

// OutputGoogleCloudStorage defines model for OutputGoogleCloudStorage.
type OutputGoogleCloudStorage struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// AwsApiKey HMAC access key. This value can be a constant or a JavaScript expression (e.g., `${C.env.GCS_ACCESS_KEY}`).
	AwsApiKey               *string                                          `json:"awsApiKey,omitempty"`
	AwsAuthenticationMethod *OutputGoogleCloudStorageAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey HMAC secret. This value can be a constant or a JavaScript expression (e.g., `${C.env.GCS_SECRET}`).
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputGoogleCloudStorageCompress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputGoogleCloudStorageCompressionLevel `json:"compressionLevel,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputGoogleCloudStorageDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`.
	DestPath *string `json:"destPath,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Endpoint Google Cloud Storage service endpoint.
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputGoogleCloudStorageFormat `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputGoogleCloudStorageObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputGoogleCloudStorageOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputGoogleCloudStorageOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputGoogleCloudStorageParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputGoogleCloudStorageParquetVersion `json:"parquetVersion,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the bucket is located
	Region string `json:"region"`

	// RejectUnauthorized Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputGoogleCloudStorageRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Whether to reuse connections between requests, which can improve performance.
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// SignatureVersion Signature version to use for signing Google Cloud Storage requests.
	SignatureVersion *OutputGoogleCloudStorageSignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputGoogleCloudStorageStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string                     `json:"systemFields,omitempty"`
	Type         *OutputGoogleCloudStorageType `json:"type,omitempty"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputGoogleCloudStorageAwsAuthenticationMethod defines model for OutputGoogleCloudStorage.AwsAuthenticationMethod.
type OutputGoogleCloudStorageAwsAuthenticationMethod string

// OutputGoogleCloudStorageCompress Choose data compression format to apply before moving files to final destination
type OutputGoogleCloudStorageCompress string

// OutputGoogleCloudStorageCompressionLevel Compression level to apply before moving files to final destination
type OutputGoogleCloudStorageCompressionLevel string

// OutputGoogleCloudStorageDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputGoogleCloudStorageDeadletterEnabled bool

// OutputGoogleCloudStorageFormat Format of the output data
type OutputGoogleCloudStorageFormat string

// OutputGoogleCloudStorageObjectACL Object ACL to assign to uploaded objects.
type OutputGoogleCloudStorageObjectACL string

// OutputGoogleCloudStorageOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputGoogleCloudStorageOnBackpressure string

// OutputGoogleCloudStorageOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputGoogleCloudStorageOnDiskFullBackpressure string

// OutputGoogleCloudStorageParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputGoogleCloudStorageParquetDataPageVersion string

// OutputGoogleCloudStorageParquetVersion Determines which data types are supported and how they are represented
type OutputGoogleCloudStorageParquetVersion string

// OutputGoogleCloudStorageRemoveEmptyDirs Remove empty staging directories after moving files
type OutputGoogleCloudStorageRemoveEmptyDirs bool

// OutputGoogleCloudStorageSignatureVersion Signature version to use for signing Google Cloud Storage requests.
type OutputGoogleCloudStorageSignatureVersion string

// OutputGoogleCloudStorageStorageClass Storage class to select for uploaded objects.
type OutputGoogleCloudStorageStorageClass string

// OutputGoogleCloudStorageType defines model for OutputGoogleCloudStorage.Type.
type OutputGoogleCloudStorageType string

// OutputGooglePubsub defines model for OutputGooglePubsub.
type OutputGooglePubsub struct {
	// BatchSize The maximum number of items the Google API should batch before it sends them to the topic.
	BatchSize *float32 `json:"batchSize,omitempty"`

	// BatchTimeout The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached).
	BatchTimeout *float32 `json:"batchTimeout,omitempty"`

	// CreateTopic If enabled, create topic if it does not exist.
	CreateTopic *bool   `json:"createTopic,omitempty"`
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec Maximum time to wait before sending a batch (when Max batch size is not reached).
	FlushPeriodSec *interface{} `json:"flushPeriodSec,omitempty"`

	// GoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
	GoogleAuthMethod *OutputGooglePubsubGoogleAuthMethod `json:"googleAuthMethod,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxInProgress The maximum number of in-progress API requests before backpressure is applied.
	MaxInProgress *float32 `json:"maxInProgress,omitempty"`

	// MaxQueueSize Maximum number of queued batches before blocking.
	MaxQueueSize *float32 `json:"maxQueueSize,omitempty"`

	// MaxRecordSizeKB Maximum size (KB) of batches to send.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputGooglePubsubOnBackpressure `json:"onBackpressure,omitempty"`

	// OrderedDelivery If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled.
	OrderedDelivery *bool `json:"orderedDelivery,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputGooglePubsubPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}       `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputGooglePubsubPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputGooglePubsubPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
	Region *string `json:"region,omitempty"`

	// Secret Select or create a stored text secret
	Secret *string `json:"secret,omitempty"`

	// ServiceAccountCredentials Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
	ServiceAccountCredentials *string `json:"serviceAccountCredentials,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TopicName ID of the topic to send events to.
	TopicName string                 `json:"topicName"`
	Type      OutputGooglePubsubType `json:"type"`
}

// OutputGooglePubsubGoogleAuthMethod Google authentication method. Choose Auto to use Google Application Default Credentials.
type OutputGooglePubsubGoogleAuthMethod string

// OutputGooglePubsubOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputGooglePubsubOnBackpressure string

// OutputGooglePubsubPqCompress Codec to use to compress the persisted data.
type OutputGooglePubsubPqCompress string

// OutputGooglePubsubPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputGooglePubsubPqMode string

// OutputGooglePubsubPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputGooglePubsubPqOnBackpressure string

// OutputGooglePubsubType defines model for OutputGooglePubsub.Type.
type OutputGooglePubsubType string

// OutputGrafanaCloud defines model for OutputGrafanaCloud.
type OutputGrafanaCloud struct {
	// Compress Whether to compress the payload body before sending. Applies only to Loki's JSON payloads, as both Prometheus' and Loki's Protobuf variant are snappy-compressed by default.
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order.
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputGrafanaCloudFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// Labels List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}').
	Labels *[]struct {
		// Name Name of the label.
		Name string `json:"name"`

		// Value Value of the label.
		Value string `json:"value"`
	} `json:"labels,omitempty"`
	LokiAuth *struct {
		// AuthType The authentication method to use for the HTTP requests
		AuthType *OutputGrafanaCloudLokiAuthAuthType `json:"authType,omitempty"`

		// CredentialsSecret Select or create a secret that references your credentials
		CredentialsSecret *string `json:"credentialsSecret,omitempty"`

		// Password Password (a.k.a API key in Grafana Cloud domain) for authentication
		Password *string `json:"password,omitempty"`

		// TextSecret Select or create a stored text secret
		TextSecret *string `json:"textSecret,omitempty"`

		// Token Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
		Token *string `json:"token,omitempty"`

		// Username Username for authentication
		Username *string `json:"username,omitempty"`
	} `json:"lokiAuth,omitempty"`

	// LokiUrl The endpoint to send logs to, e.g.: https://logs-prod-us-central1.grafana.net
	LokiUrl *string `json:"lokiUrl,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Message Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
	Message *string `json:"message,omitempty"`

	// MessageFormat Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
	MessageFormat *OutputGrafanaCloudMessageFormat `json:"messageFormat,omitempty"`

	// MetricRenameExpr A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>.
	MetricRenameExpr *string `json:"metricRenameExpr,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputGrafanaCloudOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputGrafanaCloudPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}       `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputGrafanaCloudPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputGrafanaCloudPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath         *string `json:"pqPath,omitempty"`
	PrometheusAuth *struct {
		// AuthType The authentication method to use for the HTTP requests
		AuthType *OutputGrafanaCloudPrometheusAuthAuthType `json:"authType,omitempty"`

		// CredentialsSecret Select or create a secret that references your credentials
		CredentialsSecret *string `json:"credentialsSecret,omitempty"`

		// Password Password (a.k.a API key in Grafana Cloud domain) for authentication
		Password *string `json:"password,omitempty"`

		// TextSecret Select or create a stored text secret
		TextSecret *string `json:"textSecret,omitempty"`

		// Token Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
		Token *string `json:"token,omitempty"`

		// Username Username for authentication
		Username *string `json:"username,omitempty"`
	} `json:"prometheusAuth,omitempty"`

	// PrometheusUrl The remote_write endpoint to send Prometheus metrics to, e.g.: https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
	PrometheusUrl *string `json:"prometheusUrl,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32               `json:"timeoutSec,omitempty"`
	Type       OutputGrafanaCloudType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
	Union            json.RawMessage
}

// OutputGrafanaCloudFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputGrafanaCloudFailedRequestLoggingMode string

// OutputGrafanaCloudLokiAuthAuthType The authentication method to use for the HTTP requests
type OutputGrafanaCloudLokiAuthAuthType string

// OutputGrafanaCloudMessageFormat Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
type OutputGrafanaCloudMessageFormat string

// OutputGrafanaCloudOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputGrafanaCloudOnBackpressure string

// OutputGrafanaCloudPqCompress Codec to use to compress the persisted data.
type OutputGrafanaCloudPqCompress string

// OutputGrafanaCloudPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputGrafanaCloudPqMode string

// OutputGrafanaCloudPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputGrafanaCloudPqOnBackpressure string

// OutputGrafanaCloudPrometheusAuthAuthType The authentication method to use for the HTTP requests
type OutputGrafanaCloudPrometheusAuthAuthType string

// OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputGrafanaCloudTimeoutRetrySettingsTimeoutRetry bool

// OutputGrafanaCloudType defines model for OutputGrafanaCloud.Type.
type OutputGrafanaCloudType string

// OutputGrafanaCloud0 defines model for .
type OutputGrafanaCloud0 = interface{}

// OutputGrafanaCloud1 defines model for .
type OutputGrafanaCloud1 = interface{}

// OutputGraphite defines model for OutputGraphite.
type OutputGraphite struct {
	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Host The hostname of the destination.
	Host string `json:"host"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Mtu When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
	Mtu *float32 `json:"mtu,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputGraphiteOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Destination port.
	Port float32 `json:"port"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputGraphitePqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputGraphitePqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputGraphitePqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Protocol to use when communicating with the destination.
	Protocol OutputGraphiteProtocol `json:"protocol"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string             `json:"throttleRatePerSec,omitempty"`
	Type               *OutputGraphiteType `json:"type,omitempty"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputGraphiteOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputGraphiteOnBackpressure string

// OutputGraphitePqCompress Codec to use to compress the persisted data.
type OutputGraphitePqCompress string

// OutputGraphitePqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputGraphitePqMode string

// OutputGraphitePqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputGraphitePqOnBackpressure string

// OutputGraphiteProtocol Protocol to use when communicating with the destination.
type OutputGraphiteProtocol string

// OutputGraphiteType defines model for OutputGraphite.Type.
type OutputGraphiteType string

// OutputHoneycomb defines model for OutputHoneycomb.
type OutputHoneycomb struct {
	// AuthType Enter API key directly, or select a stored secret
	AuthType *OutputHoneycombAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// Dataset Name of the dataset to send events to – e.g., observability
	Dataset     string  `json:"dataset"`
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputHoneycombFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputHoneycombOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputHoneycombPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputHoneycombPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputHoneycombPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// Team Team API key where the dataset belongs
	Team *string `json:"team,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputHoneycombTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32            `json:"timeoutSec,omitempty"`
	Type       OutputHoneycombType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputHoneycombAuthType Enter API key directly, or select a stored secret
type OutputHoneycombAuthType string

// OutputHoneycombFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputHoneycombFailedRequestLoggingMode string

// OutputHoneycombOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputHoneycombOnBackpressure string

// OutputHoneycombPqCompress Codec to use to compress the persisted data.
type OutputHoneycombPqCompress string

// OutputHoneycombPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputHoneycombPqMode string

// OutputHoneycombPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputHoneycombPqOnBackpressure string

// OutputHoneycombTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputHoneycombTimeoutRetrySettingsTimeoutRetry bool

// OutputHoneycombType defines model for OutputHoneycomb.Type.
type OutputHoneycombType string

// OutputHumioHec defines model for OutputHumioHec.
type OutputHumioHec struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputHumioHecAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputHumioHecFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
	Format OutputHumioHecFormat `json:"format"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputHumioHecOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputHumioHecPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputHumioHecPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputHumioHecPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputHumioHecTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token CrowdStrike Falcon LogScale authentication token
	Token *string             `json:"token,omitempty"`
	Type  *OutputHumioHecType `json:"type,omitempty"`

	// Url URL to a CrowdStrike Falcon LogScale endpoint to send events to, e.g., https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputHumioHecAuthType Enter a token directly, or provide a secret referencing a token
type OutputHumioHecAuthType string

// OutputHumioHecFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputHumioHecFailedRequestLoggingMode string

// OutputHumioHecFormat When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent.
type OutputHumioHecFormat string

// OutputHumioHecOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputHumioHecOnBackpressure string

// OutputHumioHecPqCompress Codec to use to compress the persisted data.
type OutputHumioHecPqCompress string

// OutputHumioHecPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputHumioHecPqMode string

// OutputHumioHecPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputHumioHecPqOnBackpressure string

// OutputHumioHecTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputHumioHecTimeoutRetrySettingsTimeoutRetry bool

// OutputHumioHecType defines model for OutputHumioHec.Type.
type OutputHumioHecType string

// OutputInfluxdb defines model for OutputInfluxdb.
type OutputInfluxdb struct {
	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType InfluxDB authentication type
	AuthType *OutputInfluxdbAuthType `json:"authType,omitempty"`

	// Bucket Bucket to write to.
	Bucket *string `json:"bucket,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`

	// Database Database to write to.
	Database    *string `json:"database,omitempty"`
	Description *string `json:"description,omitempty"`

	// DynamicValueFieldName Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field.
	DynamicValueFieldName *bool `json:"dynamicValueFieldName,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputInfluxdbFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputInfluxdbOnBackpressure `json:"onBackpressure,omitempty"`

	// Org Organization ID for this bucket.
	Org *string `json:"org,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputInfluxdbPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputInfluxdbPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputInfluxdbPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputInfluxdbTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TimestampPrecision Sets the precision for the supplied Unix time values. Defaults to milliseconds.
	TimestampPrecision *OutputInfluxdbTimestampPrecision `json:"timestampPrecision,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32           `json:"tokenTimeoutSecs,omitempty"`
	Type             OutputInfluxdbType `json:"type"`

	// Url URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// UseV2API The v2 API can be enabled with InfluxDB versions 1.8 and later.
	UseV2API *OutputInfluxdbUseV2API `json:"useV2API,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`

	// ValueFieldName Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback.
	ValueFieldName *string `json:"valueFieldName,omitempty"`
}

// OutputInfluxdbAuthType InfluxDB authentication type
type OutputInfluxdbAuthType string

// OutputInfluxdbFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputInfluxdbFailedRequestLoggingMode string

// OutputInfluxdbOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputInfluxdbOnBackpressure string

// OutputInfluxdbPqCompress Codec to use to compress the persisted data.
type OutputInfluxdbPqCompress string

// OutputInfluxdbPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputInfluxdbPqMode string

// OutputInfluxdbPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputInfluxdbPqOnBackpressure string

// OutputInfluxdbTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputInfluxdbTimeoutRetrySettingsTimeoutRetry bool

// OutputInfluxdbTimestampPrecision Sets the precision for the supplied Unix time values. Defaults to milliseconds.
type OutputInfluxdbTimestampPrecision string

// OutputInfluxdbType defines model for OutputInfluxdb.Type.
type OutputInfluxdbType string

// OutputInfluxdbUseV2API The v2 API can be enabled with InfluxDB versions 1.8 and later.
type OutputInfluxdbUseV2API bool

// OutputKafka defines model for OutputKafka.
type OutputKafka struct {
	// Ack Control the number of required acknowledgments.
	Ack *OutputKafkaAck `json:"ack,omitempty"`

	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
	Brokers []string `json:"brokers"`

	// Compression Codec to use to compress the data before sending to Kafka
	Compression *OutputKafkaCompression `json:"compression,omitempty"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushEventCount The maximum number of events you want the Destination to allow in a batch before forcing a flush
	FlushEventCount *float32 `json:"flushEventCount,omitempty"`

	// FlushPeriodSec The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Format to use to serialize events before writing to Kafka.
	Format *OutputKafkaFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled OutputKafkaKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// DefaultKeySchemaId Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
		DefaultKeySchemaId *float32 `json:"defaultKeySchemaId,omitempty"`

		// DefaultValueSchemaId Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
		DefaultValueSchemaId *float32 `json:"defaultValueSchemaId,omitempty"`

		// Disabled Enable Schema Registry
		Disabled OutputKafkaKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                    `json:"certificateName,omitempty"`
			Disabled        *OutputKafkaKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *OutputKafkaKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *OutputKafkaKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxRecordSizeKB Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputKafkaOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputKafkaPqCompress  `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputKafkaPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputKafkaPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// ProtobufLibraryId Select a set of Protobuf definitions for the events you want to send
	ProtobufLibraryId *string `json:"protobufLibraryId,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// Sasl Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
	Sasl *struct {
		// Disabled Enable Authentication
		Disabled OutputKafkaSaslDisabled `json:"disabled"`

		// Mechanism SASL authentication mechanism to use.
		Mechanism *OutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`
	Tls          *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                 `json:"certificateName,omitempty"`
		Disabled        *OutputKafkaTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputKafkaTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputKafkaTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topic The topic to publish events to. Can be overridden using the __topicOut field.
	Topic string           `json:"topic"`
	Type  *OutputKafkaType `json:"type,omitempty"`
}

// OutputKafkaAck Control the number of required acknowledgments.
type OutputKafkaAck float32

// OutputKafkaCompression Codec to use to compress the data before sending to Kafka
type OutputKafkaCompression string

// OutputKafkaFormat Format to use to serialize events before writing to Kafka.
type OutputKafkaFormat string

// OutputKafkaKafkaSchemaRegistryAuthDisabled Enable authentication
type OutputKafkaKafkaSchemaRegistryAuthDisabled bool

// OutputKafkaKafkaSchemaRegistryDisabled Enable Schema Registry
type OutputKafkaKafkaSchemaRegistryDisabled bool

// OutputKafkaKafkaSchemaRegistryTlsDisabled defines model for OutputKafka.KafkaSchemaRegistry.Tls.Disabled.
type OutputKafkaKafkaSchemaRegistryTlsDisabled bool

// OutputKafkaKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type OutputKafkaKafkaSchemaRegistryTlsMaxVersion string

// OutputKafkaKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type OutputKafkaKafkaSchemaRegistryTlsMinVersion string

// OutputKafkaOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputKafkaOnBackpressure string

// OutputKafkaPqCompress Codec to use to compress the persisted data.
type OutputKafkaPqCompress string

// OutputKafkaPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputKafkaPqMode string

// OutputKafkaPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputKafkaPqOnBackpressure string

// OutputKafkaSaslDisabled Enable Authentication
type OutputKafkaSaslDisabled bool

// OutputKafkaSaslMechanism SASL authentication mechanism to use.
type OutputKafkaSaslMechanism string

// OutputKafkaTlsDisabled defines model for OutputKafka.Tls.Disabled.
type OutputKafkaTlsDisabled bool

// OutputKafkaTlsMaxVersion Maximum TLS version to use when connecting
type OutputKafkaTlsMaxVersion string

// OutputKafkaTlsMinVersion Minimum TLS version to use when connecting
type OutputKafkaTlsMinVersion string

// OutputKafkaType defines model for OutputKafka.Type.
type OutputKafkaType string

// OutputKinesis defines model for OutputKinesis.
type OutputKinesis struct {
	// AsNdjson Batch events into a single record as NDJSON
	AsNdjson *bool `json:"asNdjson,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputKinesisAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// Compression Compression type to use for records
	Compression *OutputKinesisCompression `json:"compression,omitempty"`

	// Concurrency Maximum number of ongoing put requests before blocking.
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access Kinesis stream
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint Kinesis stream service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxRecordSizeKB Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputKinesisOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputKinesisPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputKinesisPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputKinesisPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Region where the Kinesis stream is located
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SignatureVersion Signature version to use for signing Kinesis stream requests
	SignatureVersion *OutputKinesisSignatureVersion `json:"signatureVersion,omitempty"`

	// StreamName Kinesis stream name to send events to.
	StreamName string `json:"streamName"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string          `json:"systemFields,omitempty"`
	Type         *OutputKinesisType `json:"type,omitempty"`
}

// OutputKinesisAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputKinesisAwsAuthenticationMethod string

// OutputKinesisCompression Compression type to use for records
type OutputKinesisCompression string

// OutputKinesisOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputKinesisOnBackpressure string

// OutputKinesisPqCompress Codec to use to compress the persisted data.
type OutputKinesisPqCompress string

// OutputKinesisPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputKinesisPqMode string

// OutputKinesisPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputKinesisPqOnBackpressure string

// OutputKinesisSignatureVersion Signature version to use for signing Kinesis stream requests
type OutputKinesisSignatureVersion string

// OutputKinesisType defines model for OutputKinesis.Type.
type OutputKinesisType string

// OutputLoki defines model for OutputLoki.
type OutputLoki struct {
	// AuthType The authentication method to use for the HTTP requests
	AuthType *OutputLokiAuthType `json:"authType,omitempty"`

	// Compress Whether to compress the payload body before sending.
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order.
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputLokiFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Labels List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}').
	Labels *[]struct {
		// Name Name of the label.
		Name string `json:"name"`

		// Value Value of the label.
		Value string `json:"value"`
	} `json:"labels,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order.
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Message Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
	Message *string `json:"message,omitempty"`

	// MessageFormat Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
	MessageFormat *OutputLokiMessageFormat `json:"messageFormat,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputLokiOnBackpressure `json:"onBackpressure,omitempty"`

	// Password Password (a.k.a API key in Grafana Cloud domain) for authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputLokiPqCompress   `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputLokiPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputLokiPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputLokiTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
	Token *string `json:"token,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32       `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputLokiType `json:"type"`

	// Url The endpoint to send logs to.
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for authentication
	Username *string `json:"username,omitempty"`
}

// OutputLokiAuthType The authentication method to use for the HTTP requests
type OutputLokiAuthType string

// OutputLokiFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputLokiFailedRequestLoggingMode string

// OutputLokiMessageFormat Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
type OutputLokiMessageFormat string

// OutputLokiOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputLokiOnBackpressure string

// OutputLokiPqCompress Codec to use to compress the persisted data.
type OutputLokiPqCompress string

// OutputLokiPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputLokiPqMode string

// OutputLokiPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputLokiPqOnBackpressure string

// OutputLokiTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputLokiTimeoutRetrySettingsTimeoutRetry bool

// OutputLokiType defines model for OutputLoki.Type.
type OutputLokiType string

// OutputMinio defines model for OutputMinio.
type OutputMinio struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// AwsApiKey Access key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_ACCESS_KEY}`).
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputMinioAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_SECRET}`).
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. E.g. referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputMinioCompress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputMinioCompressionLevel `json:"compressionLevel,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputMinioDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Root directory to prepend to path before uploading. Enter a constant, or a JS expression enclosed in quotes or backticks.
	DestPath *string `json:"destPath,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Endpoint MinIO service url (e.g. http://minioHost:9000)
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputMinioFormat `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputMinioObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputMinioOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputMinioOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputMinioParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputMinioParquetVersion `json:"parquetVersion,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the MinIO service/cluster is located
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputMinioRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Whether to reuse connections between requests, which can improve performance.
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ServerSideEncryption Server-side encryption for uploaded objects.
	ServerSideEncryption *OutputMinioServerSideEncryption `json:"serverSideEncryption,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// SignatureVersion Signature version to use for signing MinIO requests.
	SignatureVersion *OutputMinioSignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputMinioStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string        `json:"systemFields,omitempty"`
	Type         *OutputMinioType `json:"type,omitempty"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputMinioAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputMinioAwsAuthenticationMethod string

// OutputMinioCompress Choose data compression format to apply before moving files to final destination
type OutputMinioCompress string

// OutputMinioCompressionLevel Compression level to apply before moving files to final destination
type OutputMinioCompressionLevel string

// OutputMinioDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputMinioDeadletterEnabled bool

// OutputMinioFormat Format of the output data
type OutputMinioFormat string

// OutputMinioObjectACL Object ACL to assign to uploaded objects.
type OutputMinioObjectACL string

// OutputMinioOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputMinioOnBackpressure string

// OutputMinioOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputMinioOnDiskFullBackpressure string

// OutputMinioParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputMinioParquetDataPageVersion string

// OutputMinioParquetVersion Determines which data types are supported and how they are represented
type OutputMinioParquetVersion string

// OutputMinioRemoveEmptyDirs Remove empty staging directories after moving files
type OutputMinioRemoveEmptyDirs bool

// OutputMinioServerSideEncryption Server-side encryption for uploaded objects.
type OutputMinioServerSideEncryption string

// OutputMinioSignatureVersion Signature version to use for signing MinIO requests.
type OutputMinioSignatureVersion string

// OutputMinioStorageClass Storage class to select for uploaded objects.
type OutputMinioStorageClass string

// OutputMinioType defines model for OutputMinio.Type.
type OutputMinioType string

// OutputMsk defines model for OutputMsk.
type OutputMsk struct {
	// Ack Control the number of required acknowledgments.
	Ack *OutputMskAck `json:"ack,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AuthenticationTimeout Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *float32 `json:"authenticationTimeout,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod OutputMskAwsAuthenticationMethod `json:"awsAuthenticationMethod"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BackoffRate Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
	BackoffRate *float32 `json:"backoffRate,omitempty"`

	// Brokers Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
	Brokers []string `json:"brokers"`

	// Compression Codec to use to compress the data before sending to Kafka
	Compression *OutputMskCompression `json:"compression,omitempty"`

	// ConnectionTimeout Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint MSK cluster service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushEventCount The maximum number of events you want the Destination to allow in a batch before forcing a flush
	FlushEventCount *float32 `json:"flushEventCount,omitempty"`

	// FlushPeriodSec The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Format to use to serialize events before writing to Kafka.
	Format *OutputMskFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// InitialBackoff Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
	InitialBackoff      *float32 `json:"initialBackoff,omitempty"`
	KafkaSchemaRegistry *struct {
		// Auth Credentials to use when authenticating with the schema registry using basic HTTP authentication
		Auth *struct {
			// CredentialsSecret Select or create a secret that references your credentials
			CredentialsSecret *string `json:"credentialsSecret,omitempty"`

			// Disabled Enable authentication
			Disabled OutputMskKafkaSchemaRegistryAuthDisabled `json:"disabled"`
		} `json:"auth,omitempty"`

		// ConnectionTimeout Maximum time to wait for a Schema Registry connection to complete successfully
		ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

		// DefaultKeySchemaId Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
		DefaultKeySchemaId *float32 `json:"defaultKeySchemaId,omitempty"`

		// DefaultValueSchemaId Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
		DefaultValueSchemaId *float32 `json:"defaultValueSchemaId,omitempty"`

		// Disabled Enable Schema Registry
		Disabled OutputMskKafkaSchemaRegistryDisabled `json:"disabled"`

		// MaxRetries Maximum number of times to try fetching schemas from the Schema Registry
		MaxRetries *float32 `json:"maxRetries,omitempty"`

		// RequestTimeout Maximum time to wait for the Schema Registry to respond to a request
		RequestTimeout *float32 `json:"requestTimeout,omitempty"`

		// SchemaRegistryURL URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
		SchemaRegistryURL *string `json:"schemaRegistryURL,omitempty"`
		Tls               *struct {
			// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
			CaPath *string `json:"caPath,omitempty"`

			// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
			CertPath *string `json:"certPath,omitempty"`

			// CertificateName The name of the predefined certificate.
			CertificateName *string                                  `json:"certificateName,omitempty"`
			Disabled        *OutputMskKafkaSchemaRegistryTlsDisabled `json:"disabled,omitempty"`

			// MaxVersion Maximum TLS version to use when connecting
			MaxVersion *OutputMskKafkaSchemaRegistryTlsMaxVersion `json:"maxVersion,omitempty"`

			// MinVersion Minimum TLS version to use when connecting
			MinVersion *OutputMskKafkaSchemaRegistryTlsMinVersion `json:"minVersion,omitempty"`

			// Passphrase Passphrase to use to decrypt private key.
			Passphrase *string `json:"passphrase,omitempty"`

			// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
			PrivKeyPath *string `json:"privKeyPath,omitempty"`

			// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
			//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
			RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

			// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
			Servername *string `json:"servername,omitempty"`
		} `json:"tls,omitempty"`
	} `json:"kafkaSchemaRegistry,omitempty"`

	// MaxBackOff The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
	MaxBackOff *float32 `json:"maxBackOff,omitempty"`

	// MaxRecordSizeKB Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// MaxRetries If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputMskOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputMskPqCompress    `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputMskPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputMskPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// ProtobufLibraryId Select a set of Protobuf definitions for the events you want to send
	ProtobufLibraryId *string `json:"protobufLibraryId,omitempty"`

	// ReauthenticationThreshold Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *float32 `json:"reauthenticationThreshold,omitempty"`

	// Region Region where the MSK cluster is located
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RequestTimeout Maximum time to wait for Kafka to respond to a request
	RequestTimeout *float32 `json:"requestTimeout,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SignatureVersion Signature version to use for signing MSK cluster requests
	SignatureVersion *OutputMskSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`
	Tls          *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string               `json:"certificateName,omitempty"`
		Disabled        *OutputMskTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputMskTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputMskTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Topic The topic to publish events to. Can be overridden using the __topicOut field.
	Topic string         `json:"topic"`
	Type  *OutputMskType `json:"type,omitempty"`
}

// OutputMskAck Control the number of required acknowledgments.
type OutputMskAck float32

// OutputMskAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputMskAwsAuthenticationMethod string

// OutputMskCompression Codec to use to compress the data before sending to Kafka
type OutputMskCompression string

// OutputMskFormat Format to use to serialize events before writing to Kafka.
type OutputMskFormat string

// OutputMskKafkaSchemaRegistryAuthDisabled Enable authentication
type OutputMskKafkaSchemaRegistryAuthDisabled bool

// OutputMskKafkaSchemaRegistryDisabled Enable Schema Registry
type OutputMskKafkaSchemaRegistryDisabled bool

// OutputMskKafkaSchemaRegistryTlsDisabled defines model for OutputMsk.KafkaSchemaRegistry.Tls.Disabled.
type OutputMskKafkaSchemaRegistryTlsDisabled bool

// OutputMskKafkaSchemaRegistryTlsMaxVersion Maximum TLS version to use when connecting
type OutputMskKafkaSchemaRegistryTlsMaxVersion string

// OutputMskKafkaSchemaRegistryTlsMinVersion Minimum TLS version to use when connecting
type OutputMskKafkaSchemaRegistryTlsMinVersion string

// OutputMskOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputMskOnBackpressure string

// OutputMskPqCompress Codec to use to compress the persisted data.
type OutputMskPqCompress string

// OutputMskPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputMskPqMode string

// OutputMskPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputMskPqOnBackpressure string

// OutputMskSignatureVersion Signature version to use for signing MSK cluster requests
type OutputMskSignatureVersion string

// OutputMskTlsDisabled defines model for OutputMsk.Tls.Disabled.
type OutputMskTlsDisabled bool

// OutputMskTlsMaxVersion Maximum TLS version to use when connecting
type OutputMskTlsMaxVersion string

// OutputMskTlsMinVersion Minimum TLS version to use when connecting
type OutputMskTlsMinVersion string

// OutputMskType defines model for OutputMsk.Type.
type OutputMskType string

// OutputNetflow defines model for OutputNetflow.
type OutputNetflow struct {
	Description *string `json:"description,omitempty"`

	// DnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Hosts One or more NetFlow destinations to forward events to
	Hosts []struct {
		// Host Destination host
		Host string `json:"host"`

		// Port Destination port, default is 2055
		Port float32 `json:"port"`
	} `json:"hosts"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string         `json:"systemFields,omitempty"`
	Type         OutputNetflowType `json:"type"`
}

// OutputNetflowType defines model for OutputNetflow.Type.
type OutputNetflowType string

// OutputNewrelic defines model for OutputNewrelic.
type OutputNewrelic struct {
	// ApiKey New Relic API key. Can be overridden using __newRelic_apiKey field.
	ApiKey *string `json:"apiKey,omitempty"`

	// AuthType Enter API key directly, or select a stored secret
	AuthType *OutputNewrelicAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	CustomUrl   *string  `json:"customUrl,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputNewrelicFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LogType Name of the logtype to send with events, e.g.: observability, access_log. The event's 'sourcetype' field (if set) will override this value.
	LogType *string `json:"logType,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// MessageField Name of field to send as log message value. If not present, event will be serialized and sent as JSON.
	MessageField *string `json:"messageField,omitempty"`

	// Metadata Fields to add to events from this input
	Metadata *[]struct {
		// Name Field name
		Name OutputNewrelicMetadataName `json:"name"`

		// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputNewrelicOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputNewrelicPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputNewrelicPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputNewrelicPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Which New Relic region endpoint to use.
	Region *OutputNewrelicRegion `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputNewrelicTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32           `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputNewrelicType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputNewrelicAuthType Enter API key directly, or select a stored secret
type OutputNewrelicAuthType string

// OutputNewrelicFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputNewrelicFailedRequestLoggingMode string

// OutputNewrelicMetadataName Field name
type OutputNewrelicMetadataName string

// OutputNewrelicOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputNewrelicOnBackpressure string

// OutputNewrelicPqCompress Codec to use to compress the persisted data.
type OutputNewrelicPqCompress string

// OutputNewrelicPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputNewrelicPqMode string

// OutputNewrelicPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputNewrelicPqOnBackpressure string

// OutputNewrelicRegion Which New Relic region endpoint to use.
type OutputNewrelicRegion string

// OutputNewrelicTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputNewrelicTimeoutRetrySettingsTimeoutRetry bool

// OutputNewrelicType defines model for OutputNewrelic.Type.
type OutputNewrelicType string

// OutputNewrelicEvents defines model for OutputNewrelicEvents.
type OutputNewrelicEvents struct {
	// AccountId New Relic account ID
	AccountId string `json:"accountId"`

	// ApiKey New Relic API key. Can be overridden using __newRelic_apiKey field.
	ApiKey *string `json:"apiKey,omitempty"`

	// AuthType Enter API key directly, or select a stored secret
	AuthType *OutputNewrelicEventsAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	CustomUrl   *string  `json:"customUrl,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// EventType Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
	EventType string `json:"eventType"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputNewrelicEventsFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputNewrelicEventsOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputNewrelicEventsPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}         `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputNewrelicEventsPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputNewrelicEventsPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Which New Relic region endpoint to use.
	Region *OutputNewrelicEventsRegion `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32                  `json:"timeoutSec,omitempty"`
	Type       *OutputNewrelicEventsType `json:"type,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputNewrelicEventsAuthType Enter API key directly, or select a stored secret
type OutputNewrelicEventsAuthType string

// OutputNewrelicEventsFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputNewrelicEventsFailedRequestLoggingMode string

// OutputNewrelicEventsOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputNewrelicEventsOnBackpressure string

// OutputNewrelicEventsPqCompress Codec to use to compress the persisted data.
type OutputNewrelicEventsPqCompress string

// OutputNewrelicEventsPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputNewrelicEventsPqMode string

// OutputNewrelicEventsPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputNewrelicEventsPqOnBackpressure string

// OutputNewrelicEventsRegion Which New Relic region endpoint to use.
type OutputNewrelicEventsRegion string

// OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputNewrelicEventsTimeoutRetrySettingsTimeoutRetry bool

// OutputNewrelicEventsType defines model for OutputNewrelicEvents.Type.
type OutputNewrelicEventsType string

// OutputOpenTelemetry defines model for OutputOpenTelemetry.
type OutputOpenTelemetry struct {
	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType OpenTelemetry authentication type
	AuthType *OutputOpenTelemetryAuthType `json:"authType,omitempty"`

	// Compress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	Compress *OutputOpenTelemetryCompress `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// Endpoint The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used.
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputOpenTelemetryFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// HttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	HttpCompress *OutputOpenTelemetryHttpCompress `json:"httpCompress,omitempty"`

	// HttpLogsEndpointOverride If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpLogsEndpointOverride *string `json:"httpLogsEndpointOverride,omitempty"`

	// HttpMetricsEndpointOverride If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpMetricsEndpointOverride *string `json:"httpMetricsEndpointOverride,omitempty"`

	// HttpTracesEndpointOverride If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpTracesEndpointOverride *string `json:"httpTracesEndpointOverride,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// KeepAliveTime How often the sender should ping the peer to keep the connection open
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Metadata List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
	Metadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputOpenTelemetryOnBackpressure `json:"onBackpressure,omitempty"`

	// OtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
	OtlpVersion *OutputOpenTelemetryOtlpVersion `json:"otlpVersion,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputOpenTelemetryPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}        `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputOpenTelemetryPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputOpenTelemetryPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Select a transport option for OpenTelemetry
	Protocol *OutputOpenTelemetryProtocol `json:"protocol,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                         `json:"certificateName,omitempty"`
		Disabled        *OutputOpenTelemetryTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputOpenTelemetryTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputOpenTelemetryTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32                `json:"tokenTimeoutSecs,omitempty"`
	Type             OutputOpenTelemetryType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// OutputOpenTelemetryAuthType OpenTelemetry authentication type
type OutputOpenTelemetryAuthType string

// OutputOpenTelemetryCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputOpenTelemetryCompress string

// OutputOpenTelemetryFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputOpenTelemetryFailedRequestLoggingMode string

// OutputOpenTelemetryHttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputOpenTelemetryHttpCompress string

// OutputOpenTelemetryOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputOpenTelemetryOnBackpressure string

// OutputOpenTelemetryOtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
type OutputOpenTelemetryOtlpVersion string

// OutputOpenTelemetryPqCompress Codec to use to compress the persisted data.
type OutputOpenTelemetryPqCompress string

// OutputOpenTelemetryPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputOpenTelemetryPqMode string

// OutputOpenTelemetryPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputOpenTelemetryPqOnBackpressure string

// OutputOpenTelemetryProtocol Select a transport option for OpenTelemetry
type OutputOpenTelemetryProtocol string

// OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputOpenTelemetryTimeoutRetrySettingsTimeoutRetry bool

// OutputOpenTelemetryTlsDisabled defines model for OutputOpenTelemetry.Tls.Disabled.
type OutputOpenTelemetryTlsDisabled bool

// OutputOpenTelemetryTlsMaxVersion Maximum TLS version to use when connecting
type OutputOpenTelemetryTlsMaxVersion string

// OutputOpenTelemetryTlsMinVersion Minimum TLS version to use when connecting
type OutputOpenTelemetryTlsMinVersion string

// OutputOpenTelemetryType defines model for OutputOpenTelemetry.Type.
type OutputOpenTelemetryType string

// OutputPrometheus defines model for OutputPrometheus.
type OutputPrometheus struct {
	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType Remote Write authentication type
	AuthType *OutputPrometheusAuthType `json:"authType,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	Description       *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputPrometheusFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// MetricRenameExpr A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>.
	MetricRenameExpr *string `json:"metricRenameExpr,omitempty"`

	// MetricsFlushPeriodSec How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period (sec) set above.
	MetricsFlushPeriodSec *float32 `json:"metricsFlushPeriodSec,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputPrometheusOnBackpressure `json:"onBackpressure,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputPrometheusPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}     `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputPrometheusPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputPrometheusPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`

	// SendMetadata Whether to generate and send metadata (`type` and `metricFamilyName`) requests.
	SendMetadata *OutputPrometheusSendMetadata `json:"sendMetadata,omitempty"`
	Spacer       *string                       `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputPrometheusTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32             `json:"tokenTimeoutSecs,omitempty"`
	Type             OutputPrometheusType `json:"type"`

	// Url The endpoint to send metrics to.
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// OutputPrometheusAuthType Remote Write authentication type
type OutputPrometheusAuthType string

// OutputPrometheusFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputPrometheusFailedRequestLoggingMode string

// OutputPrometheusOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputPrometheusOnBackpressure string

// OutputPrometheusPqCompress Codec to use to compress the persisted data.
type OutputPrometheusPqCompress string

// OutputPrometheusPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputPrometheusPqMode string

// OutputPrometheusPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputPrometheusPqOnBackpressure string

// OutputPrometheusSendMetadata Whether to generate and send metadata (`type` and `metricFamilyName`) requests.
type OutputPrometheusSendMetadata bool

// OutputPrometheusTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputPrometheusTimeoutRetrySettingsTimeoutRetry bool

// OutputPrometheusType defines model for OutputPrometheus.Type.
type OutputPrometheusType string

// OutputRing defines model for OutputRing.
type OutputRing struct {
	// Compress Select data compression format. Optional.
	Compress    *OutputRingCompress `json:"compress,omitempty"`
	Description *string             `json:"description,omitempty"`

	// DestPath Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
	DestPath *string `json:"destPath,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Format Format of the output data.
	Format *OutputRingFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// MaxDataSize Maximum disk space allowed to be consumed (e.g., 420MB or 4GB). Once reached, older data will be deleted.
	MaxDataSize *string `json:"maxDataSize,omitempty"`

	// MaxDataTime Maximum amount of time to retain data (e.g., 2h or 4d). Once reached, older data will be deleted.
	MaxDataTime *string `json:"maxDataTime,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputRingOnBackpressure `json:"onBackpressure,omitempty"`

	// PartitionExpr JS expression to define how files are partitioned and organized. If left blank, Cribl Stream will fallback on event.__partition.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string      `json:"systemFields,omitempty"`
	Type         OutputRingType `json:"type"`
}

// OutputRingCompress Select data compression format. Optional.
type OutputRingCompress string

// OutputRingFormat Format of the output data.
type OutputRingFormat string

// OutputRingOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputRingOnBackpressure string

// OutputRingType defines model for OutputRing.Type.
type OutputRingType string

// OutputRouter defines model for OutputRouter.
type OutputRouter struct {
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Rules Event routing rules
	Rules []struct {
		// Description Description of this rule's purpose
		Description *string `json:"description,omitempty"`

		// Filter JavaScript expression to select events to send to output
		Filter string `json:"filter"`

		// Final Flag to control whether to stop the event from being checked against other rules
		Final *bool `json:"final,omitempty"`

		// Output Output to send matching events to
		Output string `json:"output"`
	} `json:"rules"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string        `json:"systemFields,omitempty"`
	Type         OutputRouterType `json:"type"`
}

// OutputRouterType defines model for OutputRouter.Type.
type OutputRouterType string

// OutputS3 defines model for OutputS3.
type OutputS3 struct {
	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *bool `json:"automaticSchema,omitempty"`

	// AwsApiKey Access key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_ACCESS_KEY}`).
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputS3AwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_SECRET}`).
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// Compress Choose data compression format to apply before moving files to final destination
	Compress *OutputS3Compress `json:"compress,omitempty"`

	// CompressionLevel Compression level to apply before moving files to final destination
	CompressionLevel *OutputS3CompressionLevel `json:"compressionLevel,omitempty"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputS3DeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DestPath Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`.
	DestPath *string `json:"destPath,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Endpoint S3 service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FileNameSuffix JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`).
	FileNameSuffix *string `json:"fileNameSuffix,omitempty"`

	// Format Format of the output data
	Format *OutputS3Format `json:"format,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// KmsKeyId ID or ARN of the KMS customer-managed key to use for encryption
	KmsKeyId *string `json:"kmsKeyId,omitempty"`

	// MaxClosingFilesToBackpressure Maximum number of files that can be waiting for upload before backpressure is applied
	MaxClosingFilesToBackpressure *float32 `json:"maxClosingFilesToBackpressure,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputS3ObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputS3OnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputS3OnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputS3ParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputS3ParquetVersion `json:"parquetVersion,omitempty"`

	// PartitionExpr JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory.
	PartitionExpr *string `json:"partitionExpr,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the S3 bucket is located.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputS3RemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ServerSideEncryption Server-side encryption for uploaded objects.
	ServerSideEncryption *OutputS3ServerSideEncryption `json:"serverSideEncryption,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// SignatureVersion Signature version to use for signing S3 requests
	SignatureVersion *OutputS3SignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputS3StorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string     `json:"systemFields,omitempty"`
	Type         *OutputS3Type `json:"type,omitempty"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputS3AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputS3AwsAuthenticationMethod string

// OutputS3Compress Choose data compression format to apply before moving files to final destination
type OutputS3Compress string

// OutputS3CompressionLevel Compression level to apply before moving files to final destination
type OutputS3CompressionLevel string

// OutputS3DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputS3DeadletterEnabled bool

// OutputS3Format Format of the output data
type OutputS3Format string

// OutputS3ObjectACL Object ACL to assign to uploaded objects.
type OutputS3ObjectACL string

// OutputS3OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputS3OnBackpressure string

// OutputS3OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputS3OnDiskFullBackpressure string

// OutputS3ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputS3ParquetDataPageVersion string

// OutputS3ParquetVersion Determines which data types are supported and how they are represented
type OutputS3ParquetVersion string

// OutputS3RemoveEmptyDirs Remove empty staging directories after moving files
type OutputS3RemoveEmptyDirs bool

// OutputS3ServerSideEncryption Server-side encryption for uploaded objects.
type OutputS3ServerSideEncryption string

// OutputS3SignatureVersion Signature version to use for signing S3 requests
type OutputS3SignatureVersion string

// OutputS3StorageClass Storage class to select for uploaded objects.
type OutputS3StorageClass string

// OutputS3Type defines model for OutputS3.Type.
type OutputS3Type string

// OutputSamplesResponse defines model for OutputSamplesResponse.
type OutputSamplesResponse struct {
	Events []map[string]interface{} `json:"events"`
}

// OutputSecurityLake defines model for OutputSecurityLake.
type OutputSecurityLake struct {
	// AccountId ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source.
	AccountId string `json:"accountId"`

	// AddIdToStagePath Append output's ID to staging location
	AddIdToStagePath *bool `json:"addIdToStagePath,omitempty"`

	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn string `json:"assumeRoleArn"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
	AutomaticSchema *OutputSecurityLakeAutomaticSchema `json:"automaticSchema,omitempty"`

	// AwsApiKey Access key. This value can be a constant or a JavaScript expression(e.g., `${C.env.SOME_ACCESS_KEY}`).
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputSecurityLakeAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// BaseFileName JavaScript expression to define the output filename prefix (can be constant)
	BaseFileName *string `json:"baseFileName,omitempty"`

	// Bucket Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `myBucket-${C.vars.myVar}`.
	Bucket string `json:"bucket"`

	// CustomSource Name of the custom source configured in Amazon Security Lake
	CustomSource string `json:"customSource"`

	// DeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
	DeadletterEnabled *OutputSecurityLakeDeadletterEnabled `json:"deadletterEnabled,omitempty"`

	// DeadletterPath Storage location for files that fail to reach their final destination after maximum retries are exceeded
	DeadletterPath *string `json:"deadletterPath,omitempty"`
	Description    *string `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EmptyDirCleanupSec How frequently, in seconds, to clean up empty directories when 'Remove empty staging dirs' is enabled
	EmptyDirCleanupSec *float32 `json:"emptyDirCleanupSec,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access S3
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// EnablePageChecksum Parquet tools can use the checksum of a Parquet page to verify data integrity
	EnablePageChecksum *bool `json:"enablePageChecksum,omitempty"`

	// EnableStatistics Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics.
	EnableStatistics *bool `json:"enableStatistics,omitempty"`

	// EnableWritePageIndex One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping.
	EnableWritePageIndex *bool `json:"enableWritePageIndex,omitempty"`

	// Endpoint Amazon Security Lake service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// HeaderLine If set, this line will be written to the beginning of each output file
	HeaderLine *string `json:"headerLine,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeyValueMetadata The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging, e.g., "key":"OCSF Event Class", "value":"9001".
	KeyValueMetadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"keyValueMetadata,omitempty"`

	// KmsKeyId ID or ARN of the KMS customer-managed key to use for encryption
	KmsKeyId *string `json:"kmsKeyId,omitempty"`

	// MaxClosingFilesToBackpressure Maximum number of files that can be waiting for upload before backpressure is applied
	MaxClosingFilesToBackpressure *float32 `json:"maxClosingFilesToBackpressure,omitempty"`

	// MaxConcurrentFileParts Maximum number of parts to upload in parallel per file. Minimum part size is 5MB.
	MaxConcurrentFileParts *float32 `json:"maxConcurrentFileParts,omitempty"`

	// MaxFileIdleTimeSec Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location.
	MaxFileIdleTimeSec *float32 `json:"maxFileIdleTimeSec,omitempty"`

	// MaxFileOpenTimeSec Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location.
	MaxFileOpenTimeSec *float32 `json:"maxFileOpenTimeSec,omitempty"`

	// MaxFileSizeMB Maximum uncompressed output file size. Files of this size will be closed and moved to final output location.
	MaxFileSizeMB *float32 `json:"maxFileSizeMB,omitempty"`

	// MaxOpenFiles Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location.
	MaxOpenFiles *float32 `json:"maxOpenFiles,omitempty"`

	// MaxRetryNum The maximum number of times a file will attempt to move to its final destination before being dead-lettered
	MaxRetryNum *float32 `json:"maxRetryNum,omitempty"`

	// ObjectACL Object ACL to assign to uploaded objects.
	ObjectACL *OutputSecurityLakeObjectACL `json:"objectACL,omitempty"`

	// OnBackpressure Whether to block or drop events when all receivers are exerting backpressure
	OnBackpressure *OutputSecurityLakeOnBackpressure `json:"onBackpressure,omitempty"`

	// OnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
	OnDiskFullBackpressure *OutputSecurityLakeOnDiskFullBackpressure `json:"onDiskFullBackpressure,omitempty"`

	// ParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
	ParquetDataPageVersion *OutputSecurityLakeParquetDataPageVersion `json:"parquetDataPageVersion,omitempty"`

	// ParquetPageSize Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression.
	ParquetPageSize *string `json:"parquetPageSize,omitempty"`

	// ParquetRowGroupLength The number of rows that every group will contain. The final group can contain a smaller number of rows.
	ParquetRowGroupLength *float32 `json:"parquetRowGroupLength,omitempty"`

	// ParquetVersion Determines which data types are supported and how they are represented
	ParquetVersion *OutputSecurityLakeParquetVersion `json:"parquetVersion,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Region Region where the Amazon Security Lake is located.
	Region string `json:"region"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// RemoveEmptyDirs Remove empty staging directories after moving files
	RemoveEmptyDirs *OutputSecurityLakeRemoveEmptyDirs `json:"removeEmptyDirs,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// ServerSideEncryption Server-side encryption for uploaded objects.
	ServerSideEncryption *OutputSecurityLakeServerSideEncryption `json:"serverSideEncryption,omitempty"`

	// ShouldLogInvalidRows Log up to 3 rows that @{product} skips due to data mismatch
	ShouldLogInvalidRows *bool `json:"shouldLogInvalidRows,omitempty"`

	// SignatureVersion Signature version to use for signing Amazon Security Lake requests
	SignatureVersion *OutputSecurityLakeSignatureVersion `json:"signatureVersion,omitempty"`

	// StagePath Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage.
	StagePath string `json:"stagePath"`

	// StorageClass Storage class to select for uploaded objects.
	StorageClass *OutputSecurityLakeStorageClass `json:"storageClass,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively.
	SystemFields *[]string               `json:"systemFields,omitempty"`
	Type         *OutputSecurityLakeType `json:"type,omitempty"`

	// VerifyPermissions Disable if you can access files within the bucket but not the bucket itself.
	VerifyPermissions *bool `json:"verifyPermissions,omitempty"`

	// WriteHighWaterMark Buffer size used to write to a file
	WriteHighWaterMark *float32 `json:"writeHighWaterMark,omitempty"`
}

// OutputSecurityLakeAutomaticSchema Automatically calculate the schema based on the events of each Parquet file generated
type OutputSecurityLakeAutomaticSchema bool

// OutputSecurityLakeAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputSecurityLakeAwsAuthenticationMethod string

// OutputSecurityLakeDeadletterEnabled If a file fails to move to its final destination after the maximum number of retries, dead-letter it to prevent further errors.
type OutputSecurityLakeDeadletterEnabled bool

// OutputSecurityLakeObjectACL Object ACL to assign to uploaded objects.
type OutputSecurityLakeObjectACL string

// OutputSecurityLakeOnBackpressure Whether to block or drop events when all receivers are exerting backpressure
type OutputSecurityLakeOnBackpressure string

// OutputSecurityLakeOnDiskFullBackpressure Whether to block or drop events when disk space is below the global 'Min free disk space' limit
type OutputSecurityLakeOnDiskFullBackpressure string

// OutputSecurityLakeParquetDataPageVersion Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it.
type OutputSecurityLakeParquetDataPageVersion string

// OutputSecurityLakeParquetVersion Determines which data types are supported and how they are represented
type OutputSecurityLakeParquetVersion string

// OutputSecurityLakeRemoveEmptyDirs Remove empty staging directories after moving files
type OutputSecurityLakeRemoveEmptyDirs bool

// OutputSecurityLakeServerSideEncryption Server-side encryption for uploaded objects.
type OutputSecurityLakeServerSideEncryption string

// OutputSecurityLakeSignatureVersion Signature version to use for signing Amazon Security Lake requests
type OutputSecurityLakeSignatureVersion string

// OutputSecurityLakeStorageClass Storage class to select for uploaded objects.
type OutputSecurityLakeStorageClass string

// OutputSecurityLakeType defines model for OutputSecurityLake.Type.
type OutputSecurityLakeType string

// OutputSentinel defines model for OutputSentinel.
type OutputSentinel struct {
	// AdvancedContentType HTTP content-type header value
	AdvancedContentType *string      `json:"advancedContentType,omitempty"`
	AuthType            *interface{} `json:"authType,omitempty"`

	// ClientId JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
	ClientId string `json:"client_id"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CustomContentType Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
	CustomContentType *string `json:"customContentType,omitempty"`

	// CustomDropWhenNull Whether to drop events when the source expression evaluates to null
	CustomDropWhenNull *bool `json:"customDropWhenNull,omitempty"`

	// CustomEventDelimiter Delimiter string to insert between individual events. Defaults to newline character.
	CustomEventDelimiter *string `json:"customEventDelimiter,omitempty"`

	// CustomPayloadExpression Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
	CustomPayloadExpression *string `json:"customPayloadExpression,omitempty"`

	// CustomSourceExpression Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
	CustomSourceExpression *string `json:"customSourceExpression,omitempty"`

	// DceEndpoint Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`.
	DceEndpoint *string `json:"dceEndpoint,omitempty"`

	// DcrID Immutable ID for the Data collection rule (DCR).
	DcrID                    *string                                `json:"dcrID,omitempty"`
	Description              *string                                `json:"description,omitempty"`
	EndpointURLConfiguration OutputSentinelEndpointURLConfiguration `json:"endpointURLConfiguration"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputSentinelFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32     `json:"flushPeriodSec,omitempty"`
	Format         *interface{} `json:"format,omitempty"`

	// FormatEventCode Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
	FormatEventCode *string `json:"formatEventCode,omitempty"`

	// FormatPayloadCode Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
	FormatPayloadCode *string `json:"formatPayloadCode,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl string `json:"loginUrl"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB)
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSentinelOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSentinelPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSentinelPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSentinelPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Scope Scope to pass in the OAuth request
	Scope *string `json:"scope,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret string  `json:"secret"`
	Spacer *string `json:"spacer"`

	// StreamName The name of the stream (Sentinel table) in which to store the events.
	StreamName *string `json:"streamName,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputSentinelTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32            `json:"totalMemoryLimitKB,omitempty"`
	Type               *OutputSentinelType `json:"type,omitempty"`

	// Url URL to send events to. Can be overwritten by an event's __url field.
	Url *string `json:"url,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputSentinelEndpointURLConfiguration defines model for OutputSentinel.EndpointURLConfiguration.
type OutputSentinelEndpointURLConfiguration string

// OutputSentinelFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputSentinelFailedRequestLoggingMode string

// OutputSentinelOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSentinelOnBackpressure string

// OutputSentinelPqCompress Codec to use to compress the persisted data.
type OutputSentinelPqCompress string

// OutputSentinelPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSentinelPqMode string

// OutputSentinelPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSentinelPqOnBackpressure string

// OutputSentinelTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputSentinelTimeoutRetrySettingsTimeoutRetry bool

// OutputSentinelType defines model for OutputSentinel.Type.
type OutputSentinelType string

// OutputServiceNow defines model for OutputServiceNow.
type OutputServiceNow struct {
	AuthTokenName *string `json:"authTokenName,omitempty"`

	// Compress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	Compress *OutputServiceNowCompress `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Endpoint The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets)
	Endpoint string `json:"endpoint"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputServiceNowFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// HttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
	HttpCompress *OutputServiceNowHttpCompress `json:"httpCompress,omitempty"`

	// HttpLogsEndpointOverride If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpLogsEndpointOverride *string `json:"httpLogsEndpointOverride,omitempty"`

	// HttpMetricsEndpointOverride If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpMetricsEndpointOverride *string `json:"httpMetricsEndpointOverride,omitempty"`

	// HttpTracesEndpointOverride If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
	HttpTracesEndpointOverride *string `json:"httpTracesEndpointOverride,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// KeepAliveTime How often the sender should ping the peer to keep the connection open
	KeepAliveTime *float32 `json:"keepAliveTime,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Metadata List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
	Metadata *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"metadata,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputServiceNowOnBackpressure `json:"onBackpressure,omitempty"`

	// OtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
	OtlpVersion OutputServiceNowOtlpVersion `json:"otlpVersion"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputServiceNowPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}     `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputServiceNowPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputServiceNowPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Select a transport option for OpenTelemetry
	Protocol OutputServiceNowProtocol `json:"protocol"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputServiceNowTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                      `json:"certificateName,omitempty"`
		Disabled        *OutputServiceNowTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputServiceNowTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputServiceNowTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	} `json:"tls,omitempty"`

	// TokenSecret Select or create a stored text secret
	TokenSecret string                `json:"tokenSecret"`
	Type        *OutputServiceNowType `json:"type,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputServiceNowCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputServiceNowCompress string

// OutputServiceNowFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputServiceNowFailedRequestLoggingMode string

// OutputServiceNowHttpCompress Type of compression to apply to messages sent to the OpenTelemetry endpoint
type OutputServiceNowHttpCompress string

// OutputServiceNowOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputServiceNowOnBackpressure string

// OutputServiceNowOtlpVersion The version of OTLP Protobuf definitions to use when structuring data to send
type OutputServiceNowOtlpVersion string

// OutputServiceNowPqCompress Codec to use to compress the persisted data.
type OutputServiceNowPqCompress string

// OutputServiceNowPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputServiceNowPqMode string

// OutputServiceNowPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputServiceNowPqOnBackpressure string

// OutputServiceNowProtocol Select a transport option for OpenTelemetry
type OutputServiceNowProtocol string

// OutputServiceNowTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputServiceNowTimeoutRetrySettingsTimeoutRetry bool

// OutputServiceNowTlsDisabled defines model for OutputServiceNow.Tls.Disabled.
type OutputServiceNowTlsDisabled bool

// OutputServiceNowTlsMaxVersion Maximum TLS version to use when connecting
type OutputServiceNowTlsMaxVersion string

// OutputServiceNowTlsMinVersion Minimum TLS version to use when connecting
type OutputServiceNowTlsMinVersion string

// OutputServiceNowType defines model for OutputServiceNow.Type.
type OutputServiceNowType string

// OutputSignalfx defines model for OutputSignalfx.
type OutputSignalfx struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSignalfxAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputSignalfxFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSignalfxOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSignalfxPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSignalfxPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSignalfxPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Realm SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions).
	Realm string `json:"realm"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputSignalfxTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
	Token *string            `json:"token,omitempty"`
	Type  OutputSignalfxType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputSignalfxAuthType Enter a token directly, or provide a secret referencing a token
type OutputSignalfxAuthType string

// OutputSignalfxFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputSignalfxFailedRequestLoggingMode string

// OutputSignalfxOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSignalfxOnBackpressure string

// OutputSignalfxPqCompress Codec to use to compress the persisted data.
type OutputSignalfxPqCompress string

// OutputSignalfxPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSignalfxPqMode string

// OutputSignalfxPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSignalfxPqOnBackpressure string

// OutputSignalfxTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputSignalfxTimeoutRetrySettingsTimeoutRetry bool

// OutputSignalfxType defines model for OutputSignalfx.Type.
type OutputSignalfxType string

// OutputSnmp defines model for OutputSnmp.
type OutputSnmp struct {
	Description *string `json:"description,omitempty"`

	// DnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Hosts One or more SNMP destinations to forward traps to
	Hosts []struct {
		// Host Destination host
		Host string `json:"host"`

		// Port Destination port, default is 162
		Port float32 `json:"port"`
	} `json:"hosts"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string      `json:"systemFields,omitempty"`
	Type         OutputSnmpType `json:"type"`
}

// OutputSnmpType defines model for OutputSnmp.Type.
type OutputSnmpType string

// OutputSns defines model for OutputSns.
type OutputSns struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputSnsAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	Description  *string `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access SNS
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint SNS service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxRetries Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy.
	MaxRetries *float32 `json:"maxRetries,omitempty"`

	// MessageGroupId Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	MessageGroupId string `json:"messageGroupId"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSnsOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSnsPqCompress    `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSnsPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSnsPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Region Region where the SNS is located
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SignatureVersion Signature version to use for signing SNS requests
	SignatureVersion *OutputSnsSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TopicArn The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	TopicArn string         `json:"topicArn"`
	Type     *OutputSnsType `json:"type,omitempty"`
}

// OutputSnsAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputSnsAwsAuthenticationMethod string

// OutputSnsOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSnsOnBackpressure string

// OutputSnsPqCompress Codec to use to compress the persisted data.
type OutputSnsPqCompress string

// OutputSnsPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSnsPqMode string

// OutputSnsPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSnsPqOnBackpressure string

// OutputSnsSignatureVersion Signature version to use for signing SNS requests
type OutputSnsSignatureVersion string

// OutputSnsType defines model for OutputSns.Type.
type OutputSnsType string

// OutputSplunk defines model for OutputSplunk.
type OutputSplunk struct {
	// AuthToken Shared secret token to use when establishing a connection to a Splunk indexer.
	AuthToken *string `json:"authToken,omitempty"`

	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSplunkAuthType `json:"authType,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// EnableACK Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
	EnableACK *OutputSplunkEnableACK `json:"enableACK,omitempty"`

	// EnableMultiMetrics Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
	EnableMultiMetrics *bool `json:"enableMultiMetrics,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Host The hostname of the receiver
	Host string `json:"host"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// LogFailedRequests Use to troubleshoot issues with sending data
	LogFailedRequests *bool `json:"logFailedRequests,omitempty"`

	// MaxFailedHealthChecks Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
	MaxFailedHealthChecks *float32 `json:"maxFailedHealthChecks,omitempty"`

	// MaxS2Sversion The highest S2S protocol version to advertise during handshake.
	MaxS2Sversion *OutputSplunkMaxS2Sversion `json:"maxS2Sversion,omitempty"`

	// NestedFields Specifies how to serialize nested fields into index-time fields.
	NestedFields *OutputSplunkNestedFields `json:"nestedFields,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSplunkOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port The port to connect to on the provided host
	Port float32 `json:"port"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSplunkPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSplunkPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSplunkPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	Tls                *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		Disabled        *OutputSplunkTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputSplunkTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputSplunkTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`
	Type *OutputSplunkType `json:"type,omitempty"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputSplunkAuthType Enter a token directly, or provide a secret referencing a token
type OutputSplunkAuthType string

// OutputSplunkEnableACK Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
type OutputSplunkEnableACK bool

// OutputSplunkMaxS2Sversion The highest S2S protocol version to advertise during handshake.
type OutputSplunkMaxS2Sversion string

// OutputSplunkNestedFields Specifies how to serialize nested fields into index-time fields.
type OutputSplunkNestedFields string

// OutputSplunkOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSplunkOnBackpressure string

// OutputSplunkPqCompress Codec to use to compress the persisted data.
type OutputSplunkPqCompress string

// OutputSplunkPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSplunkPqMode string

// OutputSplunkPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSplunkPqOnBackpressure string

// OutputSplunkTlsDisabled defines model for OutputSplunk.Tls.Disabled.
type OutputSplunkTlsDisabled bool

// OutputSplunkTlsMaxVersion Maximum TLS version to use when connecting
type OutputSplunkTlsMaxVersion string

// OutputSplunkTlsMinVersion Minimum TLS version to use when connecting
type OutputSplunkTlsMinVersion string

// OutputSplunkType defines model for OutputSplunk.Type.
type OutputSplunkType string

// OutputSplunkHec defines model for OutputSplunkHec.
type OutputSplunkHec struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSplunkHecAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// EnableMultiMetrics Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event.
	EnableMultiMetrics *bool `json:"enableMultiMetrics,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputSplunkHecFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
	LoadBalanced *OutputSplunkHecLoadBalanced `json:"loadBalanced,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// NextQueue In the Splunk app, define which Splunk processing queue to send the events after HEC processing.
	NextQueue *string `json:"nextQueue,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSplunkHecOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSplunkHecPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSplunkHecPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSplunkHecPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TcpRouting In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set.
	TcpRouting *string `json:"tcpRouting,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputSplunkHecTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token Splunk HEC authentication token
	Token *string             `json:"token,omitempty"`
	Type  OutputSplunkHecType `json:"type"`

	// Url URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event
	Url  *string `json:"url,omitempty"`
	Urls *[]struct {
		// Url URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event
		Url string `json:"url"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"urls,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputSplunkHecAuthType Enter a token directly, or provide a secret referencing a token
type OutputSplunkHecAuthType string

// OutputSplunkHecFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputSplunkHecFailedRequestLoggingMode string

// OutputSplunkHecLoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
type OutputSplunkHecLoadBalanced bool

// OutputSplunkHecOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSplunkHecOnBackpressure string

// OutputSplunkHecPqCompress Codec to use to compress the persisted data.
type OutputSplunkHecPqCompress string

// OutputSplunkHecPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSplunkHecPqMode string

// OutputSplunkHecPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSplunkHecPqOnBackpressure string

// OutputSplunkHecTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputSplunkHecTimeoutRetrySettingsTimeoutRetry bool

// OutputSplunkHecType defines model for OutputSplunkHec.Type.
type OutputSplunkHecType string

// OutputSplunkLb defines model for OutputSplunkLb.
type OutputSplunkLb struct {
	// AuthToken Shared secret token to use when establishing a connection to a Splunk indexer.
	AuthToken *string `json:"authToken,omitempty"`

	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSplunkLbAuthType `json:"authType,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// EnableACK Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
	EnableACK *OutputSplunkLbEnableACK `json:"enableACK,omitempty"`

	// EnableMultiMetrics Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
	EnableMultiMetrics *bool `json:"enableMultiMetrics,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// Hosts Set of Splunk indexers to load-balance data to.
	Hosts []struct {
		// Host The hostname of the receiver.
		Host string `json:"host"`

		// Port The port to connect to on the provided host.
		Port float32 `json:"port"`

		// Servername Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings.
		Servername *string `json:"servername,omitempty"`

		// Tls Whether to inherit TLS configs from group setting or disable TLS.
		Tls *OutputSplunkLbHostsTls `json:"tls,omitempty"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"hosts"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// IndexerDiscovery Automatically discover indexers in indexer clustering environment.
	IndexerDiscovery *OutputSplunkLbIndexerDiscovery `json:"indexerDiscovery,omitempty"`

	// IndexerDiscoveryConfigs List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
	IndexerDiscoveryConfigs *struct {
		// AuthToken Shared secret to be provided by any client (in authToken header field). If empty, unauthed access is permitted.
		AuthToken *string `json:"authToken,omitempty"`

		// AuthTokens Tokens required to authenticate to cluster manager for indexer discovery
		AuthTokens *[]struct {
			// AuthType Enter a token directly, or provide a secret referencing a token
			AuthType *OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType `json:"authType,omitempty"`
		} `json:"authTokens,omitempty"`

		// AuthType Enter a token directly, or provide a secret referencing a token
		AuthType *OutputSplunkLbIndexerDiscoveryConfigsAuthType `json:"authType,omitempty"`

		// MasterUri Full URI of Splunk cluster manager (scheme://host:port). E.g.: https://managerAddress:8089
		MasterUri string `json:"masterUri"`

		// RefreshIntervalSec Time interval, in seconds, between two consecutive indexer list fetches from cluster manager
		RefreshIntervalSec float32 `json:"refreshIntervalSec"`

		// RejectUnauthorized During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Site Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
		Site string `json:"site"`

		// TextSecret Select or create a stored text secret
		TextSecret *string `json:"textSecret,omitempty"`
	} `json:"indexerDiscoveryConfigs,omitempty"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LogFailedRequests Use to troubleshoot issues with sending data
	LogFailedRequests *bool `json:"logFailedRequests,omitempty"`

	// MaxConcurrentSenders Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
	MaxConcurrentSenders *float32 `json:"maxConcurrentSenders,omitempty"`

	// MaxFailedHealthChecks Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
	MaxFailedHealthChecks *float32 `json:"maxFailedHealthChecks,omitempty"`

	// MaxS2Sversion The highest S2S protocol version to advertise during handshake.
	MaxS2Sversion *OutputSplunkLbMaxS2Sversion `json:"maxS2Sversion,omitempty"`

	// NestedFields Specifies how to serialize nested fields into index-time fields.
	NestedFields *OutputSplunkLbNestedFields `json:"nestedFields,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSplunkLbOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSplunkLbPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}   `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSplunkLbPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSplunkLbPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// SenderUnhealthyTimeAllowance How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
	SenderUnhealthyTimeAllowance *float32 `json:"senderUnhealthyTimeAllowance,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	Tls                *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                    `json:"certificateName,omitempty"`
		Disabled        *OutputSplunkLbTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputSplunkLbTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputSplunkLbTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`
	Type OutputSplunkLbType `json:"type"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputSplunkLbAuthType Enter a token directly, or provide a secret referencing a token
type OutputSplunkLbAuthType string

// OutputSplunkLbEnableACK Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
type OutputSplunkLbEnableACK bool

// OutputSplunkLbHostsTls Whether to inherit TLS configs from group setting or disable TLS.
type OutputSplunkLbHostsTls string

// OutputSplunkLbIndexerDiscovery Automatically discover indexers in indexer clustering environment.
type OutputSplunkLbIndexerDiscovery bool

// OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType Enter a token directly, or provide a secret referencing a token
type OutputSplunkLbIndexerDiscoveryConfigsAuthTokensAuthType string

// OutputSplunkLbIndexerDiscoveryConfigsAuthType Enter a token directly, or provide a secret referencing a token
type OutputSplunkLbIndexerDiscoveryConfigsAuthType string

// OutputSplunkLbMaxS2Sversion The highest S2S protocol version to advertise during handshake.
type OutputSplunkLbMaxS2Sversion string

// OutputSplunkLbNestedFields Specifies how to serialize nested fields into index-time fields.
type OutputSplunkLbNestedFields string

// OutputSplunkLbOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSplunkLbOnBackpressure string

// OutputSplunkLbPqCompress Codec to use to compress the persisted data.
type OutputSplunkLbPqCompress string

// OutputSplunkLbPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSplunkLbPqMode string

// OutputSplunkLbPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSplunkLbPqOnBackpressure string

// OutputSplunkLbTlsDisabled defines model for OutputSplunkLb.Tls.Disabled.
type OutputSplunkLbTlsDisabled bool

// OutputSplunkLbTlsMaxVersion Maximum TLS version to use when connecting
type OutputSplunkLbTlsMaxVersion string

// OutputSplunkLbTlsMinVersion Minimum TLS version to use when connecting
type OutputSplunkLbTlsMinVersion string

// OutputSplunkLbType defines model for OutputSplunkLb.Type.
type OutputSplunkLbType string

// OutputSqs defines model for OutputSqs.
type OutputSqs struct {
	// AssumeRoleArn Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`

	// AssumeRoleExternalId External ID to use when assuming role
	AssumeRoleExternalId *string `json:"assumeRoleExternalId,omitempty"`

	// AwsAccountId SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
	AwsAccountId *string `json:"awsAccountId,omitempty"`

	// AwsApiKey Access key
	AwsApiKey *string `json:"awsApiKey,omitempty"`

	// AwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod *OutputSqsAwsAuthenticationMethod `json:"awsAuthenticationMethod,omitempty"`

	// AwsSecret Select or create a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`

	// AwsSecretKey Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`

	// CreateQueue Create queue if it does not exist.
	CreateQueue *bool   `json:"createQueue,omitempty"`
	Description *string `json:"description,omitempty"`

	// DurationSeconds Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// EnableAssumeRole Use Assume Role credentials to access SQS
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`

	// Endpoint SQS service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxInProgress The maximum number of in-progress API requests before backpressure is applied.
	MaxInProgress *float32 `json:"maxInProgress,omitempty"`

	// MaxQueueSize Maximum number of queued batches before blocking.
	MaxQueueSize *float32 `json:"maxQueueSize,omitempty"`

	// MaxRecordSizeKB Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB.
	MaxRecordSizeKB *float32 `json:"maxRecordSizeKB,omitempty"`

	// MessageGroupId This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value.
	MessageGroupId *string `json:"messageGroupId,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSqsOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSqsPqCompress    `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSqsPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSqsPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// QueueName The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. E.g., referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
	QueueName string `json:"queueName"`

	// QueueType The queue type used (or created). Defaults to Standard.
	QueueType OutputSqsQueueType `json:"queueType"`

	// Region AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
	Region *string `json:"region,omitempty"`

	// RejectUnauthorized Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ReuseConnections Reuse connections between requests, which can improve performance
	ReuseConnections *bool `json:"reuseConnections,omitempty"`

	// SignatureVersion Signature version to use for signing SQS requests
	SignatureVersion *OutputSqsSignatureVersion `json:"signatureVersion,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string      `json:"systemFields,omitempty"`
	Type         *OutputSqsType `json:"type,omitempty"`
}

// OutputSqsAwsAuthenticationMethod AWS authentication method. Choose Auto to use IAM roles.
type OutputSqsAwsAuthenticationMethod string

// OutputSqsOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSqsOnBackpressure string

// OutputSqsPqCompress Codec to use to compress the persisted data.
type OutputSqsPqCompress string

// OutputSqsPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSqsPqMode string

// OutputSqsPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSqsPqOnBackpressure string

// OutputSqsQueueType The queue type used (or created). Defaults to Standard.
type OutputSqsQueueType string

// OutputSqsSignatureVersion Signature version to use for signing SQS requests
type OutputSqsSignatureVersion string

// OutputSqsType defines model for OutputSqs.Type.
type OutputSqsType string

// OutputStatsd defines model for OutputStatsd.
type OutputStatsd struct {
	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Host The hostname of the destination.
	Host string `json:"host"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Mtu When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
	Mtu *float32 `json:"mtu,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputStatsdOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Destination port.
	Port float32 `json:"port"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputStatsdPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputStatsdPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputStatsdPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Protocol to use when communicating with the destination.
	Protocol OutputStatsdProtocol `json:"protocol"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string           `json:"throttleRatePerSec,omitempty"`
	Type               *OutputStatsdType `json:"type,omitempty"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputStatsdOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputStatsdOnBackpressure string

// OutputStatsdPqCompress Codec to use to compress the persisted data.
type OutputStatsdPqCompress string

// OutputStatsdPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputStatsdPqMode string

// OutputStatsdPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputStatsdPqOnBackpressure string

// OutputStatsdProtocol Protocol to use when communicating with the destination.
type OutputStatsdProtocol string

// OutputStatsdType defines model for OutputStatsd.Type.
type OutputStatsdType string

// OutputStatsdExt defines model for OutputStatsdExt.
type OutputStatsdExt struct {
	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// FlushPeriodSec When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Host The hostname of the destination.
	Host string `json:"host"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// Mtu When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system.
	Mtu *float32 `json:"mtu,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputStatsdExtOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port Destination port.
	Port float32 `json:"port"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputStatsdExtPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputStatsdExtPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputStatsdExtPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol Protocol to use when communicating with the destination.
	Protocol OutputStatsdExtProtocol `json:"protocol"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string              `json:"throttleRatePerSec,omitempty"`
	Type               *OutputStatsdExtType `json:"type,omitempty"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputStatsdExtOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputStatsdExtOnBackpressure string

// OutputStatsdExtPqCompress Codec to use to compress the persisted data.
type OutputStatsdExtPqCompress string

// OutputStatsdExtPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputStatsdExtPqMode string

// OutputStatsdExtPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputStatsdExtPqOnBackpressure string

// OutputStatsdExtProtocol Protocol to use when communicating with the destination.
type OutputStatsdExtProtocol string

// OutputStatsdExtType defines model for OutputStatsdExt.Type.
type OutputStatsdExtType string

// OutputStatus defines model for OutputStatus.
type OutputStatus struct {
	Id     string `json:"id"`
	Status struct {
		Health    OutputStatusStatusHealth `json:"health"`
		Metrics   map[string]interface{}   `json:"metrics"`
		Timestamp float32                  `json:"timestamp"`
	} `json:"status"`
}

// OutputStatusStatusHealth defines model for OutputStatus.Status.Health.
type OutputStatusStatusHealth string

// OutputSumoLogic defines model for OutputSumoLogic.
type OutputSumoLogic struct {
	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CustomCategory Optionally, override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field.
	CustomCategory *string `json:"customCategory,omitempty"`

	// CustomSource Optionally, override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field.
	CustomSource *string `json:"customSource,omitempty"`
	Description  *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputSumoLogicFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Optionally, preserve the raw event format instead of json-ifying it.
	Format *OutputSumoLogicFormat `json:"format,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSumoLogicOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSumoLogicPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSumoLogicPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSumoLogicPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields         *[]string `json:"systemFields,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputSumoLogicTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32            `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputSumoLogicType `json:"type"`

	// Url Sumo Logic HTTP collector URL to which events should be sent.
	Url string `json:"url"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputSumoLogicFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputSumoLogicFailedRequestLoggingMode string

// OutputSumoLogicFormat Optionally, preserve the raw event format instead of json-ifying it.
type OutputSumoLogicFormat string

// OutputSumoLogicOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSumoLogicOnBackpressure string

// OutputSumoLogicPqCompress Codec to use to compress the persisted data.
type OutputSumoLogicPqCompress string

// OutputSumoLogicPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSumoLogicPqMode string

// OutputSumoLogicPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSumoLogicPqOnBackpressure string

// OutputSumoLogicTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputSumoLogicTimeoutRetrySettingsTimeoutRetry bool

// OutputSumoLogicType defines model for OutputSumoLogic.Type.
type OutputSumoLogicType string

// OutputSyslog defines model for OutputSyslog.
type OutputSyslog struct {
	// AppName Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set.
	AppName *string `json:"appName,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Facility Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
	Facility *OutputSyslogFacility `json:"facility,omitempty"`

	// Host The hostname of the receiver
	Host *string `json:"host,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LoadBalanced For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS.
	LoadBalanced *bool `json:"loadBalanced,omitempty"`

	// LogFailedRequests Use to troubleshoot issues with sending data
	LogFailedRequests *bool `json:"logFailedRequests,omitempty"`

	// MaxRecordSize Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation.
	MaxRecordSize *float32 `json:"maxRecordSize,omitempty"`

	// MessageFormat The syslog message format depending on the receiver's support
	MessageFormat *OutputSyslogMessageFormat `json:"messageFormat,omitempty"`

	// OctetCountFraming When enabled, messages will be prefixed with the byte count of the message. Otherwise, no prefix will be set, and the message will be appended with a \n.
	OctetCountFraming *bool `json:"octetCountFraming,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputSyslogOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port The port to connect to on the provided host
	Port *float32 `json:"port,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputSyslogPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{} `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputSyslogPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSyslogPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// Protocol The network protocol to use for sending out syslog messages
	Protocol *OutputSyslogProtocol `json:"protocol,omitempty"`

	// Severity Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
	Severity *OutputSyslogSeverity `json:"severity,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`

	// TimestampFormat Timestamp format to use when serializing event's time field
	TimestampFormat *OutputSyslogTimestampFormat `json:"timestampFormat,omitempty"`
	Tls             *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                  `json:"certificateName,omitempty"`
		Disabled        *OutputSyslogTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputSyslogTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputSyslogTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`
	Type OutputSyslogType `json:"type"`

	// UdpDnsResolvePeriodSec How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup.
	UdpDnsResolvePeriodSec *float32 `json:"udpDnsResolvePeriodSec,omitempty"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputSyslogFacility Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user.
type OutputSyslogFacility float32

// OutputSyslogMessageFormat The syslog message format depending on the receiver's support
type OutputSyslogMessageFormat string

// OutputSyslogOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSyslogOnBackpressure string

// OutputSyslogPqCompress Codec to use to compress the persisted data.
type OutputSyslogPqCompress string

// OutputSyslogPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputSyslogPqMode string

// OutputSyslogPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSyslogPqOnBackpressure string

// OutputSyslogProtocol The network protocol to use for sending out syslog messages
type OutputSyslogProtocol string

// OutputSyslogSeverity Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice.
type OutputSyslogSeverity float32

// OutputSyslogTimestampFormat Timestamp format to use when serializing event's time field
type OutputSyslogTimestampFormat string

// OutputSyslogTlsDisabled defines model for OutputSyslog.Tls.Disabled.
type OutputSyslogTlsDisabled bool

// OutputSyslogTlsMaxVersion Maximum TLS version to use when connecting
type OutputSyslogTlsMaxVersion string

// OutputSyslogTlsMinVersion Minimum TLS version to use when connecting
type OutputSyslogTlsMinVersion string

// OutputSyslogType defines model for OutputSyslog.Type.
type OutputSyslogType string

// OutputTcpjson defines model for OutputTcpjson.
type OutputTcpjson struct {
	// AuthToken Optional authentication token to include as part of the connection header
	AuthToken *string `json:"authToken,omitempty"`

	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputTcpjsonAuthType `json:"authType,omitempty"`

	// Compression Codec to use to compress the data before sending
	Compression *OutputTcpjsonCompression `json:"compression,omitempty"`

	// ConnectionTimeout Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *float32 `json:"connectionTimeout,omitempty"`
	Description       *string  `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// Host The hostname of the receiver
	Host *string `json:"host,omitempty"`

	// Hosts Set of hosts to load-balance data to.
	Hosts *[]struct {
		// Host The hostname of the receiver.
		Host string `json:"host"`

		// Port The port to connect to on the provided host.
		Port float32 `json:"port"`

		// Servername Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings.
		Servername *string `json:"servername,omitempty"`

		// Tls Whether to inherit TLS configs from group setting or disable TLS.
		Tls *OutputTcpjsonHostsTls `json:"tls,omitempty"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"hosts,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced Use load-balanced destinations
	LoadBalanced *OutputTcpjsonLoadBalanced `json:"loadBalanced,omitempty"`

	// LogFailedRequests Use to troubleshoot issues with sending data
	LogFailedRequests *bool `json:"logFailedRequests,omitempty"`

	// MaxConcurrentSenders Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
	MaxConcurrentSenders *float32 `json:"maxConcurrentSenders,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputTcpjsonOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// Port The port to connect to on the provided host
	Port *float32 `json:"port,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputTcpjsonPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputTcpjsonPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputTcpjsonPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// SendHeader Upon connection, send a header-like record containing the auth token and other metadata.This record will not contain an actual event – only subsequent records will.
	SendHeader *bool `json:"sendHeader,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`

	// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `json:"throttleRatePerSec,omitempty"`
	Tls                *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                   `json:"certificateName,omitempty"`
		Disabled        *OutputTcpjsonTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputTcpjsonTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputTcpjsonTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// RejectUnauthorized Reject certs that are not authorized by a CA in the CA certificate path, or by another
		//                     trusted CA (e.g., the system's CA). Defaults to Yes. Overrides the toggle from Advanced Settings, when also present.
		RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// TokenTTLMinutes The number of minutes before the internally generated authentication token expires, valid values between 1 and 60
	TokenTTLMinutes *float32          `json:"tokenTTLMinutes,omitempty"`
	Type            OutputTcpjsonType `json:"type"`

	// WriteTimeout Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *float32 `json:"writeTimeout,omitempty"`
}

// OutputTcpjsonAuthType Enter a token directly, or provide a secret referencing a token
type OutputTcpjsonAuthType string

// OutputTcpjsonCompression Codec to use to compress the data before sending
type OutputTcpjsonCompression string

// OutputTcpjsonHostsTls Whether to inherit TLS configs from group setting or disable TLS.
type OutputTcpjsonHostsTls string

// OutputTcpjsonLoadBalanced Use load-balanced destinations
type OutputTcpjsonLoadBalanced bool

// OutputTcpjsonOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputTcpjsonOnBackpressure string

// OutputTcpjsonPqCompress Codec to use to compress the persisted data.
type OutputTcpjsonPqCompress string

// OutputTcpjsonPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputTcpjsonPqMode string

// OutputTcpjsonPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputTcpjsonPqOnBackpressure string

// OutputTcpjsonTlsDisabled defines model for OutputTcpjson.Tls.Disabled.
type OutputTcpjsonTlsDisabled bool

// OutputTcpjsonTlsMaxVersion Maximum TLS version to use when connecting
type OutputTcpjsonTlsMaxVersion string

// OutputTcpjsonTlsMinVersion Minimum TLS version to use when connecting
type OutputTcpjsonTlsMinVersion string

// OutputTcpjsonType defines model for OutputTcpjson.Type.
type OutputTcpjsonType string

// OutputTestRequest defines model for OutputTestRequest.
type OutputTestRequest struct {
	Events []CriblEvent `json:"events"`
}

// OutputTestResponse defines model for OutputTestResponse.
type OutputTestResponse struct {
	Details       *map[string]interface{} `json:"details,omitempty"`
	Error         *string                 `json:"error,omitempty"`
	OutputId      string                  `json:"outputId"`
	Success       bool                    `json:"success"`
	SuccessDetail *string                 `json:"successDetail,omitempty"`
}

// OutputWavefront defines model for OutputWavefront.
type OutputWavefront struct {
	// AuthType Enter a token directly, or provide a secret referencing a token
	AuthType *OutputWavefrontAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`
	Description *string  `json:"description,omitempty"`

	// Domain WaveFront domain name, e.g. "longboard"
	Domain string `json:"domain"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExtraHttpHeaders Headers to add to all events.
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputWavefrontFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Id Unique ID for this output
	Id *string `json:"id,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputWavefrontOnBackpressure `json:"onBackpressure,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputWavefrontPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}    `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputWavefrontPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputWavefrontPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputWavefrontTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`

	// Token WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
	Token *string             `json:"token,omitempty"`
	Type  OutputWavefrontType `json:"type"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`
}

// OutputWavefrontAuthType Enter a token directly, or provide a secret referencing a token
type OutputWavefrontAuthType string

// OutputWavefrontFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputWavefrontFailedRequestLoggingMode string

// OutputWavefrontOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputWavefrontOnBackpressure string

// OutputWavefrontPqCompress Codec to use to compress the persisted data.
type OutputWavefrontPqCompress string

// OutputWavefrontPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputWavefrontPqMode string

// OutputWavefrontPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputWavefrontPqOnBackpressure string

// OutputWavefrontTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputWavefrontTimeoutRetrySettingsTimeoutRetry bool

// OutputWavefrontType defines model for OutputWavefront.Type.
type OutputWavefrontType string

// OutputWebhook defines model for OutputWebhook.
type OutputWebhook struct {
	// AdvancedContentType HTTP content-type header value
	AdvancedContentType *string `json:"advancedContentType,omitempty"`

	// AuthHeaderExpr JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`

	// AuthType The authentication method to use for the HTTP request. Defaults to None.
	AuthType *OutputWebhookAuthType `json:"authType,omitempty"`

	// Compress Compress the payload body before sending
	Compress *bool `json:"compress,omitempty"`

	// Concurrency Maximum number of ongoing requests before blocking
	Concurrency *float32 `json:"concurrency,omitempty"`

	// CredentialsSecret Select or create a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`

	// CustomContentType Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry.
	CustomContentType *string `json:"customContentType,omitempty"`

	// CustomDropWhenNull Whether to drop events when the source expression evaluates to null
	CustomDropWhenNull *bool `json:"customDropWhenNull,omitempty"`

	// CustomEventDelimiter Delimiter string to insert between individual events. Defaults to newline character.
	CustomEventDelimiter *string `json:"customEventDelimiter,omitempty"`

	// CustomPayloadExpression Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object.
	CustomPayloadExpression *string `json:"customPayloadExpression,omitempty"`

	// CustomSourceExpression Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON.
	CustomSourceExpression *string `json:"customSourceExpression,omitempty"`
	Description            *string `json:"description,omitempty"`

	// DnsResolvePeriodSec Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DnsResolvePeriodSec *float32 `json:"dnsResolvePeriodSec,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// ExcludeSelf Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`

	// ExtraHttpHeaders Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained [here](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
	ExtraHttpHeaders *[]struct {
		// Name Field name
		Name *string `json:"name,omitempty"`

		// Value Field value
		Value string `json:"value"`
	} `json:"extraHttpHeaders,omitempty"`

	// FailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
	FailedRequestLoggingMode *OutputWebhookFailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`

	// FlushPeriodSec Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max body size.
	FlushPeriodSec *float32 `json:"flushPeriodSec,omitempty"`

	// Format Specifies how to format events before sending out. Defaults to NDJSON.
	Format *OutputWebhookFormat `json:"format,omitempty"`

	// FormatEventCode Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
	FormatEventCode *string `json:"formatEventCode,omitempty"`

	// FormatPayloadCode Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
	FormatPayloadCode *string `json:"formatPayloadCode,omitempty"`

	// Id Unique ID for this output
	Id string `json:"id"`

	// KeepAlive Disable to close the connection immediately after sending the outgoing request
	KeepAlive *bool `json:"keepAlive,omitempty"`

	// LoadBalanceStatsPeriodSec How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *float32 `json:"loadBalanceStatsPeriodSec,omitempty"`

	// LoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
	LoadBalanced *OutputWebhookLoadBalanced `json:"loadBalanced,omitempty"`

	// LoginUrl URL for OAuth
	LoginUrl *string `json:"loginUrl,omitempty"`

	// MaxPayloadEvents Maximum number of events to include in the request body. Default is 0 (unlimited).
	MaxPayloadEvents *float32 `json:"maxPayloadEvents,omitempty"`

	// MaxPayloadSizeKB Maximum size, in KB, of the request body
	MaxPayloadSizeKB *float32 `json:"maxPayloadSizeKB,omitempty"`

	// Method The method to use when sending events. Defaults to POST.
	Method *OutputWebhookMethod `json:"method,omitempty"`

	// OauthHeaders Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders *[]struct {
		// Name OAuth header name
		Name string `json:"name"`

		// Value OAuth header value
		Value string `json:"value"`
	} `json:"oauthHeaders,omitempty"`

	// OauthParams Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams *[]struct {
		// Name OAuth parameter name
		Name string `json:"name"`

		// Value OAuth parameter value
		Value string `json:"value"`
	} `json:"oauthParams,omitempty"`

	// OnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputWebhookOnBackpressure `json:"onBackpressure,omitempty"`

	// Password Password for Basic authentication
	Password *string `json:"password,omitempty"`

	// Pipeline Pipeline to process data before sending out to this output
	Pipeline *string `json:"pipeline,omitempty"`

	// PqCompress Codec to use to compress the persisted data.
	PqCompress *OutputWebhookPqCompress `json:"pqCompress,omitempty"`
	PqControls *map[string]interface{}  `json:"pqControls,omitempty"`

	// PqMaxFileSize The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`

	// PqMaxSize The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`

	// PqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
	PqMode *OutputWebhookPqMode `json:"pqMode,omitempty"`

	// PqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputWebhookPqOnBackpressure `json:"pqOnBackpressure,omitempty"`

	// PqPath The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`

	// RejectUnauthorized Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
	//         Defaults to Yes. When this setting is also present in TLS Settings (Client Side),
	//         that value will take precedence.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`

	// ResponseHonorRetryAfterHeader Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
	ResponseHonorRetryAfterHeader *bool `json:"responseHonorRetryAfterHeader,omitempty"`

	// ResponseRetrySettings Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable).
	ResponseRetrySettings *[]struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// HttpStatus The HTTP response status code that will trigger retries
		HttpStatus float32 `json:"httpStatus"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`
	} `json:"responseRetrySettings,omitempty"`

	// SafeHeaders List of headers that are safe to log in plain text
	SafeHeaders *[]string `json:"safeHeaders,omitempty"`

	// Secret Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`

	// SecretParamName Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// SystemFields Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields *[]string `json:"systemFields,omitempty"`

	// TextSecret Select or create a stored text secret
	TextSecret           *string `json:"textSecret,omitempty"`
	TimeoutRetrySettings *struct {
		// BackoffRate Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc.
		BackoffRate *float32 `json:"backoffRate,omitempty"`

		// InitialBackoff How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes).
		InitialBackoff *float32 `json:"initialBackoff,omitempty"`

		// MaxBackoff The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds).
		MaxBackoff *float32 `json:"maxBackoff,omitempty"`

		// TimeoutRetry Enable to retry on request timeout
		TimeoutRetry OutputWebhookTimeoutRetrySettingsTimeoutRetry `json:"timeoutRetry"`
	} `json:"timeoutRetrySettings,omitempty"`

	// TimeoutSec Amount of time, in seconds, to wait for a request to complete before canceling it
	TimeoutSec *float32 `json:"timeoutSec,omitempty"`
	Tls        *struct {
		// CaPath Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
		CaPath *string `json:"caPath,omitempty"`

		// CertPath Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
		CertPath *string `json:"certPath,omitempty"`

		// CertificateName The name of the predefined certificate.
		CertificateName *string                   `json:"certificateName,omitempty"`
		Disabled        *OutputWebhookTlsDisabled `json:"disabled,omitempty"`

		// MaxVersion Maximum TLS version to use when connecting
		MaxVersion *OutputWebhookTlsMaxVersion `json:"maxVersion,omitempty"`

		// MinVersion Minimum TLS version to use when connecting
		MinVersion *OutputWebhookTlsMinVersion `json:"minVersion,omitempty"`

		// Passphrase Passphrase to use to decrypt private key.
		Passphrase *string `json:"passphrase,omitempty"`

		// PrivKeyPath Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
		PrivKeyPath *string `json:"privKeyPath,omitempty"`

		// Servername Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
		Servername *string `json:"servername,omitempty"`
	} `json:"tls,omitempty"`

	// Token Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`

	// TokenAttributeName Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`

	// TokenTimeoutSecs How often the OAuth token should be refreshed.
	TokenTimeoutSecs *float32 `json:"tokenTimeoutSecs,omitempty"`

	// TotalMemoryLimitKB Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
	TotalMemoryLimitKB *float32          `json:"totalMemoryLimitKB,omitempty"`
	Type               OutputWebhookType `json:"type"`

	// Url URL of a webhook endpoint to send events to, such as http://localhost:10200
	Url  *string `json:"url,omitempty"`
	Urls *[]struct {
		// Url URL of a webhook endpoint to send events to, such as http://localhost:10200
		Url string `json:"url"`

		// Weight Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
		Weight *float32 `json:"weight,omitempty"`
	} `json:"urls,omitempty"`

	// UseRoundRobinDns Enables round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
	UseRoundRobinDns *bool `json:"useRoundRobinDns,omitempty"`

	// Username Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// OutputWebhookAuthType The authentication method to use for the HTTP request. Defaults to None.
type OutputWebhookAuthType string

// OutputWebhookFailedRequestLoggingMode Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
type OutputWebhookFailedRequestLoggingMode string

// OutputWebhookFormat Specifies how to format events before sending out. Defaults to NDJSON.
type OutputWebhookFormat string

// OutputWebhookLoadBalanced Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
type OutputWebhookLoadBalanced bool

// OutputWebhookMethod The method to use when sending events. Defaults to POST.
type OutputWebhookMethod string

// OutputWebhookOnBackpressure Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputWebhookOnBackpressure string

// OutputWebhookPqCompress Codec to use to compress the persisted data.
type OutputWebhookPqCompress string

// OutputWebhookPqMode In Error mode, PQ writes events to the filesystem only when it detects a non-retryable Destination error. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination or when there are non-retryable Destination errors. In Always On mode, PQ always writes events to the filesystem.
type OutputWebhookPqMode string

// OutputWebhookPqOnBackpressure Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputWebhookPqOnBackpressure string

// OutputWebhookTimeoutRetrySettingsTimeoutRetry Enable to retry on request timeout
type OutputWebhookTimeoutRetrySettingsTimeoutRetry bool

// OutputWebhookTlsDisabled defines model for OutputWebhook.Tls.Disabled.
type OutputWebhookTlsDisabled bool

// OutputWebhookTlsMaxVersion Maximum TLS version to use when connecting
type OutputWebhookTlsMaxVersion string

// OutputWebhookTlsMinVersion Minimum TLS version to use when connecting
type OutputWebhookTlsMinVersion string

// OutputWebhookType defines model for OutputWebhook.Type.
type OutputWebhookType string

// PackClone defines model for PackClone.
type PackClone struct {
	Dest      *string  `json:"dest,omitempty"`
	DstGroups []string `json:"dstGroups"`
	Force     *bool    `json:"force,omitempty"`
	Packs     []string `json:"packs"`
	SrcGroup  string   `json:"srcGroup"`
}

// PackInfo defines model for PackInfo.
type PackInfo struct {
	Author              *string                 `json:"author,omitempty"`
	Description         *string                 `json:"description,omitempty"`
	DisplayName         *string                 `json:"displayName,omitempty"`
	Id                  string                  `json:"id"`
	IsDisabled          *bool                   `json:"isDisabled,omitempty"`
	MinLogStreamVersion *string                 `json:"minLogStreamVersion,omitempty"`
	Settings            *map[string]interface{} `json:"settings,omitempty"`
	Source              string                  `json:"source"`
	Spec                *string                 `json:"spec,omitempty"`
	Tags                *struct {
		DataType   []string `json:"dataType"`
		Domain     []string `json:"domain"`
		Streamtags []string `json:"streamtags"`
		Technology []string `json:"technology"`
	} `json:"tags,omitempty"`
	Version *string `json:"version,omitempty"`
}

// ParserLibEntry defines model for ParserLibEntry.
type ParserLibEntry struct {
	// Description Brief description of this parser (optional)
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`
	Lib         *string `json:"lib,omitempty"`

	// Tags One or more tags related to this parser (optional)
	Tags *string `json:"tags,omitempty"`

	// Type Parser or formatter type to use
	Type                 ParserLibEntryType     `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ParserLibEntryType Parser or formatter type to use
type ParserLibEntryType string

// ParserMode defines model for ParserMode.
type ParserMode string

// Pipeline defines model for Pipeline.

type PipelineConf struct {
		// AsyncFuncTimeout Time (in ms) to wait for an async function to complete processing of a data item
		AsyncFuncTimeout *int    `json:"asyncFuncTimeout,omitempty"`
		Description      *string `json:"description,omitempty"`

		// Functions List of Functions to pass data through
		Functions *[]PipelineFunctionConf `json:"functions,omitempty"`
		Groups    *map[string]struct {
			// Description Short description of this group
			Description *string `json:"description,omitempty"`

			// Disabled Whether this group is disabled
			Disabled *bool  `json:"disabled,omitempty"`
			Name     string `json:"name"`
		} `json:"groups,omitempty"`

		// Output The output destination for events processed by this Pipeline
		Output *string `json:"output,omitempty"`

		// Streamtags Tags for filtering and grouping in @{product}
		Streamtags *[]string `json:"streamtags,omitempty"`
	}
type Pipeline struct {
	Conf PipelineConf `json:"conf"`
	Id string `json:"id"`
}

// PipelineFunctionConf defines model for PipelineFunctionConf.
type PipelineFunctionConf struct {
	Conf map[string]interface{} `json:"conf"`

	// Description Simple description of this step
	Description *string `json:"description,omitempty"`

	// Disabled If true, data will not be pushed through this function
	Disabled *bool `json:"disabled,omitempty"`

	// Filter Filter that selects data to be fed through this Function
	Filter *string `json:"filter,omitempty"`

	// Final If enabled, stops the results of this Function from being passed to the downstream Functions
	Final *bool `json:"final,omitempty"`

	// GroupId Group ID
	GroupId *string `json:"groupId,omitempty"`

	// Id Function ID
	Id string `json:"id"`
}

// PolicyRule defines model for PolicyRule.
type PolicyRule struct {
	Args        *[]string `json:"args,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Template    []string  `json:"template"`
	Title       *string   `json:"title,omitempty"`
}

// PreviewDataParams defines model for PreviewDataParams.
type PreviewDataParams struct {
	CpuProfile           *bool                     `json:"cpuProfile,omitempty"`
	Dropped              *bool                     `json:"dropped,omitempty"`
	EnhanceMetricsOutput *bool                     `json:"enhanceMetricsOutput,omitempty"`
	Events               *[]map[string]interface{} `json:"events,omitempty"`
	InputId              *string                   `json:"inputId,omitempty"`
	Level                *float32                  `json:"level,omitempty"`
	Memory               *float32                  `json:"memory,omitempty"`
	Mode                 PreviewDataParamsMode     `json:"mode"`
	PipelineId           string                    `json:"pipelineId"`
	SampleId             string                    `json:"sampleId"`
	SamplePipelineId     *string                   `json:"samplePipelineId,omitempty"`
	Timeout              *float32                  `json:"timeout,omitempty"`
}

// PreviewDataParamsMode defines model for PreviewDataParams.Mode.
type PreviewDataParamsMode string

// PreviewOptions defines model for PreviewOptions.
type PreviewOptions struct {
	Earliest *PreviewOptions_Earliest `json:"earliest,omitempty"`
	Latest   *PreviewOptions_Latest   `json:"latest,omitempty"`
}

// PreviewOptionsEarliest0 defines model for .
type PreviewOptionsEarliest0 = string

// PreviewOptionsEarliest1 defines model for .
type PreviewOptionsEarliest1 = float32

// PreviewOptions_Earliest defines model for PreviewOptions.Earliest.
type PreviewOptions_Earliest struct {
	Union json.RawMessage
}

// PreviewOptionsLatest0 defines model for .
type PreviewOptionsLatest0 = string

// PreviewOptionsLatest1 defines model for .
type PreviewOptionsLatest1 = float32

// PreviewOptions_Latest defines model for PreviewOptions.Latest.
type PreviewOptions_Latest struct {
	Union json.RawMessage
}

// PreviewRequestBody defines model for PreviewRequestBody.
type PreviewRequestBody struct {
	Events  []SearchEvent   `json:"events"`
	Options *PreviewOptions `json:"options,omitempty"`
	Query   string          `json:"query"`
}

// PreviewResponseBody defines model for PreviewResponseBody.
type PreviewResponseBody struct {
	Count                     float32       `json:"count"`
	Events                    []SearchEvent `json:"events"`
	ProcessingTimeMS          float32       `json:"processingTimeMS"`
	UseFormattedVisualization bool          `json:"useFormattedVisualization"`
}

// Process defines model for Process.
type Process struct {
	Id   string  `json:"id"`
	Pid  float32 `json:"pid"`
	Ppid float32 `json:"ppid"`
}

// ProcessEntry defines model for ProcessEntry.
type ProcessEntry struct {
	Env           *map[string]interface{} `json:"env,omitempty"`
	Id            string                  `json:"id"`
	Pid           *float32                `json:"pid,omitempty"`
	RestartOnExit bool                    `json:"restartOnExit"`
	Restarts      float32                 `json:"restarts"`
	StartTime     float32                 `json:"startTime"`
	Type          string                  `json:"type"`
}

// ProfilerItem defines model for ProfilerItem.
type ProfilerItem struct {
	CreateTime *float32 `json:"createTime,omitempty"`
	Id         string   `json:"id"`
	Size       *float32 `json:"size,omitempty"`
	WorkerId   *string  `json:"workerId,omitempty"`
}

// ProjectConfig defines model for ProjectConfig.
type ProjectConfig struct {
	Consumers     *map[string]interface{} `json:"consumers,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	Destinations  []string                `json:"destinations"`
	Id            string                  `json:"id"`
	Subscriptions []string                `json:"subscriptions"`
}

// ProjectDestination defines model for ProjectDestination.
type ProjectDestination struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProjectGitCommitParams defines model for ProjectGitCommitParams.
type ProjectGitCommitParams struct {
	Effective *bool  `json:"effective,omitempty"`
	Message   string `json:"message"`
}

// ProtobufBytesConversion defines model for ProtobufBytesConversion.
type ProtobufBytesConversion string

// ProtobufEncodingConfig defines model for ProtobufEncodingConfig.
type ProtobufEncodingConfig struct {
	EventModel string `json:"eventModel"`
	Id         string `json:"id"`
	Name       string `json:"name"`
	Wrapping   *struct {
		WrapperField     string                                         `json:"wrapperField"`
		WrapperFieldType ProtobufEncodingConfigWrappingWrapperFieldType `json:"wrapperFieldType"`
		WrapperModel     string                                         `json:"wrapperModel"`
	} `json:"wrapping,omitempty"`
}

// ProtobufEncodingConfigWrappingWrapperFieldType defines model for ProtobufEncodingConfig.Wrapping.WrapperFieldType.
type ProtobufEncodingConfigWrappingWrapperFieldType string

// ProtobufEnumConversion defines model for ProtobufEnumConversion.
type ProtobufEnumConversion string

// ProtobufLibraryConfig defines model for ProtobufLibraryConfig.
type ProtobufLibraryConfig struct {
	AvailableEncodings *[]ProtobufEncodingConfig        `json:"availableEncodings,omitempty"`
	Conversion         *ProtobufLibraryConversionConfig `json:"conversion,omitempty"`
	DependsOn          []string                         `json:"dependsOn"`
	Description        string                           `json:"description"`
	Id                 string                           `json:"id"`
	Name               string                           `json:"name"`
	Tags               *string                          `json:"tags,omitempty"`
}

// ProtobufLibraryConversionConfig defines model for ProtobufLibraryConversionConfig.
type ProtobufLibraryConversionConfig struct {
	Arrays   *bool                    `json:"arrays,omitempty"`
	Bytes    *ProtobufBytesConversion `json:"bytes,omitempty"`
	Defaults *bool                    `json:"defaults,omitempty"`
	Enums    *ProtobufEnumConversion  `json:"enums,omitempty"`
	Json     *bool                    `json:"json,omitempty"`
	Longs    *ProtobufLongConversion  `json:"longs,omitempty"`
	Objects  *bool                    `json:"objects,omitempty"`
	Oneofs   *bool                    `json:"oneofs,omitempty"`
}

// ProtobufLongConversion defines model for ProtobufLongConversion.
type ProtobufLongConversion string

// PublicSettings defines model for PublicSettings.
type PublicSettings struct {
	ApiProtocol  string `json:"apiProtocol"`
	Intercom     bool   `json:"intercom"`
	IsRegistered bool   `json:"isRegistered"`
}

// RbacResource defines model for RbacResource.
type RbacResource string

// RedirectInfo defines model for RedirectInfo.
type RedirectInfo struct {
	Name        string  `json:"name"`
	RedirectUrl *string `json:"redirectUrl,omitempty"`
	Token       *string `json:"token,omitempty"`
}

// RedisCacheLimits defines model for RedisCacheLimits.
type RedisCacheLimits struct {
	ClientTrackingMechanism *string  `json:"clientTrackingMechanism,omitempty"`
	EnableServerAssist      *bool    `json:"enableServerAssist,omitempty"`
	KeyTTLSecs              *float32 `json:"keyTTLSecs,omitempty"`
	MaxCacheSize            *float32 `json:"maxCacheSize,omitempty"`
	MaxNumKeys              *float32 `json:"maxNumKeys,omitempty"`
	ServicePeriodSecs       *float32 `json:"servicePeriodSecs,omitempty"`
}

// RedisConnectionLimits defines model for RedisConnectionLimits.
type RedisConnectionLimits struct {
	Disabled       *bool    `json:"disabled,omitempty"`
	MaxConnections *float32 `json:"maxConnections,omitempty"`
}

// RedisLimits defines model for RedisLimits.
type RedisLimits struct {
	Connections RedisConnectionLimits `json:"connections"`
}

// RegexLibEntry defines model for RegexLibEntry.
type RegexLibEntry struct {
	// Description Brief description of this regex (optional)
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`
	Lib         *string `json:"lib,omitempty"`
	Regex       string  `json:"regex"`

	// SampleData Sample data for this regex (optional)
	SampleData *string `json:"sampleData,omitempty"`

	// Tags One or more tags related to this regex (optional)
	Tags *string `json:"tags,omitempty"`
}

// ResourcePolicy defines model for ResourcePolicy.
type ResourcePolicy struct {
	Gid    string       `json:"gid"`
	Id     *string      `json:"id,omitempty"`
	Policy string       `json:"policy"`
	Type   RbacResource `json:"type"`
}

// RestSecret defines model for RestSecret.
type RestSecret struct {
	ApiKey      *string    `json:"apiKey,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          string     `json:"id"`
	Password    *string    `json:"password,omitempty"`
	SecretKey   *string    `json:"secretKey,omitempty"`
	SecretType  SecretType `json:"secretType"`
	Tags        *string    `json:"tags,omitempty"`
	Username    *string    `json:"username,omitempty"`
	Value       *string    `json:"value,omitempty"`
}

// RestartResponse defines model for RestartResponse.
type RestartResponse struct {
	Id      string                `json:"id"`
	Message *string               `json:"message,omitempty"`
	Status  RestartResponseStatus `json:"status"`
}

// RestartResponseStatus defines model for RestartResponse.Status.
type RestartResponseStatus string

// RetryBackoffOptions defines model for RetryBackoffOptions.
type RetryBackoffOptions struct {
	BackoffRate    *float32 `json:"backoffRate,omitempty"`
	InitialBackoff *float32 `json:"initialBackoff,omitempty"`
	MaxBackoff     *float32 `json:"maxBackoff,omitempty"`
}

// Role defines model for Role.
type Role struct {
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Policy      []string  `json:"policy"`
	Tags        *[]string `json:"tags,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// RouteConf defines model for RouteConf.
type RouteConf struct {
	Clones                 *[]interface{} `json:"clones,omitempty"`
	Context                *string        `json:"context,omitempty"`
	Description            *string        `json:"description,omitempty"`
	Disabled               *bool          `json:"disabled,omitempty"`
	EnableOutputExpression *bool          `json:"enableOutputExpression,omitempty"`
	Filter                 *string        `json:"filter,omitempty"`
	Final                  bool           `json:"final"`
	GroupId                *string        `json:"groupId,omitempty"`
	Id                     string         `json:"id"`
	Name                   string         `json:"name"`
	Output                 *string        `json:"output,omitempty"`
	OutputExpression       *string        `json:"outputExpression,omitempty"`
	Pipeline               string         `json:"pipeline"`
}

// RouteDefinitions defines model for RouteDefinitions.
type RouteDefinitions = []RouteConf

// Routes defines model for Routes.
type Routes struct {
	// Comments Comments
	Comments *[]Routes_Comments_Item `json:"comments,omitempty"`
	Groups   *map[string]struct {
		// Description Short description of this group
		Description *string `json:"description,omitempty"`

		// Disabled Whether this group is disabled
		Disabled *bool  `json:"disabled,omitempty"`
		Name     string `json:"name"`
	} `json:"groups,omitempty"`

	// Id Routes ID
	Id *string `json:"id,omitempty"`

	// Routes Pipeline routing rules
	Routes []RoutesRoute `json:"routes"`
}

// Routes_Comments_Item defines model for Routes.comments.Item.
type Routes_Comments_Item struct {
	// Comment Optional, short description of this Route's purpose
	Comment              *string                `json:"comment,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RoutesRoute defines model for RoutesRoute.
type RoutesRoute struct {
	Description *string `json:"description,omitempty"`

	// Disabled Disable this routing rule
	Disabled *bool `json:"disabled,omitempty"`

	// EnableOutputExpression Enable to use a JavaScript expression that evaluates to the name of the Output below
	EnableOutputExpression *bool `json:"enableOutputExpression,omitempty"`

	// Filter JavaScript expression to select data to route
	Filter *string `json:"filter,omitempty"`

	// Final Flag to control whether the event gets consumed by this Route (Final), or cloned into it
	Final            *bool        `json:"final,omitempty"`
	Id               *string      `json:"id,omitempty"`
	Name             string       `json:"name"`
	Output           *interface{} `json:"output,omitempty"`
	OutputExpression *interface{} `json:"outputExpression,omitempty"`

	// Pipeline Pipeline to send the matching data to
	Pipeline             string                 `json:"pipeline"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RunnableJob defines model for RunnableJob.
type RunnableJob struct {
	Union json.RawMessage
}

// RunnableJobCollection defines model for RunnableJobCollection.
type RunnableJobCollection struct {
	Collector struct {
		Conf map[string]interface{} `json:"conf"`

		// Destructive If set to Yes, the collector will delete any files that it collects (where applicable)
		Destructive *bool `json:"destructive,omitempty"`

		// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
		Encoding *string `json:"encoding,omitempty"`

		// Type The type of collector to run
		Type string `json:"type"`
	} `json:"collector"`
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this Job
	Id    *string `json:"id,omitempty"`
	Input *struct {
		// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
		BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

		// Metadata Fields to add to events from this input
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`

		// Output Destination to send results to
		Output *string `json:"output,omitempty"`

		// Pipeline Pipeline to process results
		Pipeline   *string `json:"pipeline,omitempty"`
		Preprocess *struct {
			// Args Arguments to be added to the custom command
			Args *[]string `json:"args,omitempty"`

			// Command Command to feed the data through (via stdin) and process its output (stdout)
			Command *string `json:"command,omitempty"`

			// Disabled Enable Custom Command
			Disabled RunnableJobCollectionInputPreprocessDisabled `json:"disabled"`
		} `json:"preprocess,omitempty"`

		// SendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
		SendToRoutes *RunnableJobCollectionInputSendToRoutes `json:"sendToRoutes,omitempty"`

		// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
		StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

		// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
		ThrottleRatePerSec *string                         `json:"throttleRatePerSec,omitempty"`
		Type               *RunnableJobCollectionInputType `json:"type,omitempty"`
	} `json:"input,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`
	Run          struct {
		Capture *struct {
			Level *RunnableJobCollectionRunCaptureLevel `json:"level,omitempty"`

			// MaxEvents Maximum number of events to capture
			MaxEvents *float32 `json:"maxEvents,omitempty"`
		} `json:"capture,omitempty"`

		// DiscoverToRoutes Send discover results to Routes
		DiscoverToRoutes *bool `json:"discoverToRoutes,omitempty"`

		// Earliest Earliest time to collect data for the selected timezone
		Earliest *float32 `json:"earliest,omitempty"`

		// Expression A filter for tokens in the provided collect path and/or the events being collected
		Expression *string `json:"expression,omitempty"`

		// JobTimeout Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
		JobTimeout *string `json:"jobTimeout,omitempty"`

		// Latest Latest time to collect data for the selected timezone
		Latest *float32 `json:"latest,omitempty"`

		// LogLevel Level at which to set task logging
		LogLevel *RunnableJobCollectionRunLogLevel `json:"logLevel,omitempty"`

		// MaxTaskReschedule Maximum number of times a task can be rescheduled
		MaxTaskReschedule *float32 `json:"maxTaskReschedule,omitempty"`

		// MaxTaskSize Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,
		//         you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
		MaxTaskSize *string `json:"maxTaskSize,omitempty"`

		// MinTaskSize Limits the bundle size for small tasks. For example,
		//         if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
		MinTaskSize *string `json:"minTaskSize,omitempty"`

		// Mode Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
		Mode RunnableJobCollectionRunMode `json:"mode"`

		// RescheduleDroppedTasks Reschedule tasks that failed with non-fatal errors
		RescheduleDroppedTasks *bool                                  `json:"rescheduleDroppedTasks,omitempty"`
		TimeRangeType          *RunnableJobCollectionRunTimeRangeType `json:"timeRangeType,omitempty"`
		TimeWarning            *map[string]interface{}                `json:"timeWarning,omitempty"`

		// TimestampTimezone Timezone to use for Earliest and Latest times
		TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	} `json:"run"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *RunnableJobCollectionScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                    `json:"ttl,omitempty"`
	Type *RunnableJobCollectionType `json:"type,omitempty"`

	// WorkerAffinity If enabled, tasks are created and run by the same Worker Node
	WorkerAffinity *bool `json:"workerAffinity,omitempty"`
}

// RunnableJobCollectionInputPreprocessDisabled Enable Custom Command
type RunnableJobCollectionInputPreprocessDisabled bool

// RunnableJobCollectionInputSendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
type RunnableJobCollectionInputSendToRoutes bool

// RunnableJobCollectionInputType defines model for RunnableJobCollection.Input.Type.
type RunnableJobCollectionInputType string

// RunnableJobCollectionRunCaptureLevel defines model for RunnableJobCollection.Run.Capture.Level.
type RunnableJobCollectionRunCaptureLevel string

// RunnableJobCollectionRunLogLevel Level at which to set task logging
type RunnableJobCollectionRunLogLevel string

// RunnableJobCollectionRunMode Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
type RunnableJobCollectionRunMode string

// RunnableJobCollectionRunTimeRangeType defines model for RunnableJobCollection.Run.TimeRangeType.
type RunnableJobCollectionRunTimeRangeType string

// RunnableJobCollectionScheduleEnabled Enable to configure scheduling for this Collector
type RunnableJobCollectionScheduleEnabled bool

// RunnableJobCollectionType defines model for RunnableJobCollection.Type.
type RunnableJobCollectionType string

// RunnableJobExecutor defines model for RunnableJobExecutor.
type RunnableJobExecutor struct {
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Executor    struct {
		Conf *map[string]interface{} `json:"conf,omitempty"`

		// StoreTaskResults Determines whether or not to write task results to disk
		StoreTaskResults *bool `json:"storeTaskResults,omitempty"`

		// Type The type of executor to run
		Type string `json:"type"`
	} `json:"executor"`

	// Id Unique ID for this Job
	Id *string `json:"id,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`
	Run          struct {
		// JobTimeout Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
		JobTimeout *string `json:"jobTimeout,omitempty"`

		// LogLevel Level at which to set task logging
		LogLevel *RunnableJobExecutorRunLogLevel `json:"logLevel,omitempty"`

		// MaxTaskReschedule Maximum number of times a task can be rescheduled
		MaxTaskReschedule *float32 `json:"maxTaskReschedule,omitempty"`

		// RescheduleDroppedTasks Reschedule tasks that failed with non-fatal errors
		RescheduleDroppedTasks *bool `json:"rescheduleDroppedTasks,omitempty"`
	} `json:"run"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *RunnableJobExecutorScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                  `json:"ttl,omitempty"`
	Type *RunnableJobExecutorType `json:"type,omitempty"`
}

// RunnableJobExecutorRunLogLevel Level at which to set task logging
type RunnableJobExecutorRunLogLevel string

// RunnableJobExecutorScheduleEnabled Enable to configure scheduling for this Collector
type RunnableJobExecutorScheduleEnabled bool

// RunnableJobExecutorType defines model for RunnableJobExecutor.Type.
type RunnableJobExecutorType string

// RunnableJobScheduledSearch defines model for RunnableJobScheduledSearch.
type RunnableJobScheduledSearch struct {
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this Job
	Id *string `json:"id,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`

	// SavedQueryId Identifies which search query to run
	SavedQueryId string `json:"savedQueryId"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *RunnableJobScheduledSearchScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                        `json:"ttl,omitempty"`
	Type RunnableJobScheduledSearchType `json:"type"`
}

// RunnableJobScheduledSearchScheduleEnabled Enable to configure scheduling for this Collector
type RunnableJobScheduledSearchScheduleEnabled bool

// RunnableJobScheduledSearchType defines model for RunnableJobScheduledSearch.Type.
type RunnableJobScheduledSearchType string

// SECRETPROVIDER defines model for SECRET_PROVIDER.
type SECRETPROVIDER string

// SampleContent defines model for SampleContent.
type SampleContent = []map[string]interface{}

// SampleFile defines model for SampleFile.
type SampleFile struct {
	Bytes     string  `json:"bytes"`
	BytesRead float32 `json:"bytesRead"`
	Length    float32 `json:"length"`
}

// SavedJob defines model for SavedJob.
type SavedJob struct {
	Union json.RawMessage
}

// SavedJobCollection defines model for SavedJobCollection.
type SavedJobCollection struct {
	Collector struct {
		Conf map[string]interface{} `json:"conf"`

		// Destructive If set to Yes, the collector will delete any files that it collects (where applicable)
		Destructive *bool `json:"destructive,omitempty"`

		// Encoding Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
		Encoding *string `json:"encoding,omitempty"`

		// Type The type of collector to run
		Type string `json:"type"`
	} `json:"collector"`
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this Job
	Id    *string `json:"id,omitempty"`
	Input *struct {
		// BreakerRulesets A list of event-breaking rulesets that will be applied, in order, to the input data stream
		BreakerRulesets *[]string `json:"breakerRulesets,omitempty"`

		// Metadata Fields to add to events from this input
		Metadata *[]struct {
			// Name Field name
			Name string `json:"name"`

			// Value JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
			Value string `json:"value"`
		} `json:"metadata,omitempty"`

		// Output Destination to send results to
		Output *string `json:"output,omitempty"`

		// Pipeline Pipeline to process results
		Pipeline   *string `json:"pipeline,omitempty"`
		Preprocess *struct {
			// Args Arguments to be added to the custom command
			Args *[]string `json:"args,omitempty"`

			// Command Command to feed the data through (via stdin) and process its output (stdout)
			Command *string `json:"command,omitempty"`

			// Disabled Enable Custom Command
			Disabled SavedJobCollectionInputPreprocessDisabled `json:"disabled"`
		} `json:"preprocess,omitempty"`

		// SendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
		SendToRoutes *SavedJobCollectionInputSendToRoutes `json:"sendToRoutes,omitempty"`

		// StaleChannelFlushMs How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
		StaleChannelFlushMs *float32 `json:"staleChannelFlushMs,omitempty"`

		// ThrottleRatePerSec Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
		ThrottleRatePerSec *string                      `json:"throttleRatePerSec,omitempty"`
		Type               *SavedJobCollectionInputType `json:"type,omitempty"`
	} `json:"input,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *SavedJobCollectionScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                `json:"ttl,omitempty"`
	Type SavedJobCollectionType `json:"type"`

	// WorkerAffinity If enabled, tasks are created and run by the same Worker Node
	WorkerAffinity *bool `json:"workerAffinity,omitempty"`
}

// SavedJobCollectionInputPreprocessDisabled Enable Custom Command
type SavedJobCollectionInputPreprocessDisabled bool

// SavedJobCollectionInputSendToRoutes If set to Yes, events will be sent to normal routing and event processing. Set to No if you want to select a specific Pipeline/Destination combination.
type SavedJobCollectionInputSendToRoutes bool

// SavedJobCollectionInputType defines model for SavedJobCollection.Input.Type.
type SavedJobCollectionInputType string

// SavedJobCollectionScheduleEnabled Enable to configure scheduling for this Collector
type SavedJobCollectionScheduleEnabled bool

// SavedJobCollectionType defines model for SavedJobCollection.Type.
type SavedJobCollectionType string

// SavedJobExecutor defines model for SavedJobExecutor.
type SavedJobExecutor struct {
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	Executor    struct {
		Conf *map[string]interface{} `json:"conf,omitempty"`

		// StoreTaskResults Determines whether or not to write task results to disk
		StoreTaskResults *bool `json:"storeTaskResults,omitempty"`

		// Type The type of executor to run
		Type string `json:"type"`
	} `json:"executor"`

	// Id Unique ID for this Job
	Id *string `json:"id,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *SavedJobExecutorScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string              `json:"ttl,omitempty"`
	Type SavedJobExecutorType `json:"type"`
}

// SavedJobExecutorScheduleEnabled Enable to configure scheduling for this Collector
type SavedJobExecutorScheduleEnabled bool

// SavedJobExecutorType defines model for SavedJobExecutor.Type.
type SavedJobExecutorType string

// SavedJobScheduledSearch defines model for SavedJobScheduledSearch.
type SavedJobScheduledSearch struct {
	Description *string `json:"description,omitempty"`

	// Environment Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`

	// Id Unique ID for this Job
	Id *string `json:"id,omitempty"`

	// RemoveFields List of fields to remove from Discover results. Wildcards (for example, aws*) are allowed. This is useful when discovery returns sensitive fields that should not be exposed in the Jobs user interface.
	RemoveFields *[]string `json:"removeFields,omitempty"`

	// ResumeOnBoot Resumes the ad hoc job if a failure condition causes Stream to restart during job execution
	ResumeOnBoot *bool `json:"resumeOnBoot,omitempty"`

	// SavedQueryId Identifies which search query to run
	SavedQueryId string `json:"savedQueryId"`

	// Schedule Configuration for a scheduled job
	Schedule *struct {
		// CronSchedule A cron schedule on which to run this job
		CronSchedule *string `json:"cronSchedule,omitempty"`

		// Enabled Enable to configure scheduling for this Collector
		Enabled *SavedJobScheduledSearchScheduleEnabled `json:"enabled,omitempty"`

		// MaxConcurrentRuns The maximum number of instances of this scheduled job that may be running at any time
		MaxConcurrentRuns *float32                `json:"maxConcurrentRuns,omitempty"`
		ResumeMissed      *interface{}            `json:"resumeMissed,omitempty"`
		Run               *map[string]interface{} `json:"run,omitempty"`

		// Skippable Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
		Skippable *bool `json:"skippable,omitempty"`
	} `json:"schedule,omitempty"`

	// Streamtags Tags for filtering and grouping in @{product}
	Streamtags *[]string `json:"streamtags,omitempty"`

	// Ttl Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
	Ttl  *string                     `json:"ttl,omitempty"`
	Type SavedJobScheduledSearchType `json:"type"`
}

// SavedJobScheduledSearchScheduleEnabled Enable to configure scheduling for this Collector
type SavedJobScheduledSearchScheduleEnabled bool

// SavedJobScheduledSearchType defines model for SavedJobScheduledSearch.Type.
type SavedJobScheduledSearchType string

// SavedQuery defines model for SavedQuery.
type SavedQuery struct {
	ChartConfig        *ChartConfig        `json:"chartConfig,omitempty"`
	Description        *string             `json:"description,omitempty"`
	DisplayUsername    *string             `json:"displayUsername,omitempty"`
	Earliest           *string             `json:"earliest,omitempty"`
	Id                 string              `json:"id"`
	IsPrivate          *bool               `json:"isPrivate,omitempty"`
	IsSystem           *bool               `json:"isSystem,omitempty"`
	Latest             *string             `json:"latest,omitempty"`
	Lib                *CriblLib           `json:"lib,omitempty"`
	Name               string              `json:"name"`
	Query              string              `json:"query"`
	ResolvedDatasetIds *[]string           `json:"resolvedDatasetIds,omitempty"`
	SampleRate         *float32            `json:"sampleRate,omitempty"`
	Schedule           *SavedQuerySchedule `json:"schedule,omitempty"`
	TableConfig        *Object             `json:"tableConfig,omitempty"`
	User               *string             `json:"user,omitempty"`
}

// SavedQuerySchedule defines model for SavedQuerySchedule.
type SavedQuerySchedule struct {
	CronSchedule  string  `json:"cronSchedule"`
	Enabled       bool    `json:"enabled"`
	KeepLastN     float32 `json:"keepLastN"`
	Notifications struct {
		Disabled bool            `json:"disabled"`
		Items    *[]Notification `json:"items,omitempty"`
	} `json:"notifications"`
	ResumeMissed *bool  `json:"resumeMissed,omitempty"`
	ResumeOnBoot *bool  `json:"resumeOnBoot,omitempty"`
	Tz           string `json:"tz"`
}

// SavesSearchRunMode defines model for SavesSearchRunMode.
type SavesSearchRunMode string

// SchemaLibEntry defines model for SchemaLibEntry.
type SchemaLibEntry struct {
	Description *string `json:"description,omitempty"`
	Id          string  `json:"id"`

	// Schema JSON schema matching standards of draft version 2019-09
	Schema               string                 `json:"schema"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ScriptLibEntry defines model for ScriptLibEntry.
type ScriptLibEntry struct {
	// Args Arguments to pass when executing this script
	Args *[]string `json:"args,omitempty"`

	// Command Command to execute for this script
	Command     string  `json:"command"`
	Description *string `json:"description,omitempty"`

	// Env Extra environment variables to set when executing script
	Env                  *map[string]string     `json:"env,omitempty"`
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SearchAggMode defines model for SearchAggMode.
type SearchAggMode string

// SearchAuditMetrics defines model for SearchAuditMetrics.
type SearchAuditMetrics struct {
	BytesIn   float32 `json:"bytesIn"`
	BytesOut  float32 `json:"bytesOut"`
	EventsIn  float32 `json:"eventsIn"`
	EventsOut float32 `json:"eventsOut"`
	Objects   struct {
		Discovered float32 `json:"discovered"`
		Scanned    float32 `json:"scanned"`
		Skipped    float32 `json:"skipped"`
	} `json:"objects"`
	Time struct {
		QueuedSec              float32 `json:"queuedSec"`
		RunningSec             float32 `json:"runningSec"`
		TaskCompletionTotalSec float32 `json:"taskCompletionTotalSec"`
		TaskReceivingTotalSec  float32 `json:"taskReceivingTotalSec"`
	} `json:"time"`
}

// SearchConfig defines model for SearchConfig.
type SearchConfig struct {
	CanComputeMetadataDistributively *bool          `json:"canComputeMetadataDistributively,omitempty"`
	Datasets                         []string       `json:"datasets"`
	HasSendOperator                  bool           `json:"hasSendOperator"`
	OrderedFieldNames                []string       `json:"orderedFieldNames"`
	ReferencedFieldNames             *[]string      `json:"referencedFieldNames,omitempty"`
	SearchTerms                      []SearchTerm   `json:"searchTerms"`
	SortFields                       *[]SortByField `json:"sortFields,omitempty"`
	UseFormattedVisualization        bool           `json:"useFormattedVisualization"`
}

// SearchDashboard defines model for SearchDashboard.
type SearchDashboard struct {
	CacheTTLSeconds    *float32                        `json:"cacheTTLSeconds,omitempty"`
	Category           *string                         `json:"category,omitempty"`
	Created            float32                         `json:"created"`
	CreatedBy          string                          `json:"createdBy"`
	Description        *string                         `json:"description,omitempty"`
	DisplayCreatedBy   *string                         `json:"displayCreatedBy,omitempty"`
	DisplayModifiedBy  *string                         `json:"displayModifiedBy,omitempty"`
	Elements           []SearchDashboard_Elements_Item `json:"elements"`
	Id                 string                          `json:"id"`
	Modified           float32                         `json:"modified"`
	ModifiedBy         *string                         `json:"modifiedBy,omitempty"`
	Name               string                          `json:"name"`
	PackId             *string                         `json:"packId,omitempty"`
	RefreshRate        *float32                        `json:"refreshRate,omitempty"`
	ResolvedDatasetIds *[]string                       `json:"resolvedDatasetIds,omitempty"`
	Schedule           *SavedQuerySchedule             `json:"schedule,omitempty"`
}

// SearchDashboardElements0 defines model for .
type SearchDashboardElements0 struct {
	Description     *string                  `json:"description,omitempty"`
	Empty           *bool                    `json:"empty,omitempty"`
	HidePanel       *bool                    `json:"hidePanel,omitempty"`
	HorizontalChart *bool                    `json:"horizontalChart,omitempty"`
	Id              string                   `json:"id"`
	Index           *float32                 `json:"index,omitempty"`
	InputId         *string                  `json:"inputId,omitempty"`
	Layout          DashboardLayout          `json:"layout"`
	Search          SearchQuery              `json:"search"`
	Title           *string                  `json:"title,omitempty"`
	Type            DashboardElementType     `json:"type"`
	Value           *map[string]interface{}  `json:"value,omitempty"`
	Variant         *DashboardElementVariant `json:"variant,omitempty"`
}

// SearchDashboardElements1 defines model for .
type SearchDashboardElements1 struct {
	Description *string                         `json:"description,omitempty"`
	Empty       *bool                           `json:"empty,omitempty"`
	HidePanel   *bool                           `json:"hidePanel,omitempty"`
	Id          string                          `json:"id"`
	Index       *float32                        `json:"index,omitempty"`
	Layout      DashboardLayout                 `json:"layout"`
	Title       *string                         `json:"title,omitempty"`
	Type        SearchDashboardElements1Type    `json:"type"`
	Value       *string                         `json:"value,omitempty"`
	Variant     SearchDashboardElements1Variant `json:"variant"`
}

// SearchDashboardElements1Type defines model for SearchDashboard.Elements.1.Type.
type SearchDashboardElements1Type string

// SearchDashboardElements1Variant defines model for SearchDashboard.Elements.1.Variant.
type SearchDashboardElements1Variant string

// SearchDashboard_Elements_Item defines model for SearchDashboard.elements.Item.
type SearchDashboard_Elements_Item struct {
	Union json.RawMessage
}

// SearchEvent defines model for SearchEvent.
type SearchEvent = interface{}

// SearchHealthCheckStatus defines model for SearchHealthCheckStatus.
type SearchHealthCheckStatus struct {
	ReportedAt float32                       `json:"reported_at"`
	Status     SearchHealthCheckStatusStatus `json:"status"`
}

// SearchHealthCheckStatusStatus defines model for SearchHealthCheckStatus.Status.
type SearchHealthCheckStatusStatus string

// SearchJob defines model for SearchJob.
type SearchJob struct {
	Accelerated          *bool   `json:"accelerated,omitempty"`
	AliasOfOriginalJobId *string `json:"aliasOfOriginalJobId,omitempty"`
	CompatibilityChecks  *struct {
		Datatypes *bool     `json:"datatypes,omitempty"`
		StageIds  *[]string `json:"stageIds,omitempty"`
	} `json:"compatibilityChecks,omitempty"`
	CompletionInfo              *string                    `json:"completionInfo,omitempty"`
	Context                     *string                    `json:"context,omitempty"`
	CorrelationId               *string                    `json:"correlationId,omitempty"`
	CpuMetrics                  *CPUTimeMetric             `json:"cpuMetrics,omitempty"`
	DatatypeOverrides           *DatatypeOverrides         `json:"datatypeOverrides,omitempty"`
	DisableNotifications        *bool                      `json:"disableNotifications,omitempty"`
	DisplayUsername             string                     `json:"displayUsername"`
	Earliest                    *SearchJob_Earliest        `json:"earliest,omitempty"`
	EarliestEpoch               *float32                   `json:"earliestEpoch,omitempty"`
	ErrorStateConfig            *SearchJobErrorStateConfig `json:"errorStateConfig,omitempty"`
	Group                       string                     `json:"group"`
	Id                          string                     `json:"id"`
	IsPrivate                   *bool                      `json:"isPrivate,omitempty"`
	Latest                      *SearchJob_Latest          `json:"latest,omitempty"`
	LatestEpoch                 *float32                   `json:"latestEpoch,omitempty"`
	Metadata                    *SearchJobMetadata         `json:"metadata,omitempty"`
	NumEventsAfter              *float32                   `json:"numEventsAfter,omitempty"`
	NumEventsBefore             *float32                   `json:"numEventsBefore,omitempty"`
	Query                       string                     `json:"query"`
	QueryWithMacrosResolved     *string                    `json:"queryWithMacrosResolved,omitempty"`
	SampleRate                  *float32                   `json:"sampleRate,omitempty"`
	SavedQueryName              *string                    `json:"savedQueryName,omitempty"`
	SearchParameterDeclarations *[]SearchParameter         `json:"searchParameterDeclarations,omitempty"`
	SearchParameterValues       *SearchParameters          `json:"searchParameterValues,omitempty"`
	Stages                      *[]SearchJobStageConfig    `json:"stages,omitempty"`
	Status                      SearchJobStatus            `json:"status"`
	TableConfig                 *TableViewSettings         `json:"tableConfig,omitempty"`
	TargetEventTime             *float32                   `json:"targetEventTime,omitempty"`
	TimeCompleted               *float32                   `json:"timeCompleted,omitempty"`
	TimeCreated                 float32                    `json:"timeCreated"`
	TimeStarted                 float32                    `json:"timeStarted"`
	TimeToFirstByte             *float32                   `json:"timeToFirstByte,omitempty"`
	TotalBytesScanned           *float32                   `json:"totalBytesScanned,omitempty"`
	TotalEventCount             *float32                   `json:"totalEventCount,omitempty"`
	Type                        *SearchJobType             `json:"type,omitempty"`
	UsageGroupId                *string                    `json:"usageGroupId,omitempty"`
	UsageMetrics                *SearchAuditMetrics        `json:"usageMetrics,omitempty"`
	User                        string                     `json:"user"`
}

// SearchJobEarliest0 defines model for .
type SearchJobEarliest0 = string

// SearchJobEarliest1 defines model for .
type SearchJobEarliest1 = float32

// SearchJob_Earliest defines model for SearchJob.Earliest.
type SearchJob_Earliest struct {
	Union json.RawMessage
}

// SearchJobLatest0 defines model for .
type SearchJobLatest0 = string

// SearchJobLatest1 defines model for .
type SearchJobLatest1 = float32

// SearchJob_Latest defines model for SearchJob.Latest.
type SearchJob_Latest struct {
	Union json.RawMessage
}

// SearchJobStatus defines model for SearchJob.Status.
type SearchJobStatus string

// SearchJobType defines model for SearchJob.Type.
type SearchJobType string

// SearchJobErrorStateConfig defines model for SearchJobErrorStateConfig.
type SearchJobErrorStateConfig struct {
	Coordinated   bool     `json:"coordinated"`
	ErrorMessages []string `json:"errorMessages"`
}

// SearchJobMetadata defines model for SearchJobMetadata.
type SearchJobMetadata = map[string]interface{}

// SearchJobResults defines model for SearchJobResults.
type SearchJobResults struct {
	IsFinished          bool                    `json:"isFinished"`
	Job                 SearchJobResultsJobInfo `json:"job"`
	Limit               float32                 `json:"limit"`
	Offset              float32                 `json:"offset"`
	PersistedEventCount float32                 `json:"persistedEventCount"`
	TotalEventCount     float32                 `json:"totalEventCount"`
}

// SearchJobResultsJobInfo defines model for SearchJobResultsJobInfo.
type SearchJobResultsJobInfo = interface{}

// SearchJobStageConfig defines model for SearchJobStageConfig.
type SearchJobStageConfig struct {
	CacheStatusByDatasetId *CacheStatusByDatasetId        `json:"cacheStatusByDatasetId,omitempty"`
	Earliest               *SearchJobStageConfig_Earliest `json:"earliest,omitempty"`
	ExecutionWarnings      *[]JobExecutionWarning         `json:"executionWarnings,omitempty"`
	Filter                 string                         `json:"filter"`
	Id                     string                         `json:"id"`
	Latest                 *SearchJobStageConfig_Latest   `json:"latest,omitempty"`
	ResolvedDatasetIds     []string                       `json:"resolvedDatasetIds"`
	SearchConfig           SearchConfig                   `json:"searchConfig"`
	Status                 SearchJobStageConfigStatus     `json:"status"`
	SubQueryText           string                         `json:"subQueryText"`
}

// SearchJobStageConfigEarliest0 defines model for .
type SearchJobStageConfigEarliest0 = string

// SearchJobStageConfigEarliest1 defines model for .
type SearchJobStageConfigEarliest1 = float32

// SearchJobStageConfig_Earliest defines model for SearchJobStageConfig.Earliest.
type SearchJobStageConfig_Earliest struct {
	Union json.RawMessage
}

// SearchJobStageConfigLatest0 defines model for .
type SearchJobStageConfigLatest0 = string

// SearchJobStageConfigLatest1 defines model for .
type SearchJobStageConfigLatest1 = float32

// SearchJobStageConfig_Latest defines model for SearchJobStageConfig.Latest.
type SearchJobStageConfig_Latest struct {
	Union json.RawMessage
}

// SearchJobStageConfigStatus defines model for SearchJobStageConfig.Status.
type SearchJobStageConfigStatus string

// SearchMacro defines model for SearchMacro.
type SearchMacro struct {
	Created     *float32 `json:"created,omitempty"`
	CreatedBy   *string  `json:"createdBy,omitempty"`
	Description *string  `json:"description,omitempty"`
	Id          string   `json:"id"`
	Modified    *float32 `json:"modified,omitempty"`
	Replacement string   `json:"replacement"`
	Tags        *string  `json:"tags,omitempty"`
}

// SearchParameter defines model for SearchParameter.
type SearchParameter struct {
	DefaultValue *SearchParameterValue `json:"defaultValue,omitempty"`
	Name         string                `json:"name"`
	Type         SearchParameterType   `json:"type"`
}

// SearchParameterType defines model for SearchParameterType.
type SearchParameterType string

// SearchParameterValue defines model for SearchParameterValue.
type SearchParameterValue struct {
	Union json.RawMessage
}

// SearchParameterValue0 defines model for .
type SearchParameterValue0 = string

// SearchParameterValue1 defines model for .
type SearchParameterValue1 = float32

// SearchParameterValue2 defines model for .
type SearchParameterValue2 = bool

// SearchParameters defines model for SearchParameters.
type SearchParameters = interface{}

// SearchQuery defines model for SearchQuery.
type SearchQuery struct {
	Union json.RawMessage
}

// SearchQuery0 defines model for .
type SearchQuery0 struct {
	Query   *string             `json:"query,omitempty"`
	QueryId string              `json:"queryId"`
	RunMode *SavesSearchRunMode `json:"runMode,omitempty"`
	Type    SearchQuery0Type    `json:"type"`
}

// SearchQuery0Type defines model for SearchQuery.0.Type.
type SearchQuery0Type string

// SearchQuery1 defines model for .
type SearchQuery1 struct {
	Earliest       *SearchQuery_1_Earliest `json:"earliest"`
	Latest         *SearchQuery_1_Latest   `json:"latest"`
	ParentSearchId *string                 `json:"parentSearchId,omitempty"`
	Query          *SearchQuery_1_Query    `json:"query"`
	SampleRate     *float32                `json:"sampleRate,omitempty"`
	Timezone       *string                 `json:"timezone,omitempty"`
	Type           SearchQuery1Type        `json:"type"`
}

// SearchQuery1Earliest0 defines model for .
type SearchQuery1Earliest0 = string

// SearchQuery1Earliest1 defines model for .
type SearchQuery1Earliest1 = float32

// SearchQuery_1_Earliest defines model for SearchQuery.1.Earliest.
type SearchQuery_1_Earliest struct {
	Union json.RawMessage
}

// SearchQuery1Latest0 defines model for .
type SearchQuery1Latest0 = string

// SearchQuery1Latest1 defines model for .
type SearchQuery1Latest1 = float32

// SearchQuery_1_Latest defines model for SearchQuery.1.Latest.
type SearchQuery_1_Latest struct {
	Union json.RawMessage
}

// SearchQuery1Query0 defines model for .
type SearchQuery1Query0 = string

// SearchQuery_1_Query defines model for SearchQuery.1.Query.
type SearchQuery_1_Query struct {
	Union json.RawMessage
}

// SearchQuery1Type defines model for SearchQuery.1.Type.
type SearchQuery1Type string

// SearchQuery2 defines model for .
type SearchQuery2 struct {
	Type   SearchQuery2Type `json:"type"`
	Values []string         `json:"values"`
}

// SearchQuery2Type defines model for SearchQuery.2.Type.
type SearchQuery2Type string

// SearchSettings defines model for SearchSettings.
type SearchSettings struct {
	CompressObjectCacheArtifacts bool                             `json:"compressObjectCacheArtifacts"`
	FieldSummaryMaxFields        float32                          `json:"fieldSummaryMaxFields"`
	FieldSummaryMaxNestedDepth   float32                          `json:"fieldSummaryMaxNestedDepth"`
	MaxConcurrentSearches        MaxConcurrentSearchesType        `json:"maxConcurrentSearches"`
	MaxExecutorsPerSearch        float32                          `json:"maxExecutorsPerSearch"`
	MaxResultsPerSearch          float32                          `json:"maxResultsPerSearch"`
	SearchHistoryMaxJobs         float32                          `json:"searchHistoryMaxJobs"`
	SearchQueueLength            SearchSettings_SearchQueueLength `json:"searchQueueLength"`
	WarmPoolSize                 SearchSettings_WarmPoolSize      `json:"warmPoolSize"`
	WriteOnlyProviderSecrets     bool                             `json:"writeOnlyProviderSecrets"`
}

// SearchSettingsSearchQueueLength0 defines model for .
type SearchSettingsSearchQueueLength0 = float32

// SearchSettings_SearchQueueLength defines model for SearchSettings.SearchQueueLength.
type SearchSettings_SearchQueueLength struct {
	Union json.RawMessage
}

// SearchSettingsWarmPoolSize0 defines model for .
type SearchSettingsWarmPoolSize0 = float32

// SearchSettingsWarmPoolSize1 defines model for .
type SearchSettingsWarmPoolSize1 = interface{}

// SearchSettings_WarmPoolSize defines model for SearchSettings.WarmPoolSize.
type SearchSettings_WarmPoolSize struct {
	Union json.RawMessage
}

// SearchTerm defines model for SearchTerm.
type SearchTerm struct {
	IsCaseSensitive bool   `json:"isCaseSensitive"`
	Term            string `json:"term"`
}

// SecretType defines model for SecretType.
type SecretType string

// SendDiagBundle defines model for SendDiagBundle.
type SendDiagBundle struct {
	// IncludeGit Disable to exclude the git audit from the bundle
	IncludeGit *bool `json:"includeGit,omitempty"`

	// IncludeInstallLogs Enable to include installation logs in the bundle (Windows only)
	IncludeInstallLogs *bool `json:"includeInstallLogs,omitempty"`

	// IncludeMetrics Disable to exclude metrics from the bundle
	IncludeMetrics *bool `json:"includeMetrics,omitempty"`

	// MaxIncludeJobs Number of jobs, including all tasks that will be included in the bundle
	MaxIncludeJobs *float32 `json:"maxIncludeJobs,omitempty"`

	// Path Existing bundle that will be sent to Cribl Support. Max 100MB.
	Path *string `json:"path,omitempty"`

	// RenameJs Append .txt to JavaScript files
	RenameJs *bool `json:"renameJs,omitempty"`

	// SendToCribl Send diagnostic bundle to Cribl Support
	SendToCribl *bool `json:"sendToCribl,omitempty"`
}

// ServiceHealthStatus defines model for ServiceHealthStatus.
type ServiceHealthStatus struct {
	CpuPerc    *float32                  `json:"cpuPerc,omitempty"`
	NumSockets *float32                  `json:"numSockets,omitempty"`
	StartTime  float32                   `json:"startTime"`
	Status     ServiceHealthStatusStatus `json:"status"`
}

// ServiceHealthStatusStatus defines model for ServiceHealthStatus.Status.
type ServiceHealthStatusStatus string

// ServicesLimits defines model for ServicesLimits.
type ServicesLimits struct {
	Connections   CommonServiceLimitConfigs `json:"connections"`
	Metrics       CommonServiceLimitConfigs `json:"metrics"`
	Notifications CommonServiceLimitConfigs `json:"notifications"`
}

// SortByField defines model for SortByField.
type SortByField struct {
	Direction    SortByFieldDirection    `json:"direction"`
	FieldName    string                  `json:"fieldName"`
	NullPosition SortByFieldNullPosition `json:"nullPosition"`
}

// SortByFieldDirection defines model for SortByField.Direction.
type SortByFieldDirection string

// SortByFieldNullPosition defines model for SortByField.NullPosition.
type SortByFieldNullPosition string

// State defines model for State.
type State map[string]interface{}

// Subscription defines model for Subscription.
type Subscription struct {
	Consumer    *SubscriptionConsumer `json:"consumer,omitempty"`
	Description *string               `json:"description,omitempty"`
	Disabled    *bool                 `json:"disabled,omitempty"`
	Filter      *string               `json:"filter,omitempty"`
	Id          string                `json:"id"`
	Pipeline    string                `json:"pipeline"`
}

// SubscriptionConsumer defines model for SubscriptionConsumer.
type SubscriptionConsumer struct {
	Connections *[]Connection `json:"connections,omitempty"`
	Disabled    *bool         `json:"disabled,omitempty"`
	Type        *string       `json:"type,omitempty"`
}

// SymLinkInfo defines model for SymLinkInfo.
type SymLinkInfo struct {
	SymLinkTarget             string `json:"symLinkTarget"`
	SymLinkTargetAbsolutePath string `json:"symLinkTargetAbsolutePath"`
	SymLinkTargetIsDirectory  *bool  `json:"symLinkTargetIsDirectory,omitempty"`
	SymLinkTargetIsFile       *bool  `json:"symLinkTargetIsFile,omitempty"`
}

// SystemConf defines model for SystemConf.
type SystemConf struct {
	InstallType string `json:"installType"`
	Restart     string `json:"restart"`
	Upgrade     string `json:"upgrade"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	BUILD   map[string]interface{} `json:"BUILD"`
	ApiPort float32                `json:"apiPort"`
	Conf    struct {
		ConfVersion *string `json:"confVersion,omitempty"`
		Inputs      float32 `json:"inputs"`
		Name        *string `json:"name,omitempty"`
		Outputs     float32 `json:"outputs"`
		Pipelines   float32 `json:"pipelines"`
		Routes      float32 `json:"routes"`
		Rules       float32 `json:"rules"`
	} `json:"conf"`
	ConfigPath string `json:"configPath"`
	Cpus       []struct {
		Model string                 `json:"model"`
		Speed float32                `json:"speed"`
		Times map[string]interface{} `json:"times"`
	} `json:"cpus"`
	DiskUsage struct {
		BytesAvailable float32 `json:"bytesAvailable"`
		BytesUsed      float32 `json:"bytesUsed"`
		DiskPath       string  `json:"diskPath"`
		TotalDiskSize  float32 `json:"totalDiskSize"`
	} `json:"diskUsage"`
	DistMode          AppMode                `json:"distMode"`
	Env               map[string]interface{} `json:"env"`
	Guid              string                 `json:"guid"`
	HasCloudWorkspace *bool                  `json:"hasCloudWorkspace,omitempty"`
	Hostname          string                 `json:"hostname"`
	InstallPath       string                 `json:"installPath"`
	IsCriblSandbox    *bool                  `json:"isCriblSandbox,omitempty"`
	IsFedRampEnabled  *bool                  `json:"isFedRampEnabled,omitempty"`
	IsFipsEnabled     *bool                  `json:"isFipsEnabled,omitempty"`
	License           LicenseInfo            `json:"license"`
	Limits            struct {
		Samples struct {
			MaxSize string `json:"maxSize"`
		} `json:"samples"`
	} `json:"limits"`
	Loadavg []float32 `json:"loadavg"`
	Memory  struct {
		Free  float32 `json:"free"`
		Total float32 `json:"total"`
	} `json:"memory"`
	Messages []BulletinMessage      `json:"messages"`
	Net      map[string]interface{} `json:"net"`
	Os       struct {
		Arch       string `json:"arch"`
		Endianness string `json:"endianness"`
		Platform   string `json:"platform"`
		Release    string `json:"release"`
		Type       string `json:"type"`
	} `json:"os"`
	SystemConf      SystemConf `json:"systemConf"`
	Uptime          float32    `json:"uptime"`
	Version         string     `json:"version"`
	WorkerProcesses float32    `json:"workerProcesses"`
}

// SystemSettings defines model for SystemSettings.
type SystemSettings struct {
	Api struct {
		BaseUrl         *string                 `json:"baseUrl,omitempty"`
		DisableApiCache *bool                   `json:"disableApiCache,omitempty"`
		Disabled        bool                    `json:"disabled"`
		Headers         *map[string]interface{} `json:"headers,omitempty"`
		Host            string                  `json:"host"`
		IdleSessionTTL  *float32                `json:"idleSessionTTL,omitempty"`
		LoginRateLimit  *string                 `json:"loginRateLimit,omitempty"`
		Port            float32                 `json:"port"`
		Protocol        string                  `json:"protocol"`
		Scripts         *bool                   `json:"scripts,omitempty"`
		SensitiveFields *[]string               `json:"sensitiveFields,omitempty"`
		Ssl             struct {
			CaPath      *string `json:"caPath,omitempty"`
			CertPath    string  `json:"certPath"`
			Disabled    bool    `json:"disabled"`
			Passphrase  string  `json:"passphrase"`
			PrivKeyPath string  `json:"privKeyPath"`
		} `json:"ssl"`
		SsoRateLimit       *string `json:"ssoRateLimit,omitempty"`
		WorkerRemoteAccess bool    `json:"workerRemoteAccess"`
	} `json:"api"`
	Auth    AuthConfig `json:"auth"`
	Backups struct {
		BackupPersistence string `json:"backupPersistence"`
		BackupsDirectory  string `json:"backupsDirectory"`
	} `json:"backups"`
	CustomLogo struct {
		Enabled         bool   `json:"enabled"`
		LogoDescription string `json:"logoDescription"`
		LogoImage       string `json:"logoImage"`
	} `json:"customLogo"`
	Distributed struct {
		Mode AppMode `json:"mode"`
	} `json:"distributed"`
	Fips      bool        `json:"fips"`
	Git       GitSettings `json:"git"`
	JobLimits JobSettings `json:"jobLimits"`
	Limits    Limits      `json:"limits"`
	Pii       struct {
		EnablePiiDetection bool `json:"enablePiiDetection"`
	} `json:"pii"`
	Proxy struct {
		UseEnvVars bool `json:"useEnvVars"`
	} `json:"proxy"`
	RedisCacheLimits RedisCacheLimits `json:"redisCacheLimits"`
	RedisLimits      RedisLimits      `json:"redisLimits"`
	Rollback         struct {
		RollbackEnabled bool     `json:"rollbackEnabled"`
		RollbackRetries *float32 `json:"rollbackRetries,omitempty"`
		RollbackTimeout *float32 `json:"rollbackTimeout,omitempty"`
	} `json:"rollback"`
	SearchLimits   SearchSettings `json:"searchLimits"`
	ServicesLimits ServicesLimits `json:"servicesLimits"`
	Shutdown       struct {
		DrainTimeout float32 `json:"drainTimeout"`
	} `json:"shutdown"`
	Sni struct {
		DisableSNIRouting bool `json:"disableSNIRouting"`
	} `json:"sni"`
	Sockets *struct {
		Directory *string `json:"directory,omitempty"`
	} `json:"sockets,omitempty"`
	System struct {
		Intercom bool        `json:"intercom"`
		Upgrade  interface{} `json:"upgrade"`
	} `json:"system"`
	Tls struct {
		DefaultCipherList  string `json:"defaultCipherList"`
		DefaultEcdhCurve   string `json:"defaultEcdhCurve"`
		MaxVersion         string `json:"maxVersion"`
		MinVersion         string `json:"minVersion"`
		RejectUnauthorized bool   `json:"rejectUnauthorized"`
	} `json:"tls"`
	UpgradeSettings UpgradeSettings `json:"upgradeSettings"`
	Workers         struct {
		Count                  float32  `json:"count"`
		EnableHeapSnapshots    *bool    `json:"enableHeapSnapshots,omitempty"`
		LoadThrottlePerc       *float32 `json:"loadThrottlePerc,omitempty"`
		Memory                 float32  `json:"memory"`
		Minimum                float32  `json:"minimum"`
		StartupMaxConns        *float32 `json:"startupMaxConns,omitempty"`
		StartupThrottleTimeout *float32 `json:"startupThrottleTimeout,omitempty"`
		V8SingleThread         *bool    `json:"v8SingleThread,omitempty"`
	} `json:"workers"`
}

// SystemSettingsConf defines model for SystemSettingsConf.
type SystemSettingsConf struct {
	Api struct {
		BaseUrl         *string                 `json:"baseUrl,omitempty"`
		DisableApiCache *bool                   `json:"disableApiCache,omitempty"`
		Disabled        bool                    `json:"disabled"`
		Headers         *map[string]interface{} `json:"headers,omitempty"`
		Host            string                  `json:"host"`
		IdleSessionTTL  *float32                `json:"idleSessionTTL,omitempty"`
		LoginRateLimit  *string                 `json:"loginRateLimit,omitempty"`
		Port            float32                 `json:"port"`
		Protocol        string                  `json:"protocol"`
		Scripts         *bool                   `json:"scripts,omitempty"`
		SensitiveFields *[]string               `json:"sensitiveFields,omitempty"`
		Ssl             struct {
			CaPath      *string `json:"caPath,omitempty"`
			CertPath    string  `json:"certPath"`
			Disabled    bool    `json:"disabled"`
			Passphrase  string  `json:"passphrase"`
			PrivKeyPath string  `json:"privKeyPath"`
		} `json:"ssl"`
		SsoRateLimit       *string `json:"ssoRateLimit,omitempty"`
		WorkerRemoteAccess bool    `json:"workerRemoteAccess"`
	} `json:"api"`
	Backups struct {
		BackupPersistence string `json:"backupPersistence"`
		BackupsDirectory  string `json:"backupsDirectory"`
	} `json:"backups"`
	CustomLogo struct {
		Enabled         bool   `json:"enabled"`
		LogoDescription string `json:"logoDescription"`
		LogoImage       string `json:"logoImage"`
	} `json:"customLogo"`
	Pii struct {
		EnablePiiDetection bool `json:"enablePiiDetection"`
	} `json:"pii"`
	Proxy struct {
		UseEnvVars bool `json:"useEnvVars"`
	} `json:"proxy"`
	Rollback struct {
		RollbackEnabled bool     `json:"rollbackEnabled"`
		RollbackRetries *float32 `json:"rollbackRetries,omitempty"`
		RollbackTimeout *float32 `json:"rollbackTimeout,omitempty"`
	} `json:"rollback"`
	Shutdown struct {
		DrainTimeout float32 `json:"drainTimeout"`
	} `json:"shutdown"`
	Sni struct {
		DisableSNIRouting bool `json:"disableSNIRouting"`
	} `json:"sni"`
	Sockets *struct {
		Directory *string `json:"directory,omitempty"`
	} `json:"sockets,omitempty"`
	System struct {
		Intercom bool        `json:"intercom"`
		Upgrade  interface{} `json:"upgrade"`
	} `json:"system"`
	Tls struct {
		DefaultCipherList  string `json:"defaultCipherList"`
		DefaultEcdhCurve   string `json:"defaultEcdhCurve"`
		MaxVersion         string `json:"maxVersion"`
		MinVersion         string `json:"minVersion"`
		RejectUnauthorized bool   `json:"rejectUnauthorized"`
	} `json:"tls"`
	UpgradeSettings UpgradeSettings `json:"upgradeSettings"`
	Workers         struct {
		Count                  float32  `json:"count"`
		EnableHeapSnapshots    *bool    `json:"enableHeapSnapshots,omitempty"`
		LoadThrottlePerc       *float32 `json:"loadThrottlePerc,omitempty"`
		Memory                 float32  `json:"memory"`
		Minimum                float32  `json:"minimum"`
		StartupMaxConns        *float32 `json:"startupMaxConns,omitempty"`
		StartupThrottleTimeout *float32 `json:"startupThrottleTimeout,omitempty"`
		V8SingleThread         *bool    `json:"v8SingleThread,omitempty"`
	} `json:"workers"`
}

// TLSClientParams defines model for TLSClientParams.
type TLSClientParams struct {
	CaPath              *string                 `json:"caPath,omitempty"`
	CertPath            *string                 `json:"certPath,omitempty"`
	CheckServerIdentity *map[string]interface{} `json:"checkServerIdentity,omitempty"`
	Disabled            bool                    `json:"disabled"`
	Passphrase          *string                 `json:"passphrase,omitempty"`
	PrivKeyPath         *string                 `json:"privKeyPath,omitempty"`
	RejectUnauthorized  *bool                   `json:"rejectUnauthorized,omitempty"`
	Servername          *string                 `json:"servername,omitempty"`
}

// TableViewSettings defines model for TableViewSettings.
type TableViewSettings struct {
	ColumnFilterSettings   *ColumnFilterSettings `json:"columnFilterSettings,omitempty"`
	ColumnFormatSettings   *ColumnFormatSettings `json:"columnFormatSettings,omitempty"`
	ColumnOrderSettings    *ColumnOrderSettings  `json:"columnOrderSettings,omitempty"`
	ColumnSortSettings     *ColumnSortSettings   `json:"columnSortSettings,omitempty"`
	EventTableFields       *[]string             `json:"eventTableFields,omitempty"`
	RowNumberColumnWidth   *float32              `json:"rowNumberColumnWidth,omitempty"`
	ShowColumnTotals       bool                  `json:"showColumnTotals"`
	ShowColumnTotalsPinned bool                  `json:"showColumnTotalsPinned"`
	ShowRowNumbers         bool                  `json:"showRowNumbers"`
	ShowRowTotals          bool                  `json:"showRowTotals"`
	ShowRowTotalsPinned    bool                  `json:"showRowTotalsPinned"`
	WrapCells              *bool                 `json:"wrapCells,omitempty"`
}

// Team defines model for Team.
type Team struct {
	Description string    `json:"description"`
	Id          string    `json:"id"`
	Name        string    `json:"name"`
	Roles       []string  `json:"roles"`
	SsoGroupIds *[]string `json:"ssoGroupIds,omitempty"`
}

// TeamAccessControlList defines model for TeamAccessControlList.
type TeamAccessControlList struct {
	Perms []ResourcePolicy `json:"perms"`
	Team  string           `json:"team"`
}

// TrustPolicy defines model for TrustPolicy.
type TrustPolicy struct {
	Id     string        `json:"id"`
	Policy AMTrustPolicy `json:"policy"`
}

// UiStatePatch defines model for UiStatePatch.
type UiStatePatch struct {
	Args  *map[string]interface{} `json:"args,omitempty"`
	Op    UiStatePatchOp          `json:"op"`
	Value interface{}             `json:"value"`
}

// UiStatePatchOp defines model for UiStatePatch.Op.
type UiStatePatchOp string

// UpdateHecTokenRequest defines model for UpdateHecTokenRequest.
type UpdateHecTokenRequest struct {
	Description *string `json:"description,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Metadata    *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"metadata,omitempty"`
}

// UpgradeMasterRequest defines model for UpgradeMasterRequest.
type UpgradeMasterRequest struct {
	// Packages Provide your own URLs or local paths for platform-specific Cribl packages
	Packages *[]struct {
		// PackageHashUrl Package's MD5 or SHA256 hash HTTP URL or local path
		PackageHashUrl *string `json:"packageHashUrl,omitempty"`

		// PackageUrl Package HTTP URL or local path
		PackageUrl string `json:"packageUrl"`
	} `json:"packages,omitempty"`
}

// UpgradePackageUrls defines model for UpgradePackageUrls.
type UpgradePackageUrls struct {
	PackageHashUrl *string `json:"packageHashUrl,omitempty"`
	PackageUrl     string  `json:"packageUrl"`
}

// UpgradeResult defines model for UpgradeResult.
type UpgradeResult struct {
	AvailableVersions []VersionInfo `json:"availableVersions"`
	CanUpgrade        bool          `json:"canUpgrade"`
	InstalledVersion  VersionInfo   `json:"installedVersion"`
	IsSuccess         bool          `json:"isSuccess"`
	Message           string        `json:"message"`
	UpgradedToVersion VersionInfo   `json:"upgradedToVersion"`
}

// UpgradeSettings defines model for UpgradeSettings.
type UpgradeSettings struct {
	AutomaticUpgradeCheckPeriod *string               `json:"automaticUpgradeCheckPeriod,omitempty"`
	DisableAutomaticUpgrade     bool                  `json:"disableAutomaticUpgrade"`
	EnableLegacyEdgeUpgrade     bool                  `json:"enableLegacyEdgeUpgrade"`
	PackageUrls                 *[]UpgradePackageUrls `json:"packageUrls,omitempty"`
	UpgradeSource               string                `json:"upgradeSource"`
}

// UsageGroup defines model for UsageGroup.
type UsageGroup struct {
	Description *string              `json:"description,omitempty"`
	Enabled     *bool                `json:"enabled,omitempty"`
	Id          string               `json:"id"`
	Rules       LimitRuleDefinitions `json:"rules"`
	UsersCount  *float32             `json:"usersCount,omitempty"`
}

// User defines model for User.
type User struct {
	CurrentPassword *string   `json:"currentPassword,omitempty"`
	Disabled        bool      `json:"disabled"`
	Email           string    `json:"email"`
	First           string    `json:"first"`
	Id              string    `json:"id"`
	Last            string    `json:"last"`
	Password        *string   `json:"password,omitempty"`
	Roles           *[]string `json:"roles,omitempty"`
	Teams           *[]string `json:"teams,omitempty"`
	Username        string    `json:"username"`
}

// UserAccessControlList defines model for UserAccessControlList.
type UserAccessControlList struct {
	Perms []ResourcePolicy `json:"perms"`
	User  string           `json:"user"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	CurrentPassword *string   `json:"currentPassword,omitempty"`
	Disabled        bool      `json:"disabled"`
	Email           string    `json:"email"`
	First           string    `json:"first"`
	Id              string    `json:"id"`
	Last            string    `json:"last"`
	Password        *string   `json:"password,omitempty"`
	Roles           *[]string `json:"roles,omitempty"`
	Username        string    `json:"username"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {
	Disabled bool      `json:"disabled"`
	Email    string    `json:"email"`
	First    string    `json:"first"`
	Id       string    `json:"id"`
	Last     string    `json:"last"`
	Password *string   `json:"password,omitempty"`
	Roles    *[]string `json:"roles,omitempty"`
	Username string    `json:"username"`
}

// VaultKMSTlsClientConfig defines model for VaultKMSTlsClientConfig.
type VaultKMSTlsClientConfig struct {
	CaPath             *string `json:"caPath,omitempty"`
	CertPath           *string `json:"certPath,omitempty"`
	CertificateName    *string `json:"certificateName,omitempty"`
	Disabled           bool    `json:"disabled"`
	Passphrase         *string `json:"passphrase,omitempty"`
	PrivKeyPath        *string `json:"privKeyPath,omitempty"`
	RejectUnauthorized *bool   `json:"rejectUnauthorized,omitempty"`
	Servername         *string `json:"servername,omitempty"`
}

// VersionInfo defines model for VersionInfo.
type VersionInfo struct {
	Architecture *string  `json:"architecture,omitempty"`
	Build        string   `json:"build"`
	DownloadUrl  *string  `json:"downloadUrl,omitempty"`
	FullVersion  string   `json:"fullVersion"`
	Major        float32  `json:"major"`
	Minor        float32  `json:"minor"`
	Platform     *string  `json:"platform,omitempty"`
	Point        *float32 `json:"point,omitempty"`
	PreRelease   *string  `json:"preRelease,omitempty"`
}

// Default defines model for default.
type Default = []map[string]interface{}

// Object defines model for object.
type Object = string

// Unknown defines model for unknown.
type Unknown float32

// GetAuthAuthorizationCodeCallbackParams defines parameters for GetAuthAuthorizationCodeCallback.
type GetAuthAuthorizationCodeCallbackParams struct {
	// Code Authorization Code
	Code  *string `form:"code,omitempty" json:"code,omitempty"`
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// GetAuthSloCallbackParams defines parameters for GetAuthSloCallback.
type GetAuthSloCallbackParams struct {
	// SAMLResponse Logout request object
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`
	RelayState   *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`
}

// PostAuthSloCallbackFormdataBody defines parameters for PostAuthSloCallback.
type PostAuthSloCallbackFormdataBody struct {
	RelayState *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`

	// SAMLResponse Logout request object
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`
}

// GetAuthSsoCallbackParams defines parameters for GetAuthSsoCallback.
type GetAuthSsoCallbackParams struct {
	// SAMLResponse Authentication request object
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`
	RelayState   *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`
}

// PostAuthSsoCallbackFormdataBody defines parameters for PostAuthSsoCallback.
type PostAuthSsoCallbackFormdataBody struct {
	RelayState *string `form:"RelayState,omitempty" json:"RelayState,omitempty"`

	// SAMLResponse Authentication request object
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`
}

// GetCluiParams defines parameters for GetClui.
type GetCluiParams struct {
	// Query Search query
	Query string `form:"query" json:"query"`

	// Context Search query context
	Context *GetCluiParamsContext `form:"context,omitempty" json:"context,omitempty"`
}

// GetCluiParamsContext defines parameters for GetClui.
type GetCluiParamsContext string

// PostEdgeAppscopeProcessesParams defines parameters for PostEdgeAppscopeProcesses.
type PostEdgeAppscopeProcessesParams struct {
	// Pid config string required
	Pid string `form:"pid" json:"pid"`
}

// GetEdgeEventsQueryParams defines parameters for GetEdgeEventsQuery.
type GetEdgeEventsQueryParams struct {
	// Files Optional parameter, when provided the files and provided offsets are used to look for events.
	Files *string `form:"Files,omitempty" json:"Files,omitempty"`

	// Source The type of source events to search in the format {type}/{subtype} i.e system_state/hostsfile, system_state/routes, etc...
	Source *string `form:"source,omitempty" json:"source,omitempty"`

	// Limit Maximum number of log lines to retrieve starting from offset.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Et Epoch timestamp of the earliest event (includes rolled files present on disk)
	Et *int `form:"et,omitempty" json:"et,omitempty"`

	// Lt Epoch timestamp of the latest event (includes rolled files present on disk)
	Lt *int `form:"lt,omitempty" json:"lt,omitempty"`

	// Filter Filter
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// PostEdgeFileIngestParams defines parameters for PostEdgeFileIngest.
type PostEdgeFileIngestParams struct {
	// FilePath Absolute path to file to ingest.
	FilePath *string `form:"filePath,omitempty" json:"filePath,omitempty"`

	// PipelineId Id of the pipeline to use.
	PipelineId *string `form:"pipelineId,omitempty" json:"pipelineId,omitempty"`

	// OutputId Destination to send events to.
	OutputId *string `form:"outputId,omitempty" json:"outputId,omitempty"`

	// PreProcessingPipelineId Id to the pre-processing pipeline to use for routes.
	PreProcessingPipelineId *string `form:"preProcessingPipelineId,omitempty" json:"preProcessingPipelineId,omitempty"`

	// SendToRoutes boolean condition required on whether to send events to routes.
	SendToRoutes *string `form:"sendToRoutes,omitempty" json:"sendToRoutes,omitempty"`

	// BreakerRuleSet Breaker rules to use on the file.
	BreakerRuleSet *string `form:"breakerRuleSet,omitempty" json:"breakerRuleSet,omitempty"`
}

// GetEdgeFileSampleParams defines parameters for GetEdgeFileSample.
type GetEdgeFileSampleParams struct {
	// Path The path to the file to sample
	Path string `form:"path" json:"path"`

	// BytesRequested The number of bytes to return;   this value could be constrained by system limits.
	BytesRequested *float32 `form:"bytesRequested,omitempty" json:"bytesRequested,omitempty"`
}

// GetEdgeKubeProxyParams defines parameters for GetEdgeKubeProxy.
type GetEdgeKubeProxyParams struct {
	// Path string optional
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// GetEdgeLogsParams defines parameters for GetEdgeLogs.
type GetEdgeLogsParams struct {
	// Mode Discovery Mode (default is "auto")
	Mode *string `form:"mode,omitempty" json:"mode,omitempty"`

	// Allow query array[string] optional List of allowed-filename wildcard patterns
	Allow *string `form:"allow,omitempty" json:"allow,omitempty"`

	// Path Search directory for "manual" mode
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// Depth Search depth for "manual" mode
	Depth *float32 `form:"depth,omitempty" json:"depth,omitempty"`
}

// GetJobsParams defines parameters for GetJobs.
type GetJobsParams struct {
	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Maximum number of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// RunType Filter by job run type
	RunType *GetJobsParamsRunType `form:"runType,omitempty" json:"runType,omitempty"`

	// State Filter by current job state, e.g. "running"
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Id Filter by job id, e.g. "id=1608713335.3&id=1608713326.1"
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// CollectorId Filter by collector id, e.g. "collectorId=Prometheus-in"
	CollectorId *string `form:"collectorId,omitempty" json:"collectorId,omitempty"`

	// GroupId Filter by worker group id, e.g. "defaultHybrid"
	GroupId *string `form:"groupId,omitempty" json:"groupId,omitempty"`
}

// GetJobsParamsRunType defines parameters for GetJobs.
type GetJobsParamsRunType string

// GetJobsIdResultsGroupParams defines parameters for GetJobsIdResultsGroup.
type GetJobsIdResultsGroupParams struct {
	// MaxFiles Maximum files to get job results
	MaxFiles *float32 `form:"maxFiles,omitempty" json:"maxFiles,omitempty"`
}

// GetLibDatabaseConnectionsParams defines parameters for GetLibDatabaseConnections.
type GetLibDatabaseConnectionsParams struct {
	// DatabaseType type of database connection
	DatabaseType *string `form:"databaseType,omitempty" json:"databaseType,omitempty"`
}

// GetLibProtobufLibrariesParams defines parameters for GetLibProtobufLibraries.
type GetLibProtobufLibrariesParams struct {
	// OnlyWithEncodings onlyWithEncodings
	OnlyWithEncodings string `form:"onlyWithEncodings" json:"onlyWithEncodings"`
}

// GetMGroupIdSystemProjectsProjectIdVersionDiffParams defines parameters for GetMGroupIdSystemProjectsProjectIdVersionDiff.
type GetMGroupIdSystemProjectsProjectIdVersionDiffParams struct {
	Commit *string `form:"commit,omitempty" json:"commit,omitempty"`
}

// GetMasterGroupsIdParams defines parameters for GetMasterGroupsId.
type GetMasterGroupsIdParams struct {
	// Fields fields to add to results: git.commit, git.localChanges, git.log
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetMasterGroupsIdAclParams defines parameters for GetMasterGroupsIdAcl.
type GetMasterGroupsIdAclParams struct {
	// Type resource type by which to filter access levels
	Type *GetMasterGroupsIdAclParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetMasterGroupsIdAclParamsType defines parameters for GetMasterGroupsIdAcl.
type GetMasterGroupsIdAclParamsType string

// GetMasterSummaryParams defines parameters for GetMasterSummary.
type GetMasterSummaryParams struct {
	// Mode product filter
	Mode *GetMasterSummaryParamsMode `form:"mode,omitempty" json:"mode,omitempty"`
}

// GetMasterSummaryParamsMode defines parameters for GetMasterSummary.
type GetMasterSummaryParamsMode string

// GetMasterSummaryWorkersParams defines parameters for GetMasterSummaryWorkers.
type GetMasterSummaryWorkersParams struct {
	// FilterExp Filter expression evaluated against nodes
	FilterExp *string `form:"filterExp,omitempty" json:"filterExp,omitempty"`
}

// GetMasterWorkersParams defines parameters for GetMasterWorkers.
type GetMasterWorkersParams struct {
	// FilterExp Filter expression evaluated against nodes
	FilterExp *string `form:"filterExp,omitempty" json:"filterExp,omitempty"`

	// SortExp Sorting expression evaluated against nodes
	SortExp *string `form:"sortExp,omitempty" json:"sortExp,omitempty"`

	// Limit Maximum number of nodes to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PutPacksParams defines parameters for PutPacks.
type PutPacksParams struct {
	// Filename the file to upload
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// PatchPacksIdParams defines parameters for PatchPacksId.
type PatchPacksIdParams struct {
	// Source body string required Pack source
	Source *string `form:"source,omitempty" json:"source,omitempty"`

	// Minor body boolean optional Only upgrade to minor/patch versions
	Minor *string `form:"minor,omitempty" json:"minor,omitempty"`

	// Spec body string optional Specify a branch, tag or a semver spec
	Spec *string `form:"spec,omitempty" json:"spec,omitempty"`
}

// GetPacksIdExportParams defines parameters for GetPacksIdExport.
type GetPacksIdExportParams struct {
	// Mode Export mode. Note: "merge_safe" is deprecated and will be removed in v5.0.0. Use "merge" instead.
	Mode GetPacksIdExportParamsMode `form:"mode" json:"mode"`

	// Filename Filename of the exported Pack
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GetPacksIdExportParamsMode defines parameters for GetPacksIdExport.
type GetPacksIdExportParamsMode string

// GetProductsProductGroupsParams defines parameters for GetProductsProductGroups.
type GetProductsProductGroupsParams struct {
	// Fields fields to add to results: git.commit, git.localChanges, git.log
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsProductGroupsParamsProduct defines parameters for GetProductsProductGroups.
type GetProductsProductGroupsParamsProduct string

// PostProductsProductGroupsParamsProduct defines parameters for PostProductsProductGroups.
type PostProductsProductGroupsParamsProduct string

// GetProductsProductGroupsIdAclTeamsParams defines parameters for GetProductsProductGroupsIdAclTeams.
type GetProductsProductGroupsIdAclTeamsParams struct {
	// Type resource type by which to filter access levels
	Type *GetProductsProductGroupsIdAclTeamsParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetProductsProductGroupsIdAclTeamsParamsType defines parameters for GetProductsProductGroupsIdAclTeams.
type GetProductsProductGroupsIdAclTeamsParamsType string

// GetProductsProductGroupsIdAclTeamsParamsProduct defines parameters for GetProductsProductGroupsIdAclTeams.
type GetProductsProductGroupsIdAclTeamsParamsProduct string

// GetProductsProductUsersParams defines parameters for GetProductsProductUsers.
type GetProductsProductUsersParams struct {
	// GroupId filter to specific group by groupId
	GroupId *string `form:"groupId,omitempty" json:"groupId,omitempty"`
}

// GetProductsProductUsersParamsProduct defines parameters for GetProductsProductUsers.
type GetProductsProductUsersParamsProduct string

// DeleteProductsProductUsersCacheParamsProduct defines parameters for DeleteProductsProductUsersCache.
type DeleteProductsProductUsersCacheParamsProduct string

// GetProductsProductUsersIdAclParams defines parameters for GetProductsProductUsersIdAcl.
type GetProductsProductUsersIdAclParams struct {
	// Type resource type by which to filter access levels
	Type *GetProductsProductUsersIdAclParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetProductsProductUsersIdAclParamsType defines parameters for GetProductsProductUsersIdAcl.
type GetProductsProductUsersIdAclParamsType string

// GetProductsProductUsersIdAclParamsProduct defines parameters for GetProductsProductUsersIdAcl.
type GetProductsProductUsersIdAclParamsProduct string

// GetSearchJobsIdResultsParams defines parameters for GetSearchJobsIdResults.
type GetSearchJobsIdResultsParams struct {
	// Limit maximum number of events returned
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset starting offset of the events
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// LowerBound lower bound of the time range, inclusive
	LowerBound *float32 `form:"lowerBound,omitempty" json:"lowerBound,omitempty"`

	// UpperBound upper bound of the time range, exclusive
	UpperBound *float32 `form:"upperBound,omitempty" json:"upperBound,omitempty"`
}

// GetSearchJobsIdResultsPollParams defines parameters for GetSearchJobsIdResultsPoll.
type GetSearchJobsIdResultsPollParams struct {
	// Limit maximum number of events returned
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset starting offset of the events
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// LowerBound lower bound of the time range, inclusive
	LowerBound *float32 `form:"lowerBound,omitempty" json:"lowerBound,omitempty"`

	// UpperBound upper bound of the time range, exclusive
	UpperBound *float32 `form:"upperBound,omitempty" json:"upperBound,omitempty"`

	// LastJobStatus last known status of the Search Job. Used to return immediatelyupon status change if the status was queued.
	LastJobStatus *string `form:"lastJobStatus,omitempty" json:"lastJobStatus,omitempty"`
}

// DeleteSystemDiagParams defines parameters for DeleteSystemDiag.
type DeleteSystemDiagParams struct {
	// Path Diag bundle path
	Path string `form:"path" json:"path"`
}

// PostSystemDistributedUpgradeStageGroupParams defines parameters for PostSystemDistributedUpgradeStageGroup.
type PostSystemDistributedUpgradeStageGroupParams struct {
	// UpgradePercentage body number percentage of nodes on the worker group to upgrade
	UpgradePercentage *string `form:"upgradePercentage,omitempty" json:"upgradePercentage,omitempty"`
}

// GetSystemJobsLogsIdGroupIdParams defines parameters for GetSystemJobsLogsIdGroupId.
type GetSystemJobsLogsIdGroupIdParams struct {
	// Limit Maximum number of log lines to retrieve starting from offset.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset in the current log file to fetch the log events from.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// EndOffset in the current log file to fetch the log events upto.
	EndOffset *int `form:"endOffset,omitempty" json:"endOffset,omitempty"`

	// Et Epoch timestamp of the earliest event (includes rolled files present on disk)
	Et *int `form:"et,omitempty" json:"et,omitempty"`

	// Lt Epoch timestamp of the latest event (includes rolled files present on disk)
	Lt *int `form:"lt,omitempty" json:"lt,omitempty"`

	// Filter Filter
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSystemLogsSearchParams defines parameters for GetSystemLogsSearch.
type GetSystemLogsSearchParams struct {
	// Type type of logs request single multi group
	Type string `form:"type" json:"type"`

	// GroupId id of the group to query
	GroupId *string `form:"groupId,omitempty" json:"groupId,omitempty"`

	// Files query string[] optional file or files to query
	Files *string `form:"files,omitempty" json:"files,omitempty"`

	// Limit Maximum number of log lines to retrieve starting from offset.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Et Epoch timestamp of the earliest event (includes rolled files present on disk)
	Et *int `form:"et,omitempty" json:"et,omitempty"`

	// Lt Epoch timestamp of the latest event (includes rolled files present on disk)
	Lt *int `form:"lt,omitempty" json:"lt,omitempty"`

	// Filter Filter
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSystemLogsIdParams defines parameters for GetSystemLogsId.
type GetSystemLogsIdParams struct {
	// Limit Maximum number of log lines to retrieve starting from offset.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// EndOffset in the current log file to fetch the log events upto.
	EndOffset *int `form:"endOffset,omitempty" json:"endOffset,omitempty"`

	// Et Epoch timestamp of the earliest event (includes rolled files present on disk)
	Et *int `form:"et,omitempty" json:"et,omitempty"`

	// Lt Epoch timestamp of the latest event (includes rolled files present on disk)
	Lt *int `form:"lt,omitempty" json:"lt,omitempty"`

	// Filter Filter
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// PutSystemLookupsParams defines parameters for PutSystemLookups.
type PutSystemLookupsParams struct {
	// Filename query LookupFilenameSchema required Filename
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`
}

// GetSystemMetricsParams defines parameters for GetSystemMetrics.
type GetSystemMetricsParams struct {
	// Wp worker process to query, this would work only on a worker node
	Wp *string `form:"wp,omitempty" json:"wp,omitempty"`

	// NumBuckets buckets in the past to include in the query results
	NumBuckets *float32 `form:"numBuckets,omitempty" json:"numBuckets,omitempty"`

	// Earliest earliest time to query against
	Earliest *string `form:"earliest,omitempty" json:"earliest,omitempty"`

	// Latest latest time to query against
	Latest *string `form:"latest,omitempty" json:"latest,omitempty"`

	// MetricNameFilter can be a regex or an array of metric names
	MetricNameFilter *string `form:"metricNameFilter,omitempty" json:"metricNameFilter,omitempty"`

	// FilterExpr a js expression to apply against the metrics returned (can filter dimensions)
	FilterExpr *string `form:"filterExpr,omitempty" json:"filterExpr,omitempty"`
}

// GetSystemProjectsProjectIdVersionCountParams defines parameters for GetSystemProjectsProjectIdVersionCount.
type GetSystemProjectsProjectIdVersionCountParams struct {
	// ID Commit ID
	ID *string `form:"ID,omitempty" json:"ID,omitempty"`
}

// GetSystemProjectsProjectIdVersionDiffParams defines parameters for GetSystemProjectsProjectIdVersionDiff.
type GetSystemProjectsProjectIdVersionDiffParams struct {
	// Commit Commit hash (default is HEAD)
	Commit *string `form:"commit,omitempty" json:"commit,omitempty"`

	// Filename Filename
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// DiffLineLimit Limit maximum lines in the diff
	DiffLineLimit *float32 `form:"diffLineLimit,omitempty" json:"diffLineLimit,omitempty"`
}

// GetSystemProjectsProjectIdVersionFilesParams defines parameters for GetSystemProjectsProjectIdVersionFiles.
type GetSystemProjectsProjectIdVersionFilesParams struct {
	// ID Commit ID
	ID *string `form:"ID,omitempty" json:"ID,omitempty"`
}

// GetSystemProjectsProjectIdVersionShowParams defines parameters for GetSystemProjectsProjectIdVersionShow.
type GetSystemProjectsProjectIdVersionShowParams struct {
	// ID Commit ID
	ID *string `form:"ID,omitempty" json:"ID,omitempty"`

	// Filename Filename
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// DiffLineLimit Limit maximum lines in the diff
	DiffLineLimit *float32 `form:"diffLineLimit,omitempty" json:"diffLineLimit,omitempty"`
}

// GetSystemTeamsParams defines parameters for GetSystemTeams.
type GetSystemTeamsParams struct {
	// Product filter teams by product
	Product *GetSystemTeamsParamsProduct `form:"product,omitempty" json:"product,omitempty"`
}

// GetSystemTeamsParamsProduct defines parameters for GetSystemTeams.
type GetSystemTeamsParamsProduct string

// GetSystemTeamsIdAclParams defines parameters for GetSystemTeamsIdAcl.
type GetSystemTeamsIdAclParams struct {
	// Type resource type by which to filter access levels
	Type *GetSystemTeamsIdAclParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetSystemTeamsIdAclParamsType defines parameters for GetSystemTeamsIdAcl.
type GetSystemTeamsIdAclParamsType string

// GetVersionCountParams defines parameters for GetVersionCount.
type GetVersionCountParams struct {
	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// ID Commit ID
	ID *string `form:"ID,omitempty" json:"ID,omitempty"`
}

// GetVersionDiffParams defines parameters for GetVersionDiff.
type GetVersionDiffParams struct {
	// Commit Commit hash (default is HEAD)
	Commit *string `form:"commit,omitempty" json:"commit,omitempty"`

	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Filename Filename
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// DiffLineLimit Limit maximum lines in the diff
	DiffLineLimit *float32 `form:"diffLineLimit,omitempty" json:"diffLineLimit,omitempty"`
}

// GetVersionFilesParams defines parameters for GetVersionFiles.
type GetVersionFilesParams struct {
	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// ID Commit ID
	ID *string `form:"ID,omitempty" json:"ID,omitempty"`
}

// PostVersionRevertParams defines parameters for PostVersionRevert.
type PostVersionRevertParams struct {
	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// GetVersionShowParams defines parameters for GetVersionShow.
type GetVersionShowParams struct {
	// Commit Commit hash (default is HEAD)
	Commit *string `form:"commit,omitempty" json:"commit,omitempty"`

	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Filename Filename
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// DiffLineLimit Limit maximum lines in the diff
	DiffLineLimit *float32 `form:"diffLineLimit,omitempty" json:"diffLineLimit,omitempty"`
}

// GetVersionStatusParams defines parameters for GetVersionStatus.
type GetVersionStatusParams struct {
	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// PostVersionUndoParams defines parameters for PostVersionUndo.
type PostVersionUndoParams struct {
	// Group Group ID
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = LoginInfo

// PostAuthSloCallbackFormdataRequestBody defines body for PostAuthSloCallback for application/x-www-form-urlencoded ContentType.
type PostAuthSloCallbackFormdataRequestBody PostAuthSloCallbackFormdataBody

// PostAuthSsoCallbackFormdataRequestBody defines body for PostAuthSsoCallback for application/x-www-form-urlencoded ContentType.
type PostAuthSsoCallbackFormdataRequestBody PostAuthSsoCallbackFormdataBody

// PostJobsJSONRequestBody defines body for PostJobs for application/json ContentType.
type PostJobsJSONRequestBody = SavedJob

// PostLibAppscopeConfigsJSONRequestBody defines body for PostLibAppscopeConfigs for application/json ContentType.
type PostLibAppscopeConfigsJSONRequestBody = AppscopeLibEntry

// PatchLibAppscopeConfigsIdJSONRequestBody defines body for PatchLibAppscopeConfigsId for application/json ContentType.
type PatchLibAppscopeConfigsIdJSONRequestBody = AppscopeLibEntry

// PostLibBreakersJSONRequestBody defines body for PostLibBreakers for application/json ContentType.
type PostLibBreakersJSONRequestBody = EventBreakerRuleset

// PatchLibBreakersIdJSONRequestBody defines body for PatchLibBreakersId for application/json ContentType.
type PatchLibBreakersIdJSONRequestBody = EventBreakerRuleset

// PostLibDatabaseConnectionsJSONRequestBody defines body for PostLibDatabaseConnections for application/json ContentType.
type PostLibDatabaseConnectionsJSONRequestBody = DatabaseConnectionConfig

// PostLibDatabaseConnectionsTestJSONRequestBody defines body for PostLibDatabaseConnectionsTest for application/json ContentType.
type PostLibDatabaseConnectionsTestJSONRequestBody = DatabaseConnectionTest

// PatchLibDatabaseConnectionsIdJSONRequestBody defines body for PatchLibDatabaseConnectionsId for application/json ContentType.
type PatchLibDatabaseConnectionsIdJSONRequestBody = DatabaseConnectionConfig

// PostLibGrokJSONRequestBody defines body for PostLibGrok for application/json ContentType.
type PostLibGrokJSONRequestBody = GrokFile

// PatchLibGrokIdJSONRequestBody defines body for PatchLibGrokId for application/json ContentType.
type PatchLibGrokIdJSONRequestBody = GrokFile

// PostLibHmacFunctionsJSONRequestBody defines body for PostLibHmacFunctions for application/json ContentType.
type PostLibHmacFunctionsJSONRequestBody = HmacFunction

// PatchLibHmacFunctionsIdJSONRequestBody defines body for PatchLibHmacFunctionsId for application/json ContentType.
type PatchLibHmacFunctionsIdJSONRequestBody = HmacFunction

// PostLibJobsJSONRequestBody defines body for PostLibJobs for application/json ContentType.
type PostLibJobsJSONRequestBody = SavedJob

// PatchLibJobsIdJSONRequestBody defines body for PatchLibJobsId for application/json ContentType.
type PatchLibJobsIdJSONRequestBody = SavedJob

// PostLibParquetSchemasJSONRequestBody defines body for PostLibParquetSchemas for application/json ContentType.
type PostLibParquetSchemasJSONRequestBody = SchemaLibEntry

// PatchLibParquetSchemasIdJSONRequestBody defines body for PatchLibParquetSchemasId for application/json ContentType.
type PatchLibParquetSchemasIdJSONRequestBody = SchemaLibEntry

// PostLibParsersJSONRequestBody defines body for PostLibParsers for application/json ContentType.
type PostLibParsersJSONRequestBody = ParserLibEntry

// PatchLibParsersIdJSONRequestBody defines body for PatchLibParsersId for application/json ContentType.
type PatchLibParsersIdJSONRequestBody = ParserLibEntry

// PostLibRegexJSONRequestBody defines body for PostLibRegex for application/json ContentType.
type PostLibRegexJSONRequestBody = RegexLibEntry

// PatchLibRegexIdJSONRequestBody defines body for PatchLibRegexId for application/json ContentType.
type PatchLibRegexIdJSONRequestBody = RegexLibEntry

// PostLibSchemasJSONRequestBody defines body for PostLibSchemas for application/json ContentType.
type PostLibSchemasJSONRequestBody = SchemaLibEntry

// PatchLibSchemasIdJSONRequestBody defines body for PatchLibSchemasId for application/json ContentType.
type PatchLibSchemasIdJSONRequestBody = SchemaLibEntry

// PostLibVarsJSONRequestBody defines body for PostLibVars for application/json ContentType.
type PostLibVarsJSONRequestBody = GlobalVar

// PatchLibVarsIdJSONRequestBody defines body for PatchLibVarsId for application/json ContentType.
type PatchLibVarsIdJSONRequestBody = GlobalVar

// PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody defines body for PostMGroupIdSystemProjectsProjectIdCapture for application/json ContentType.
type PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody = CaptureParams

// PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody defines body for PostMGroupIdSystemProjectsProjectIdPipelines for application/json ContentType.
type PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody = Pipeline

// PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody defines body for PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId for application/json ContentType.
type PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody = Pipeline

// PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody defines body for PostMGroupIdSystemProjectsProjectIdPreview for application/json ContentType.
type PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody = PreviewDataParams

// PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody defines body for PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture for application/json ContentType.
type PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody = CaptureParams

// PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody defines body for PostMGroupIdSystemProjectsProjectIdVersionCommit for application/json ContentType.
type PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody = ProjectGitCommitParams

// PatchMasterGroupsIdDeployJSONRequestBody defines body for PatchMasterGroupsIdDeploy for application/json ContentType.
type PatchMasterGroupsIdDeployJSONRequestBody = DeployRequest

// PostNotificationTargetsJSONRequestBody defines body for PostNotificationTargets for application/json ContentType.
type PostNotificationTargetsJSONRequestBody = NotificationTarget

// PatchNotificationTargetsIdJSONRequestBody defines body for PatchNotificationTargetsId for application/json ContentType.
type PatchNotificationTargetsIdJSONRequestBody = NotificationTarget

// PostNotificationsJSONRequestBody defines body for PostNotifications for application/json ContentType.
type PostNotificationsJSONRequestBody = Notification

// PatchNotificationsIdJSONRequestBody defines body for PatchNotificationsId for application/json ContentType.
type PatchNotificationsIdJSONRequestBody = Notification

// PostOutputClickHouseDescribeTableJSONRequestBody defines body for PostOutputClickHouseDescribeTable for application/json ContentType.
type PostOutputClickHouseDescribeTableJSONRequestBody = CHOutConfig

// PostPPackLibSchemasJSONRequestBody defines body for PostPPackLibSchemas for application/json ContentType.
type PostPPackLibSchemasJSONRequestBody = SchemaLibEntry

// PatchPPackLibSchemasIdJSONRequestBody defines body for PatchPPackLibSchemasId for application/json ContentType.
type PatchPPackLibSchemasIdJSONRequestBody = SchemaLibEntry

// PostPPackLibVarsJSONRequestBody defines body for PostPPackLibVars for application/json ContentType.
type PostPPackLibVarsJSONRequestBody = GlobalVar

// PatchPPackLibVarsIdJSONRequestBody defines body for PatchPPackLibVarsId for application/json ContentType.
type PatchPPackLibVarsIdJSONRequestBody = GlobalVar

// PostPPackPipelinesJSONRequestBody defines body for PostPPackPipelines for application/json ContentType.
type PostPPackPipelinesJSONRequestBody = Pipeline

// PatchPPackPipelinesIdJSONRequestBody defines body for PatchPPackPipelinesId for application/json ContentType.
type PatchPPackPipelinesIdJSONRequestBody = Pipeline

// PatchPPackRoutesIdJSONRequestBody defines body for PatchPPackRoutesId for application/json ContentType.
type PatchPPackRoutesIdJSONRequestBody = Routes

// PostPPackRoutesIdAppendJSONRequestBody defines body for PostPPackRoutesIdAppend for application/json ContentType.
type PostPPackRoutesIdAppendJSONRequestBody = RouteDefinitions

// PostPacksJSONRequestBody defines body for PostPacks for application/json ContentType.
type PostPacksJSONRequestBody = CrudEntityBase

// PostPacksCloneJSONRequestBody defines body for PostPacksClone for application/json ContentType.
type PostPacksCloneJSONRequestBody = PackClone

// PostPipelinesJSONRequestBody defines body for PostPipelines for application/json ContentType.
type PostPipelinesJSONRequestBody = Pipeline

// PatchPipelinesIdJSONRequestBody defines body for PatchPipelinesId for application/json ContentType.
type PatchPipelinesIdJSONRequestBody = Pipeline

// PostPreviewJSONRequestBody defines body for PostPreview for application/json ContentType.
type PostPreviewJSONRequestBody = PreviewDataParams

// PostProductsLakeLakesLakeIdDatasetsJSONRequestBody defines body for PostProductsLakeLakesLakeIdDatasets for application/json ContentType.
type PostProductsLakeLakesLakeIdDatasetsJSONRequestBody = CriblLakeDataset

// PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody defines body for PatchProductsLakeLakesLakeIdDatasetsId for application/json ContentType.
type PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody = CriblLakeDataset

// PostProductsProductGroupsJSONRequestBody defines body for PostProductsProductGroups for application/json ContentType.
type PostProductsProductGroupsJSONRequestBody = ConfigGroup

// PatchRoutesIdJSONRequestBody defines body for PatchRoutesId for application/json ContentType.
type PatchRoutesIdJSONRequestBody = Routes

// PostRoutesIdAppendJSONRequestBody defines body for PostRoutesIdAppend for application/json ContentType.
type PostRoutesIdAppendJSONRequestBody = RouteDefinitions

// PostSearchDashboardCategoriesJSONRequestBody defines body for PostSearchDashboardCategories for application/json ContentType.
type PostSearchDashboardCategoriesJSONRequestBody = DashboardCategory

// PatchSearchDashboardCategoriesIdJSONRequestBody defines body for PatchSearchDashboardCategoriesId for application/json ContentType.
type PatchSearchDashboardCategoriesIdJSONRequestBody = DashboardCategory

// PostSearchDashboardsJSONRequestBody defines body for PostSearchDashboards for application/json ContentType.
type PostSearchDashboardsJSONRequestBody = SearchDashboard

// PatchSearchDashboardsIdJSONRequestBody defines body for PatchSearchDashboardsId for application/json ContentType.
type PatchSearchDashboardsIdJSONRequestBody = SearchDashboard

// PostSearchDashboardsIdAclApplyJSONRequestBody defines body for PostSearchDashboardsIdAclApply for application/json ContentType.
type PostSearchDashboardsIdAclApplyJSONRequestBody = AccessControlSchema

// PostSearchDashboardsIdAclTeamsApplyJSONRequestBody defines body for PostSearchDashboardsIdAclTeamsApply for application/json ContentType.
type PostSearchDashboardsIdAclTeamsApplyJSONRequestBody = AccessControlSchema

// PostSearchDatasetProviderTypesJSONRequestBody defines body for PostSearchDatasetProviderTypes for application/json ContentType.
type PostSearchDatasetProviderTypesJSONRequestBody = DatasetProviderType

// PatchSearchDatasetProviderTypesIdJSONRequestBody defines body for PatchSearchDatasetProviderTypesId for application/json ContentType.
type PatchSearchDatasetProviderTypesIdJSONRequestBody = DatasetProviderType

// PostSearchDatasetProvidersJSONRequestBody defines body for PostSearchDatasetProviders for application/json ContentType.
type PostSearchDatasetProvidersJSONRequestBody = DatasetProvider

// PatchSearchDatasetProvidersIdJSONRequestBody defines body for PatchSearchDatasetProvidersId for application/json ContentType.
type PatchSearchDatasetProvidersIdJSONRequestBody = DatasetProvider

// PostSearchDatasetsJSONRequestBody defines body for PostSearchDatasets for application/json ContentType.
type PostSearchDatasetsJSONRequestBody = Dataset

// PatchSearchDatasetsIdJSONRequestBody defines body for PatchSearchDatasetsId for application/json ContentType.
type PatchSearchDatasetsIdJSONRequestBody = Dataset

// PostSearchDatasetsIdAclApplyJSONRequestBody defines body for PostSearchDatasetsIdAclApply for application/json ContentType.
type PostSearchDatasetsIdAclApplyJSONRequestBody = AccessControlSchema

// PostSearchDatasetsIdAclTeamsApplyJSONRequestBody defines body for PostSearchDatasetsIdAclTeamsApply for application/json ContentType.
type PostSearchDatasetsIdAclTeamsApplyJSONRequestBody = AccessControlSchema

// PostSearchEventBreakerPreviewJSONRequestBody defines body for PostSearchEventBreakerPreview for application/json ContentType.
type PostSearchEventBreakerPreviewJSONRequestBody = DatatypePreviewRequestBody

// PostSearchJobsJSONRequestBody defines body for PostSearchJobs for application/json ContentType.
type PostSearchJobsJSONRequestBody = SearchJob

// PatchSearchJobsIdJSONRequestBody defines body for PatchSearchJobsId for application/json ContentType.
type PatchSearchJobsIdJSONRequestBody = SearchJob

// PostSearchMacrosJSONRequestBody defines body for PostSearchMacros for application/json ContentType.
type PostSearchMacrosJSONRequestBody = SearchMacro

// PatchSearchMacrosIdJSONRequestBody defines body for PatchSearchMacrosId for application/json ContentType.
type PatchSearchMacrosIdJSONRequestBody = SearchMacro

// PostSearchPreviewJSONRequestBody defines body for PostSearchPreview for application/json ContentType.
type PostSearchPreviewJSONRequestBody = PreviewRequestBody

// PostSearchSavedJSONRequestBody defines body for PostSearchSaved for application/json ContentType.
type PostSearchSavedJSONRequestBody = SavedQuery

// PatchSearchSavedIdJSONRequestBody defines body for PatchSearchSavedId for application/json ContentType.
type PatchSearchSavedIdJSONRequestBody = SavedQuery

// PostSearchUsageGroupsJSONRequestBody defines body for PostSearchUsageGroups for application/json ContentType.
type PostSearchUsageGroupsJSONRequestBody = UsageGroup

// PatchSearchUsageGroupsIdJSONRequestBody defines body for PatchSearchUsageGroupsId for application/json ContentType.
type PatchSearchUsageGroupsIdJSONRequestBody = UsageGroup

// PatchSecurityKmsConfigJSONRequestBody defines body for PatchSecurityKmsConfig for application/json ContentType.
type PatchSecurityKmsConfigJSONRequestBody = KMSProviderConfig

// PostSystemBannersJSONRequestBody defines body for PostSystemBanners for application/json ContentType.
type PostSystemBannersJSONRequestBody = BannerMessage

// PatchSystemBannersIdJSONRequestBody defines body for PatchSystemBannersId for application/json ContentType.
type PatchSystemBannersIdJSONRequestBody = BannerMessage

// PostSystemCaptureJSONRequestBody defines body for PostSystemCapture for application/json ContentType.
type PostSystemCaptureJSONRequestBody = CaptureParams

// PostSystemCertificatesJSONRequestBody defines body for PostSystemCertificates for application/json ContentType.
type PostSystemCertificatesJSONRequestBody = Certificate

// PatchSystemCertificatesIdJSONRequestBody defines body for PatchSystemCertificatesId for application/json ContentType.
type PatchSystemCertificatesIdJSONRequestBody = Certificate

// PostSystemDiagSendJSONRequestBody defines body for PostSystemDiagSend for application/json ContentType.
type PostSystemDiagSendJSONRequestBody = SendDiagBundle

// PostSystemDistributedUpgradeGroupJSONRequestBody defines body for PostSystemDistributedUpgradeGroup for application/json ContentType.
type PostSystemDistributedUpgradeGroupJSONRequestBody = DistributedUpgradeRequest

// PostSystemInputsJSONRequestBody defines body for PostSystemInputs for application/json ContentType.
type PostSystemInputsJSONRequestBody = Input

// PatchSystemInputsIdJSONRequestBody defines body for PatchSystemInputsId for application/json ContentType.
type PatchSystemInputsIdJSONRequestBody = Input

// PostSystemInputsIdHectokenJSONRequestBody defines body for PostSystemInputsIdHectoken for application/json ContentType.
type PostSystemInputsIdHectokenJSONRequestBody = AddHecTokenRequest

// PatchSystemInputsIdHectokenTokenJSONRequestBody defines body for PatchSystemInputsIdHectokenToken for application/json ContentType.
type PatchSystemInputsIdHectokenTokenJSONRequestBody = UpdateHecTokenRequest

// PostSystemKeysJSONRequestBody defines body for PostSystemKeys for application/json ContentType.
type PostSystemKeysJSONRequestBody = KeyMetadataEntity

// PatchSystemKeysIdJSONRequestBody defines body for PatchSystemKeysId for application/json ContentType.
type PatchSystemKeysIdJSONRequestBody = KeyMetadataEntity

// PostSystemLicensesJSONRequestBody defines body for PostSystemLicenses for application/json ContentType.
type PostSystemLicensesJSONRequestBody = LicenseRequest

// PatchSystemLoggerIdJSONRequestBody defines body for PatchSystemLoggerId for application/json ContentType.
type PatchSystemLoggerIdJSONRequestBody = LoggerConfig

// PostSystemLookupsJSONRequestBody defines body for PostSystemLookups for application/json ContentType.
type PostSystemLookupsJSONRequestBody = LookupFile

// PatchSystemLookupsIdJSONRequestBody defines body for PatchSystemLookupsId for application/json ContentType.
type PatchSystemLookupsIdJSONRequestBody = LookupFile

// PostSystemMessagesJSONRequestBody defines body for PostSystemMessages for application/json ContentType.
type PostSystemMessagesJSONRequestBody = BulletinMessage

// PostSystemMetricsEnumJSONRequestBody defines body for PostSystemMetricsEnum for application/json ContentType.
type PostSystemMetricsEnumJSONRequestBody = GetNamesOpts

// PostSystemMetricsQueryJSONRequestBody defines body for PostSystemMetricsQuery for application/json ContentType.
type PostSystemMetricsQueryJSONRequestBody = MetricsAggOpts

// PostSystemOutputsJSONRequestBody defines body for PostSystemOutputs for application/json ContentType.
type PostSystemOutputsJSONRequestBody = Output

// PatchSystemOutputsIdJSONRequestBody defines body for PatchSystemOutputsId for application/json ContentType.
type PatchSystemOutputsIdJSONRequestBody = Output

// PostSystemOutputsIdTestJSONRequestBody defines body for PostSystemOutputsIdTest for application/json ContentType.
type PostSystemOutputsIdTestJSONRequestBody = OutputTestRequest

// PostSystemPoliciesJSONRequestBody defines body for PostSystemPolicies for application/json ContentType.
type PostSystemPoliciesJSONRequestBody = PolicyRule

// PatchSystemPoliciesIdJSONRequestBody defines body for PatchSystemPoliciesId for application/json ContentType.
type PatchSystemPoliciesIdJSONRequestBody = PolicyRule

// PostSystemProfilerJSONRequestBody defines body for PostSystemProfiler for application/json ContentType.
type PostSystemProfilerJSONRequestBody = ProfilerItem

// PatchSystemProfilerIdJSONRequestBody defines body for PatchSystemProfilerId for application/json ContentType.
type PatchSystemProfilerIdJSONRequestBody = ProfilerItem

// PostSystemProjectsJSONRequestBody defines body for PostSystemProjects for application/json ContentType.
type PostSystemProjectsJSONRequestBody = ProjectConfig

// PatchSystemProjectsIdJSONRequestBody defines body for PatchSystemProjectsId for application/json ContentType.
type PatchSystemProjectsIdJSONRequestBody = ProjectConfig

// PostSystemProjectsIdAclApplyJSONRequestBody defines body for PostSystemProjectsIdAclApply for application/json ContentType.
type PostSystemProjectsIdAclApplyJSONRequestBody = AccessControlSchema

// PostSystemProjectsIdAclTeamsApplyJSONRequestBody defines body for PostSystemProjectsIdAclTeamsApply for application/json ContentType.
type PostSystemProjectsIdAclTeamsApplyJSONRequestBody = AccessControlSchema

// PostSystemProjectsProjectIdCaptureJSONRequestBody defines body for PostSystemProjectsProjectIdCapture for application/json ContentType.
type PostSystemProjectsProjectIdCaptureJSONRequestBody = CaptureParams

// PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody defines body for PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture for application/json ContentType.
type PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody = CaptureParams

// PostSystemProjectsProjectIdVersionCommitJSONRequestBody defines body for PostSystemProjectsProjectIdVersionCommit for application/json ContentType.
type PostSystemProjectsProjectIdVersionCommitJSONRequestBody = ProjectGitCommitParams

// PostSystemProjectsProjectIdVersionRevertJSONRequestBody defines body for PostSystemProjectsProjectIdVersionRevert for application/json ContentType.
type PostSystemProjectsProjectIdVersionRevertJSONRequestBody = ProjectGitCommitParams

// PostSystemRolesJSONRequestBody defines body for PostSystemRoles for application/json ContentType.
type PostSystemRolesJSONRequestBody = Role

// PatchSystemRolesIdJSONRequestBody defines body for PatchSystemRolesId for application/json ContentType.
type PatchSystemRolesIdJSONRequestBody = Role

// PostSystemSamplesJSONRequestBody defines body for PostSystemSamples for application/json ContentType.
type PostSystemSamplesJSONRequestBody = DataSample

// PatchSystemSamplesIdJSONRequestBody defines body for PatchSystemSamplesId for application/json ContentType.
type PatchSystemSamplesIdJSONRequestBody = DataSample

// PostSystemScriptsJSONRequestBody defines body for PostSystemScripts for application/json ContentType.
type PostSystemScriptsJSONRequestBody = ScriptLibEntry

// PatchSystemScriptsIdJSONRequestBody defines body for PatchSystemScriptsId for application/json ContentType.
type PatchSystemScriptsIdJSONRequestBody = ScriptLibEntry

// PostSystemSecretsJSONRequestBody defines body for PostSystemSecrets for application/json ContentType.
type PostSystemSecretsJSONRequestBody = RestSecret

// PatchSystemSecretsIdJSONRequestBody defines body for PatchSystemSecretsId for application/json ContentType.
type PatchSystemSecretsIdJSONRequestBody = RestSecret

// PatchSystemSettingsConfJSONRequestBody defines body for PatchSystemSettingsConf for application/json ContentType.
type PatchSystemSettingsConfJSONRequestBody = SystemSettingsConf

// PostSystemSettingsUpgradeFromPackageJSONRequestBody defines body for PostSystemSettingsUpgradeFromPackage for application/json ContentType.
type PostSystemSettingsUpgradeFromPackageJSONRequestBody = UpgradeMasterRequest

// PostSystemTeamsJSONRequestBody defines body for PostSystemTeams for application/json ContentType.
type PostSystemTeamsJSONRequestBody = Team

// PatchSystemTeamsIdJSONRequestBody defines body for PatchSystemTeamsId for application/json ContentType.
type PatchSystemTeamsIdJSONRequestBody = Team

// PostSystemTeamsIdUsersJSONRequestBody defines body for PostSystemTeamsIdUsers for application/json ContentType.
type PostSystemTeamsIdUsersJSONRequestBody = MembershipSchema

// PostSystemUsersJSONRequestBody defines body for PostSystemUsers for application/json ContentType.
type PostSystemUsersJSONRequestBody = UserProfile

// PatchSystemUsersIdJSONRequestBody defines body for PatchSystemUsersId for application/json ContentType.
type PatchSystemUsersIdJSONRequestBody = UserProfile

// PatchSystemUsersIdInfoJSONRequestBody defines body for PatchSystemUsersIdInfo for application/json ContentType.
type PatchSystemUsersIdInfoJSONRequestBody = UserInfo

// PatchUiKeyJSONRequestBody defines body for PatchUiKey for application/json ContentType.
type PatchUiKeyJSONRequestBody = UiStatePatch

// PostVersionCommitJSONRequestBody defines body for PostVersionCommit for application/json ContentType.
type PostVersionCommitJSONRequestBody = GitCommitParams

// PostVersionRevertJSONRequestBody defines body for PostVersionRevert for application/json ContentType.
type PostVersionRevertJSONRequestBody = GitRevertParams

// Getter for additional properties for DataSample. Returns the specified
// element and whether it was found
func (a DataSample) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DataSample
func (a *DataSample) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DataSample to handle AdditionalProperties
func (a *DataSample) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["pipelineId"]; found {
		err = json.Unmarshal(raw, &a.PipelineId)
		if err != nil {
			return fmt.Errorf("error reading 'pipelineId': %w", err)
		}
		delete(object, "pipelineId")
	}

	if raw, found := object["sampleName"]; found {
		err = json.Unmarshal(raw, &a.SampleName)
		if err != nil {
			return fmt.Errorf("error reading 'sampleName': %w", err)
		}
		delete(object, "sampleName")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["ttl"]; found {
		err = json.Unmarshal(raw, &a.Ttl)
		if err != nil {
			return fmt.Errorf("error reading 'ttl': %w", err)
		}
		delete(object, "ttl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DataSample to handle AdditionalProperties
func (a DataSample) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.PipelineId != nil {
		object["pipelineId"], err = json.Marshal(a.PipelineId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipelineId': %w", err)
		}
	}

	object["sampleName"], err = json.Marshal(a.SampleName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sampleName': %w", err)
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if a.Ttl != nil {
		object["ttl"], err = json.Marshal(a.Ttl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ttl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ParserLibEntry. Returns the specified
// element and whether it was found
func (a ParserLibEntry) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ParserLibEntry
func (a *ParserLibEntry) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ParserLibEntry to handle AdditionalProperties
func (a *ParserLibEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["lib"]; found {
		err = json.Unmarshal(raw, &a.Lib)
		if err != nil {
			return fmt.Errorf("error reading 'lib': %w", err)
		}
		delete(object, "lib")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ParserLibEntry to handle AdditionalProperties
func (a ParserLibEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.Lib != nil {
		object["lib"], err = json.Marshal(a.Lib)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lib': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Routes_Comments_Item. Returns the specified
// element and whether it was found
func (a Routes_Comments_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Routes_Comments_Item
func (a *Routes_Comments_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Routes_Comments_Item to handle AdditionalProperties
func (a *Routes_Comments_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["comment"]; found {
		err = json.Unmarshal(raw, &a.Comment)
		if err != nil {
			return fmt.Errorf("error reading 'comment': %w", err)
		}
		delete(object, "comment")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Routes_Comments_Item to handle AdditionalProperties
func (a Routes_Comments_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Comment != nil {
		object["comment"], err = json.Marshal(a.Comment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'comment': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RoutesRoute. Returns the specified
// element and whether it was found
func (a RoutesRoute) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RoutesRoute
func (a *RoutesRoute) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RoutesRoute to handle AdditionalProperties
func (a *RoutesRoute) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["disabled"]; found {
		err = json.Unmarshal(raw, &a.Disabled)
		if err != nil {
			return fmt.Errorf("error reading 'disabled': %w", err)
		}
		delete(object, "disabled")
	}

	if raw, found := object["enableOutputExpression"]; found {
		err = json.Unmarshal(raw, &a.EnableOutputExpression)
		if err != nil {
			return fmt.Errorf("error reading 'enableOutputExpression': %w", err)
		}
		delete(object, "enableOutputExpression")
	}

	if raw, found := object["filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return fmt.Errorf("error reading 'filter': %w", err)
		}
		delete(object, "filter")
	}

	if raw, found := object["final"]; found {
		err = json.Unmarshal(raw, &a.Final)
		if err != nil {
			return fmt.Errorf("error reading 'final': %w", err)
		}
		delete(object, "final")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if raw, found := object["outputExpression"]; found {
		err = json.Unmarshal(raw, &a.OutputExpression)
		if err != nil {
			return fmt.Errorf("error reading 'outputExpression': %w", err)
		}
		delete(object, "outputExpression")
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &a.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
		delete(object, "pipeline")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RoutesRoute to handle AdditionalProperties
func (a RoutesRoute) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Disabled != nil {
		object["disabled"], err = json.Marshal(a.Disabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disabled': %w", err)
		}
	}

	if a.EnableOutputExpression != nil {
		object["enableOutputExpression"], err = json.Marshal(a.EnableOutputExpression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enableOutputExpression': %w", err)
		}
	}

	if a.Filter != nil {
		object["filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'filter': %w", err)
		}
	}

	if a.Final != nil {
		object["final"], err = json.Marshal(a.Final)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'final': %w", err)
		}
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Output != nil {
		object["output"], err = json.Marshal(a.Output)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'output': %w", err)
		}
	}

	if a.OutputExpression != nil {
		object["outputExpression"], err = json.Marshal(a.OutputExpression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outputExpression': %w", err)
		}
	}

	object["pipeline"], err = json.Marshal(a.Pipeline)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SchemaLibEntry. Returns the specified
// element and whether it was found
func (a SchemaLibEntry) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SchemaLibEntry
func (a *SchemaLibEntry) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SchemaLibEntry to handle AdditionalProperties
func (a *SchemaLibEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["schema"]; found {
		err = json.Unmarshal(raw, &a.Schema)
		if err != nil {
			return fmt.Errorf("error reading 'schema': %w", err)
		}
		delete(object, "schema")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SchemaLibEntry to handle AdditionalProperties
func (a SchemaLibEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["schema"], err = json.Marshal(a.Schema)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'schema': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScriptLibEntry. Returns the specified
// element and whether it was found
func (a ScriptLibEntry) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScriptLibEntry
func (a *ScriptLibEntry) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScriptLibEntry to handle AdditionalProperties
func (a *ScriptLibEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["args"]; found {
		err = json.Unmarshal(raw, &a.Args)
		if err != nil {
			return fmt.Errorf("error reading 'args': %w", err)
		}
		delete(object, "args")
	}

	if raw, found := object["command"]; found {
		err = json.Unmarshal(raw, &a.Command)
		if err != nil {
			return fmt.Errorf("error reading 'command': %w", err)
		}
		delete(object, "command")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["env"]; found {
		err = json.Unmarshal(raw, &a.Env)
		if err != nil {
			return fmt.Errorf("error reading 'env': %w", err)
		}
		delete(object, "env")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScriptLibEntry to handle AdditionalProperties
func (a ScriptLibEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Args != nil {
		object["args"], err = json.Marshal(a.Args)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'args': %w", err)
		}
	}

	object["command"], err = json.Marshal(a.Command)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'command': %w", err)
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Env != nil {
		object["env"], err = json.Marshal(a.Env)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'env': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAMTrustPolicyStatementAction0 returns the Union data inside the AMTrustPolicy_Statement_Action as a AMTrustPolicyStatementAction0
func (t AMTrustPolicy_Statement_Action) AsAMTrustPolicyStatementAction0() (AMTrustPolicyStatementAction0, error) {
	var body AMTrustPolicyStatementAction0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromAMTrustPolicyStatementAction0 overwrites any Union data inside the AMTrustPolicy_Statement_Action as the provided AMTrustPolicyStatementAction0
func (t *AMTrustPolicy_Statement_Action) FromAMTrustPolicyStatementAction0(v AMTrustPolicyStatementAction0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeAMTrustPolicyStatementAction0 performs a merge with any Union data inside the AMTrustPolicy_Statement_Action, using the provided AMTrustPolicyStatementAction0
func (t *AMTrustPolicy_Statement_Action) MergeAMTrustPolicyStatementAction0(v AMTrustPolicyStatementAction0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsAMTrustPolicyStatementAction1 returns the Union data inside the AMTrustPolicy_Statement_Action as a AMTrustPolicyStatementAction1
func (t AMTrustPolicy_Statement_Action) AsAMTrustPolicyStatementAction1() (AMTrustPolicyStatementAction1, error) {
	var body AMTrustPolicyStatementAction1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromAMTrustPolicyStatementAction1 overwrites any Union data inside the AMTrustPolicy_Statement_Action as the provided AMTrustPolicyStatementAction1
func (t *AMTrustPolicy_Statement_Action) FromAMTrustPolicyStatementAction1(v AMTrustPolicyStatementAction1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeAMTrustPolicyStatementAction1 performs a merge with any Union data inside the AMTrustPolicy_Statement_Action, using the provided AMTrustPolicyStatementAction1
func (t *AMTrustPolicy_Statement_Action) MergeAMTrustPolicyStatementAction1(v AMTrustPolicyStatementAction1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t AMTrustPolicy_Statement_Action) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *AMTrustPolicy_Statement_Action) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsChartConfigCustomDataPointScale0 returns the Union data inside the ChartConfig_CustomData_PointScale as a ChartConfigCustomDataPointScale0
func (t ChartConfig_CustomData_PointScale) AsChartConfigCustomDataPointScale0() (ChartConfigCustomDataPointScale0, error) {
	var body ChartConfigCustomDataPointScale0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromChartConfigCustomDataPointScale0 overwrites any Union data inside the ChartConfig_CustomData_PointScale as the provided ChartConfigCustomDataPointScale0
func (t *ChartConfig_CustomData_PointScale) FromChartConfigCustomDataPointScale0(v ChartConfigCustomDataPointScale0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeChartConfigCustomDataPointScale0 performs a merge with any Union data inside the ChartConfig_CustomData_PointScale, using the provided ChartConfigCustomDataPointScale0
func (t *ChartConfig_CustomData_PointScale) MergeChartConfigCustomDataPointScale0(v ChartConfigCustomDataPointScale0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsChartConfigCustomDataPointScale1 returns the Union data inside the ChartConfig_CustomData_PointScale as a ChartConfigCustomDataPointScale1
func (t ChartConfig_CustomData_PointScale) AsChartConfigCustomDataPointScale1() (ChartConfigCustomDataPointScale1, error) {
	var body ChartConfigCustomDataPointScale1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromChartConfigCustomDataPointScale1 overwrites any Union data inside the ChartConfig_CustomData_PointScale as the provided ChartConfigCustomDataPointScale1
func (t *ChartConfig_CustomData_PointScale) FromChartConfigCustomDataPointScale1(v ChartConfigCustomDataPointScale1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeChartConfigCustomDataPointScale1 performs a merge with any Union data inside the ChartConfig_CustomData_PointScale, using the provided ChartConfigCustomDataPointScale1
func (t *ChartConfig_CustomData_PointScale) MergeChartConfigCustomDataPointScale1(v ChartConfigCustomDataPointScale1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t ChartConfig_CustomData_PointScale) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *ChartConfig_CustomData_PointScale) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsChartConfigMapDetailsPointScale0 returns the Union data inside the ChartConfig_MapDetails_PointScale as a ChartConfigMapDetailsPointScale0
func (t ChartConfig_MapDetails_PointScale) AsChartConfigMapDetailsPointScale0() (ChartConfigMapDetailsPointScale0, error) {
	var body ChartConfigMapDetailsPointScale0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromChartConfigMapDetailsPointScale0 overwrites any Union data inside the ChartConfig_MapDetails_PointScale as the provided ChartConfigMapDetailsPointScale0
func (t *ChartConfig_MapDetails_PointScale) FromChartConfigMapDetailsPointScale0(v ChartConfigMapDetailsPointScale0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeChartConfigMapDetailsPointScale0 performs a merge with any Union data inside the ChartConfig_MapDetails_PointScale, using the provided ChartConfigMapDetailsPointScale0
func (t *ChartConfig_MapDetails_PointScale) MergeChartConfigMapDetailsPointScale0(v ChartConfigMapDetailsPointScale0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsChartConfigMapDetailsPointScale1 returns the Union data inside the ChartConfig_MapDetails_PointScale as a ChartConfigMapDetailsPointScale1
func (t ChartConfig_MapDetails_PointScale) AsChartConfigMapDetailsPointScale1() (ChartConfigMapDetailsPointScale1, error) {
	var body ChartConfigMapDetailsPointScale1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromChartConfigMapDetailsPointScale1 overwrites any Union data inside the ChartConfig_MapDetails_PointScale as the provided ChartConfigMapDetailsPointScale1
func (t *ChartConfig_MapDetails_PointScale) FromChartConfigMapDetailsPointScale1(v ChartConfigMapDetailsPointScale1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeChartConfigMapDetailsPointScale1 performs a merge with any Union data inside the ChartConfig_MapDetails_PointScale, using the provided ChartConfigMapDetailsPointScale1
func (t *ChartConfig_MapDetails_PointScale) MergeChartConfigMapDetailsPointScale1(v ChartConfigMapDetailsPointScale1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t ChartConfig_MapDetails_PointScale) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *ChartConfig_MapDetails_PointScale) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsContainerCommand0 returns the Union data inside the Container_Command as a ContainerCommand0
func (t Container_Command) AsContainerCommand0() (ContainerCommand0, error) {
	var body ContainerCommand0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromContainerCommand0 overwrites any Union data inside the Container_Command as the provided ContainerCommand0
func (t *Container_Command) FromContainerCommand0(v ContainerCommand0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeContainerCommand0 performs a merge with any Union data inside the Container_Command, using the provided ContainerCommand0
func (t *Container_Command) MergeContainerCommand0(v ContainerCommand0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsContainerCommand1 returns the Union data inside the Container_Command as a ContainerCommand1
func (t Container_Command) AsContainerCommand1() (ContainerCommand1, error) {
	var body ContainerCommand1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromContainerCommand1 overwrites any Union data inside the Container_Command as the provided ContainerCommand1
func (t *Container_Command) FromContainerCommand1(v ContainerCommand1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeContainerCommand1 performs a merge with any Union data inside the Container_Command, using the provided ContainerCommand1
func (t *Container_Command) MergeContainerCommand1(v ContainerCommand1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t Container_Command) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *Container_Command) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsDatatypePreviewInput0 returns the Union data inside the DatatypePreviewInput as a DatatypePreviewInput0
func (t DatatypePreviewInput) AsDatatypePreviewInput0() (DatatypePreviewInput0, error) {
	var body DatatypePreviewInput0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromDatatypePreviewInput0 overwrites any Union data inside the DatatypePreviewInput as the provided DatatypePreviewInput0
func (t *DatatypePreviewInput) FromDatatypePreviewInput0(v DatatypePreviewInput0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeDatatypePreviewInput0 performs a merge with any Union data inside the DatatypePreviewInput, using the provided DatatypePreviewInput0
func (t *DatatypePreviewInput) MergeDatatypePreviewInput0(v DatatypePreviewInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsDatatypePreviewInput1 returns the Union data inside the DatatypePreviewInput as a DatatypePreviewInput1
func (t DatatypePreviewInput) AsDatatypePreviewInput1() (DatatypePreviewInput1, error) {
	var body DatatypePreviewInput1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromDatatypePreviewInput1 overwrites any Union data inside the DatatypePreviewInput as the provided DatatypePreviewInput1
func (t *DatatypePreviewInput) FromDatatypePreviewInput1(v DatatypePreviewInput1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeDatatypePreviewInput1 performs a merge with any Union data inside the DatatypePreviewInput, using the provided DatatypePreviewInput1
func (t *DatatypePreviewInput) MergeDatatypePreviewInput1(v DatatypePreviewInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t DatatypePreviewInput) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *DatatypePreviewInput) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsEventBreakerRuleParser0 returns the Union data inside the EventBreakerRule_Parser as a EventBreakerRuleParser0
func (t EventBreakerRule_Parser) AsEventBreakerRuleParser0() (EventBreakerRuleParser0, error) {
	var body EventBreakerRuleParser0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleParser0 overwrites any Union data inside the EventBreakerRule_Parser as the provided EventBreakerRuleParser0
func (t *EventBreakerRule_Parser) FromEventBreakerRuleParser0(v EventBreakerRuleParser0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleParser0 performs a merge with any Union data inside the EventBreakerRule_Parser, using the provided EventBreakerRuleParser0
func (t *EventBreakerRule_Parser) MergeEventBreakerRuleParser0(v EventBreakerRuleParser0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsEventBreakerRuleParser1 returns the Union data inside the EventBreakerRule_Parser as a EventBreakerRuleParser1
func (t EventBreakerRule_Parser) AsEventBreakerRuleParser1() (EventBreakerRuleParser1, error) {
	var body EventBreakerRuleParser1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleParser1 overwrites any Union data inside the EventBreakerRule_Parser as the provided EventBreakerRuleParser1
func (t *EventBreakerRule_Parser) FromEventBreakerRuleParser1(v EventBreakerRuleParser1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleParser1 performs a merge with any Union data inside the EventBreakerRule_Parser, using the provided EventBreakerRuleParser1
func (t *EventBreakerRule_Parser) MergeEventBreakerRuleParser1(v EventBreakerRuleParser1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsEventBreakerRuleParser2 returns the Union data inside the EventBreakerRule_Parser as a EventBreakerRuleParser2
func (t EventBreakerRule_Parser) AsEventBreakerRuleParser2() (EventBreakerRuleParser2, error) {
	var body EventBreakerRuleParser2
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleParser2 overwrites any Union data inside the EventBreakerRule_Parser as the provided EventBreakerRuleParser2
func (t *EventBreakerRule_Parser) FromEventBreakerRuleParser2(v EventBreakerRuleParser2) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleParser2 performs a merge with any Union data inside the EventBreakerRule_Parser, using the provided EventBreakerRuleParser2
func (t *EventBreakerRule_Parser) MergeEventBreakerRuleParser2(v EventBreakerRuleParser2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsEventBreakerRuleParser3 returns the Union data inside the EventBreakerRule_Parser as a EventBreakerRuleParser3
func (t EventBreakerRule_Parser) AsEventBreakerRuleParser3() (EventBreakerRuleParser3, error) {
	var body EventBreakerRuleParser3
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleParser3 overwrites any Union data inside the EventBreakerRule_Parser as the provided EventBreakerRuleParser3
func (t *EventBreakerRule_Parser) FromEventBreakerRuleParser3(v EventBreakerRuleParser3) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleParser3 performs a merge with any Union data inside the EventBreakerRule_Parser, using the provided EventBreakerRuleParser3
func (t *EventBreakerRule_Parser) MergeEventBreakerRuleParser3(v EventBreakerRuleParser3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t EventBreakerRule_Parser) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *EventBreakerRule_Parser) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsEventBreakerRuleTimestampTimezone0 returns the Union data inside the EventBreakerRule_TimestampTimezone as a EventBreakerRuleTimestampTimezone0
func (t EventBreakerRule_TimestampTimezone) AsEventBreakerRuleTimestampTimezone0() (EventBreakerRuleTimestampTimezone0, error) {
	var body EventBreakerRuleTimestampTimezone0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleTimestampTimezone0 overwrites any Union data inside the EventBreakerRule_TimestampTimezone as the provided EventBreakerRuleTimestampTimezone0
func (t *EventBreakerRule_TimestampTimezone) FromEventBreakerRuleTimestampTimezone0(v EventBreakerRuleTimestampTimezone0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleTimestampTimezone0 performs a merge with any Union data inside the EventBreakerRule_TimestampTimezone, using the provided EventBreakerRuleTimestampTimezone0
func (t *EventBreakerRule_TimestampTimezone) MergeEventBreakerRuleTimestampTimezone0(v EventBreakerRuleTimestampTimezone0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsEventBreakerRuleTimestampTimezone1 returns the Union data inside the EventBreakerRule_TimestampTimezone as a EventBreakerRuleTimestampTimezone1
func (t EventBreakerRule_TimestampTimezone) AsEventBreakerRuleTimestampTimezone1() (EventBreakerRuleTimestampTimezone1, error) {
	var body EventBreakerRuleTimestampTimezone1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromEventBreakerRuleTimestampTimezone1 overwrites any Union data inside the EventBreakerRule_TimestampTimezone as the provided EventBreakerRuleTimestampTimezone1
func (t *EventBreakerRule_TimestampTimezone) FromEventBreakerRuleTimestampTimezone1(v EventBreakerRuleTimestampTimezone1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeEventBreakerRuleTimestampTimezone1 performs a merge with any Union data inside the EventBreakerRule_TimestampTimezone, using the provided EventBreakerRuleTimestampTimezone1
func (t *EventBreakerRule_TimestampTimezone) MergeEventBreakerRuleTimestampTimezone1(v EventBreakerRuleTimestampTimezone1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t EventBreakerRule_TimestampTimezone) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *EventBreakerRule_TimestampTimezone) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsGitInfoRemote0 returns the Union data inside the GitInfo_Remote as a GitInfoRemote0
func (t GitInfo_Remote) AsGitInfoRemote0() (GitInfoRemote0, error) {
	var body GitInfoRemote0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromGitInfoRemote0 overwrites any Union data inside the GitInfo_Remote as the provided GitInfoRemote0
func (t *GitInfo_Remote) FromGitInfoRemote0(v GitInfoRemote0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeGitInfoRemote0 performs a merge with any Union data inside the GitInfo_Remote, using the provided GitInfoRemote0
func (t *GitInfo_Remote) MergeGitInfoRemote0(v GitInfoRemote0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsGitInfoRemote1 returns the Union data inside the GitInfo_Remote as a GitInfoRemote1
func (t GitInfo_Remote) AsGitInfoRemote1() (GitInfoRemote1, error) {
	var body GitInfoRemote1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromGitInfoRemote1 overwrites any Union data inside the GitInfo_Remote as the provided GitInfoRemote1
func (t *GitInfo_Remote) FromGitInfoRemote1(v GitInfoRemote1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeGitInfoRemote1 performs a merge with any Union data inside the GitInfo_Remote, using the provided GitInfoRemote1
func (t *GitInfo_Remote) MergeGitInfoRemote1(v GitInfoRemote1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t GitInfo_Remote) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *GitInfo_Remote) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsInputCollection returns the Union data inside the Input as a InputCollection
func (t Input) AsInputCollection() (InputCollection, error) {
	var body InputCollection
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCollection overwrites any Union data inside the Input as the provided InputCollection
func (t *Input) FromInputCollection(v InputCollection) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCollection performs a merge with any Union data inside the Input, using the provided InputCollection
func (t *Input) MergeInputCollection(v InputCollection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputKafka returns the Union data inside the Input as a InputKafka
func (t Input) AsInputKafka() (InputKafka, error) {
	var body InputKafka
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputKafka overwrites any Union data inside the Input as the provided InputKafka
func (t *Input) FromInputKafka(v InputKafka) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputKafka performs a merge with any Union data inside the Input, using the provided InputKafka
func (t *Input) MergeInputKafka(v InputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputMsk returns the Union data inside the Input as a InputMsk
func (t Input) AsInputMsk() (InputMsk, error) {
	var body InputMsk
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputMsk overwrites any Union data inside the Input as the provided InputMsk
func (t *Input) FromInputMsk(v InputMsk) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputMsk performs a merge with any Union data inside the Input, using the provided InputMsk
func (t *Input) MergeInputMsk(v InputMsk) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputHttp returns the Union data inside the Input as a InputHttp
func (t Input) AsInputHttp() (InputHttp, error) {
	var body InputHttp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputHttp overwrites any Union data inside the Input as the provided InputHttp
func (t *Input) FromInputHttp(v InputHttp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputHttp performs a merge with any Union data inside the Input, using the provided InputHttp
func (t *Input) MergeInputHttp(v InputHttp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSplunk returns the Union data inside the Input as a InputSplunk
func (t Input) AsInputSplunk() (InputSplunk, error) {
	var body InputSplunk
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSplunk overwrites any Union data inside the Input as the provided InputSplunk
func (t *Input) FromInputSplunk(v InputSplunk) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSplunk performs a merge with any Union data inside the Input, using the provided InputSplunk
func (t *Input) MergeInputSplunk(v InputSplunk) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSplunkSearch returns the Union data inside the Input as a InputSplunkSearch
func (t Input) AsInputSplunkSearch() (InputSplunkSearch, error) {
	var body InputSplunkSearch
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSplunkSearch overwrites any Union data inside the Input as the provided InputSplunkSearch
func (t *Input) FromInputSplunkSearch(v InputSplunkSearch) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSplunkSearch performs a merge with any Union data inside the Input, using the provided InputSplunkSearch
func (t *Input) MergeInputSplunkSearch(v InputSplunkSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSplunkHec returns the Union data inside the Input as a InputSplunkHec
func (t Input) AsInputSplunkHec() (InputSplunkHec, error) {
	var body InputSplunkHec
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSplunkHec overwrites any Union data inside the Input as the provided InputSplunkHec
func (t *Input) FromInputSplunkHec(v InputSplunkHec) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSplunkHec performs a merge with any Union data inside the Input, using the provided InputSplunkHec
func (t *Input) MergeInputSplunkHec(v InputSplunkHec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputAzureBlob returns the Union data inside the Input as a InputAzureBlob
func (t Input) AsInputAzureBlob() (InputAzureBlob, error) {
	var body InputAzureBlob
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputAzureBlob overwrites any Union data inside the Input as the provided InputAzureBlob
func (t *Input) FromInputAzureBlob(v InputAzureBlob) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputAzureBlob performs a merge with any Union data inside the Input, using the provided InputAzureBlob
func (t *Input) MergeInputAzureBlob(v InputAzureBlob) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputElastic returns the Union data inside the Input as a InputElastic
func (t Input) AsInputElastic() (InputElastic, error) {
	var body InputElastic
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputElastic overwrites any Union data inside the Input as the provided InputElastic
func (t *Input) FromInputElastic(v InputElastic) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputElastic performs a merge with any Union data inside the Input, using the provided InputElastic
func (t *Input) MergeInputElastic(v InputElastic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputConfluentCloud returns the Union data inside the Input as a InputConfluentCloud
func (t Input) AsInputConfluentCloud() (InputConfluentCloud, error) {
	var body InputConfluentCloud
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputConfluentCloud overwrites any Union data inside the Input as the provided InputConfluentCloud
func (t *Input) FromInputConfluentCloud(v InputConfluentCloud) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputConfluentCloud performs a merge with any Union data inside the Input, using the provided InputConfluentCloud
func (t *Input) MergeInputConfluentCloud(v InputConfluentCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputGrafana returns the Union data inside the Input as a InputGrafana
func (t Input) AsInputGrafana() (InputGrafana, error) {
	var body InputGrafana
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputGrafana overwrites any Union data inside the Input as the provided InputGrafana
func (t *Input) FromInputGrafana(v InputGrafana) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputGrafana performs a merge with any Union data inside the Input, using the provided InputGrafana
func (t *Input) MergeInputGrafana(v InputGrafana) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputLoki returns the Union data inside the Input as a InputLoki
func (t Input) AsInputLoki() (InputLoki, error) {
	var body InputLoki
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputLoki overwrites any Union data inside the Input as the provided InputLoki
func (t *Input) FromInputLoki(v InputLoki) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputLoki performs a merge with any Union data inside the Input, using the provided InputLoki
func (t *Input) MergeInputLoki(v InputLoki) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputPrometheusRw returns the Union data inside the Input as a InputPrometheusRw
func (t Input) AsInputPrometheusRw() (InputPrometheusRw, error) {
	var body InputPrometheusRw
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputPrometheusRw overwrites any Union data inside the Input as the provided InputPrometheusRw
func (t *Input) FromInputPrometheusRw(v InputPrometheusRw) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputPrometheusRw performs a merge with any Union data inside the Input, using the provided InputPrometheusRw
func (t *Input) MergeInputPrometheusRw(v InputPrometheusRw) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputPrometheus returns the Union data inside the Input as a InputPrometheus
func (t Input) AsInputPrometheus() (InputPrometheus, error) {
	var body InputPrometheus
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputPrometheus overwrites any Union data inside the Input as the provided InputPrometheus
func (t *Input) FromInputPrometheus(v InputPrometheus) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputPrometheus performs a merge with any Union data inside the Input, using the provided InputPrometheus
func (t *Input) MergeInputPrometheus(v InputPrometheus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputEdgePrometheus returns the Union data inside the Input as a InputEdgePrometheus
func (t Input) AsInputEdgePrometheus() (InputEdgePrometheus, error) {
	var body InputEdgePrometheus
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputEdgePrometheus overwrites any Union data inside the Input as the provided InputEdgePrometheus
func (t *Input) FromInputEdgePrometheus(v InputEdgePrometheus) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputEdgePrometheus performs a merge with any Union data inside the Input, using the provided InputEdgePrometheus
func (t *Input) MergeInputEdgePrometheus(v InputEdgePrometheus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputOffice365Mgmt returns the Union data inside the Input as a InputOffice365Mgmt
func (t Input) AsInputOffice365Mgmt() (InputOffice365Mgmt, error) {
	var body InputOffice365Mgmt
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputOffice365Mgmt overwrites any Union data inside the Input as the provided InputOffice365Mgmt
func (t *Input) FromInputOffice365Mgmt(v InputOffice365Mgmt) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputOffice365Mgmt performs a merge with any Union data inside the Input, using the provided InputOffice365Mgmt
func (t *Input) MergeInputOffice365Mgmt(v InputOffice365Mgmt) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputOffice365Service returns the Union data inside the Input as a InputOffice365Service
func (t Input) AsInputOffice365Service() (InputOffice365Service, error) {
	var body InputOffice365Service
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputOffice365Service overwrites any Union data inside the Input as the provided InputOffice365Service
func (t *Input) FromInputOffice365Service(v InputOffice365Service) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputOffice365Service performs a merge with any Union data inside the Input, using the provided InputOffice365Service
func (t *Input) MergeInputOffice365Service(v InputOffice365Service) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputOffice365MsgTrace returns the Union data inside the Input as a InputOffice365MsgTrace
func (t Input) AsInputOffice365MsgTrace() (InputOffice365MsgTrace, error) {
	var body InputOffice365MsgTrace
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputOffice365MsgTrace overwrites any Union data inside the Input as the provided InputOffice365MsgTrace
func (t *Input) FromInputOffice365MsgTrace(v InputOffice365MsgTrace) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputOffice365MsgTrace performs a merge with any Union data inside the Input, using the provided InputOffice365MsgTrace
func (t *Input) MergeInputOffice365MsgTrace(v InputOffice365MsgTrace) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputEventhub returns the Union data inside the Input as a InputEventhub
func (t Input) AsInputEventhub() (InputEventhub, error) {
	var body InputEventhub
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputEventhub overwrites any Union data inside the Input as the provided InputEventhub
func (t *Input) FromInputEventhub(v InputEventhub) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputEventhub performs a merge with any Union data inside the Input, using the provided InputEventhub
func (t *Input) MergeInputEventhub(v InputEventhub) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputExec returns the Union data inside the Input as a InputExec
func (t Input) AsInputExec() (InputExec, error) {
	var body InputExec
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputExec overwrites any Union data inside the Input as the provided InputExec
func (t *Input) FromInputExec(v InputExec) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputExec performs a merge with any Union data inside the Input, using the provided InputExec
func (t *Input) MergeInputExec(v InputExec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputFirehose returns the Union data inside the Input as a InputFirehose
func (t Input) AsInputFirehose() (InputFirehose, error) {
	var body InputFirehose
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputFirehose overwrites any Union data inside the Input as the provided InputFirehose
func (t *Input) FromInputFirehose(v InputFirehose) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputFirehose performs a merge with any Union data inside the Input, using the provided InputFirehose
func (t *Input) MergeInputFirehose(v InputFirehose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputGooglePubsub returns the Union data inside the Input as a InputGooglePubsub
func (t Input) AsInputGooglePubsub() (InputGooglePubsub, error) {
	var body InputGooglePubsub
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputGooglePubsub overwrites any Union data inside the Input as the provided InputGooglePubsub
func (t *Input) FromInputGooglePubsub(v InputGooglePubsub) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputGooglePubsub performs a merge with any Union data inside the Input, using the provided InputGooglePubsub
func (t *Input) MergeInputGooglePubsub(v InputGooglePubsub) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputCribl returns the Union data inside the Input as a InputCribl
func (t Input) AsInputCribl() (InputCribl, error) {
	var body InputCribl
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCribl overwrites any Union data inside the Input as the provided InputCribl
func (t *Input) FromInputCribl(v InputCribl) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCribl performs a merge with any Union data inside the Input, using the provided InputCribl
func (t *Input) MergeInputCribl(v InputCribl) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputCriblTcp returns the Union data inside the Input as a InputCriblTcp
func (t Input) AsInputCriblTcp() (InputCriblTcp, error) {
	var body InputCriblTcp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCriblTcp overwrites any Union data inside the Input as the provided InputCriblTcp
func (t *Input) FromInputCriblTcp(v InputCriblTcp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCriblTcp performs a merge with any Union data inside the Input, using the provided InputCriblTcp
func (t *Input) MergeInputCriblTcp(v InputCriblTcp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputCriblHttp returns the Union data inside the Input as a InputCriblHttp
func (t Input) AsInputCriblHttp() (InputCriblHttp, error) {
	var body InputCriblHttp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCriblHttp overwrites any Union data inside the Input as the provided InputCriblHttp
func (t *Input) FromInputCriblHttp(v InputCriblHttp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCriblHttp performs a merge with any Union data inside the Input, using the provided InputCriblHttp
func (t *Input) MergeInputCriblHttp(v InputCriblHttp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputTcpjson returns the Union data inside the Input as a InputTcpjson
func (t Input) AsInputTcpjson() (InputTcpjson, error) {
	var body InputTcpjson
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputTcpjson overwrites any Union data inside the Input as the provided InputTcpjson
func (t *Input) FromInputTcpjson(v InputTcpjson) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputTcpjson performs a merge with any Union data inside the Input, using the provided InputTcpjson
func (t *Input) MergeInputTcpjson(v InputTcpjson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSystemMetrics returns the Union data inside the Input as a InputSystemMetrics
func (t Input) AsInputSystemMetrics() (InputSystemMetrics, error) {
	var body InputSystemMetrics
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSystemMetrics overwrites any Union data inside the Input as the provided InputSystemMetrics
func (t *Input) FromInputSystemMetrics(v InputSystemMetrics) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSystemMetrics performs a merge with any Union data inside the Input, using the provided InputSystemMetrics
func (t *Input) MergeInputSystemMetrics(v InputSystemMetrics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSystemState returns the Union data inside the Input as a InputSystemState
func (t Input) AsInputSystemState() (InputSystemState, error) {
	var body InputSystemState
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSystemState overwrites any Union data inside the Input as the provided InputSystemState
func (t *Input) FromInputSystemState(v InputSystemState) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSystemState performs a merge with any Union data inside the Input, using the provided InputSystemState
func (t *Input) MergeInputSystemState(v InputSystemState) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputKubeMetrics returns the Union data inside the Input as a InputKubeMetrics
func (t Input) AsInputKubeMetrics() (InputKubeMetrics, error) {
	var body InputKubeMetrics
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputKubeMetrics overwrites any Union data inside the Input as the provided InputKubeMetrics
func (t *Input) FromInputKubeMetrics(v InputKubeMetrics) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputKubeMetrics performs a merge with any Union data inside the Input, using the provided InputKubeMetrics
func (t *Input) MergeInputKubeMetrics(v InputKubeMetrics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputKubeLogs returns the Union data inside the Input as a InputKubeLogs
func (t Input) AsInputKubeLogs() (InputKubeLogs, error) {
	var body InputKubeLogs
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputKubeLogs overwrites any Union data inside the Input as the provided InputKubeLogs
func (t *Input) FromInputKubeLogs(v InputKubeLogs) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputKubeLogs performs a merge with any Union data inside the Input, using the provided InputKubeLogs
func (t *Input) MergeInputKubeLogs(v InputKubeLogs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputKubeEvents returns the Union data inside the Input as a InputKubeEvents
func (t Input) AsInputKubeEvents() (InputKubeEvents, error) {
	var body InputKubeEvents
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputKubeEvents overwrites any Union data inside the Input as the provided InputKubeEvents
func (t *Input) FromInputKubeEvents(v InputKubeEvents) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputKubeEvents performs a merge with any Union data inside the Input, using the provided InputKubeEvents
func (t *Input) MergeInputKubeEvents(v InputKubeEvents) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputWindowsMetrics returns the Union data inside the Input as a InputWindowsMetrics
func (t Input) AsInputWindowsMetrics() (InputWindowsMetrics, error) {
	var body InputWindowsMetrics
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputWindowsMetrics overwrites any Union data inside the Input as the provided InputWindowsMetrics
func (t *Input) FromInputWindowsMetrics(v InputWindowsMetrics) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputWindowsMetrics performs a merge with any Union data inside the Input, using the provided InputWindowsMetrics
func (t *Input) MergeInputWindowsMetrics(v InputWindowsMetrics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputCrowdstrike returns the Union data inside the Input as a InputCrowdstrike
func (t Input) AsInputCrowdstrike() (InputCrowdstrike, error) {
	var body InputCrowdstrike
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCrowdstrike overwrites any Union data inside the Input as the provided InputCrowdstrike
func (t *Input) FromInputCrowdstrike(v InputCrowdstrike) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCrowdstrike performs a merge with any Union data inside the Input, using the provided InputCrowdstrike
func (t *Input) MergeInputCrowdstrike(v InputCrowdstrike) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputDatadogAgent returns the Union data inside the Input as a InputDatadogAgent
func (t Input) AsInputDatadogAgent() (InputDatadogAgent, error) {
	var body InputDatadogAgent
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputDatadogAgent overwrites any Union data inside the Input as the provided InputDatadogAgent
func (t *Input) FromInputDatadogAgent(v InputDatadogAgent) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputDatadogAgent performs a merge with any Union data inside the Input, using the provided InputDatadogAgent
func (t *Input) MergeInputDatadogAgent(v InputDatadogAgent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputDatagen returns the Union data inside the Input as a InputDatagen
func (t Input) AsInputDatagen() (InputDatagen, error) {
	var body InputDatagen
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputDatagen overwrites any Union data inside the Input as the provided InputDatagen
func (t *Input) FromInputDatagen(v InputDatagen) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputDatagen performs a merge with any Union data inside the Input, using the provided InputDatagen
func (t *Input) MergeInputDatagen(v InputDatagen) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputHttpRaw returns the Union data inside the Input as a InputHttpRaw
func (t Input) AsInputHttpRaw() (InputHttpRaw, error) {
	var body InputHttpRaw
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputHttpRaw overwrites any Union data inside the Input as the provided InputHttpRaw
func (t *Input) FromInputHttpRaw(v InputHttpRaw) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputHttpRaw performs a merge with any Union data inside the Input, using the provided InputHttpRaw
func (t *Input) MergeInputHttpRaw(v InputHttpRaw) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputKinesis returns the Union data inside the Input as a InputKinesis
func (t Input) AsInputKinesis() (InputKinesis, error) {
	var body InputKinesis
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputKinesis overwrites any Union data inside the Input as the provided InputKinesis
func (t *Input) FromInputKinesis(v InputKinesis) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputKinesis performs a merge with any Union data inside the Input, using the provided InputKinesis
func (t *Input) MergeInputKinesis(v InputKinesis) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputCriblmetrics returns the Union data inside the Input as a InputCriblmetrics
func (t Input) AsInputCriblmetrics() (InputCriblmetrics, error) {
	var body InputCriblmetrics
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputCriblmetrics overwrites any Union data inside the Input as the provided InputCriblmetrics
func (t *Input) FromInputCriblmetrics(v InputCriblmetrics) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputCriblmetrics performs a merge with any Union data inside the Input, using the provided InputCriblmetrics
func (t *Input) MergeInputCriblmetrics(v InputCriblmetrics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputMetrics returns the Union data inside the Input as a InputMetrics
func (t Input) AsInputMetrics() (InputMetrics, error) {
	var body InputMetrics
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputMetrics overwrites any Union data inside the Input as the provided InputMetrics
func (t *Input) FromInputMetrics(v InputMetrics) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputMetrics performs a merge with any Union data inside the Input, using the provided InputMetrics
func (t *Input) MergeInputMetrics(v InputMetrics) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputS3 returns the Union data inside the Input as a InputS3
func (t Input) AsInputS3() (InputS3, error) {
	var body InputS3
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputS3 overwrites any Union data inside the Input as the provided InputS3
func (t *Input) FromInputS3(v InputS3) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputS3 performs a merge with any Union data inside the Input, using the provided InputS3
func (t *Input) MergeInputS3(v InputS3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputS3Inventory returns the Union data inside the Input as a InputS3Inventory
func (t Input) AsInputS3Inventory() (InputS3Inventory, error) {
	var body InputS3Inventory
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputS3Inventory overwrites any Union data inside the Input as the provided InputS3Inventory
func (t *Input) FromInputS3Inventory(v InputS3Inventory) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputS3Inventory performs a merge with any Union data inside the Input, using the provided InputS3Inventory
func (t *Input) MergeInputS3Inventory(v InputS3Inventory) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSnmp returns the Union data inside the Input as a InputSnmp
func (t Input) AsInputSnmp() (InputSnmp, error) {
	var body InputSnmp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSnmp overwrites any Union data inside the Input as the provided InputSnmp
func (t *Input) FromInputSnmp(v InputSnmp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSnmp performs a merge with any Union data inside the Input, using the provided InputSnmp
func (t *Input) MergeInputSnmp(v InputSnmp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputOpenTelemetry returns the Union data inside the Input as a InputOpenTelemetry
func (t Input) AsInputOpenTelemetry() (InputOpenTelemetry, error) {
	var body InputOpenTelemetry
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputOpenTelemetry overwrites any Union data inside the Input as the provided InputOpenTelemetry
func (t *Input) FromInputOpenTelemetry(v InputOpenTelemetry) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputOpenTelemetry performs a merge with any Union data inside the Input, using the provided InputOpenTelemetry
func (t *Input) MergeInputOpenTelemetry(v InputOpenTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputModelDrivenTelemetry returns the Union data inside the Input as a InputModelDrivenTelemetry
func (t Input) AsInputModelDrivenTelemetry() (InputModelDrivenTelemetry, error) {
	var body InputModelDrivenTelemetry
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputModelDrivenTelemetry overwrites any Union data inside the Input as the provided InputModelDrivenTelemetry
func (t *Input) FromInputModelDrivenTelemetry(v InputModelDrivenTelemetry) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputModelDrivenTelemetry performs a merge with any Union data inside the Input, using the provided InputModelDrivenTelemetry
func (t *Input) MergeInputModelDrivenTelemetry(v InputModelDrivenTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSqs returns the Union data inside the Input as a InputSqs
func (t Input) AsInputSqs() (InputSqs, error) {
	var body InputSqs
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSqs overwrites any Union data inside the Input as the provided InputSqs
func (t *Input) FromInputSqs(v InputSqs) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSqs performs a merge with any Union data inside the Input, using the provided InputSqs
func (t *Input) MergeInputSqs(v InputSqs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSyslog returns the Union data inside the Input as a InputSyslog
func (t Input) AsInputSyslog() (InputSyslog, error) {
	var body InputSyslog
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSyslog overwrites any Union data inside the Input as the provided InputSyslog
func (t *Input) FromInputSyslog(v InputSyslog) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSyslog performs a merge with any Union data inside the Input, using the provided InputSyslog
func (t *Input) MergeInputSyslog(v InputSyslog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputFile returns the Union data inside the Input as a InputFile
func (t Input) AsInputFile() (InputFile, error) {
	var body InputFile
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputFile overwrites any Union data inside the Input as the provided InputFile
func (t *Input) FromInputFile(v InputFile) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputFile performs a merge with any Union data inside the Input, using the provided InputFile
func (t *Input) MergeInputFile(v InputFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputTcp returns the Union data inside the Input as a InputTcp
func (t Input) AsInputTcp() (InputTcp, error) {
	var body InputTcp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputTcp overwrites any Union data inside the Input as the provided InputTcp
func (t *Input) FromInputTcp(v InputTcp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputTcp performs a merge with any Union data inside the Input, using the provided InputTcp
func (t *Input) MergeInputTcp(v InputTcp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputAppscope returns the Union data inside the Input as a InputAppscope
func (t Input) AsInputAppscope() (InputAppscope, error) {
	var body InputAppscope
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputAppscope overwrites any Union data inside the Input as the provided InputAppscope
func (t *Input) FromInputAppscope(v InputAppscope) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputAppscope performs a merge with any Union data inside the Input, using the provided InputAppscope
func (t *Input) MergeInputAppscope(v InputAppscope) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputWef returns the Union data inside the Input as a InputWef
func (t Input) AsInputWef() (InputWef, error) {
	var body InputWef
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputWef overwrites any Union data inside the Input as the provided InputWef
func (t *Input) FromInputWef(v InputWef) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputWef performs a merge with any Union data inside the Input, using the provided InputWef
func (t *Input) MergeInputWef(v InputWef) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputWinEventLogs returns the Union data inside the Input as a InputWinEventLogs
func (t Input) AsInputWinEventLogs() (InputWinEventLogs, error) {
	var body InputWinEventLogs
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputWinEventLogs overwrites any Union data inside the Input as the provided InputWinEventLogs
func (t *Input) FromInputWinEventLogs(v InputWinEventLogs) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputWinEventLogs performs a merge with any Union data inside the Input, using the provided InputWinEventLogs
func (t *Input) MergeInputWinEventLogs(v InputWinEventLogs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputRawUdp returns the Union data inside the Input as a InputRawUdp
func (t Input) AsInputRawUdp() (InputRawUdp, error) {
	var body InputRawUdp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputRawUdp overwrites any Union data inside the Input as the provided InputRawUdp
func (t *Input) FromInputRawUdp(v InputRawUdp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputRawUdp performs a merge with any Union data inside the Input, using the provided InputRawUdp
func (t *Input) MergeInputRawUdp(v InputRawUdp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputJournalFiles returns the Union data inside the Input as a InputJournalFiles
func (t Input) AsInputJournalFiles() (InputJournalFiles, error) {
	var body InputJournalFiles
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputJournalFiles overwrites any Union data inside the Input as the provided InputJournalFiles
func (t *Input) FromInputJournalFiles(v InputJournalFiles) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputJournalFiles performs a merge with any Union data inside the Input, using the provided InputJournalFiles
func (t *Input) MergeInputJournalFiles(v InputJournalFiles) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputWiz returns the Union data inside the Input as a InputWiz
func (t Input) AsInputWiz() (InputWiz, error) {
	var body InputWiz
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputWiz overwrites any Union data inside the Input as the provided InputWiz
func (t *Input) FromInputWiz(v InputWiz) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputWiz performs a merge with any Union data inside the Input, using the provided InputWiz
func (t *Input) MergeInputWiz(v InputWiz) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputNetflow returns the Union data inside the Input as a InputNetflow
func (t Input) AsInputNetflow() (InputNetflow, error) {
	var body InputNetflow
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputNetflow overwrites any Union data inside the Input as the provided InputNetflow
func (t *Input) FromInputNetflow(v InputNetflow) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputNetflow performs a merge with any Union data inside the Input, using the provided InputNetflow
func (t *Input) MergeInputNetflow(v InputNetflow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSecurityLake returns the Union data inside the Input as a InputSecurityLake
func (t Input) AsInputSecurityLake() (InputSecurityLake, error) {
	var body InputSecurityLake
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSecurityLake overwrites any Union data inside the Input as the provided InputSecurityLake
func (t *Input) FromInputSecurityLake(v InputSecurityLake) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSecurityLake performs a merge with any Union data inside the Input, using the provided InputSecurityLake
func (t *Input) MergeInputSecurityLake(v InputSecurityLake) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputZscalerHec returns the Union data inside the Input as a InputZscalerHec
func (t Input) AsInputZscalerHec() (InputZscalerHec, error) {
	var body InputZscalerHec
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputZscalerHec overwrites any Union data inside the Input as the provided InputZscalerHec
func (t *Input) FromInputZscalerHec(v InputZscalerHec) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputZscalerHec performs a merge with any Union data inside the Input, using the provided InputZscalerHec
func (t *Input) MergeInputZscalerHec(v InputZscalerHec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t Input) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *Input) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsInputGrafana0 returns the Union data inside the InputGrafana as a InputGrafana0
func (t InputGrafana) AsInputGrafana0() (InputGrafana0, error) {
	var body InputGrafana0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputGrafana0 overwrites any Union data inside the InputGrafana as the provided InputGrafana0
func (t *InputGrafana) FromInputGrafana0(v InputGrafana0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputGrafana0 performs a merge with any Union data inside the InputGrafana, using the provided InputGrafana0
func (t *InputGrafana) MergeInputGrafana0(v InputGrafana0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputGrafana1 returns the Union data inside the InputGrafana as a InputGrafana1
func (t InputGrafana) AsInputGrafana1() (InputGrafana1, error) {
	var body InputGrafana1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputGrafana1 overwrites any Union data inside the InputGrafana as the provided InputGrafana1
func (t *InputGrafana) FromInputGrafana1(v InputGrafana1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputGrafana1 performs a merge with any Union data inside the InputGrafana, using the provided InputGrafana1
func (t *InputGrafana) MergeInputGrafana1(v InputGrafana1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t InputGrafana) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ActivityLogSampleRate != nil {
		object["activityLogSampleRate"], err = json.Marshal(t.ActivityLogSampleRate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'activityLogSampleRate': %w", err)
		}
	}

	if t.CaptureHeaders != nil {
		object["captureHeaders"], err = json.Marshal(t.CaptureHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'captureHeaders': %w", err)
		}
	}

	if t.Connections != nil {
		object["connections"], err = json.Marshal(t.Connections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'connections': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.Disabled != nil {
		object["disabled"], err = json.Marshal(t.Disabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disabled': %w", err)
		}
	}

	if t.EnableHealthCheck != nil {
		object["enableHealthCheck"], err = json.Marshal(t.EnableHealthCheck)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enableHealthCheck': %w", err)
		}
	}

	if t.EnableProxyHeader != nil {
		object["enableProxyHeader"], err = json.Marshal(t.EnableProxyHeader)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enableProxyHeader': %w", err)
		}
	}

	if t.Environment != nil {
		object["environment"], err = json.Marshal(t.Environment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'environment': %w", err)
		}
	}

	object["host"], err = json.Marshal(t.Host)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'host': %w", err)
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.IpAllowlistRegex != nil {
		object["ipAllowlistRegex"], err = json.Marshal(t.IpAllowlistRegex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipAllowlistRegex': %w", err)
		}
	}

	if t.IpDenylistRegex != nil {
		object["ipDenylistRegex"], err = json.Marshal(t.IpDenylistRegex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipDenylistRegex': %w", err)
		}
	}

	if t.KeepAliveTimeout != nil {
		object["keepAliveTimeout"], err = json.Marshal(t.KeepAliveTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keepAliveTimeout': %w", err)
		}
	}

	if t.LokiAPI != nil {
		object["lokiAPI"], err = json.Marshal(t.LokiAPI)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lokiAPI': %w", err)
		}
	}

	if t.LokiAuth != nil {
		object["lokiAuth"], err = json.Marshal(t.LokiAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lokiAuth': %w", err)
		}
	}

	if t.MaxActiveReq != nil {
		object["maxActiveReq"], err = json.Marshal(t.MaxActiveReq)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxActiveReq': %w", err)
		}
	}

	if t.MaxRequestsPerSocket != nil {
		object["maxRequestsPerSocket"], err = json.Marshal(t.MaxRequestsPerSocket)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxRequestsPerSocket': %w", err)
		}
	}

	if t.Metadata != nil {
		object["metadata"], err = json.Marshal(t.Metadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
		}
	}

	if t.Pipeline != nil {
		object["pipeline"], err = json.Marshal(t.Pipeline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
		}
	}

	object["port"], err = json.Marshal(t.Port)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'port': %w", err)
	}

	if t.Pq != nil {
		object["pq"], err = json.Marshal(t.Pq)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pq': %w", err)
		}
	}

	if t.PqEnabled != nil {
		object["pqEnabled"], err = json.Marshal(t.PqEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqEnabled': %w", err)
		}
	}

	if t.PrometheusAPI != nil {
		object["prometheusAPI"], err = json.Marshal(t.PrometheusAPI)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'prometheusAPI': %w", err)
		}
	}

	if t.PrometheusAuth != nil {
		object["prometheusAuth"], err = json.Marshal(t.PrometheusAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'prometheusAuth': %w", err)
		}
	}

	if t.RequestTimeout != nil {
		object["requestTimeout"], err = json.Marshal(t.RequestTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'requestTimeout': %w", err)
		}
	}

	if t.SendToRoutes != nil {
		object["sendToRoutes"], err = json.Marshal(t.SendToRoutes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sendToRoutes': %w", err)
		}
	}

	if t.SocketTimeout != nil {
		object["socketTimeout"], err = json.Marshal(t.SocketTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socketTimeout': %w", err)
		}
	}

	if t.Streamtags != nil {
		object["streamtags"], err = json.Marshal(t.Streamtags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streamtags': %w", err)
		}
	}

	if t.Tls != nil {
		object["tls"], err = json.Marshal(t.Tls)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tls': %w", err)
		}
	}

	if t.Type != nil {
		object["type"], err = json.Marshal(t.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *InputGrafana) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activityLogSampleRate"]; found {
		err = json.Unmarshal(raw, &t.ActivityLogSampleRate)
		if err != nil {
			return fmt.Errorf("error reading 'activityLogSampleRate': %w", err)
		}
	}

	if raw, found := object["captureHeaders"]; found {
		err = json.Unmarshal(raw, &t.CaptureHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'captureHeaders': %w", err)
		}
	}

	if raw, found := object["connections"]; found {
		err = json.Unmarshal(raw, &t.Connections)
		if err != nil {
			return fmt.Errorf("error reading 'connections': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["disabled"]; found {
		err = json.Unmarshal(raw, &t.Disabled)
		if err != nil {
			return fmt.Errorf("error reading 'disabled': %w", err)
		}
	}

	if raw, found := object["enableHealthCheck"]; found {
		err = json.Unmarshal(raw, &t.EnableHealthCheck)
		if err != nil {
			return fmt.Errorf("error reading 'enableHealthCheck': %w", err)
		}
	}

	if raw, found := object["enableProxyHeader"]; found {
		err = json.Unmarshal(raw, &t.EnableProxyHeader)
		if err != nil {
			return fmt.Errorf("error reading 'enableProxyHeader': %w", err)
		}
	}

	if raw, found := object["environment"]; found {
		err = json.Unmarshal(raw, &t.Environment)
		if err != nil {
			return fmt.Errorf("error reading 'environment': %w", err)
		}
	}

	if raw, found := object["host"]; found {
		err = json.Unmarshal(raw, &t.Host)
		if err != nil {
			return fmt.Errorf("error reading 'host': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["ipAllowlistRegex"]; found {
		err = json.Unmarshal(raw, &t.IpAllowlistRegex)
		if err != nil {
			return fmt.Errorf("error reading 'ipAllowlistRegex': %w", err)
		}
	}

	if raw, found := object["ipDenylistRegex"]; found {
		err = json.Unmarshal(raw, &t.IpDenylistRegex)
		if err != nil {
			return fmt.Errorf("error reading 'ipDenylistRegex': %w", err)
		}
	}

	if raw, found := object["keepAliveTimeout"]; found {
		err = json.Unmarshal(raw, &t.KeepAliveTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'keepAliveTimeout': %w", err)
		}
	}

	if raw, found := object["lokiAPI"]; found {
		err = json.Unmarshal(raw, &t.LokiAPI)
		if err != nil {
			return fmt.Errorf("error reading 'lokiAPI': %w", err)
		}
	}

	if raw, found := object["lokiAuth"]; found {
		err = json.Unmarshal(raw, &t.LokiAuth)
		if err != nil {
			return fmt.Errorf("error reading 'lokiAuth': %w", err)
		}
	}

	if raw, found := object["maxActiveReq"]; found {
		err = json.Unmarshal(raw, &t.MaxActiveReq)
		if err != nil {
			return fmt.Errorf("error reading 'maxActiveReq': %w", err)
		}
	}

	if raw, found := object["maxRequestsPerSocket"]; found {
		err = json.Unmarshal(raw, &t.MaxRequestsPerSocket)
		if err != nil {
			return fmt.Errorf("error reading 'maxRequestsPerSocket': %w", err)
		}
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &t.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &t.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &t.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
	}

	if raw, found := object["pq"]; found {
		err = json.Unmarshal(raw, &t.Pq)
		if err != nil {
			return fmt.Errorf("error reading 'pq': %w", err)
		}
	}

	if raw, found := object["pqEnabled"]; found {
		err = json.Unmarshal(raw, &t.PqEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'pqEnabled': %w", err)
		}
	}

	if raw, found := object["prometheusAPI"]; found {
		err = json.Unmarshal(raw, &t.PrometheusAPI)
		if err != nil {
			return fmt.Errorf("error reading 'prometheusAPI': %w", err)
		}
	}

	if raw, found := object["prometheusAuth"]; found {
		err = json.Unmarshal(raw, &t.PrometheusAuth)
		if err != nil {
			return fmt.Errorf("error reading 'prometheusAuth': %w", err)
		}
	}

	if raw, found := object["requestTimeout"]; found {
		err = json.Unmarshal(raw, &t.RequestTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'requestTimeout': %w", err)
		}
	}

	if raw, found := object["sendToRoutes"]; found {
		err = json.Unmarshal(raw, &t.SendToRoutes)
		if err != nil {
			return fmt.Errorf("error reading 'sendToRoutes': %w", err)
		}
	}

	if raw, found := object["socketTimeout"]; found {
		err = json.Unmarshal(raw, &t.SocketTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'socketTimeout': %w", err)
		}
	}

	if raw, found := object["streamtags"]; found {
		err = json.Unmarshal(raw, &t.Streamtags)
		if err != nil {
			return fmt.Errorf("error reading 'streamtags': %w", err)
		}
	}

	if raw, found := object["tls"]; found {
		err = json.Unmarshal(raw, &t.Tls)
		if err != nil {
			return fmt.Errorf("error reading 'tls': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsInputSyslog0 returns the Union data inside the InputSyslog as a InputSyslog0
func (t InputSyslog) AsInputSyslog0() (InputSyslog0, error) {
	var body InputSyslog0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSyslog0 overwrites any Union data inside the InputSyslog as the provided InputSyslog0
func (t *InputSyslog) FromInputSyslog0(v InputSyslog0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSyslog0 performs a merge with any Union data inside the InputSyslog, using the provided InputSyslog0
func (t *InputSyslog) MergeInputSyslog0(v InputSyslog0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsInputSyslog1 returns the Union data inside the InputSyslog as a InputSyslog1
func (t InputSyslog) AsInputSyslog1() (InputSyslog1, error) {
	var body InputSyslog1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromInputSyslog1 overwrites any Union data inside the InputSyslog as the provided InputSyslog1
func (t *InputSyslog) FromInputSyslog1(v InputSyslog1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeInputSyslog1 performs a merge with any Union data inside the InputSyslog, using the provided InputSyslog1
func (t *InputSyslog) MergeInputSyslog1(v InputSyslog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t InputSyslog) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AllowNonStandardAppName != nil {
		object["allowNonStandardAppName"], err = json.Marshal(t.AllowNonStandardAppName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowNonStandardAppName': %w", err)
		}
	}

	if t.Connections != nil {
		object["connections"], err = json.Marshal(t.Connections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'connections': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.Disabled != nil {
		object["disabled"], err = json.Marshal(t.Disabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disabled': %w", err)
		}
	}

	if t.EnableLoadBalancing != nil {
		object["enableLoadBalancing"], err = json.Marshal(t.EnableLoadBalancing)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enableLoadBalancing': %w", err)
		}
	}

	if t.EnableProxyHeader != nil {
		object["enableProxyHeader"], err = json.Marshal(t.EnableProxyHeader)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enableProxyHeader': %w", err)
		}
	}

	if t.Environment != nil {
		object["environment"], err = json.Marshal(t.Environment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'environment': %w", err)
		}
	}

	object["host"], err = json.Marshal(t.Host)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'host': %w", err)
	}

	if t.Id != nil {
		object["id"], err = json.Marshal(t.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if t.InferFraming != nil {
		object["inferFraming"], err = json.Marshal(t.InferFraming)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'inferFraming': %w", err)
		}
	}

	if t.IpWhitelistRegex != nil {
		object["ipWhitelistRegex"], err = json.Marshal(t.IpWhitelistRegex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipWhitelistRegex': %w", err)
		}
	}

	if t.KeepFieldsList != nil {
		object["keepFieldsList"], err = json.Marshal(t.KeepFieldsList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keepFieldsList': %w", err)
		}
	}

	if t.MaxActiveCxn != nil {
		object["maxActiveCxn"], err = json.Marshal(t.MaxActiveCxn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxActiveCxn': %w", err)
		}
	}

	if t.MaxBufferSize != nil {
		object["maxBufferSize"], err = json.Marshal(t.MaxBufferSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxBufferSize': %w", err)
		}
	}

	if t.Metadata != nil {
		object["metadata"], err = json.Marshal(t.Metadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
		}
	}

	if t.OctetCounting != nil {
		object["octetCounting"], err = json.Marshal(t.OctetCounting)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'octetCounting': %w", err)
		}
	}

	if t.Pipeline != nil {
		object["pipeline"], err = json.Marshal(t.Pipeline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
		}
	}

	if t.Pq != nil {
		object["pq"], err = json.Marshal(t.Pq)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pq': %w", err)
		}
	}

	if t.PqEnabled != nil {
		object["pqEnabled"], err = json.Marshal(t.PqEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqEnabled': %w", err)
		}
	}

	if t.SendToRoutes != nil {
		object["sendToRoutes"], err = json.Marshal(t.SendToRoutes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sendToRoutes': %w", err)
		}
	}

	if t.SingleMsgUdpPackets != nil {
		object["singleMsgUdpPackets"], err = json.Marshal(t.SingleMsgUdpPackets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'singleMsgUdpPackets': %w", err)
		}
	}

	if t.SocketEndingMaxWait != nil {
		object["socketEndingMaxWait"], err = json.Marshal(t.SocketEndingMaxWait)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socketEndingMaxWait': %w", err)
		}
	}

	if t.SocketIdleTimeout != nil {
		object["socketIdleTimeout"], err = json.Marshal(t.SocketIdleTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socketIdleTimeout': %w", err)
		}
	}

	if t.SocketMaxLifespan != nil {
		object["socketMaxLifespan"], err = json.Marshal(t.SocketMaxLifespan)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socketMaxLifespan': %w", err)
		}
	}

	if t.Streamtags != nil {
		object["streamtags"], err = json.Marshal(t.Streamtags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streamtags': %w", err)
		}
	}

	if t.StrictlyInferOctetCounting != nil {
		object["strictlyInferOctetCounting"], err = json.Marshal(t.StrictlyInferOctetCounting)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'strictlyInferOctetCounting': %w", err)
		}
	}

	if t.TcpPort != nil {
		object["tcpPort"], err = json.Marshal(t.TcpPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tcpPort': %w", err)
		}
	}

	if t.TimestampTimezone != nil {
		object["timestampTimezone"], err = json.Marshal(t.TimestampTimezone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timestampTimezone': %w", err)
		}
	}

	if t.Tls != nil {
		object["tls"], err = json.Marshal(t.Tls)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tls': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if t.UdpPort != nil {
		object["udpPort"], err = json.Marshal(t.UdpPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udpPort': %w", err)
		}
	}

	if t.UdpSocketRxBufSize != nil {
		object["udpSocketRxBufSize"], err = json.Marshal(t.UdpSocketRxBufSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udpSocketRxBufSize': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *InputSyslog) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allowNonStandardAppName"]; found {
		err = json.Unmarshal(raw, &t.AllowNonStandardAppName)
		if err != nil {
			return fmt.Errorf("error reading 'allowNonStandardAppName': %w", err)
		}
	}

	if raw, found := object["connections"]; found {
		err = json.Unmarshal(raw, &t.Connections)
		if err != nil {
			return fmt.Errorf("error reading 'connections': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["disabled"]; found {
		err = json.Unmarshal(raw, &t.Disabled)
		if err != nil {
			return fmt.Errorf("error reading 'disabled': %w", err)
		}
	}

	if raw, found := object["enableLoadBalancing"]; found {
		err = json.Unmarshal(raw, &t.EnableLoadBalancing)
		if err != nil {
			return fmt.Errorf("error reading 'enableLoadBalancing': %w", err)
		}
	}

	if raw, found := object["enableProxyHeader"]; found {
		err = json.Unmarshal(raw, &t.EnableProxyHeader)
		if err != nil {
			return fmt.Errorf("error reading 'enableProxyHeader': %w", err)
		}
	}

	if raw, found := object["environment"]; found {
		err = json.Unmarshal(raw, &t.Environment)
		if err != nil {
			return fmt.Errorf("error reading 'environment': %w", err)
		}
	}

	if raw, found := object["host"]; found {
		err = json.Unmarshal(raw, &t.Host)
		if err != nil {
			return fmt.Errorf("error reading 'host': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["inferFraming"]; found {
		err = json.Unmarshal(raw, &t.InferFraming)
		if err != nil {
			return fmt.Errorf("error reading 'inferFraming': %w", err)
		}
	}

	if raw, found := object["ipWhitelistRegex"]; found {
		err = json.Unmarshal(raw, &t.IpWhitelistRegex)
		if err != nil {
			return fmt.Errorf("error reading 'ipWhitelistRegex': %w", err)
		}
	}

	if raw, found := object["keepFieldsList"]; found {
		err = json.Unmarshal(raw, &t.KeepFieldsList)
		if err != nil {
			return fmt.Errorf("error reading 'keepFieldsList': %w", err)
		}
	}

	if raw, found := object["maxActiveCxn"]; found {
		err = json.Unmarshal(raw, &t.MaxActiveCxn)
		if err != nil {
			return fmt.Errorf("error reading 'maxActiveCxn': %w", err)
		}
	}

	if raw, found := object["maxBufferSize"]; found {
		err = json.Unmarshal(raw, &t.MaxBufferSize)
		if err != nil {
			return fmt.Errorf("error reading 'maxBufferSize': %w", err)
		}
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &t.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
	}

	if raw, found := object["octetCounting"]; found {
		err = json.Unmarshal(raw, &t.OctetCounting)
		if err != nil {
			return fmt.Errorf("error reading 'octetCounting': %w", err)
		}
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &t.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
	}

	if raw, found := object["pq"]; found {
		err = json.Unmarshal(raw, &t.Pq)
		if err != nil {
			return fmt.Errorf("error reading 'pq': %w", err)
		}
	}

	if raw, found := object["pqEnabled"]; found {
		err = json.Unmarshal(raw, &t.PqEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'pqEnabled': %w", err)
		}
	}

	if raw, found := object["sendToRoutes"]; found {
		err = json.Unmarshal(raw, &t.SendToRoutes)
		if err != nil {
			return fmt.Errorf("error reading 'sendToRoutes': %w", err)
		}
	}

	if raw, found := object["singleMsgUdpPackets"]; found {
		err = json.Unmarshal(raw, &t.SingleMsgUdpPackets)
		if err != nil {
			return fmt.Errorf("error reading 'singleMsgUdpPackets': %w", err)
		}
	}

	if raw, found := object["socketEndingMaxWait"]; found {
		err = json.Unmarshal(raw, &t.SocketEndingMaxWait)
		if err != nil {
			return fmt.Errorf("error reading 'socketEndingMaxWait': %w", err)
		}
	}

	if raw, found := object["socketIdleTimeout"]; found {
		err = json.Unmarshal(raw, &t.SocketIdleTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'socketIdleTimeout': %w", err)
		}
	}

	if raw, found := object["socketMaxLifespan"]; found {
		err = json.Unmarshal(raw, &t.SocketMaxLifespan)
		if err != nil {
			return fmt.Errorf("error reading 'socketMaxLifespan': %w", err)
		}
	}

	if raw, found := object["streamtags"]; found {
		err = json.Unmarshal(raw, &t.Streamtags)
		if err != nil {
			return fmt.Errorf("error reading 'streamtags': %w", err)
		}
	}

	if raw, found := object["strictlyInferOctetCounting"]; found {
		err = json.Unmarshal(raw, &t.StrictlyInferOctetCounting)
		if err != nil {
			return fmt.Errorf("error reading 'strictlyInferOctetCounting': %w", err)
		}
	}

	if raw, found := object["tcpPort"]; found {
		err = json.Unmarshal(raw, &t.TcpPort)
		if err != nil {
			return fmt.Errorf("error reading 'tcpPort': %w", err)
		}
	}

	if raw, found := object["timestampTimezone"]; found {
		err = json.Unmarshal(raw, &t.TimestampTimezone)
		if err != nil {
			return fmt.Errorf("error reading 'timestampTimezone': %w", err)
		}
	}

	if raw, found := object["tls"]; found {
		err = json.Unmarshal(raw, &t.Tls)
		if err != nil {
			return fmt.Errorf("error reading 'tls': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	if raw, found := object["udpPort"]; found {
		err = json.Unmarshal(raw, &t.UdpPort)
		if err != nil {
			return fmt.Errorf("error reading 'udpPort': %w", err)
		}
	}

	if raw, found := object["udpSocketRxBufSize"]; found {
		err = json.Unmarshal(raw, &t.UdpSocketRxBufSize)
		if err != nil {
			return fmt.Errorf("error reading 'udpSocketRxBufSize': %w", err)
		}
	}

	return err
}

// AsKMSProviderConfigAuth0 returns the Union data inside the KMSProviderConfig_Auth as a KMSProviderConfigAuth0
func (t KMSProviderConfig_Auth) AsKMSProviderConfigAuth0() (KMSProviderConfigAuth0, error) {
	var body KMSProviderConfigAuth0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromKMSProviderConfigAuth0 overwrites any Union data inside the KMSProviderConfig_Auth as the provided KMSProviderConfigAuth0
func (t *KMSProviderConfig_Auth) FromKMSProviderConfigAuth0(v KMSProviderConfigAuth0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeKMSProviderConfigAuth0 performs a merge with any Union data inside the KMSProviderConfig_Auth, using the provided KMSProviderConfigAuth0
func (t *KMSProviderConfig_Auth) MergeKMSProviderConfigAuth0(v KMSProviderConfigAuth0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsKMSProviderConfigAuth1 returns the Union data inside the KMSProviderConfig_Auth as a KMSProviderConfigAuth1
func (t KMSProviderConfig_Auth) AsKMSProviderConfigAuth1() (KMSProviderConfigAuth1, error) {
	var body KMSProviderConfigAuth1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromKMSProviderConfigAuth1 overwrites any Union data inside the KMSProviderConfig_Auth as the provided KMSProviderConfigAuth1
func (t *KMSProviderConfig_Auth) FromKMSProviderConfigAuth1(v KMSProviderConfigAuth1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeKMSProviderConfigAuth1 performs a merge with any Union data inside the KMSProviderConfig_Auth, using the provided KMSProviderConfigAuth1
func (t *KMSProviderConfig_Auth) MergeKMSProviderConfigAuth1(v KMSProviderConfigAuth1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t KMSProviderConfig_Auth) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *KMSProviderConfig_Auth) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsLookupFile0 returns the Union data inside the LookupFile as a LookupFile0
func (t LookupFile) AsLookupFile0() (LookupFile0, error) {
	var body LookupFile0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromLookupFile0 overwrites any Union data inside the LookupFile as the provided LookupFile0
func (t *LookupFile) FromLookupFile0(v LookupFile0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeLookupFile0 performs a merge with any Union data inside the LookupFile, using the provided LookupFile0
func (t *LookupFile) MergeLookupFile0(v LookupFile0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsLookupFile1 returns the Union data inside the LookupFile as a LookupFile1
func (t LookupFile) AsLookupFile1() (LookupFile1, error) {
	var body LookupFile1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromLookupFile1 overwrites any Union data inside the LookupFile as the provided LookupFile1
func (t *LookupFile) FromLookupFile1(v LookupFile1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeLookupFile1 performs a merge with any Union data inside the LookupFile, using the provided LookupFile1
func (t *LookupFile) MergeLookupFile1(v LookupFile1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t LookupFile) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Size != nil {
		object["size"], err = json.Marshal(t.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	if t.Tags != nil {
		object["tags"], err = json.Marshal(t.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *LookupFile) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &t.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &t.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
	}

	return err
}

// AsMaxConcurrentSearchesType0 returns the Union data inside the MaxConcurrentSearchesType as a MaxConcurrentSearchesType0
func (t MaxConcurrentSearchesType) AsMaxConcurrentSearchesType0() (MaxConcurrentSearchesType0, error) {
	var body MaxConcurrentSearchesType0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromMaxConcurrentSearchesType0 overwrites any Union data inside the MaxConcurrentSearchesType as the provided MaxConcurrentSearchesType0
func (t *MaxConcurrentSearchesType) FromMaxConcurrentSearchesType0(v MaxConcurrentSearchesType0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeMaxConcurrentSearchesType0 performs a merge with any Union data inside the MaxConcurrentSearchesType, using the provided MaxConcurrentSearchesType0
func (t *MaxConcurrentSearchesType) MergeMaxConcurrentSearchesType0(v MaxConcurrentSearchesType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t MaxConcurrentSearchesType) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *MaxConcurrentSearchesType) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsMetricsAggOptsEarliest0 returns the Union data inside the MetricsAggOpts_Earliest as a MetricsAggOptsEarliest0
func (t MetricsAggOpts_Earliest) AsMetricsAggOptsEarliest0() (MetricsAggOptsEarliest0, error) {
	var body MetricsAggOptsEarliest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromMetricsAggOptsEarliest0 overwrites any Union data inside the MetricsAggOpts_Earliest as the provided MetricsAggOptsEarliest0
func (t *MetricsAggOpts_Earliest) FromMetricsAggOptsEarliest0(v MetricsAggOptsEarliest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeMetricsAggOptsEarliest0 performs a merge with any Union data inside the MetricsAggOpts_Earliest, using the provided MetricsAggOptsEarliest0
func (t *MetricsAggOpts_Earliest) MergeMetricsAggOptsEarliest0(v MetricsAggOptsEarliest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsMetricsAggOptsEarliest1 returns the Union data inside the MetricsAggOpts_Earliest as a MetricsAggOptsEarliest1
func (t MetricsAggOpts_Earliest) AsMetricsAggOptsEarliest1() (MetricsAggOptsEarliest1, error) {
	var body MetricsAggOptsEarliest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromMetricsAggOptsEarliest1 overwrites any Union data inside the MetricsAggOpts_Earliest as the provided MetricsAggOptsEarliest1
func (t *MetricsAggOpts_Earliest) FromMetricsAggOptsEarliest1(v MetricsAggOptsEarliest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeMetricsAggOptsEarliest1 performs a merge with any Union data inside the MetricsAggOpts_Earliest, using the provided MetricsAggOptsEarliest1
func (t *MetricsAggOpts_Earliest) MergeMetricsAggOptsEarliest1(v MetricsAggOptsEarliest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t MetricsAggOpts_Earliest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *MetricsAggOpts_Earliest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsMetricsAggOptsLatest0 returns the Union data inside the MetricsAggOpts_Latest as a MetricsAggOptsLatest0
func (t MetricsAggOpts_Latest) AsMetricsAggOptsLatest0() (MetricsAggOptsLatest0, error) {
	var body MetricsAggOptsLatest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromMetricsAggOptsLatest0 overwrites any Union data inside the MetricsAggOpts_Latest as the provided MetricsAggOptsLatest0
func (t *MetricsAggOpts_Latest) FromMetricsAggOptsLatest0(v MetricsAggOptsLatest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeMetricsAggOptsLatest0 performs a merge with any Union data inside the MetricsAggOpts_Latest, using the provided MetricsAggOptsLatest0
func (t *MetricsAggOpts_Latest) MergeMetricsAggOptsLatest0(v MetricsAggOptsLatest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsMetricsAggOptsLatest1 returns the Union data inside the MetricsAggOpts_Latest as a MetricsAggOptsLatest1
func (t MetricsAggOpts_Latest) AsMetricsAggOptsLatest1() (MetricsAggOptsLatest1, error) {
	var body MetricsAggOptsLatest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromMetricsAggOptsLatest1 overwrites any Union data inside the MetricsAggOpts_Latest as the provided MetricsAggOptsLatest1
func (t *MetricsAggOpts_Latest) FromMetricsAggOptsLatest1(v MetricsAggOptsLatest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeMetricsAggOptsLatest1 performs a merge with any Union data inside the MetricsAggOpts_Latest, using the provided MetricsAggOptsLatest1
func (t *MetricsAggOpts_Latest) MergeMetricsAggOptsLatest1(v MetricsAggOptsLatest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t MetricsAggOpts_Latest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *MetricsAggOpts_Latest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsNodeProvidedInfoOs0 returns the Union data inside the NodeProvidedInfo_Os as a NodeProvidedInfoOs0
func (t NodeProvidedInfo_Os) AsNodeProvidedInfoOs0() (NodeProvidedInfoOs0, error) {
	var body NodeProvidedInfoOs0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromNodeProvidedInfoOs0 overwrites any Union data inside the NodeProvidedInfo_Os as the provided NodeProvidedInfoOs0
func (t *NodeProvidedInfo_Os) FromNodeProvidedInfoOs0(v NodeProvidedInfoOs0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeNodeProvidedInfoOs0 performs a merge with any Union data inside the NodeProvidedInfo_Os, using the provided NodeProvidedInfoOs0
func (t *NodeProvidedInfo_Os) MergeNodeProvidedInfoOs0(v NodeProvidedInfoOs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsNodeProvidedInfoOs1 returns the Union data inside the NodeProvidedInfo_Os as a NodeProvidedInfoOs1
func (t NodeProvidedInfo_Os) AsNodeProvidedInfoOs1() (NodeProvidedInfoOs1, error) {
	var body NodeProvidedInfoOs1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromNodeProvidedInfoOs1 overwrites any Union data inside the NodeProvidedInfo_Os as the provided NodeProvidedInfoOs1
func (t *NodeProvidedInfo_Os) FromNodeProvidedInfoOs1(v NodeProvidedInfoOs1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeNodeProvidedInfoOs1 performs a merge with any Union data inside the NodeProvidedInfo_Os, using the provided NodeProvidedInfoOs1
func (t *NodeProvidedInfo_Os) MergeNodeProvidedInfoOs1(v NodeProvidedInfoOs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t NodeProvidedInfo_Os) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *NodeProvidedInfo_Os) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsNotificationTargetConfigs0 returns the Union data inside the Notification_TargetConfigs_Item as a NotificationTargetConfigs0
func (t Notification_TargetConfigs_Item) AsNotificationTargetConfigs0() (NotificationTargetConfigs0, error) {
	var body NotificationTargetConfigs0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromNotificationTargetConfigs0 overwrites any Union data inside the Notification_TargetConfigs_Item as the provided NotificationTargetConfigs0
func (t *Notification_TargetConfigs_Item) FromNotificationTargetConfigs0(v NotificationTargetConfigs0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeNotificationTargetConfigs0 performs a merge with any Union data inside the Notification_TargetConfigs_Item, using the provided NotificationTargetConfigs0
func (t *Notification_TargetConfigs_Item) MergeNotificationTargetConfigs0(v NotificationTargetConfigs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t Notification_TargetConfigs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Notification_TargetConfigs_Item) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	return err
}

// AsOutputDefault returns the Union data inside the Output as a OutputDefault
func (t Output) AsOutputDefault() (OutputDefault, error) {
	var body OutputDefault
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDefault overwrites any Union data inside the Output as the provided OutputDefault
func (t *Output) FromOutputDefault(v OutputDefault) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDefault performs a merge with any Union data inside the Output, using the provided OutputDefault
func (t *Output) MergeOutputDefault(v OutputDefault) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputWebhook returns the Union data inside the Output as a OutputWebhook
func (t Output) AsOutputWebhook() (OutputWebhook, error) {
	var body OutputWebhook
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputWebhook overwrites any Union data inside the Output as the provided OutputWebhook
func (t *Output) FromOutputWebhook(v OutputWebhook) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputWebhook performs a merge with any Union data inside the Output, using the provided OutputWebhook
func (t *Output) MergeOutputWebhook(v OutputWebhook) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSentinel returns the Union data inside the Output as a OutputSentinel
func (t Output) AsOutputSentinel() (OutputSentinel, error) {
	var body OutputSentinel
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSentinel overwrites any Union data inside the Output as the provided OutputSentinel
func (t *Output) FromOutputSentinel(v OutputSentinel) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSentinel performs a merge with any Union data inside the Output, using the provided OutputSentinel
func (t *Output) MergeOutputSentinel(v OutputSentinel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDevnull returns the Union data inside the Output as a OutputDevnull
func (t Output) AsOutputDevnull() (OutputDevnull, error) {
	var body OutputDevnull
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDevnull overwrites any Union data inside the Output as the provided OutputDevnull
func (t *Output) FromOutputDevnull(v OutputDevnull) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDevnull performs a merge with any Union data inside the Output, using the provided OutputDevnull
func (t *Output) MergeOutputDevnull(v OutputDevnull) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSyslog returns the Union data inside the Output as a OutputSyslog
func (t Output) AsOutputSyslog() (OutputSyslog, error) {
	var body OutputSyslog
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSyslog overwrites any Union data inside the Output as the provided OutputSyslog
func (t *Output) FromOutputSyslog(v OutputSyslog) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSyslog performs a merge with any Union data inside the Output, using the provided OutputSyslog
func (t *Output) MergeOutputSyslog(v OutputSyslog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSplunk returns the Union data inside the Output as a OutputSplunk
func (t Output) AsOutputSplunk() (OutputSplunk, error) {
	var body OutputSplunk
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSplunk overwrites any Union data inside the Output as the provided OutputSplunk
func (t *Output) FromOutputSplunk(v OutputSplunk) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSplunk performs a merge with any Union data inside the Output, using the provided OutputSplunk
func (t *Output) MergeOutputSplunk(v OutputSplunk) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSplunkLb returns the Union data inside the Output as a OutputSplunkLb
func (t Output) AsOutputSplunkLb() (OutputSplunkLb, error) {
	var body OutputSplunkLb
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSplunkLb overwrites any Union data inside the Output as the provided OutputSplunkLb
func (t *Output) FromOutputSplunkLb(v OutputSplunkLb) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSplunkLb performs a merge with any Union data inside the Output, using the provided OutputSplunkLb
func (t *Output) MergeOutputSplunkLb(v OutputSplunkLb) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSplunkHec returns the Union data inside the Output as a OutputSplunkHec
func (t Output) AsOutputSplunkHec() (OutputSplunkHec, error) {
	var body OutputSplunkHec
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSplunkHec overwrites any Union data inside the Output as the provided OutputSplunkHec
func (t *Output) FromOutputSplunkHec(v OutputSplunkHec) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSplunkHec performs a merge with any Union data inside the Output, using the provided OutputSplunkHec
func (t *Output) MergeOutputSplunkHec(v OutputSplunkHec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputTcpjson returns the Union data inside the Output as a OutputTcpjson
func (t Output) AsOutputTcpjson() (OutputTcpjson, error) {
	var body OutputTcpjson
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputTcpjson overwrites any Union data inside the Output as the provided OutputTcpjson
func (t *Output) FromOutputTcpjson(v OutputTcpjson) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputTcpjson performs a merge with any Union data inside the Output, using the provided OutputTcpjson
func (t *Output) MergeOutputTcpjson(v OutputTcpjson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputWavefront returns the Union data inside the Output as a OutputWavefront
func (t Output) AsOutputWavefront() (OutputWavefront, error) {
	var body OutputWavefront
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputWavefront overwrites any Union data inside the Output as the provided OutputWavefront
func (t *Output) FromOutputWavefront(v OutputWavefront) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputWavefront performs a merge with any Union data inside the Output, using the provided OutputWavefront
func (t *Output) MergeOutputWavefront(v OutputWavefront) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSignalfx returns the Union data inside the Output as a OutputSignalfx
func (t Output) AsOutputSignalfx() (OutputSignalfx, error) {
	var body OutputSignalfx
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSignalfx overwrites any Union data inside the Output as the provided OutputSignalfx
func (t *Output) FromOutputSignalfx(v OutputSignalfx) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSignalfx performs a merge with any Union data inside the Output, using the provided OutputSignalfx
func (t *Output) MergeOutputSignalfx(v OutputSignalfx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputFilesystem returns the Union data inside the Output as a OutputFilesystem
func (t Output) AsOutputFilesystem() (OutputFilesystem, error) {
	var body OutputFilesystem
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputFilesystem overwrites any Union data inside the Output as the provided OutputFilesystem
func (t *Output) FromOutputFilesystem(v OutputFilesystem) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputFilesystem performs a merge with any Union data inside the Output, using the provided OutputFilesystem
func (t *Output) MergeOutputFilesystem(v OutputFilesystem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputS3 returns the Union data inside the Output as a OutputS3
func (t Output) AsOutputS3() (OutputS3, error) {
	var body OutputS3
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputS3 overwrites any Union data inside the Output as the provided OutputS3
func (t *Output) FromOutputS3(v OutputS3) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputS3 performs a merge with any Union data inside the Output, using the provided OutputS3
func (t *Output) MergeOutputS3(v OutputS3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputAzureBlob returns the Union data inside the Output as a OutputAzureBlob
func (t Output) AsOutputAzureBlob() (OutputAzureBlob, error) {
	var body OutputAzureBlob
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputAzureBlob overwrites any Union data inside the Output as the provided OutputAzureBlob
func (t *Output) FromOutputAzureBlob(v OutputAzureBlob) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputAzureBlob performs a merge with any Union data inside the Output, using the provided OutputAzureBlob
func (t *Output) MergeOutputAzureBlob(v OutputAzureBlob) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputAzureDataExplorer returns the Union data inside the Output as a OutputAzureDataExplorer
func (t Output) AsOutputAzureDataExplorer() (OutputAzureDataExplorer, error) {
	var body OutputAzureDataExplorer
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputAzureDataExplorer overwrites any Union data inside the Output as the provided OutputAzureDataExplorer
func (t *Output) FromOutputAzureDataExplorer(v OutputAzureDataExplorer) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputAzureDataExplorer performs a merge with any Union data inside the Output, using the provided OutputAzureDataExplorer
func (t *Output) MergeOutputAzureDataExplorer(v OutputAzureDataExplorer) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputAzureLogs returns the Union data inside the Output as a OutputAzureLogs
func (t Output) AsOutputAzureLogs() (OutputAzureLogs, error) {
	var body OutputAzureLogs
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputAzureLogs overwrites any Union data inside the Output as the provided OutputAzureLogs
func (t *Output) FromOutputAzureLogs(v OutputAzureLogs) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputAzureLogs performs a merge with any Union data inside the Output, using the provided OutputAzureLogs
func (t *Output) MergeOutputAzureLogs(v OutputAzureLogs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputKinesis returns the Union data inside the Output as a OutputKinesis
func (t Output) AsOutputKinesis() (OutputKinesis, error) {
	var body OutputKinesis
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputKinesis overwrites any Union data inside the Output as the provided OutputKinesis
func (t *Output) FromOutputKinesis(v OutputKinesis) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputKinesis performs a merge with any Union data inside the Output, using the provided OutputKinesis
func (t *Output) MergeOutputKinesis(v OutputKinesis) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputHoneycomb returns the Union data inside the Output as a OutputHoneycomb
func (t Output) AsOutputHoneycomb() (OutputHoneycomb, error) {
	var body OutputHoneycomb
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputHoneycomb overwrites any Union data inside the Output as the provided OutputHoneycomb
func (t *Output) FromOutputHoneycomb(v OutputHoneycomb) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputHoneycomb performs a merge with any Union data inside the Output, using the provided OutputHoneycomb
func (t *Output) MergeOutputHoneycomb(v OutputHoneycomb) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputAzureEventhub returns the Union data inside the Output as a OutputAzureEventhub
func (t Output) AsOutputAzureEventhub() (OutputAzureEventhub, error) {
	var body OutputAzureEventhub
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputAzureEventhub overwrites any Union data inside the Output as the provided OutputAzureEventhub
func (t *Output) FromOutputAzureEventhub(v OutputAzureEventhub) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputAzureEventhub performs a merge with any Union data inside the Output, using the provided OutputAzureEventhub
func (t *Output) MergeOutputAzureEventhub(v OutputAzureEventhub) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGoogleChronicle returns the Union data inside the Output as a OutputGoogleChronicle
func (t Output) AsOutputGoogleChronicle() (OutputGoogleChronicle, error) {
	var body OutputGoogleChronicle
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGoogleChronicle overwrites any Union data inside the Output as the provided OutputGoogleChronicle
func (t *Output) FromOutputGoogleChronicle(v OutputGoogleChronicle) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGoogleChronicle performs a merge with any Union data inside the Output, using the provided OutputGoogleChronicle
func (t *Output) MergeOutputGoogleChronicle(v OutputGoogleChronicle) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGoogleCloudStorage returns the Union data inside the Output as a OutputGoogleCloudStorage
func (t Output) AsOutputGoogleCloudStorage() (OutputGoogleCloudStorage, error) {
	var body OutputGoogleCloudStorage
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGoogleCloudStorage overwrites any Union data inside the Output as the provided OutputGoogleCloudStorage
func (t *Output) FromOutputGoogleCloudStorage(v OutputGoogleCloudStorage) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGoogleCloudStorage performs a merge with any Union data inside the Output, using the provided OutputGoogleCloudStorage
func (t *Output) MergeOutputGoogleCloudStorage(v OutputGoogleCloudStorage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGoogleCloudLogging returns the Union data inside the Output as a OutputGoogleCloudLogging
func (t Output) AsOutputGoogleCloudLogging() (OutputGoogleCloudLogging, error) {
	var body OutputGoogleCloudLogging
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGoogleCloudLogging overwrites any Union data inside the Output as the provided OutputGoogleCloudLogging
func (t *Output) FromOutputGoogleCloudLogging(v OutputGoogleCloudLogging) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGoogleCloudLogging performs a merge with any Union data inside the Output, using the provided OutputGoogleCloudLogging
func (t *Output) MergeOutputGoogleCloudLogging(v OutputGoogleCloudLogging) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGooglePubsub returns the Union data inside the Output as a OutputGooglePubsub
func (t Output) AsOutputGooglePubsub() (OutputGooglePubsub, error) {
	var body OutputGooglePubsub
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGooglePubsub overwrites any Union data inside the Output as the provided OutputGooglePubsub
func (t *Output) FromOutputGooglePubsub(v OutputGooglePubsub) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGooglePubsub performs a merge with any Union data inside the Output, using the provided OutputGooglePubsub
func (t *Output) MergeOutputGooglePubsub(v OutputGooglePubsub) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputExabeam returns the Union data inside the Output as a OutputExabeam
func (t Output) AsOutputExabeam() (OutputExabeam, error) {
	var body OutputExabeam
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputExabeam overwrites any Union data inside the Output as the provided OutputExabeam
func (t *Output) FromOutputExabeam(v OutputExabeam) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputExabeam performs a merge with any Union data inside the Output, using the provided OutputExabeam
func (t *Output) MergeOutputExabeam(v OutputExabeam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputKafka returns the Union data inside the Output as a OutputKafka
func (t Output) AsOutputKafka() (OutputKafka, error) {
	var body OutputKafka
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputKafka overwrites any Union data inside the Output as the provided OutputKafka
func (t *Output) FromOutputKafka(v OutputKafka) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputKafka performs a merge with any Union data inside the Output, using the provided OutputKafka
func (t *Output) MergeOutputKafka(v OutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputConfluentCloud returns the Union data inside the Output as a OutputConfluentCloud
func (t Output) AsOutputConfluentCloud() (OutputConfluentCloud, error) {
	var body OutputConfluentCloud
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputConfluentCloud overwrites any Union data inside the Output as the provided OutputConfluentCloud
func (t *Output) FromOutputConfluentCloud(v OutputConfluentCloud) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputConfluentCloud performs a merge with any Union data inside the Output, using the provided OutputConfluentCloud
func (t *Output) MergeOutputConfluentCloud(v OutputConfluentCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputMsk returns the Union data inside the Output as a OutputMsk
func (t Output) AsOutputMsk() (OutputMsk, error) {
	var body OutputMsk
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputMsk overwrites any Union data inside the Output as the provided OutputMsk
func (t *Output) FromOutputMsk(v OutputMsk) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputMsk performs a merge with any Union data inside the Output, using the provided OutputMsk
func (t *Output) MergeOutputMsk(v OutputMsk) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputElastic returns the Union data inside the Output as a OutputElastic
func (t Output) AsOutputElastic() (OutputElastic, error) {
	var body OutputElastic
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputElastic overwrites any Union data inside the Output as the provided OutputElastic
func (t *Output) FromOutputElastic(v OutputElastic) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputElastic performs a merge with any Union data inside the Output, using the provided OutputElastic
func (t *Output) MergeOutputElastic(v OutputElastic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputElasticCloud returns the Union data inside the Output as a OutputElasticCloud
func (t Output) AsOutputElasticCloud() (OutputElasticCloud, error) {
	var body OutputElasticCloud
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputElasticCloud overwrites any Union data inside the Output as the provided OutputElasticCloud
func (t *Output) FromOutputElasticCloud(v OutputElasticCloud) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputElasticCloud performs a merge with any Union data inside the Output, using the provided OutputElasticCloud
func (t *Output) MergeOutputElasticCloud(v OutputElasticCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputNewrelic returns the Union data inside the Output as a OutputNewrelic
func (t Output) AsOutputNewrelic() (OutputNewrelic, error) {
	var body OutputNewrelic
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputNewrelic overwrites any Union data inside the Output as the provided OutputNewrelic
func (t *Output) FromOutputNewrelic(v OutputNewrelic) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputNewrelic performs a merge with any Union data inside the Output, using the provided OutputNewrelic
func (t *Output) MergeOutputNewrelic(v OutputNewrelic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputNewrelicEvents returns the Union data inside the Output as a OutputNewrelicEvents
func (t Output) AsOutputNewrelicEvents() (OutputNewrelicEvents, error) {
	var body OutputNewrelicEvents
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputNewrelicEvents overwrites any Union data inside the Output as the provided OutputNewrelicEvents
func (t *Output) FromOutputNewrelicEvents(v OutputNewrelicEvents) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputNewrelicEvents performs a merge with any Union data inside the Output, using the provided OutputNewrelicEvents
func (t *Output) MergeOutputNewrelicEvents(v OutputNewrelicEvents) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputInfluxdb returns the Union data inside the Output as a OutputInfluxdb
func (t Output) AsOutputInfluxdb() (OutputInfluxdb, error) {
	var body OutputInfluxdb
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputInfluxdb overwrites any Union data inside the Output as the provided OutputInfluxdb
func (t *Output) FromOutputInfluxdb(v OutputInfluxdb) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputInfluxdb performs a merge with any Union data inside the Output, using the provided OutputInfluxdb
func (t *Output) MergeOutputInfluxdb(v OutputInfluxdb) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputCloudwatch returns the Union data inside the Output as a OutputCloudwatch
func (t Output) AsOutputCloudwatch() (OutputCloudwatch, error) {
	var body OutputCloudwatch
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputCloudwatch overwrites any Union data inside the Output as the provided OutputCloudwatch
func (t *Output) FromOutputCloudwatch(v OutputCloudwatch) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputCloudwatch performs a merge with any Union data inside the Output, using the provided OutputCloudwatch
func (t *Output) MergeOutputCloudwatch(v OutputCloudwatch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputMinio returns the Union data inside the Output as a OutputMinio
func (t Output) AsOutputMinio() (OutputMinio, error) {
	var body OutputMinio
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputMinio overwrites any Union data inside the Output as the provided OutputMinio
func (t *Output) FromOutputMinio(v OutputMinio) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputMinio performs a merge with any Union data inside the Output, using the provided OutputMinio
func (t *Output) MergeOutputMinio(v OutputMinio) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputStatsd returns the Union data inside the Output as a OutputStatsd
func (t Output) AsOutputStatsd() (OutputStatsd, error) {
	var body OutputStatsd
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputStatsd overwrites any Union data inside the Output as the provided OutputStatsd
func (t *Output) FromOutputStatsd(v OutputStatsd) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputStatsd performs a merge with any Union data inside the Output, using the provided OutputStatsd
func (t *Output) MergeOutputStatsd(v OutputStatsd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputStatsdExt returns the Union data inside the Output as a OutputStatsdExt
func (t Output) AsOutputStatsdExt() (OutputStatsdExt, error) {
	var body OutputStatsdExt
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputStatsdExt overwrites any Union data inside the Output as the provided OutputStatsdExt
func (t *Output) FromOutputStatsdExt(v OutputStatsdExt) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputStatsdExt performs a merge with any Union data inside the Output, using the provided OutputStatsdExt
func (t *Output) MergeOutputStatsdExt(v OutputStatsdExt) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGraphite returns the Union data inside the Output as a OutputGraphite
func (t Output) AsOutputGraphite() (OutputGraphite, error) {
	var body OutputGraphite
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGraphite overwrites any Union data inside the Output as the provided OutputGraphite
func (t *Output) FromOutputGraphite(v OutputGraphite) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGraphite performs a merge with any Union data inside the Output, using the provided OutputGraphite
func (t *Output) MergeOutputGraphite(v OutputGraphite) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputRouter returns the Union data inside the Output as a OutputRouter
func (t Output) AsOutputRouter() (OutputRouter, error) {
	var body OutputRouter
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputRouter overwrites any Union data inside the Output as the provided OutputRouter
func (t *Output) FromOutputRouter(v OutputRouter) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputRouter performs a merge with any Union data inside the Output, using the provided OutputRouter
func (t *Output) MergeOutputRouter(v OutputRouter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSns returns the Union data inside the Output as a OutputSns
func (t Output) AsOutputSns() (OutputSns, error) {
	var body OutputSns
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSns overwrites any Union data inside the Output as the provided OutputSns
func (t *Output) FromOutputSns(v OutputSns) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSns performs a merge with any Union data inside the Output, using the provided OutputSns
func (t *Output) MergeOutputSns(v OutputSns) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSqs returns the Union data inside the Output as a OutputSqs
func (t Output) AsOutputSqs() (OutputSqs, error) {
	var body OutputSqs
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSqs overwrites any Union data inside the Output as the provided OutputSqs
func (t *Output) FromOutputSqs(v OutputSqs) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSqs performs a merge with any Union data inside the Output, using the provided OutputSqs
func (t *Output) MergeOutputSqs(v OutputSqs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSnmp returns the Union data inside the Output as a OutputSnmp
func (t Output) AsOutputSnmp() (OutputSnmp, error) {
	var body OutputSnmp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSnmp overwrites any Union data inside the Output as the provided OutputSnmp
func (t *Output) FromOutputSnmp(v OutputSnmp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSnmp performs a merge with any Union data inside the Output, using the provided OutputSnmp
func (t *Output) MergeOutputSnmp(v OutputSnmp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSumoLogic returns the Union data inside the Output as a OutputSumoLogic
func (t Output) AsOutputSumoLogic() (OutputSumoLogic, error) {
	var body OutputSumoLogic
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSumoLogic overwrites any Union data inside the Output as the provided OutputSumoLogic
func (t *Output) FromOutputSumoLogic(v OutputSumoLogic) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSumoLogic performs a merge with any Union data inside the Output, using the provided OutputSumoLogic
func (t *Output) MergeOutputSumoLogic(v OutputSumoLogic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDatadog returns the Union data inside the Output as a OutputDatadog
func (t Output) AsOutputDatadog() (OutputDatadog, error) {
	var body OutputDatadog
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDatadog overwrites any Union data inside the Output as the provided OutputDatadog
func (t *Output) FromOutputDatadog(v OutputDatadog) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDatadog performs a merge with any Union data inside the Output, using the provided OutputDatadog
func (t *Output) MergeOutputDatadog(v OutputDatadog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGrafanaCloud returns the Union data inside the Output as a OutputGrafanaCloud
func (t Output) AsOutputGrafanaCloud() (OutputGrafanaCloud, error) {
	var body OutputGrafanaCloud
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGrafanaCloud overwrites any Union data inside the Output as the provided OutputGrafanaCloud
func (t *Output) FromOutputGrafanaCloud(v OutputGrafanaCloud) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGrafanaCloud performs a merge with any Union data inside the Output, using the provided OutputGrafanaCloud
func (t *Output) MergeOutputGrafanaCloud(v OutputGrafanaCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputLoki returns the Union data inside the Output as a OutputLoki
func (t Output) AsOutputLoki() (OutputLoki, error) {
	var body OutputLoki
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputLoki overwrites any Union data inside the Output as the provided OutputLoki
func (t *Output) FromOutputLoki(v OutputLoki) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputLoki performs a merge with any Union data inside the Output, using the provided OutputLoki
func (t *Output) MergeOutputLoki(v OutputLoki) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputPrometheus returns the Union data inside the Output as a OutputPrometheus
func (t Output) AsOutputPrometheus() (OutputPrometheus, error) {
	var body OutputPrometheus
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputPrometheus overwrites any Union data inside the Output as the provided OutputPrometheus
func (t *Output) FromOutputPrometheus(v OutputPrometheus) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputPrometheus performs a merge with any Union data inside the Output, using the provided OutputPrometheus
func (t *Output) MergeOutputPrometheus(v OutputPrometheus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputRing returns the Union data inside the Output as a OutputRing
func (t Output) AsOutputRing() (OutputRing, error) {
	var body OutputRing
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputRing overwrites any Union data inside the Output as the provided OutputRing
func (t *Output) FromOutputRing(v OutputRing) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputRing performs a merge with any Union data inside the Output, using the provided OutputRing
func (t *Output) MergeOutputRing(v OutputRing) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputOpenTelemetry returns the Union data inside the Output as a OutputOpenTelemetry
func (t Output) AsOutputOpenTelemetry() (OutputOpenTelemetry, error) {
	var body OutputOpenTelemetry
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputOpenTelemetry overwrites any Union data inside the Output as the provided OutputOpenTelemetry
func (t *Output) FromOutputOpenTelemetry(v OutputOpenTelemetry) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputOpenTelemetry performs a merge with any Union data inside the Output, using the provided OutputOpenTelemetry
func (t *Output) MergeOutputOpenTelemetry(v OutputOpenTelemetry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputServiceNow returns the Union data inside the Output as a OutputServiceNow
func (t Output) AsOutputServiceNow() (OutputServiceNow, error) {
	var body OutputServiceNow
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputServiceNow overwrites any Union data inside the Output as the provided OutputServiceNow
func (t *Output) FromOutputServiceNow(v OutputServiceNow) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputServiceNow performs a merge with any Union data inside the Output, using the provided OutputServiceNow
func (t *Output) MergeOutputServiceNow(v OutputServiceNow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDataset returns the Union data inside the Output as a OutputDataset
func (t Output) AsOutputDataset() (OutputDataset, error) {
	var body OutputDataset
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDataset overwrites any Union data inside the Output as the provided OutputDataset
func (t *Output) FromOutputDataset(v OutputDataset) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDataset performs a merge with any Union data inside the Output, using the provided OutputDataset
func (t *Output) MergeOutputDataset(v OutputDataset) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputCriblTcp returns the Union data inside the Output as a OutputCriblTcp
func (t Output) AsOutputCriblTcp() (OutputCriblTcp, error) {
	var body OutputCriblTcp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputCriblTcp overwrites any Union data inside the Output as the provided OutputCriblTcp
func (t *Output) FromOutputCriblTcp(v OutputCriblTcp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputCriblTcp performs a merge with any Union data inside the Output, using the provided OutputCriblTcp
func (t *Output) MergeOutputCriblTcp(v OutputCriblTcp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputCriblHttp returns the Union data inside the Output as a OutputCriblHttp
func (t Output) AsOutputCriblHttp() (OutputCriblHttp, error) {
	var body OutputCriblHttp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputCriblHttp overwrites any Union data inside the Output as the provided OutputCriblHttp
func (t *Output) FromOutputCriblHttp(v OutputCriblHttp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputCriblHttp performs a merge with any Union data inside the Output, using the provided OutputCriblHttp
func (t *Output) MergeOutputCriblHttp(v OutputCriblHttp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputHumioHec returns the Union data inside the Output as a OutputHumioHec
func (t Output) AsOutputHumioHec() (OutputHumioHec, error) {
	var body OutputHumioHec
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputHumioHec overwrites any Union data inside the Output as the provided OutputHumioHec
func (t *Output) FromOutputHumioHec(v OutputHumioHec) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputHumioHec performs a merge with any Union data inside the Output, using the provided OutputHumioHec
func (t *Output) MergeOutputHumioHec(v OutputHumioHec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputCrowdstrikeNextGenSiem returns the Union data inside the Output as a OutputCrowdstrikeNextGenSiem
func (t Output) AsOutputCrowdstrikeNextGenSiem() (OutputCrowdstrikeNextGenSiem, error) {
	var body OutputCrowdstrikeNextGenSiem
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputCrowdstrikeNextGenSiem overwrites any Union data inside the Output as the provided OutputCrowdstrikeNextGenSiem
func (t *Output) FromOutputCrowdstrikeNextGenSiem(v OutputCrowdstrikeNextGenSiem) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputCrowdstrikeNextGenSiem performs a merge with any Union data inside the Output, using the provided OutputCrowdstrikeNextGenSiem
func (t *Output) MergeOutputCrowdstrikeNextGenSiem(v OutputCrowdstrikeNextGenSiem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDlS3 returns the Union data inside the Output as a OutputDlS3
func (t Output) AsOutputDlS3() (OutputDlS3, error) {
	var body OutputDlS3
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDlS3 overwrites any Union data inside the Output as the provided OutputDlS3
func (t *Output) FromOutputDlS3(v OutputDlS3) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDlS3 performs a merge with any Union data inside the Output, using the provided OutputDlS3
func (t *Output) MergeOutputDlS3(v OutputDlS3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputSecurityLake returns the Union data inside the Output as a OutputSecurityLake
func (t Output) AsOutputSecurityLake() (OutputSecurityLake, error) {
	var body OutputSecurityLake
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputSecurityLake overwrites any Union data inside the Output as the provided OutputSecurityLake
func (t *Output) FromOutputSecurityLake(v OutputSecurityLake) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputSecurityLake performs a merge with any Union data inside the Output, using the provided OutputSecurityLake
func (t *Output) MergeOutputSecurityLake(v OutputSecurityLake) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputCriblLake returns the Union data inside the Output as a OutputCriblLake
func (t Output) AsOutputCriblLake() (OutputCriblLake, error) {
	var body OutputCriblLake
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputCriblLake overwrites any Union data inside the Output as the provided OutputCriblLake
func (t *Output) FromOutputCriblLake(v OutputCriblLake) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputCriblLake performs a merge with any Union data inside the Output, using the provided OutputCriblLake
func (t *Output) MergeOutputCriblLake(v OutputCriblLake) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDiskSpool returns the Union data inside the Output as a OutputDiskSpool
func (t Output) AsOutputDiskSpool() (OutputDiskSpool, error) {
	var body OutputDiskSpool
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDiskSpool overwrites any Union data inside the Output as the provided OutputDiskSpool
func (t *Output) FromOutputDiskSpool(v OutputDiskSpool) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDiskSpool performs a merge with any Union data inside the Output, using the provided OutputDiskSpool
func (t *Output) MergeOutputDiskSpool(v OutputDiskSpool) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputClickHouse returns the Union data inside the Output as a OutputClickHouse
func (t Output) AsOutputClickHouse() (OutputClickHouse, error) {
	var body OutputClickHouse
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputClickHouse overwrites any Union data inside the Output as the provided OutputClickHouse
func (t *Output) FromOutputClickHouse(v OutputClickHouse) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputClickHouse performs a merge with any Union data inside the Output, using the provided OutputClickHouse
func (t *Output) MergeOutputClickHouse(v OutputClickHouse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputNetflow returns the Union data inside the Output as a OutputNetflow
func (t Output) AsOutputNetflow() (OutputNetflow, error) {
	var body OutputNetflow
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputNetflow overwrites any Union data inside the Output as the provided OutputNetflow
func (t *Output) FromOutputNetflow(v OutputNetflow) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputNetflow performs a merge with any Union data inside the Output, using the provided OutputNetflow
func (t *Output) MergeOutputNetflow(v OutputNetflow) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDynatraceHttp returns the Union data inside the Output as a OutputDynatraceHttp
func (t Output) AsOutputDynatraceHttp() (OutputDynatraceHttp, error) {
	var body OutputDynatraceHttp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDynatraceHttp overwrites any Union data inside the Output as the provided OutputDynatraceHttp
func (t *Output) FromOutputDynatraceHttp(v OutputDynatraceHttp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDynatraceHttp performs a merge with any Union data inside the Output, using the provided OutputDynatraceHttp
func (t *Output) MergeOutputDynatraceHttp(v OutputDynatraceHttp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputDynatraceOtlp returns the Union data inside the Output as a OutputDynatraceOtlp
func (t Output) AsOutputDynatraceOtlp() (OutputDynatraceOtlp, error) {
	var body OutputDynatraceOtlp
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputDynatraceOtlp overwrites any Union data inside the Output as the provided OutputDynatraceOtlp
func (t *Output) FromOutputDynatraceOtlp(v OutputDynatraceOtlp) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputDynatraceOtlp performs a merge with any Union data inside the Output, using the provided OutputDynatraceOtlp
func (t *Output) MergeOutputDynatraceOtlp(v OutputDynatraceOtlp) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t Output) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *Output) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsOutputGrafanaCloud0 returns the Union data inside the OutputGrafanaCloud as a OutputGrafanaCloud0
func (t OutputGrafanaCloud) AsOutputGrafanaCloud0() (OutputGrafanaCloud0, error) {
	var body OutputGrafanaCloud0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGrafanaCloud0 overwrites any Union data inside the OutputGrafanaCloud as the provided OutputGrafanaCloud0
func (t *OutputGrafanaCloud) FromOutputGrafanaCloud0(v OutputGrafanaCloud0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGrafanaCloud0 performs a merge with any Union data inside the OutputGrafanaCloud, using the provided OutputGrafanaCloud0
func (t *OutputGrafanaCloud) MergeOutputGrafanaCloud0(v OutputGrafanaCloud0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsOutputGrafanaCloud1 returns the Union data inside the OutputGrafanaCloud as a OutputGrafanaCloud1
func (t OutputGrafanaCloud) AsOutputGrafanaCloud1() (OutputGrafanaCloud1, error) {
	var body OutputGrafanaCloud1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromOutputGrafanaCloud1 overwrites any Union data inside the OutputGrafanaCloud as the provided OutputGrafanaCloud1
func (t *OutputGrafanaCloud) FromOutputGrafanaCloud1(v OutputGrafanaCloud1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeOutputGrafanaCloud1 performs a merge with any Union data inside the OutputGrafanaCloud, using the provided OutputGrafanaCloud1
func (t *OutputGrafanaCloud) MergeOutputGrafanaCloud1(v OutputGrafanaCloud1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t OutputGrafanaCloud) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Compress != nil {
		object["compress"], err = json.Marshal(t.Compress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compress': %w", err)
		}
	}

	if t.Concurrency != nil {
		object["concurrency"], err = json.Marshal(t.Concurrency)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'concurrency': %w", err)
		}
	}

	if t.Description != nil {
		object["description"], err = json.Marshal(t.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if t.Environment != nil {
		object["environment"], err = json.Marshal(t.Environment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'environment': %w", err)
		}
	}

	if t.ExtraHttpHeaders != nil {
		object["extraHttpHeaders"], err = json.Marshal(t.ExtraHttpHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'extraHttpHeaders': %w", err)
		}
	}

	if t.FailedRequestLoggingMode != nil {
		object["failedRequestLoggingMode"], err = json.Marshal(t.FailedRequestLoggingMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'failedRequestLoggingMode': %w", err)
		}
	}

	if t.FlushPeriodSec != nil {
		object["flushPeriodSec"], err = json.Marshal(t.FlushPeriodSec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flushPeriodSec': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Labels != nil {
		object["labels"], err = json.Marshal(t.Labels)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'labels': %w", err)
		}
	}

	if t.LokiAuth != nil {
		object["lokiAuth"], err = json.Marshal(t.LokiAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lokiAuth': %w", err)
		}
	}

	if t.LokiUrl != nil {
		object["lokiUrl"], err = json.Marshal(t.LokiUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lokiUrl': %w", err)
		}
	}

	if t.MaxPayloadEvents != nil {
		object["maxPayloadEvents"], err = json.Marshal(t.MaxPayloadEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxPayloadEvents': %w", err)
		}
	}

	if t.MaxPayloadSizeKB != nil {
		object["maxPayloadSizeKB"], err = json.Marshal(t.MaxPayloadSizeKB)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxPayloadSizeKB': %w", err)
		}
	}

	if t.Message != nil {
		object["message"], err = json.Marshal(t.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if t.MessageFormat != nil {
		object["messageFormat"], err = json.Marshal(t.MessageFormat)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'messageFormat': %w", err)
		}
	}

	if t.MetricRenameExpr != nil {
		object["metricRenameExpr"], err = json.Marshal(t.MetricRenameExpr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metricRenameExpr': %w", err)
		}
	}

	if t.OnBackpressure != nil {
		object["onBackpressure"], err = json.Marshal(t.OnBackpressure)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'onBackpressure': %w", err)
		}
	}

	if t.Pipeline != nil {
		object["pipeline"], err = json.Marshal(t.Pipeline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
		}
	}

	if t.PqCompress != nil {
		object["pqCompress"], err = json.Marshal(t.PqCompress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqCompress': %w", err)
		}
	}

	if t.PqControls != nil {
		object["pqControls"], err = json.Marshal(t.PqControls)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqControls': %w", err)
		}
	}

	if t.PqMaxFileSize != nil {
		object["pqMaxFileSize"], err = json.Marshal(t.PqMaxFileSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqMaxFileSize': %w", err)
		}
	}

	if t.PqMaxSize != nil {
		object["pqMaxSize"], err = json.Marshal(t.PqMaxSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqMaxSize': %w", err)
		}
	}

	if t.PqMode != nil {
		object["pqMode"], err = json.Marshal(t.PqMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqMode': %w", err)
		}
	}

	if t.PqOnBackpressure != nil {
		object["pqOnBackpressure"], err = json.Marshal(t.PqOnBackpressure)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqOnBackpressure': %w", err)
		}
	}

	if t.PqPath != nil {
		object["pqPath"], err = json.Marshal(t.PqPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pqPath': %w", err)
		}
	}

	if t.PrometheusAuth != nil {
		object["prometheusAuth"], err = json.Marshal(t.PrometheusAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'prometheusAuth': %w", err)
		}
	}

	if t.PrometheusUrl != nil {
		object["prometheusUrl"], err = json.Marshal(t.PrometheusUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'prometheusUrl': %w", err)
		}
	}

	if t.RejectUnauthorized != nil {
		object["rejectUnauthorized"], err = json.Marshal(t.RejectUnauthorized)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rejectUnauthorized': %w", err)
		}
	}

	if t.ResponseHonorRetryAfterHeader != nil {
		object["responseHonorRetryAfterHeader"], err = json.Marshal(t.ResponseHonorRetryAfterHeader)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'responseHonorRetryAfterHeader': %w", err)
		}
	}

	if t.ResponseRetrySettings != nil {
		object["responseRetrySettings"], err = json.Marshal(t.ResponseRetrySettings)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'responseRetrySettings': %w", err)
		}
	}

	if t.SafeHeaders != nil {
		object["safeHeaders"], err = json.Marshal(t.SafeHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'safeHeaders': %w", err)
		}
	}

	if t.Streamtags != nil {
		object["streamtags"], err = json.Marshal(t.Streamtags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'streamtags': %w", err)
		}
	}

	if t.SystemFields != nil {
		object["systemFields"], err = json.Marshal(t.SystemFields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'systemFields': %w", err)
		}
	}

	if t.TimeoutRetrySettings != nil {
		object["timeoutRetrySettings"], err = json.Marshal(t.TimeoutRetrySettings)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeoutRetrySettings': %w", err)
		}
	}

	if t.TimeoutSec != nil {
		object["timeoutSec"], err = json.Marshal(t.TimeoutSec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeoutSec': %w", err)
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if t.UseRoundRobinDns != nil {
		object["useRoundRobinDns"], err = json.Marshal(t.UseRoundRobinDns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'useRoundRobinDns': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *OutputGrafanaCloud) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["compress"]; found {
		err = json.Unmarshal(raw, &t.Compress)
		if err != nil {
			return fmt.Errorf("error reading 'compress': %w", err)
		}
	}

	if raw, found := object["concurrency"]; found {
		err = json.Unmarshal(raw, &t.Concurrency)
		if err != nil {
			return fmt.Errorf("error reading 'concurrency': %w", err)
		}
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &t.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
	}

	if raw, found := object["environment"]; found {
		err = json.Unmarshal(raw, &t.Environment)
		if err != nil {
			return fmt.Errorf("error reading 'environment': %w", err)
		}
	}

	if raw, found := object["extraHttpHeaders"]; found {
		err = json.Unmarshal(raw, &t.ExtraHttpHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'extraHttpHeaders': %w", err)
		}
	}

	if raw, found := object["failedRequestLoggingMode"]; found {
		err = json.Unmarshal(raw, &t.FailedRequestLoggingMode)
		if err != nil {
			return fmt.Errorf("error reading 'failedRequestLoggingMode': %w", err)
		}
	}

	if raw, found := object["flushPeriodSec"]; found {
		err = json.Unmarshal(raw, &t.FlushPeriodSec)
		if err != nil {
			return fmt.Errorf("error reading 'flushPeriodSec': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["labels"]; found {
		err = json.Unmarshal(raw, &t.Labels)
		if err != nil {
			return fmt.Errorf("error reading 'labels': %w", err)
		}
	}

	if raw, found := object["lokiAuth"]; found {
		err = json.Unmarshal(raw, &t.LokiAuth)
		if err != nil {
			return fmt.Errorf("error reading 'lokiAuth': %w", err)
		}
	}

	if raw, found := object["lokiUrl"]; found {
		err = json.Unmarshal(raw, &t.LokiUrl)
		if err != nil {
			return fmt.Errorf("error reading 'lokiUrl': %w", err)
		}
	}

	if raw, found := object["maxPayloadEvents"]; found {
		err = json.Unmarshal(raw, &t.MaxPayloadEvents)
		if err != nil {
			return fmt.Errorf("error reading 'maxPayloadEvents': %w", err)
		}
	}

	if raw, found := object["maxPayloadSizeKB"]; found {
		err = json.Unmarshal(raw, &t.MaxPayloadSizeKB)
		if err != nil {
			return fmt.Errorf("error reading 'maxPayloadSizeKB': %w", err)
		}
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &t.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
	}

	if raw, found := object["messageFormat"]; found {
		err = json.Unmarshal(raw, &t.MessageFormat)
		if err != nil {
			return fmt.Errorf("error reading 'messageFormat': %w", err)
		}
	}

	if raw, found := object["metricRenameExpr"]; found {
		err = json.Unmarshal(raw, &t.MetricRenameExpr)
		if err != nil {
			return fmt.Errorf("error reading 'metricRenameExpr': %w", err)
		}
	}

	if raw, found := object["onBackpressure"]; found {
		err = json.Unmarshal(raw, &t.OnBackpressure)
		if err != nil {
			return fmt.Errorf("error reading 'onBackpressure': %w", err)
		}
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &t.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
	}

	if raw, found := object["pqCompress"]; found {
		err = json.Unmarshal(raw, &t.PqCompress)
		if err != nil {
			return fmt.Errorf("error reading 'pqCompress': %w", err)
		}
	}

	if raw, found := object["pqControls"]; found {
		err = json.Unmarshal(raw, &t.PqControls)
		if err != nil {
			return fmt.Errorf("error reading 'pqControls': %w", err)
		}
	}

	if raw, found := object["pqMaxFileSize"]; found {
		err = json.Unmarshal(raw, &t.PqMaxFileSize)
		if err != nil {
			return fmt.Errorf("error reading 'pqMaxFileSize': %w", err)
		}
	}

	if raw, found := object["pqMaxSize"]; found {
		err = json.Unmarshal(raw, &t.PqMaxSize)
		if err != nil {
			return fmt.Errorf("error reading 'pqMaxSize': %w", err)
		}
	}

	if raw, found := object["pqMode"]; found {
		err = json.Unmarshal(raw, &t.PqMode)
		if err != nil {
			return fmt.Errorf("error reading 'pqMode': %w", err)
		}
	}

	if raw, found := object["pqOnBackpressure"]; found {
		err = json.Unmarshal(raw, &t.PqOnBackpressure)
		if err != nil {
			return fmt.Errorf("error reading 'pqOnBackpressure': %w", err)
		}
	}

	if raw, found := object["pqPath"]; found {
		err = json.Unmarshal(raw, &t.PqPath)
		if err != nil {
			return fmt.Errorf("error reading 'pqPath': %w", err)
		}
	}

	if raw, found := object["prometheusAuth"]; found {
		err = json.Unmarshal(raw, &t.PrometheusAuth)
		if err != nil {
			return fmt.Errorf("error reading 'prometheusAuth': %w", err)
		}
	}

	if raw, found := object["prometheusUrl"]; found {
		err = json.Unmarshal(raw, &t.PrometheusUrl)
		if err != nil {
			return fmt.Errorf("error reading 'prometheusUrl': %w", err)
		}
	}

	if raw, found := object["rejectUnauthorized"]; found {
		err = json.Unmarshal(raw, &t.RejectUnauthorized)
		if err != nil {
			return fmt.Errorf("error reading 'rejectUnauthorized': %w", err)
		}
	}

	if raw, found := object["responseHonorRetryAfterHeader"]; found {
		err = json.Unmarshal(raw, &t.ResponseHonorRetryAfterHeader)
		if err != nil {
			return fmt.Errorf("error reading 'responseHonorRetryAfterHeader': %w", err)
		}
	}

	if raw, found := object["responseRetrySettings"]; found {
		err = json.Unmarshal(raw, &t.ResponseRetrySettings)
		if err != nil {
			return fmt.Errorf("error reading 'responseRetrySettings': %w", err)
		}
	}

	if raw, found := object["safeHeaders"]; found {
		err = json.Unmarshal(raw, &t.SafeHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'safeHeaders': %w", err)
		}
	}

	if raw, found := object["streamtags"]; found {
		err = json.Unmarshal(raw, &t.Streamtags)
		if err != nil {
			return fmt.Errorf("error reading 'streamtags': %w", err)
		}
	}

	if raw, found := object["systemFields"]; found {
		err = json.Unmarshal(raw, &t.SystemFields)
		if err != nil {
			return fmt.Errorf("error reading 'systemFields': %w", err)
		}
	}

	if raw, found := object["timeoutRetrySettings"]; found {
		err = json.Unmarshal(raw, &t.TimeoutRetrySettings)
		if err != nil {
			return fmt.Errorf("error reading 'timeoutRetrySettings': %w", err)
		}
	}

	if raw, found := object["timeoutSec"]; found {
		err = json.Unmarshal(raw, &t.TimeoutSec)
		if err != nil {
			return fmt.Errorf("error reading 'timeoutSec': %w", err)
		}
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	if raw, found := object["useRoundRobinDns"]; found {
		err = json.Unmarshal(raw, &t.UseRoundRobinDns)
		if err != nil {
			return fmt.Errorf("error reading 'useRoundRobinDns': %w", err)
		}
	}

	return err
}

// AsPreviewOptionsEarliest0 returns the Union data inside the PreviewOptions_Earliest as a PreviewOptionsEarliest0
func (t PreviewOptions_Earliest) AsPreviewOptionsEarliest0() (PreviewOptionsEarliest0, error) {
	var body PreviewOptionsEarliest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromPreviewOptionsEarliest0 overwrites any Union data inside the PreviewOptions_Earliest as the provided PreviewOptionsEarliest0
func (t *PreviewOptions_Earliest) FromPreviewOptionsEarliest0(v PreviewOptionsEarliest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergePreviewOptionsEarliest0 performs a merge with any Union data inside the PreviewOptions_Earliest, using the provided PreviewOptionsEarliest0
func (t *PreviewOptions_Earliest) MergePreviewOptionsEarliest0(v PreviewOptionsEarliest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsPreviewOptionsEarliest1 returns the Union data inside the PreviewOptions_Earliest as a PreviewOptionsEarliest1
func (t PreviewOptions_Earliest) AsPreviewOptionsEarliest1() (PreviewOptionsEarliest1, error) {
	var body PreviewOptionsEarliest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromPreviewOptionsEarliest1 overwrites any Union data inside the PreviewOptions_Earliest as the provided PreviewOptionsEarliest1
func (t *PreviewOptions_Earliest) FromPreviewOptionsEarliest1(v PreviewOptionsEarliest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergePreviewOptionsEarliest1 performs a merge with any Union data inside the PreviewOptions_Earliest, using the provided PreviewOptionsEarliest1
func (t *PreviewOptions_Earliest) MergePreviewOptionsEarliest1(v PreviewOptionsEarliest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t PreviewOptions_Earliest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *PreviewOptions_Earliest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsPreviewOptionsLatest0 returns the Union data inside the PreviewOptions_Latest as a PreviewOptionsLatest0
func (t PreviewOptions_Latest) AsPreviewOptionsLatest0() (PreviewOptionsLatest0, error) {
	var body PreviewOptionsLatest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromPreviewOptionsLatest0 overwrites any Union data inside the PreviewOptions_Latest as the provided PreviewOptionsLatest0
func (t *PreviewOptions_Latest) FromPreviewOptionsLatest0(v PreviewOptionsLatest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergePreviewOptionsLatest0 performs a merge with any Union data inside the PreviewOptions_Latest, using the provided PreviewOptionsLatest0
func (t *PreviewOptions_Latest) MergePreviewOptionsLatest0(v PreviewOptionsLatest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsPreviewOptionsLatest1 returns the Union data inside the PreviewOptions_Latest as a PreviewOptionsLatest1
func (t PreviewOptions_Latest) AsPreviewOptionsLatest1() (PreviewOptionsLatest1, error) {
	var body PreviewOptionsLatest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromPreviewOptionsLatest1 overwrites any Union data inside the PreviewOptions_Latest as the provided PreviewOptionsLatest1
func (t *PreviewOptions_Latest) FromPreviewOptionsLatest1(v PreviewOptionsLatest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergePreviewOptionsLatest1 performs a merge with any Union data inside the PreviewOptions_Latest, using the provided PreviewOptionsLatest1
func (t *PreviewOptions_Latest) MergePreviewOptionsLatest1(v PreviewOptionsLatest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t PreviewOptions_Latest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *PreviewOptions_Latest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsRunnableJobCollection returns the Union data inside the RunnableJob as a RunnableJobCollection
func (t RunnableJob) AsRunnableJobCollection() (RunnableJobCollection, error) {
	var body RunnableJobCollection
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromRunnableJobCollection overwrites any Union data inside the RunnableJob as the provided RunnableJobCollection
func (t *RunnableJob) FromRunnableJobCollection(v RunnableJobCollection) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeRunnableJobCollection performs a merge with any Union data inside the RunnableJob, using the provided RunnableJobCollection
func (t *RunnableJob) MergeRunnableJobCollection(v RunnableJobCollection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsRunnableJobExecutor returns the Union data inside the RunnableJob as a RunnableJobExecutor
func (t RunnableJob) AsRunnableJobExecutor() (RunnableJobExecutor, error) {
	var body RunnableJobExecutor
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromRunnableJobExecutor overwrites any Union data inside the RunnableJob as the provided RunnableJobExecutor
func (t *RunnableJob) FromRunnableJobExecutor(v RunnableJobExecutor) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeRunnableJobExecutor performs a merge with any Union data inside the RunnableJob, using the provided RunnableJobExecutor
func (t *RunnableJob) MergeRunnableJobExecutor(v RunnableJobExecutor) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsRunnableJobScheduledSearch returns the Union data inside the RunnableJob as a RunnableJobScheduledSearch
func (t RunnableJob) AsRunnableJobScheduledSearch() (RunnableJobScheduledSearch, error) {
	var body RunnableJobScheduledSearch
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromRunnableJobScheduledSearch overwrites any Union data inside the RunnableJob as the provided RunnableJobScheduledSearch
func (t *RunnableJob) FromRunnableJobScheduledSearch(v RunnableJobScheduledSearch) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeRunnableJobScheduledSearch performs a merge with any Union data inside the RunnableJob, using the provided RunnableJobScheduledSearch
func (t *RunnableJob) MergeRunnableJobScheduledSearch(v RunnableJobScheduledSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t RunnableJob) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *RunnableJob) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSavedJobCollection returns the Union data inside the SavedJob as a SavedJobCollection
func (t SavedJob) AsSavedJobCollection() (SavedJobCollection, error) {
	var body SavedJobCollection
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSavedJobCollection overwrites any Union data inside the SavedJob as the provided SavedJobCollection
func (t *SavedJob) FromSavedJobCollection(v SavedJobCollection) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSavedJobCollection performs a merge with any Union data inside the SavedJob, using the provided SavedJobCollection
func (t *SavedJob) MergeSavedJobCollection(v SavedJobCollection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSavedJobExecutor returns the Union data inside the SavedJob as a SavedJobExecutor
func (t SavedJob) AsSavedJobExecutor() (SavedJobExecutor, error) {
	var body SavedJobExecutor
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSavedJobExecutor overwrites any Union data inside the SavedJob as the provided SavedJobExecutor
func (t *SavedJob) FromSavedJobExecutor(v SavedJobExecutor) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSavedJobExecutor performs a merge with any Union data inside the SavedJob, using the provided SavedJobExecutor
func (t *SavedJob) MergeSavedJobExecutor(v SavedJobExecutor) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSavedJobScheduledSearch returns the Union data inside the SavedJob as a SavedJobScheduledSearch
func (t SavedJob) AsSavedJobScheduledSearch() (SavedJobScheduledSearch, error) {
	var body SavedJobScheduledSearch
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSavedJobScheduledSearch overwrites any Union data inside the SavedJob as the provided SavedJobScheduledSearch
func (t *SavedJob) FromSavedJobScheduledSearch(v SavedJobScheduledSearch) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSavedJobScheduledSearch performs a merge with any Union data inside the SavedJob, using the provided SavedJobScheduledSearch
func (t *SavedJob) MergeSavedJobScheduledSearch(v SavedJobScheduledSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SavedJob) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SavedJob) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchDashboardElements0 returns the Union data inside the SearchDashboard_Elements_Item as a SearchDashboardElements0
func (t SearchDashboard_Elements_Item) AsSearchDashboardElements0() (SearchDashboardElements0, error) {
	var body SearchDashboardElements0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchDashboardElements0 overwrites any Union data inside the SearchDashboard_Elements_Item as the provided SearchDashboardElements0
func (t *SearchDashboard_Elements_Item) FromSearchDashboardElements0(v SearchDashboardElements0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchDashboardElements0 performs a merge with any Union data inside the SearchDashboard_Elements_Item, using the provided SearchDashboardElements0
func (t *SearchDashboard_Elements_Item) MergeSearchDashboardElements0(v SearchDashboardElements0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchDashboardElements1 returns the Union data inside the SearchDashboard_Elements_Item as a SearchDashboardElements1
func (t SearchDashboard_Elements_Item) AsSearchDashboardElements1() (SearchDashboardElements1, error) {
	var body SearchDashboardElements1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchDashboardElements1 overwrites any Union data inside the SearchDashboard_Elements_Item as the provided SearchDashboardElements1
func (t *SearchDashboard_Elements_Item) FromSearchDashboardElements1(v SearchDashboardElements1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchDashboardElements1 performs a merge with any Union data inside the SearchDashboard_Elements_Item, using the provided SearchDashboardElements1
func (t *SearchDashboard_Elements_Item) MergeSearchDashboardElements1(v SearchDashboardElements1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchDashboard_Elements_Item) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchDashboard_Elements_Item) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchJobEarliest0 returns the Union data inside the SearchJob_Earliest as a SearchJobEarliest0
func (t SearchJob_Earliest) AsSearchJobEarliest0() (SearchJobEarliest0, error) {
	var body SearchJobEarliest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobEarliest0 overwrites any Union data inside the SearchJob_Earliest as the provided SearchJobEarliest0
func (t *SearchJob_Earliest) FromSearchJobEarliest0(v SearchJobEarliest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobEarliest0 performs a merge with any Union data inside the SearchJob_Earliest, using the provided SearchJobEarliest0
func (t *SearchJob_Earliest) MergeSearchJobEarliest0(v SearchJobEarliest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchJobEarliest1 returns the Union data inside the SearchJob_Earliest as a SearchJobEarliest1
func (t SearchJob_Earliest) AsSearchJobEarliest1() (SearchJobEarliest1, error) {
	var body SearchJobEarliest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobEarliest1 overwrites any Union data inside the SearchJob_Earliest as the provided SearchJobEarliest1
func (t *SearchJob_Earliest) FromSearchJobEarliest1(v SearchJobEarliest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobEarliest1 performs a merge with any Union data inside the SearchJob_Earliest, using the provided SearchJobEarliest1
func (t *SearchJob_Earliest) MergeSearchJobEarliest1(v SearchJobEarliest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchJob_Earliest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchJob_Earliest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchJobLatest0 returns the Union data inside the SearchJob_Latest as a SearchJobLatest0
func (t SearchJob_Latest) AsSearchJobLatest0() (SearchJobLatest0, error) {
	var body SearchJobLatest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobLatest0 overwrites any Union data inside the SearchJob_Latest as the provided SearchJobLatest0
func (t *SearchJob_Latest) FromSearchJobLatest0(v SearchJobLatest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobLatest0 performs a merge with any Union data inside the SearchJob_Latest, using the provided SearchJobLatest0
func (t *SearchJob_Latest) MergeSearchJobLatest0(v SearchJobLatest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchJobLatest1 returns the Union data inside the SearchJob_Latest as a SearchJobLatest1
func (t SearchJob_Latest) AsSearchJobLatest1() (SearchJobLatest1, error) {
	var body SearchJobLatest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobLatest1 overwrites any Union data inside the SearchJob_Latest as the provided SearchJobLatest1
func (t *SearchJob_Latest) FromSearchJobLatest1(v SearchJobLatest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobLatest1 performs a merge with any Union data inside the SearchJob_Latest, using the provided SearchJobLatest1
func (t *SearchJob_Latest) MergeSearchJobLatest1(v SearchJobLatest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchJob_Latest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchJob_Latest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchJobStageConfigEarliest0 returns the Union data inside the SearchJobStageConfig_Earliest as a SearchJobStageConfigEarliest0
func (t SearchJobStageConfig_Earliest) AsSearchJobStageConfigEarliest0() (SearchJobStageConfigEarliest0, error) {
	var body SearchJobStageConfigEarliest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobStageConfigEarliest0 overwrites any Union data inside the SearchJobStageConfig_Earliest as the provided SearchJobStageConfigEarliest0
func (t *SearchJobStageConfig_Earliest) FromSearchJobStageConfigEarliest0(v SearchJobStageConfigEarliest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobStageConfigEarliest0 performs a merge with any Union data inside the SearchJobStageConfig_Earliest, using the provided SearchJobStageConfigEarliest0
func (t *SearchJobStageConfig_Earliest) MergeSearchJobStageConfigEarliest0(v SearchJobStageConfigEarliest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchJobStageConfigEarliest1 returns the Union data inside the SearchJobStageConfig_Earliest as a SearchJobStageConfigEarliest1
func (t SearchJobStageConfig_Earliest) AsSearchJobStageConfigEarliest1() (SearchJobStageConfigEarliest1, error) {
	var body SearchJobStageConfigEarliest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobStageConfigEarliest1 overwrites any Union data inside the SearchJobStageConfig_Earliest as the provided SearchJobStageConfigEarliest1
func (t *SearchJobStageConfig_Earliest) FromSearchJobStageConfigEarliest1(v SearchJobStageConfigEarliest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobStageConfigEarliest1 performs a merge with any Union data inside the SearchJobStageConfig_Earliest, using the provided SearchJobStageConfigEarliest1
func (t *SearchJobStageConfig_Earliest) MergeSearchJobStageConfigEarliest1(v SearchJobStageConfigEarliest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchJobStageConfig_Earliest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchJobStageConfig_Earliest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchJobStageConfigLatest0 returns the Union data inside the SearchJobStageConfig_Latest as a SearchJobStageConfigLatest0
func (t SearchJobStageConfig_Latest) AsSearchJobStageConfigLatest0() (SearchJobStageConfigLatest0, error) {
	var body SearchJobStageConfigLatest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobStageConfigLatest0 overwrites any Union data inside the SearchJobStageConfig_Latest as the provided SearchJobStageConfigLatest0
func (t *SearchJobStageConfig_Latest) FromSearchJobStageConfigLatest0(v SearchJobStageConfigLatest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobStageConfigLatest0 performs a merge with any Union data inside the SearchJobStageConfig_Latest, using the provided SearchJobStageConfigLatest0
func (t *SearchJobStageConfig_Latest) MergeSearchJobStageConfigLatest0(v SearchJobStageConfigLatest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchJobStageConfigLatest1 returns the Union data inside the SearchJobStageConfig_Latest as a SearchJobStageConfigLatest1
func (t SearchJobStageConfig_Latest) AsSearchJobStageConfigLatest1() (SearchJobStageConfigLatest1, error) {
	var body SearchJobStageConfigLatest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchJobStageConfigLatest1 overwrites any Union data inside the SearchJobStageConfig_Latest as the provided SearchJobStageConfigLatest1
func (t *SearchJobStageConfig_Latest) FromSearchJobStageConfigLatest1(v SearchJobStageConfigLatest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchJobStageConfigLatest1 performs a merge with any Union data inside the SearchJobStageConfig_Latest, using the provided SearchJobStageConfigLatest1
func (t *SearchJobStageConfig_Latest) MergeSearchJobStageConfigLatest1(v SearchJobStageConfigLatest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchJobStageConfig_Latest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchJobStageConfig_Latest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchParameterValue0 returns the Union data inside the SearchParameterValue as a SearchParameterValue0
func (t SearchParameterValue) AsSearchParameterValue0() (SearchParameterValue0, error) {
	var body SearchParameterValue0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchParameterValue0 overwrites any Union data inside the SearchParameterValue as the provided SearchParameterValue0
func (t *SearchParameterValue) FromSearchParameterValue0(v SearchParameterValue0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchParameterValue0 performs a merge with any Union data inside the SearchParameterValue, using the provided SearchParameterValue0
func (t *SearchParameterValue) MergeSearchParameterValue0(v SearchParameterValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchParameterValue1 returns the Union data inside the SearchParameterValue as a SearchParameterValue1
func (t SearchParameterValue) AsSearchParameterValue1() (SearchParameterValue1, error) {
	var body SearchParameterValue1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchParameterValue1 overwrites any Union data inside the SearchParameterValue as the provided SearchParameterValue1
func (t *SearchParameterValue) FromSearchParameterValue1(v SearchParameterValue1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchParameterValue1 performs a merge with any Union data inside the SearchParameterValue, using the provided SearchParameterValue1
func (t *SearchParameterValue) MergeSearchParameterValue1(v SearchParameterValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchParameterValue2 returns the Union data inside the SearchParameterValue as a SearchParameterValue2
func (t SearchParameterValue) AsSearchParameterValue2() (SearchParameterValue2, error) {
	var body SearchParameterValue2
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchParameterValue2 overwrites any Union data inside the SearchParameterValue as the provided SearchParameterValue2
func (t *SearchParameterValue) FromSearchParameterValue2(v SearchParameterValue2) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchParameterValue2 performs a merge with any Union data inside the SearchParameterValue, using the provided SearchParameterValue2
func (t *SearchParameterValue) MergeSearchParameterValue2(v SearchParameterValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchParameterValue) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchParameterValue) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchQuery0 returns the Union data inside the SearchQuery as a SearchQuery0
func (t SearchQuery) AsSearchQuery0() (SearchQuery0, error) {
	var body SearchQuery0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery0 overwrites any Union data inside the SearchQuery as the provided SearchQuery0
func (t *SearchQuery) FromSearchQuery0(v SearchQuery0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery0 performs a merge with any Union data inside the SearchQuery, using the provided SearchQuery0
func (t *SearchQuery) MergeSearchQuery0(v SearchQuery0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchQuery1 returns the Union data inside the SearchQuery as a SearchQuery1
func (t SearchQuery) AsSearchQuery1() (SearchQuery1, error) {
	var body SearchQuery1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1 overwrites any Union data inside the SearchQuery as the provided SearchQuery1
func (t *SearchQuery) FromSearchQuery1(v SearchQuery1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1 performs a merge with any Union data inside the SearchQuery, using the provided SearchQuery1
func (t *SearchQuery) MergeSearchQuery1(v SearchQuery1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchQuery2 returns the Union data inside the SearchQuery as a SearchQuery2
func (t SearchQuery) AsSearchQuery2() (SearchQuery2, error) {
	var body SearchQuery2
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery2 overwrites any Union data inside the SearchQuery as the provided SearchQuery2
func (t *SearchQuery) FromSearchQuery2(v SearchQuery2) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery2 performs a merge with any Union data inside the SearchQuery, using the provided SearchQuery2
func (t *SearchQuery) MergeSearchQuery2(v SearchQuery2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchQuery) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchQuery) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchQuery1Earliest0 returns the Union data inside the SearchQuery_1_Earliest as a SearchQuery1Earliest0
func (t SearchQuery_1_Earliest) AsSearchQuery1Earliest0() (SearchQuery1Earliest0, error) {
	var body SearchQuery1Earliest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1Earliest0 overwrites any Union data inside the SearchQuery_1_Earliest as the provided SearchQuery1Earliest0
func (t *SearchQuery_1_Earliest) FromSearchQuery1Earliest0(v SearchQuery1Earliest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1Earliest0 performs a merge with any Union data inside the SearchQuery_1_Earliest, using the provided SearchQuery1Earliest0
func (t *SearchQuery_1_Earliest) MergeSearchQuery1Earliest0(v SearchQuery1Earliest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchQuery1Earliest1 returns the Union data inside the SearchQuery_1_Earliest as a SearchQuery1Earliest1
func (t SearchQuery_1_Earliest) AsSearchQuery1Earliest1() (SearchQuery1Earliest1, error) {
	var body SearchQuery1Earliest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1Earliest1 overwrites any Union data inside the SearchQuery_1_Earliest as the provided SearchQuery1Earliest1
func (t *SearchQuery_1_Earliest) FromSearchQuery1Earliest1(v SearchQuery1Earliest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1Earliest1 performs a merge with any Union data inside the SearchQuery_1_Earliest, using the provided SearchQuery1Earliest1
func (t *SearchQuery_1_Earliest) MergeSearchQuery1Earliest1(v SearchQuery1Earliest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchQuery_1_Earliest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchQuery_1_Earliest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchQuery1Latest0 returns the Union data inside the SearchQuery_1_Latest as a SearchQuery1Latest0
func (t SearchQuery_1_Latest) AsSearchQuery1Latest0() (SearchQuery1Latest0, error) {
	var body SearchQuery1Latest0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1Latest0 overwrites any Union data inside the SearchQuery_1_Latest as the provided SearchQuery1Latest0
func (t *SearchQuery_1_Latest) FromSearchQuery1Latest0(v SearchQuery1Latest0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1Latest0 performs a merge with any Union data inside the SearchQuery_1_Latest, using the provided SearchQuery1Latest0
func (t *SearchQuery_1_Latest) MergeSearchQuery1Latest0(v SearchQuery1Latest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchQuery1Latest1 returns the Union data inside the SearchQuery_1_Latest as a SearchQuery1Latest1
func (t SearchQuery_1_Latest) AsSearchQuery1Latest1() (SearchQuery1Latest1, error) {
	var body SearchQuery1Latest1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1Latest1 overwrites any Union data inside the SearchQuery_1_Latest as the provided SearchQuery1Latest1
func (t *SearchQuery_1_Latest) FromSearchQuery1Latest1(v SearchQuery1Latest1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1Latest1 performs a merge with any Union data inside the SearchQuery_1_Latest, using the provided SearchQuery1Latest1
func (t *SearchQuery_1_Latest) MergeSearchQuery1Latest1(v SearchQuery1Latest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchQuery_1_Latest) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchQuery_1_Latest) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchQuery1Query0 returns the Union data inside the SearchQuery_1_Query as a SearchQuery1Query0
func (t SearchQuery_1_Query) AsSearchQuery1Query0() (SearchQuery1Query0, error) {
	var body SearchQuery1Query0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchQuery1Query0 overwrites any Union data inside the SearchQuery_1_Query as the provided SearchQuery1Query0
func (t *SearchQuery_1_Query) FromSearchQuery1Query0(v SearchQuery1Query0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchQuery1Query0 performs a merge with any Union data inside the SearchQuery_1_Query, using the provided SearchQuery1Query0
func (t *SearchQuery_1_Query) MergeSearchQuery1Query0(v SearchQuery1Query0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchQuery_1_Query) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchQuery_1_Query) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchSettingsSearchQueueLength0 returns the Union data inside the SearchSettings_SearchQueueLength as a SearchSettingsSearchQueueLength0
func (t SearchSettings_SearchQueueLength) AsSearchSettingsSearchQueueLength0() (SearchSettingsSearchQueueLength0, error) {
	var body SearchSettingsSearchQueueLength0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchSettingsSearchQueueLength0 overwrites any Union data inside the SearchSettings_SearchQueueLength as the provided SearchSettingsSearchQueueLength0
func (t *SearchSettings_SearchQueueLength) FromSearchSettingsSearchQueueLength0(v SearchSettingsSearchQueueLength0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchSettingsSearchQueueLength0 performs a merge with any Union data inside the SearchSettings_SearchQueueLength, using the provided SearchSettingsSearchQueueLength0
func (t *SearchSettings_SearchQueueLength) MergeSearchSettingsSearchQueueLength0(v SearchSettingsSearchQueueLength0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchSettings_SearchQueueLength) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchSettings_SearchQueueLength) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// AsSearchSettingsWarmPoolSize0 returns the Union data inside the SearchSettings_WarmPoolSize as a SearchSettingsWarmPoolSize0
func (t SearchSettings_WarmPoolSize) AsSearchSettingsWarmPoolSize0() (SearchSettingsWarmPoolSize0, error) {
	var body SearchSettingsWarmPoolSize0
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchSettingsWarmPoolSize0 overwrites any Union data inside the SearchSettings_WarmPoolSize as the provided SearchSettingsWarmPoolSize0
func (t *SearchSettings_WarmPoolSize) FromSearchSettingsWarmPoolSize0(v SearchSettingsWarmPoolSize0) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchSettingsWarmPoolSize0 performs a merge with any Union data inside the SearchSettings_WarmPoolSize, using the provided SearchSettingsWarmPoolSize0
func (t *SearchSettings_WarmPoolSize) MergeSearchSettingsWarmPoolSize0(v SearchSettingsWarmPoolSize0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsSearchSettingsWarmPoolSize1 returns the Union data inside the SearchSettings_WarmPoolSize as a SearchSettingsWarmPoolSize1
func (t SearchSettings_WarmPoolSize) AsSearchSettingsWarmPoolSize1() (SearchSettingsWarmPoolSize1, error) {
	var body SearchSettingsWarmPoolSize1
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromSearchSettingsWarmPoolSize1 overwrites any Union data inside the SearchSettings_WarmPoolSize as the provided SearchSettingsWarmPoolSize1
func (t *SearchSettings_WarmPoolSize) FromSearchSettingsWarmPoolSize1(v SearchSettingsWarmPoolSize1) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeSearchSettingsWarmPoolSize1 performs a merge with any Union data inside the SearchSettings_WarmPoolSize, using the provided SearchSettingsWarmPoolSize1
func (t *SearchSettings_WarmPoolSize) MergeSearchSettingsWarmPoolSize1(v SearchSettingsWarmPoolSize1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t SearchSettings_WarmPoolSize) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *SearchSettings_WarmPoolSize) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAiConsent request
	GetAiConsent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAiConsent request
	PostAiConsent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthAuthorizationCodeCallback request
	GetAuthAuthorizationCodeCallback(ctx context.Context, params *GetAuthAuthorizationCodeCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthGroups request
	GetAuthGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthLoginWithBody request with any body
	PostAuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthLogin(ctx context.Context, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthLogout request
	PostAuthLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthMetadata request
	GetAuthMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthMultiFactor request
	GetAuthMultiFactor(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthSlo request
	GetAuthSlo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthSloCallback request
	GetAuthSloCallback(ctx context.Context, params *GetAuthSloCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthSloCallbackWithBody request with any body
	PostAuthSloCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthSloCallbackWithFormdataBody(ctx context.Context, body PostAuthSloCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthSso request
	GetAuthSso(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthSsoCallback request
	GetAuthSsoCallback(ctx context.Context, params *GetAuthSsoCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthSsoCallbackWithBody request with any body
	PostAuthSsoCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthSsoCallbackWithFormdataBody(ctx context.Context, body PostAuthSsoCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthUsersIdToken request
	DeleteAuthUsersIdToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorizePolicy request
	GetAuthorizePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorizeRoles request
	GetAuthorizeRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChangelogViewed request
	GetChangelogViewed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchChangelogViewed request
	PatchChangelogViewed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClui request
	GetClui(ctx context.Context, params *GetCluiParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectors request
	GetCollectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorsId request
	GetCollectorsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConditions request
	GetConditions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConditionsId request
	GetConditionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeAppscopeProcesses request
	GetEdgeAppscopeProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEdgeAppscopeProcesses request
	PostEdgeAppscopeProcesses(ctx context.Context, params *PostEdgeAppscopeProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEdgeAppscopeProcessesPid request
	DeleteEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeAppscopeProcessesPid request
	GetEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutEdgeAppscopeProcessesPid request
	PutEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeContainers request
	GetEdgeContainers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeContainersId request
	GetEdgeContainersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeEventsCollectors request
	GetEdgeEventsCollectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeEventsQuery request
	GetEdgeEventsQuery(ctx context.Context, params *GetEdgeEventsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEdgeFileIngest request
	PostEdgeFileIngest(ctx context.Context, params *PostEdgeFileIngestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeFileSample request
	GetEdgeFileSample(ctx context.Context, params *GetEdgeFileSampleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeFileinspect request
	GetEdgeFileinspect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEdgeKubeLogs request
	PostEdgeKubeLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeKubeProxy request
	GetEdgeKubeProxy(ctx context.Context, params *GetEdgeKubeProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeLogs request
	GetEdgeLogs(ctx context.Context, params *GetEdgeLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeLsPath request
	GetEdgeLsPath(ctx context.Context, path string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeMetadata request
	GetEdgeMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeProcesses request
	GetEdgeProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEdgeProcessesPid request
	GetEdgeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExecutors request
	GetExecutors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExecutorsId request
	GetExecutorsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunctions request
	GetFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunctionsId request
	GetFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobs request
	GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostJobsWithBody request with any body
	PostJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostJobs(ctx context.Context, body PostJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJobsId request
	DeleteJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsId request
	GetJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchJobsIdCancel request
	PatchJobsIdCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsIdErrors request
	GetJobsIdErrors(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsIdErrorsGroup request
	GetJobsIdErrorsGroup(ctx context.Context, id string, group string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchJobsIdKeep request
	PatchJobsIdKeep(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchJobsIdPause request
	PatchJobsIdPause(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsIdResults request
	GetJobsIdResults(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobsIdResultsGroup request
	GetJobsIdResultsGroup(ctx context.Context, id string, group string, params *GetJobsIdResultsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchJobsIdResume request
	PatchJobsIdResume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibAppscopeConfigs request
	GetLibAppscopeConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibAppscopeConfigsWithBody request with any body
	PostLibAppscopeConfigsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibAppscopeConfigs(ctx context.Context, body PostLibAppscopeConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibAppscopeConfigsId request
	DeleteLibAppscopeConfigsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibAppscopeConfigsId request
	GetLibAppscopeConfigsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibAppscopeConfigsIdWithBody request with any body
	PatchLibAppscopeConfigsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibAppscopeConfigsId(ctx context.Context, id string, body PatchLibAppscopeConfigsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibBreakers request
	GetLibBreakers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibBreakersWithBody request with any body
	PostLibBreakersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibBreakers(ctx context.Context, body PostLibBreakersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibBreakersId request
	DeleteLibBreakersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibBreakersId request
	GetLibBreakersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibBreakersIdWithBody request with any body
	PatchLibBreakersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibBreakersId(ctx context.Context, id string, body PatchLibBreakersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibDatabaseConnections request
	GetLibDatabaseConnections(ctx context.Context, params *GetLibDatabaseConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibDatabaseConnectionsWithBody request with any body
	PostLibDatabaseConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibDatabaseConnections(ctx context.Context, body PostLibDatabaseConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibDatabaseConnectionsTestWithBody request with any body
	PostLibDatabaseConnectionsTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibDatabaseConnectionsTest(ctx context.Context, body PostLibDatabaseConnectionsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibDatabaseConnectionsId request
	DeleteLibDatabaseConnectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibDatabaseConnectionsId request
	GetLibDatabaseConnectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibDatabaseConnectionsIdWithBody request with any body
	PatchLibDatabaseConnectionsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibDatabaseConnectionsId(ctx context.Context, id string, body PatchLibDatabaseConnectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibExpression request
	PostLibExpression(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibGrok request
	GetLibGrok(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibGrokWithBody request with any body
	PostLibGrokWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibGrok(ctx context.Context, body PostLibGrokJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibGrokId request
	DeleteLibGrokId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibGrokId request
	GetLibGrokId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibGrokIdWithBody request with any body
	PatchLibGrokIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibGrokId(ctx context.Context, id string, body PatchLibGrokIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibHmacFunctions request
	GetLibHmacFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibHmacFunctionsWithBody request with any body
	PostLibHmacFunctionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibHmacFunctions(ctx context.Context, body PostLibHmacFunctionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibHmacFunctionsId request
	DeleteLibHmacFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibHmacFunctionsId request
	GetLibHmacFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibHmacFunctionsIdWithBody request with any body
	PatchLibHmacFunctionsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibHmacFunctionsId(ctx context.Context, id string, body PatchLibHmacFunctionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibJobs request
	GetLibJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibJobsWithBody request with any body
	PostLibJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibJobs(ctx context.Context, body PostLibJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibJobsId request
	DeleteLibJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibJobsId request
	GetLibJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibJobsIdWithBody request with any body
	PatchLibJobsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibJobsId(ctx context.Context, id string, body PatchLibJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibParquetSchemas request
	GetLibParquetSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibParquetSchemasWithBody request with any body
	PostLibParquetSchemasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibParquetSchemas(ctx context.Context, body PostLibParquetSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibParquetSchemasId request
	DeleteLibParquetSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibParquetSchemasId request
	GetLibParquetSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibParquetSchemasIdWithBody request with any body
	PatchLibParquetSchemasIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibParquetSchemasId(ctx context.Context, id string, body PatchLibParquetSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibParsers request
	GetLibParsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibParsersWithBody request with any body
	PostLibParsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibParsers(ctx context.Context, body PostLibParsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibParsersId request
	DeleteLibParsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibParsersId request
	GetLibParsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibParsersIdWithBody request with any body
	PatchLibParsersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibParsersId(ctx context.Context, id string, body PatchLibParsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibProtobufLibraries request
	GetLibProtobufLibraries(ctx context.Context, params *GetLibProtobufLibrariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibProtobufLibrariesId request
	GetLibProtobufLibrariesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibProtobufLibrariesIdEncodings request
	GetLibProtobufLibrariesIdEncodings(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibProtobufLibrariesIdEncodingsEncid request
	GetLibProtobufLibrariesIdEncodingsEncid(ctx context.Context, id string, encid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibRegex request
	GetLibRegex(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibRegexWithBody request with any body
	PostLibRegexWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibRegex(ctx context.Context, body PostLibRegexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibRegexId request
	DeleteLibRegexId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibRegexId request
	GetLibRegexId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibRegexIdWithBody request with any body
	PatchLibRegexIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibRegexId(ctx context.Context, id string, body PatchLibRegexIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibSchemas request
	GetLibSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibSchemasWithBody request with any body
	PostLibSchemasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibSchemas(ctx context.Context, body PostLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibSchemasId request
	DeleteLibSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibSchemasId request
	GetLibSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibSchemasIdWithBody request with any body
	PatchLibSchemasIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibSchemasId(ctx context.Context, id string, body PatchLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibVars request
	GetLibVars(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLibVarsWithBody request with any body
	PostLibVarsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLibVars(ctx context.Context, body PostLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLibVarsId request
	DeleteLibVarsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibVarsId request
	GetLibVarsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLibVarsIdWithBody request with any body
	PatchLibVarsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLibVarsId(ctx context.Context, id string, body PatchLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMGroupIdSystemProjectsProjectIdCaptureWithBody request with any body
	PostMGroupIdSystemProjectsProjectIdCaptureWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMGroupIdSystemProjectsProjectIdCapture(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdPipelines request
	GetMGroupIdSystemProjectsProjectIdPipelines(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMGroupIdSystemProjectsProjectIdPipelinesWithBody request with any body
	PostMGroupIdSystemProjectsProjectIdPipelinesWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMGroupIdSystemProjectsProjectIdPipelines(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId request
	DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId request
	GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBody request with any body
	PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBody(ctx context.Context, groupId string, projectId string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, body PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMGroupIdSystemProjectsProjectIdPreviewWithBody request with any body
	PostMGroupIdSystemProjectsProjectIdPreviewWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMGroupIdSystemProjectsProjectIdPreview(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdSubscriptions request
	GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody request with any body
	PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx context.Context, groupId string, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx context.Context, groupId string, projectId string, subscriptionId string, body PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMGroupIdSystemProjectsProjectIdVersionCommitWithBody request with any body
	PostMGroupIdSystemProjectsProjectIdVersionCommitWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdVersionCount request
	GetMGroupIdSystemProjectsProjectIdVersionCount(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdVersionDiff request
	GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx context.Context, groupId string, projectId string, params *GetMGroupIdSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMGroupIdSystemProjectsProjectIdVersionFiles request
	GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterBundlesGroupVersion request
	GetMasterBundlesGroupVersion(ctx context.Context, group string, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterGroupsId request
	GetMasterGroupsId(ctx context.Context, id string, params *GetMasterGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterGroupsIdAcl request
	GetMasterGroupsIdAcl(ctx context.Context, id string, params *GetMasterGroupsIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterGroupsIdConfigVersion request
	GetMasterGroupsIdConfigVersion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMasterGroupsIdDeployWithBody request with any body
	PatchMasterGroupsIdDeployWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchMasterGroupsIdDeploy(ctx context.Context, id string, body PatchMasterGroupsIdDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterSummary request
	GetMasterSummary(ctx context.Context, params *GetMasterSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterSummaryWorkers request
	GetMasterSummaryWorkers(ctx context.Context, params *GetMasterSummaryWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterWorkers request
	GetMasterWorkers(ctx context.Context, params *GetMasterWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchMasterWorkersRestart request
	PatchMasterWorkersRestart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationTargets request
	GetNotificationTargets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNotificationTargetsWithBody request with any body
	PostNotificationTargetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNotificationTargets(ctx context.Context, body PostNotificationTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationTargetsId request
	DeleteNotificationTargetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationTargetsId request
	GetNotificationTargetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchNotificationTargetsIdWithBody request with any body
	PatchNotificationTargetsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchNotificationTargetsId(ctx context.Context, id string, body PatchNotificationTargetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotifications request
	GetNotifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNotificationsWithBody request with any body
	PostNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNotifications(ctx context.Context, body PostNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationsId request
	DeleteNotificationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationsId request
	GetNotificationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchNotificationsIdWithBody request with any body
	PatchNotificationsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchNotificationsId(ctx context.Context, id string, body PatchNotificationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOutputClickHouseDescribeTableWithBody request with any body
	PostOutputClickHouseDescribeTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOutputClickHouseDescribeTable(ctx context.Context, body PostOutputClickHouseDescribeTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackFunctions request
	GetPPackFunctions(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackFunctionsId request
	GetPPackFunctionsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackLibSchemas request
	GetPPackLibSchemas(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPPackLibSchemasWithBody request with any body
	PostPPackLibSchemasWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPPackLibSchemas(ctx context.Context, pack string, body PostPPackLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePPackLibSchemasId request
	DeletePPackLibSchemasId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackLibSchemasId request
	GetPPackLibSchemasId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPPackLibSchemasIdWithBody request with any body
	PatchPPackLibSchemasIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPPackLibSchemasId(ctx context.Context, pack string, id string, body PatchPPackLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackLibVars request
	GetPPackLibVars(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPPackLibVarsWithBody request with any body
	PostPPackLibVarsWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPPackLibVars(ctx context.Context, pack string, body PostPPackLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePPackLibVarsId request
	DeletePPackLibVarsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackLibVarsId request
	GetPPackLibVarsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPPackLibVarsIdWithBody request with any body
	PatchPPackLibVarsIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPPackLibVarsId(ctx context.Context, pack string, id string, body PatchPPackLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackPipelines request
	GetPPackPipelines(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPPackPipelinesWithBody request with any body
	PostPPackPipelinesWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPPackPipelines(ctx context.Context, pack string, body PostPPackPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePPackPipelinesId request
	DeletePPackPipelinesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackPipelinesId request
	GetPPackPipelinesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPPackPipelinesIdWithBody request with any body
	PatchPPackPipelinesIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPPackPipelinesId(ctx context.Context, pack string, id string, body PatchPPackPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackRoutes request
	GetPPackRoutes(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPPackRoutesId request
	GetPPackRoutesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPPackRoutesIdWithBody request with any body
	PatchPPackRoutesIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPPackRoutesId(ctx context.Context, pack string, id string, body PatchPPackRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPPackRoutesIdAppendWithBody request with any body
	PostPPackRoutesIdAppendWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPPackRoutesIdAppend(ctx context.Context, pack string, id string, body PostPPackRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPacks request
	GetPacks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPacksWithBody request with any body
	PostPacksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPacks(ctx context.Context, body PostPacksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPacks request
	PutPacks(ctx context.Context, params *PutPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPacksCloneWithBody request with any body
	PostPacksCloneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPacksClone(ctx context.Context, body PostPacksCloneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePacksId request
	DeletePacksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPacksId request
	PatchPacksId(ctx context.Context, id string, params *PatchPacksIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPacksIdExport request
	GetPacksIdExport(ctx context.Context, id string, params *GetPacksIdExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelines request
	GetPipelines(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPipelinesWithBody request with any body
	PostPipelinesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPipelines(ctx context.Context, body PostPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePipelinesId request
	DeletePipelinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelinesId request
	GetPipelinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPipelinesIdWithBody request with any body
	PatchPipelinesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPipelinesId(ctx context.Context, id string, body PatchPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPreviewWithBody request with any body
	PostPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPreview(ctx context.Context, body PostPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsEdgeMapQuery request
	PostProductsEdgeMapQuery(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsLakeLakesLakeIdDatasets request
	GetProductsLakeLakesLakeIdDatasets(ctx context.Context, lakeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsLakeLakesLakeIdDatasetsWithBody request with any body
	PostProductsLakeLakesLakeIdDatasetsWithBody(ctx context.Context, lakeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsLakeLakesLakeIdDatasets(ctx context.Context, lakeId string, body PostProductsLakeLakesLakeIdDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsLakeLakesLakeIdDatasetsId request
	DeleteProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsLakeLakesLakeIdDatasetsId request
	GetProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchProductsLakeLakesLakeIdDatasetsIdWithBody request with any body
	PatchProductsLakeLakesLakeIdDatasetsIdWithBody(ctx context.Context, lakeId string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, body PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProductGroups request
	GetProductsProductGroups(ctx context.Context, product GetProductsProductGroupsParamsProduct, params *GetProductsProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductGroupsWithBody request with any body
	PostProductsProductGroupsWithBody(ctx context.Context, product PostProductsProductGroupsParamsProduct, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductGroups(ctx context.Context, product PostProductsProductGroupsParamsProduct, body PostProductsProductGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProductGroupsIdAclTeams request
	GetProductsProductGroupsIdAclTeams(ctx context.Context, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params *GetProductsProductGroupsIdAclTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProductUsers request
	GetProductsProductUsers(ctx context.Context, product GetProductsProductUsersParamsProduct, params *GetProductsProductUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsProductUsersCache request
	DeleteProductsProductUsersCache(ctx context.Context, product DeleteProductsProductUsersCacheParamsProduct, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProductUsersIdAcl request
	GetProductsProductUsersIdAcl(ctx context.Context, product GetProductsProductUsersIdAclParamsProduct, id string, params *GetProductsProductUsersIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutes request
	GetRoutes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesId request
	GetRoutesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRoutesIdWithBody request with any body
	PatchRoutesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRoutesId(ctx context.Context, id string, body PatchRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRoutesIdAppendWithBody request with any body
	PostRoutesIdAppendWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRoutesIdAppend(ctx context.Context, id string, body PostRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboardCategories request
	GetSearchDashboardCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDashboardCategoriesWithBody request with any body
	PostSearchDashboardCategoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDashboardCategories(ctx context.Context, body PostSearchDashboardCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchDashboardCategoriesId request
	DeleteSearchDashboardCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboardCategoriesId request
	GetSearchDashboardCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchDashboardCategoriesIdWithBody request with any body
	PatchSearchDashboardCategoriesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchDashboardCategoriesId(ctx context.Context, id string, body PatchSearchDashboardCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboards request
	GetSearchDashboards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDashboardsWithBody request with any body
	PostSearchDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDashboards(ctx context.Context, body PostSearchDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchDashboardsId request
	DeleteSearchDashboardsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboardsId request
	GetSearchDashboardsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchDashboardsIdWithBody request with any body
	PatchSearchDashboardsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchDashboardsId(ctx context.Context, id string, body PatchSearchDashboardsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboardsIdAcl request
	GetSearchDashboardsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDashboardsIdAclApplyWithBody request with any body
	PostSearchDashboardsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDashboardsIdAclApply(ctx context.Context, id string, body PostSearchDashboardsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDashboardsIdAclTeams request
	GetSearchDashboardsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDashboardsIdAclTeamsApplyWithBody request with any body
	PostSearchDashboardsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDashboardsIdAclTeamsApply(ctx context.Context, id string, body PostSearchDashboardsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetProviderTypes request
	GetSearchDatasetProviderTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDatasetProviderTypesWithBody request with any body
	PostSearchDatasetProviderTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDatasetProviderTypes(ctx context.Context, body PostSearchDatasetProviderTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchDatasetProviderTypesId request
	DeleteSearchDatasetProviderTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetProviderTypesId request
	GetSearchDatasetProviderTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchDatasetProviderTypesIdWithBody request with any body
	PatchSearchDatasetProviderTypesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchDatasetProviderTypesId(ctx context.Context, id string, body PatchSearchDatasetProviderTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetProviders request
	GetSearchDatasetProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDatasetProvidersWithBody request with any body
	PostSearchDatasetProvidersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDatasetProviders(ctx context.Context, body PostSearchDatasetProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchDatasetProvidersId request
	DeleteSearchDatasetProvidersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetProvidersId request
	GetSearchDatasetProvidersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchDatasetProvidersIdWithBody request with any body
	PatchSearchDatasetProvidersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchDatasetProvidersId(ctx context.Context, id string, body PatchSearchDatasetProvidersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasets request
	GetSearchDatasets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDatasetsWithBody request with any body
	PostSearchDatasetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDatasets(ctx context.Context, body PostSearchDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchDatasetsId request
	DeleteSearchDatasetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetsId request
	GetSearchDatasetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchDatasetsIdWithBody request with any body
	PatchSearchDatasetsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchDatasetsId(ctx context.Context, id string, body PatchSearchDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetsIdAcl request
	GetSearchDatasetsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDatasetsIdAclApplyWithBody request with any body
	PostSearchDatasetsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDatasetsIdAclApply(ctx context.Context, id string, body PostSearchDatasetsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDatasetsIdAclTeams request
	GetSearchDatasetsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchDatasetsIdAclTeamsApplyWithBody request with any body
	PostSearchDatasetsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchDatasetsIdAclTeamsApply(ctx context.Context, id string, body PostSearchDatasetsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchEventBreakerPreviewWithBody request with any body
	PostSearchEventBreakerPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchEventBreakerPreview(ctx context.Context, body PostSearchEventBreakerPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchHealthcheck request
	GetSearchHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobMetrics request
	GetSearchJobMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobs request
	GetSearchJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchJobsWithBody request with any body
	PostSearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchJobs(ctx context.Context, body PostSearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchJobsId request
	DeleteSearchJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsId request
	GetSearchJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchJobsIdWithBody request with any body
	PatchSearchJobsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchJobsId(ctx context.Context, id string, body PatchSearchJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchJobsIdDispatchExecutors request
	PostSearchJobsIdDispatchExecutors(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsIdLogs request
	GetSearchJobsIdLogs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsIdMetrics request
	GetSearchJobsIdMetrics(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsIdResults request
	GetSearchJobsIdResults(ctx context.Context, id string, params *GetSearchJobsIdResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsIdResultsPoll request
	GetSearchJobsIdResultsPoll(ctx context.Context, id string, params *GetSearchJobsIdResultsPollParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchJobsIdStagesStageIdResults request
	GetSearchJobsIdStagesStageIdResults(ctx context.Context, id string, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchMacros request
	GetSearchMacros(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchMacrosWithBody request with any body
	PostSearchMacrosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchMacros(ctx context.Context, body PostSearchMacrosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchMacrosId request
	DeleteSearchMacrosId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchMacrosId request
	GetSearchMacrosId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchMacrosIdWithBody request with any body
	PatchSearchMacrosIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchMacrosId(ctx context.Context, id string, body PatchSearchMacrosIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchPreviewWithBody request with any body
	PostSearchPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchPreview(ctx context.Context, body PostSearchPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchSaved request
	GetSearchSaved(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchSavedWithBody request with any body
	PostSearchSavedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchSaved(ctx context.Context, body PostSearchSavedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchSavedId request
	DeleteSearchSavedId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchSavedId request
	GetSearchSavedId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchSavedIdWithBody request with any body
	PatchSearchSavedIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchSavedId(ctx context.Context, id string, body PatchSearchSavedIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchTrustPolicies request
	GetSearchTrustPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchUsageGroups request
	GetSearchUsageGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSearchUsageGroupsWithBody request with any body
	PostSearchUsageGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSearchUsageGroups(ctx context.Context, body PostSearchUsageGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSearchUsageGroupsId request
	DeleteSearchUsageGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchUsageGroupsId request
	GetSearchUsageGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSearchUsageGroupsIdWithBody request with any body
	PatchSearchUsageGroupsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSearchUsageGroupsId(ctx context.Context, id string, body PatchSearchUsageGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityKmsConfig request
	GetSecurityKmsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSecurityKmsConfigWithBody request with any body
	PatchSecurityKmsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSecurityKmsConfig(ctx context.Context, body PatchSecurityKmsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityKmsHealth request
	GetSecurityKmsHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsFeatures request
	GetSettingsFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsFeaturesId request
	GetSettingsFeaturesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemBanners request
	GetSystemBanners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemBannersWithBody request with any body
	PostSystemBannersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemBanners(ctx context.Context, body PostSystemBannersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemBannersId request
	DeleteSystemBannersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemBannersId request
	GetSystemBannersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemBannersIdWithBody request with any body
	PatchSystemBannersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemBannersId(ctx context.Context, id string, body PatchSystemBannersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemCaptureWithBody request with any body
	PostSystemCaptureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemCapture(ctx context.Context, body PostSystemCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemCertificates request
	GetSystemCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemCertificatesWithBody request with any body
	PostSystemCertificatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemCertificates(ctx context.Context, body PostSystemCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemCertificatesId request
	DeleteSystemCertificatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemCertificatesId request
	GetSystemCertificatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemCertificatesIdWithBody request with any body
	PatchSystemCertificatesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemCertificatesId(ctx context.Context, id string, body PatchSystemCertificatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemDiag request
	DeleteSystemDiag(ctx context.Context, params *DeleteSystemDiagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemDiag request
	GetSystemDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemDiagDownload request
	GetSystemDiagDownload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemDiagSendWithBody request with any body
	PostSystemDiagSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemDiagSend(ctx context.Context, body PostSystemDiagSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemDistributedUpgradeCancelGroup request
	PostSystemDistributedUpgradeCancelGroup(ctx context.Context, group string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemDistributedUpgradeDownloadFile request
	GetSystemDistributedUpgradeDownloadFile(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemDistributedUpgradeStageGroup request
	PostSystemDistributedUpgradeStageGroup(ctx context.Context, group string, params *PostSystemDistributedUpgradeStageGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemDistributedUpgradeGroupWithBody request with any body
	PostSystemDistributedUpgradeGroupWithBody(ctx context.Context, group string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemDistributedUpgradeGroup(ctx context.Context, group string, body PostSystemDistributedUpgradeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInfo request
	GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInputs request
	GetSystemInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemInputsWithBody request with any body
	PostSystemInputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemInputs(ctx context.Context, body PostSystemInputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemInputsId request
	DeleteSystemInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInputsId request
	GetSystemInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemInputsIdWithBody request with any body
	PatchSystemInputsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemInputsId(ctx context.Context, id string, body PatchSystemInputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemInputsIdHectokenWithBody request with any body
	PostSystemInputsIdHectokenWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemInputsIdHectoken(ctx context.Context, id string, body PostSystemInputsIdHectokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemInputsIdHectokenTokenWithBody request with any body
	PatchSystemInputsIdHectokenTokenWithBody(ctx context.Context, id string, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemInputsIdHectokenToken(ctx context.Context, id string, token string, body PatchSystemInputsIdHectokenTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemJobsLogsIdGroupId request
	GetSystemJobsLogsIdGroupId(ctx context.Context, id string, groupId string, params *GetSystemJobsLogsIdGroupIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemKeys request
	GetSystemKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemKeysWithBody request with any body
	PostSystemKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemKeys(ctx context.Context, body PostSystemKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemKeysId request
	DeleteSystemKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemKeysId request
	GetSystemKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemKeysIdWithBody request with any body
	PatchSystemKeysIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemKeysId(ctx context.Context, id string, body PatchSystemKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLicenses request
	GetSystemLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemLicensesWithBody request with any body
	PostSystemLicensesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemLicenses(ctx context.Context, body PostSystemLicensesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLicensesUsage request
	GetSystemLicensesUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemLicensesId request
	DeleteSystemLicensesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLicensesId request
	GetSystemLicensesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLogger request
	GetSystemLogger(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemLoggerId request
	DeleteSystemLoggerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLoggerId request
	GetSystemLoggerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemLoggerIdWithBody request with any body
	PatchSystemLoggerIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemLoggerId(ctx context.Context, id string, body PatchSystemLoggerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLogs request
	GetSystemLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLogsSearch request
	GetSystemLogsSearch(ctx context.Context, params *GetSystemLogsSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLogsId request
	GetSystemLogsId(ctx context.Context, id string, params *GetSystemLogsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLookups request
	GetSystemLookups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemLookupsWithBody request with any body
	PostSystemLookupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemLookups(ctx context.Context, body PostSystemLookupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutSystemLookupsWithBody request with any body
	PutSystemLookupsWithBody(ctx context.Context, params *PutSystemLookupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemLookupsId request
	DeleteSystemLookupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemLookupsId request
	GetSystemLookupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemLookupsIdWithBody request with any body
	PatchSystemLookupsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemLookupsId(ctx context.Context, id string, body PatchSystemLookupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemMessages request
	GetSystemMessages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemMessagesWithBody request with any body
	PostSystemMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemMessages(ctx context.Context, body PostSystemMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemMessagesId request
	DeleteSystemMessagesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemMessagesId request
	GetSystemMessagesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemMetrics request
	GetSystemMetrics(ctx context.Context, params *GetSystemMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemMetricsEnumWithBody request with any body
	PostSystemMetricsEnumWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemMetricsEnum(ctx context.Context, body PostSystemMetricsEnumJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemMetricsQueryWithBody request with any body
	PostSystemMetricsQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemMetricsQuery(ctx context.Context, body PostSystemMetricsQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemOutputs request
	GetSystemOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemOutputsWithBody request with any body
	PostSystemOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemOutputs(ctx context.Context, body PostSystemOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemOutputsId request
	DeleteSystemOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemOutputsId request
	GetSystemOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemOutputsIdWithBody request with any body
	PatchSystemOutputsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemOutputsId(ctx context.Context, id string, body PatchSystemOutputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemOutputsIdPq request
	DeleteSystemOutputsIdPq(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemOutputsIdPq request
	GetSystemOutputsIdPq(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemOutputsIdSamples request
	GetSystemOutputsIdSamples(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemOutputsIdTestWithBody request with any body
	PostSystemOutputsIdTestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemOutputsIdTest(ctx context.Context, id string, body PostSystemOutputsIdTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemPolicies request
	GetSystemPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemPoliciesWithBody request with any body
	PostSystemPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemPolicies(ctx context.Context, body PostSystemPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemPoliciesId request
	DeleteSystemPoliciesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemPoliciesId request
	GetSystemPoliciesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemPoliciesIdWithBody request with any body
	PatchSystemPoliciesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemPoliciesId(ctx context.Context, id string, body PatchSystemPoliciesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProcesses request
	GetSystemProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProfiler request
	GetSystemProfiler(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProfilerWithBody request with any body
	PostSystemProfilerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProfiler(ctx context.Context, body PostSystemProfilerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemProfilerId request
	DeleteSystemProfilerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProfilerId request
	GetSystemProfilerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemProfilerIdWithBody request with any body
	PatchSystemProfilerIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemProfilerId(ctx context.Context, id string, body PatchSystemProfilerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjects request
	GetSystemProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsWithBody request with any body
	PostSystemProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjects(ctx context.Context, body PostSystemProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemProjectsId request
	DeleteSystemProjectsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsId request
	GetSystemProjectsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemProjectsIdWithBody request with any body
	PatchSystemProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemProjectsId(ctx context.Context, id string, body PatchSystemProjectsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsIdAcl request
	GetSystemProjectsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsIdAclApplyWithBody request with any body
	PostSystemProjectsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsIdAclApply(ctx context.Context, id string, body PostSystemProjectsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsIdAclTeams request
	GetSystemProjectsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsIdAclTeamsApplyWithBody request with any body
	PostSystemProjectsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsIdAclTeamsApply(ctx context.Context, id string, body PostSystemProjectsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsProjectIdCaptureWithBody request with any body
	PostSystemProjectsProjectIdCaptureWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsProjectIdCapture(ctx context.Context, projectId string, body PostSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdDestinations request
	GetSystemProjectsProjectIdDestinations(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdSubscriptions request
	GetSystemProjectsProjectIdSubscriptions(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody request with any body
	PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx context.Context, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx context.Context, projectId string, subscriptionId string, body PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsProjectIdVersionCommitWithBody request with any body
	PostSystemProjectsProjectIdVersionCommitWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsProjectIdVersionCommit(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdVersionCount request
	GetSystemProjectsProjectIdVersionCount(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdVersionDiff request
	GetSystemProjectsProjectIdVersionDiff(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdVersionFiles request
	GetSystemProjectsProjectIdVersionFiles(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemProjectsProjectIdVersionRevertWithBody request with any body
	PostSystemProjectsProjectIdVersionRevertWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemProjectsProjectIdVersionRevert(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemProjectsProjectIdVersionShow request
	GetSystemProjectsProjectIdVersionShow(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemRoles request
	GetSystemRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemRolesWithBody request with any body
	PostSystemRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemRoles(ctx context.Context, body PostSystemRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemRolesId request
	DeleteSystemRolesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemRolesId request
	GetSystemRolesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemRolesIdWithBody request with any body
	PatchSystemRolesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemRolesId(ctx context.Context, id string, body PatchSystemRolesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSamples request
	GetSystemSamples(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSamplesWithBody request with any body
	PostSystemSamplesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemSamples(ctx context.Context, body PostSystemSamplesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemSamplesId request
	DeleteSystemSamplesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSamplesId request
	GetSystemSamplesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSamplesIdWithBody request with any body
	PatchSystemSamplesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemSamplesId(ctx context.Context, id string, body PatchSystemSamplesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSamplesIdContent request
	GetSystemSamplesIdContent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemScripts request
	GetSystemScripts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemScriptsWithBody request with any body
	PostSystemScriptsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemScripts(ctx context.Context, body PostSystemScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemScriptsId request
	DeleteSystemScriptsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemScriptsId request
	GetSystemScriptsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemScriptsIdWithBody request with any body
	PatchSystemScriptsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemScriptsId(ctx context.Context, id string, body PatchSystemScriptsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSecrets request
	GetSystemSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSecretsWithBody request with any body
	PostSystemSecretsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemSecrets(ctx context.Context, body PostSystemSecretsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemSecretsId request
	DeleteSystemSecretsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSecretsId request
	GetSystemSecretsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSecretsIdWithBody request with any body
	PatchSystemSecretsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemSecretsId(ctx context.Context, id string, body PatchSystemSecretsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettings request
	GetSystemSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSettings request
	PatchSystemSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsAuth request
	GetSystemSettingsAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSettingsAuth request
	PatchSystemSettingsAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsConf request
	GetSystemSettingsConf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSettingsConfWithBody request with any body
	PatchSystemSettingsConfWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemSettingsConf(ctx context.Context, body PatchSystemSettingsConfJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsCribl request
	GetSystemSettingsCribl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsGitSettings request
	GetSystemSettingsGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSettingsGitSettings request
	PatchSystemSettingsGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSettingsReload request
	PostSystemSettingsReload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSettingsRestart request
	PostSystemSettingsRestart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsSearchLimits request
	GetSystemSettingsSearchLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSettingsUpgrade request
	GetSystemSettingsUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSettingsUpgradeFromPackageWithBody request with any body
	PostSystemSettingsUpgradeFromPackageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemSettingsUpgradeFromPackage(ctx context.Context, body PostSystemSettingsUpgradeFromPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSettingsUpgradeVersion request
	PostSystemSettingsUpgradeVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatusInputs request
	GetSystemStatusInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatusInputsId request
	GetSystemStatusInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatusOutputs request
	GetSystemStatusOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatusOutputsId request
	GetSystemStatusOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSubscriptions request
	GetSystemSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemSubscriptions request
	PostSystemSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemSubscriptionsId request
	DeleteSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemSubscriptionsId request
	GetSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemSubscriptionsId request
	PatchSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemTeams request
	GetSystemTeams(ctx context.Context, params *GetSystemTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemTeamsWithBody request with any body
	PostSystemTeamsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemTeams(ctx context.Context, body PostSystemTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemTeamsUsersIdRoles request
	GetSystemTeamsUsersIdRoles(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemTeamsId request
	DeleteSystemTeamsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemTeamsId request
	GetSystemTeamsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemTeamsIdWithBody request with any body
	PatchSystemTeamsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemTeamsId(ctx context.Context, id string, body PatchSystemTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemTeamsIdAcl request
	GetSystemTeamsIdAcl(ctx context.Context, id string, params *GetSystemTeamsIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemTeamsIdUsers request
	GetSystemTeamsIdUsers(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemTeamsIdUsersWithBody request with any body
	PostSystemTeamsIdUsersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemTeamsIdUsers(ctx context.Context, id string, body PostSystemTeamsIdUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemUsers request
	GetSystemUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSystemUsersWithBody request with any body
	PostSystemUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSystemUsers(ctx context.Context, body PostSystemUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSystemUsersId request
	DeleteSystemUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemUsersId request
	GetSystemUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemUsersIdWithBody request with any body
	PatchSystemUsersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemUsersId(ctx context.Context, id string, body PatchSystemUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSystemUsersIdInfoWithBody request with any body
	PatchSystemUsersIdInfoWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSystemUsersIdInfo(ctx context.Context, id string, body PatchSystemUsersIdInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUiKey request
	GetUiKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUiKeyWithBody request with any body
	PatchUiKeyWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUiKey(ctx context.Context, key string, body PatchUiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionBranch request
	GetVersionBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVersionCommitWithBody request with any body
	PostVersionCommitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVersionCommit(ctx context.Context, body PostVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionCount request
	GetVersionCount(ctx context.Context, params *GetVersionCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionCurrentBranch request
	GetVersionCurrentBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionDiff request
	GetVersionDiff(ctx context.Context, params *GetVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionFiles request
	GetVersionFiles(ctx context.Context, params *GetVersionFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionInfo request
	GetVersionInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVersionPush request
	PostVersionPush(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVersionRevertWithBody request with any body
	PostVersionRevertWithBody(ctx context.Context, params *PostVersionRevertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVersionRevert(ctx context.Context, params *PostVersionRevertParams, body PostVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionShow request
	GetVersionShow(ctx context.Context, params *GetVersionShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionStatus request
	GetVersionStatus(ctx context.Context, params *GetVersionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVersionSync request
	PostVersionSync(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVersionUndo request
	PostVersionUndo(ctx context.Context, params *PostVersionUndoParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAiConsent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiConsentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAiConsent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAiConsentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthAuthorizationCodeCallback(ctx context.Context, params *GetAuthAuthorizationCodeCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthAuthorizationCodeCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLogin(ctx context.Context, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthMultiFactor(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthMultiFactorRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthSlo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthSloRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthSloCallback(ctx context.Context, params *GetAuthSloCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthSloCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthSloCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthSloCallbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthSloCallbackWithFormdataBody(ctx context.Context, body PostAuthSloCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthSloCallbackRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthSso(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthSsoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthSsoCallback(ctx context.Context, params *GetAuthSsoCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthSsoCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthSsoCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthSsoCallbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthSsoCallbackWithFormdataBody(ctx context.Context, body PostAuthSsoCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthSsoCallbackRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthUsersIdToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthUsersIdTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorizePolicy(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizePolicyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorizeRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorizeRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChangelogViewed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangelogViewedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChangelogViewed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChangelogViewedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClui(ctx context.Context, params *GetCluiParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCluiRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConditions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConditionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConditionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConditionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeAppscopeProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeAppscopeProcessesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEdgeAppscopeProcesses(ctx context.Context, params *PostEdgeAppscopeProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEdgeAppscopeProcessesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEdgeAppscopeProcessesPidRequest(c.Server, pid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeAppscopeProcessesPidRequest(c.Server, pid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEdgeAppscopeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEdgeAppscopeProcessesPidRequest(c.Server, pid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeContainers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeContainersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeContainersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeContainersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeEventsCollectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeEventsCollectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeEventsQuery(ctx context.Context, params *GetEdgeEventsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeEventsQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEdgeFileIngest(ctx context.Context, params *PostEdgeFileIngestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEdgeFileIngestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeFileSample(ctx context.Context, params *GetEdgeFileSampleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeFileSampleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeFileinspect(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeFileinspectRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEdgeKubeLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEdgeKubeLogsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeKubeProxy(ctx context.Context, params *GetEdgeKubeProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeKubeProxyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeLogs(ctx context.Context, params *GetEdgeLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeLsPath(ctx context.Context, path string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeLsPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeMetadata(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeMetadataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeProcessesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEdgeProcessesPid(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEdgeProcessesPidRequest(c.Server, pid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExecutors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExecutorsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutorsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostJobs(ctx context.Context, body PostJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchJobsIdCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchJobsIdCancelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsIdErrors(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsIdErrorsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsIdErrorsGroup(ctx context.Context, id string, group string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsIdErrorsGroupRequest(c.Server, id, group)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchJobsIdKeep(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchJobsIdKeepRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchJobsIdPause(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchJobsIdPauseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsIdResults(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsIdResultsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobsIdResultsGroup(ctx context.Context, id string, group string, params *GetJobsIdResultsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsIdResultsGroupRequest(c.Server, id, group, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchJobsIdResume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchJobsIdResumeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibAppscopeConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibAppscopeConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibAppscopeConfigsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibAppscopeConfigsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibAppscopeConfigs(ctx context.Context, body PostLibAppscopeConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibAppscopeConfigsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibAppscopeConfigsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibAppscopeConfigsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibAppscopeConfigsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibAppscopeConfigsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibAppscopeConfigsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibAppscopeConfigsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibAppscopeConfigsId(ctx context.Context, id string, body PatchLibAppscopeConfigsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibAppscopeConfigsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibBreakers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibBreakersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibBreakersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibBreakersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibBreakers(ctx context.Context, body PostLibBreakersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibBreakersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibBreakersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibBreakersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibBreakersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibBreakersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibBreakersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibBreakersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibBreakersId(ctx context.Context, id string, body PatchLibBreakersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibBreakersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibDatabaseConnections(ctx context.Context, params *GetLibDatabaseConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibDatabaseConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibDatabaseConnectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibDatabaseConnectionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibDatabaseConnections(ctx context.Context, body PostLibDatabaseConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibDatabaseConnectionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibDatabaseConnectionsTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibDatabaseConnectionsTestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibDatabaseConnectionsTest(ctx context.Context, body PostLibDatabaseConnectionsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibDatabaseConnectionsTestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibDatabaseConnectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibDatabaseConnectionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibDatabaseConnectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibDatabaseConnectionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibDatabaseConnectionsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibDatabaseConnectionsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibDatabaseConnectionsId(ctx context.Context, id string, body PatchLibDatabaseConnectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibDatabaseConnectionsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibExpression(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibExpressionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibGrok(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibGrokRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibGrokWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibGrokRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibGrok(ctx context.Context, body PostLibGrokJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibGrokRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibGrokId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibGrokIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibGrokId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibGrokIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibGrokIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibGrokIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibGrokId(ctx context.Context, id string, body PatchLibGrokIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibGrokIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibHmacFunctions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibHmacFunctionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibHmacFunctionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibHmacFunctionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibHmacFunctions(ctx context.Context, body PostLibHmacFunctionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibHmacFunctionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibHmacFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibHmacFunctionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibHmacFunctionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibHmacFunctionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibHmacFunctionsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibHmacFunctionsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibHmacFunctionsId(ctx context.Context, id string, body PatchLibHmacFunctionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibHmacFunctionsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibJobs(ctx context.Context, body PostLibJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibJobsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibJobsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibJobsId(ctx context.Context, id string, body PatchLibJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibJobsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibParquetSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibParquetSchemasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibParquetSchemasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibParquetSchemasRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibParquetSchemas(ctx context.Context, body PostLibParquetSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibParquetSchemasRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibParquetSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibParquetSchemasIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibParquetSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibParquetSchemasIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibParquetSchemasIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibParquetSchemasIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibParquetSchemasId(ctx context.Context, id string, body PatchLibParquetSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibParquetSchemasIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibParsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibParsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibParsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibParsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibParsers(ctx context.Context, body PostLibParsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibParsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibParsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibParsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibParsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibParsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibParsersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibParsersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibParsersId(ctx context.Context, id string, body PatchLibParsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibParsersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibProtobufLibraries(ctx context.Context, params *GetLibProtobufLibrariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibProtobufLibrariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibProtobufLibrariesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibProtobufLibrariesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibProtobufLibrariesIdEncodings(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibProtobufLibrariesIdEncodingsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibProtobufLibrariesIdEncodingsEncid(ctx context.Context, id string, encid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibProtobufLibrariesIdEncodingsEncidRequest(c.Server, id, encid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibRegex(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibRegexRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibRegexWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibRegexRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibRegex(ctx context.Context, body PostLibRegexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibRegexRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibRegexId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibRegexIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibRegexId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibRegexIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibRegexIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibRegexIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibRegexId(ctx context.Context, id string, body PatchLibRegexIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibRegexIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibSchemas(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibSchemasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibSchemasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibSchemasRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibSchemas(ctx context.Context, body PostLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibSchemasRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibSchemasIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibSchemasId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibSchemasIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibSchemasIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibSchemasIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibSchemasId(ctx context.Context, id string, body PatchLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibSchemasIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibVars(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibVarsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibVarsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibVarsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLibVars(ctx context.Context, body PostLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLibVarsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLibVarsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLibVarsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibVarsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibVarsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibVarsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibVarsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLibVarsId(ctx context.Context, id string, body PatchLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLibVarsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdCaptureWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdCaptureRequestWithBody(c.Server, groupId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdCapture(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdCaptureRequest(c.Server, groupId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdPipelines(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdPipelinesRequest(c.Server, groupId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdPipelinesWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdPipelinesRequestWithBody(c.Server, groupId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdPipelines(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdPipelinesRequest(c.Server, groupId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(c.Server, groupId, projectId, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(c.Server, groupId, projectId, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBody(ctx context.Context, groupId string, projectId string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequestWithBody(c.Server, groupId, projectId, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx context.Context, groupId string, projectId string, pipelineId string, body PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(c.Server, groupId, projectId, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdPreviewWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdPreviewRequestWithBody(c.Server, groupId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdPreview(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdPreviewRequest(c.Server, groupId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdSubscriptionsRequest(c.Server, groupId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx context.Context, groupId string, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(c.Server, groupId, projectId, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx context.Context, groupId string, projectId string, subscriptionId string, body PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest(c.Server, groupId, projectId, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdVersionCommitWithBody(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequestWithBody(c.Server, groupId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequest(c.Server, groupId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdVersionCount(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdVersionCountRequest(c.Server, groupId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx context.Context, groupId string, projectId string, params *GetMGroupIdSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdVersionDiffRequest(c.Server, groupId, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMGroupIdSystemProjectsProjectIdVersionFilesRequest(c.Server, groupId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterBundlesGroupVersion(ctx context.Context, group string, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterBundlesGroupVersionRequest(c.Server, group, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterGroupsId(ctx context.Context, id string, params *GetMasterGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterGroupsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterGroupsIdAcl(ctx context.Context, id string, params *GetMasterGroupsIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterGroupsIdAclRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterGroupsIdConfigVersion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterGroupsIdConfigVersionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMasterGroupsIdDeployWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMasterGroupsIdDeployRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMasterGroupsIdDeploy(ctx context.Context, id string, body PatchMasterGroupsIdDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMasterGroupsIdDeployRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterSummary(ctx context.Context, params *GetMasterSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterSummaryWorkers(ctx context.Context, params *GetMasterSummaryWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterSummaryWorkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterWorkers(ctx context.Context, params *GetMasterWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterWorkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchMasterWorkersRestart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchMasterWorkersRestartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationTargets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationTargetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotificationTargetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationTargetsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotificationTargets(ctx context.Context, body PostNotificationTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationTargetsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationTargetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationTargetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationTargetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationTargetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchNotificationTargetsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchNotificationTargetsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchNotificationTargetsId(ctx context.Context, id string, body PatchNotificationTargetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchNotificationTargetsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotificationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotifications(ctx context.Context, body PostNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchNotificationsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchNotificationsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchNotificationsId(ctx context.Context, id string, body PatchNotificationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchNotificationsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputClickHouseDescribeTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputClickHouseDescribeTableRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputClickHouseDescribeTable(ctx context.Context, body PostOutputClickHouseDescribeTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputClickHouseDescribeTableRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackFunctions(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackFunctionsRequest(c.Server, pack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackFunctionsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackFunctionsIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackLibSchemas(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackLibSchemasRequest(c.Server, pack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackLibSchemasWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackLibSchemasRequestWithBody(c.Server, pack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackLibSchemas(ctx context.Context, pack string, body PostPPackLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackLibSchemasRequest(c.Server, pack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePPackLibSchemasId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePPackLibSchemasIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackLibSchemasId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackLibSchemasIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackLibSchemasIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackLibSchemasIdRequestWithBody(c.Server, pack, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackLibSchemasId(ctx context.Context, pack string, id string, body PatchPPackLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackLibSchemasIdRequest(c.Server, pack, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackLibVars(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackLibVarsRequest(c.Server, pack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackLibVarsWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackLibVarsRequestWithBody(c.Server, pack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackLibVars(ctx context.Context, pack string, body PostPPackLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackLibVarsRequest(c.Server, pack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePPackLibVarsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePPackLibVarsIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackLibVarsId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackLibVarsIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackLibVarsIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackLibVarsIdRequestWithBody(c.Server, pack, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackLibVarsId(ctx context.Context, pack string, id string, body PatchPPackLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackLibVarsIdRequest(c.Server, pack, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackPipelines(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackPipelinesRequest(c.Server, pack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackPipelinesWithBody(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackPipelinesRequestWithBody(c.Server, pack, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackPipelines(ctx context.Context, pack string, body PostPPackPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackPipelinesRequest(c.Server, pack, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePPackPipelinesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePPackPipelinesIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackPipelinesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackPipelinesIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackPipelinesIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackPipelinesIdRequestWithBody(c.Server, pack, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackPipelinesId(ctx context.Context, pack string, id string, body PatchPPackPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackPipelinesIdRequest(c.Server, pack, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackRoutes(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackRoutesRequest(c.Server, pack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPPackRoutesId(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPPackRoutesIdRequest(c.Server, pack, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackRoutesIdWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackRoutesIdRequestWithBody(c.Server, pack, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPPackRoutesId(ctx context.Context, pack string, id string, body PatchPPackRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPPackRoutesIdRequest(c.Server, pack, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackRoutesIdAppendWithBody(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackRoutesIdAppendRequestWithBody(c.Server, pack, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPPackRoutesIdAppend(ctx context.Context, pack string, id string, body PostPPackRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPPackRoutesIdAppendRequest(c.Server, pack, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPacks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPacksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPacksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPacksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPacks(ctx context.Context, body PostPacksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPacksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPacks(ctx context.Context, params *PutPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPacksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPacksCloneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPacksCloneRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPacksClone(ctx context.Context, body PostPacksCloneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPacksCloneRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePacksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePacksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPacksId(ctx context.Context, id string, params *PatchPacksIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPacksIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPacksIdExport(ctx context.Context, id string, params *GetPacksIdExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPacksIdExportRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelines(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelinesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPipelinesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPipelinesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPipelines(ctx context.Context, body PostPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPipelinesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePipelinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePipelinesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelinesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelinesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPipelinesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPipelinesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPipelinesId(ctx context.Context, id string, body PatchPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPipelinesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPreviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPreview(ctx context.Context, body PostPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPreviewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsEdgeMapQuery(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsEdgeMapQueryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsLakeLakesLakeIdDatasets(ctx context.Context, lakeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsLakeLakesLakeIdDatasetsRequest(c.Server, lakeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsLakeLakesLakeIdDatasetsWithBody(ctx context.Context, lakeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsLakeLakesLakeIdDatasetsRequestWithBody(c.Server, lakeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsLakeLakesLakeIdDatasets(ctx context.Context, lakeId string, body PostProductsLakeLakesLakeIdDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsLakeLakesLakeIdDatasetsRequest(c.Server, lakeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsLakeLakesLakeIdDatasetsIdRequest(c.Server, lakeId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsLakeLakesLakeIdDatasetsIdRequest(c.Server, lakeId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProductsLakeLakesLakeIdDatasetsIdWithBody(ctx context.Context, lakeId string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProductsLakeLakesLakeIdDatasetsIdRequestWithBody(c.Server, lakeId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProductsLakeLakesLakeIdDatasetsId(ctx context.Context, lakeId string, id string, body PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProductsLakeLakesLakeIdDatasetsIdRequest(c.Server, lakeId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProductGroups(ctx context.Context, product GetProductsProductGroupsParamsProduct, params *GetProductsProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductGroupsRequest(c.Server, product, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductGroupsWithBody(ctx context.Context, product PostProductsProductGroupsParamsProduct, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductGroupsRequestWithBody(c.Server, product, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductGroups(ctx context.Context, product PostProductsProductGroupsParamsProduct, body PostProductsProductGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductGroupsRequest(c.Server, product, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProductGroupsIdAclTeams(ctx context.Context, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params *GetProductsProductGroupsIdAclTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductGroupsIdAclTeamsRequest(c.Server, product, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProductUsers(ctx context.Context, product GetProductsProductUsersParamsProduct, params *GetProductsProductUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductUsersRequest(c.Server, product, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsProductUsersCache(ctx context.Context, product DeleteProductsProductUsersCacheParamsProduct, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsProductUsersCacheRequest(c.Server, product)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProductUsersIdAcl(ctx context.Context, product GetProductsProductUsersIdAclParamsProduct, id string, params *GetProductsProductUsersIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductUsersIdAclRequest(c.Server, product, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoutesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoutesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRoutesId(ctx context.Context, id string, body PatchRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRoutesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRoutesIdAppendWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRoutesIdAppendRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRoutesIdAppend(ctx context.Context, id string, body PostRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRoutesIdAppendRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboardCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardCategoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardCategoriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardCategories(ctx context.Context, body PostSearchDashboardCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardCategoriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchDashboardCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchDashboardCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboardCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDashboardCategoriesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDashboardCategoriesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDashboardCategoriesId(ctx context.Context, id string, body PatchSearchDashboardCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDashboardCategoriesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboards(ctx context.Context, body PostSearchDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchDashboardsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchDashboardsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboardsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDashboardsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDashboardsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDashboardsId(ctx context.Context, id string, body PatchSearchDashboardsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDashboardsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboardsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardsIdAclRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsIdAclApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardsIdAclApply(ctx context.Context, id string, body PostSearchDashboardsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsIdAclApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDashboardsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDashboardsIdAclTeamsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsIdAclTeamsApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDashboardsIdAclTeamsApply(ctx context.Context, id string, body PostSearchDashboardsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDashboardsIdAclTeamsApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetProviderTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetProviderTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetProviderTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetProviderTypesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetProviderTypes(ctx context.Context, body PostSearchDatasetProviderTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetProviderTypesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchDatasetProviderTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchDatasetProviderTypesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetProviderTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetProviderTypesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetProviderTypesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetProviderTypesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetProviderTypesId(ctx context.Context, id string, body PatchSearchDatasetProviderTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetProviderTypesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetProvidersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetProvidersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetProviders(ctx context.Context, body PostSearchDatasetProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetProvidersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchDatasetProvidersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchDatasetProvidersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetProvidersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetProvidersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetProvidersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetProvidersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetProvidersId(ctx context.Context, id string, body PatchSearchDatasetProvidersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetProvidersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasets(ctx context.Context, body PostSearchDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchDatasetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchDatasetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchDatasetsId(ctx context.Context, id string, body PatchSearchDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchDatasetsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetsIdAclRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsIdAclApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetsIdAclApply(ctx context.Context, id string, body PostSearchDatasetsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsIdAclApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDatasetsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDatasetsIdAclTeamsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsIdAclTeamsApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchDatasetsIdAclTeamsApply(ctx context.Context, id string, body PostSearchDatasetsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchDatasetsIdAclTeamsApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchEventBreakerPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchEventBreakerPreviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchEventBreakerPreview(ctx context.Context, body PostSearchEventBreakerPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchEventBreakerPreviewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchHealthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchJobs(ctx context.Context, body PostSearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchJobsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchJobsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchJobsId(ctx context.Context, id string, body PatchSearchJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchJobsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchJobsIdDispatchExecutors(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchJobsIdDispatchExecutorsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsIdLogs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdLogsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsIdMetrics(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdMetricsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsIdResults(ctx context.Context, id string, params *GetSearchJobsIdResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdResultsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsIdResultsPoll(ctx context.Context, id string, params *GetSearchJobsIdResultsPollParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdResultsPollRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchJobsIdStagesStageIdResults(ctx context.Context, id string, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchJobsIdStagesStageIdResultsRequest(c.Server, id, stageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchMacros(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchMacrosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchMacrosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchMacrosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchMacros(ctx context.Context, body PostSearchMacrosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchMacrosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchMacrosId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchMacrosIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchMacrosId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchMacrosIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchMacrosIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchMacrosIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchMacrosId(ctx context.Context, id string, body PatchSearchMacrosIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchMacrosIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchPreviewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchPreviewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchPreview(ctx context.Context, body PostSearchPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchPreviewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchSaved(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchSavedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchSavedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchSavedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchSaved(ctx context.Context, body PostSearchSavedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchSavedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchSavedId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchSavedIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchSavedId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchSavedIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchSavedIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchSavedIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchSavedId(ctx context.Context, id string, body PatchSearchSavedIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchSavedIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchTrustPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchTrustPoliciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchUsageGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchUsageGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchUsageGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchUsageGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSearchUsageGroups(ctx context.Context, body PostSearchUsageGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSearchUsageGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSearchUsageGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSearchUsageGroupsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchUsageGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchUsageGroupsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchUsageGroupsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchUsageGroupsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSearchUsageGroupsId(ctx context.Context, id string, body PatchSearchUsageGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSearchUsageGroupsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityKmsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityKmsConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSecurityKmsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSecurityKmsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSecurityKmsConfig(ctx context.Context, body PatchSecurityKmsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSecurityKmsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityKmsHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityKmsHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsFeaturesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsFeaturesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsFeaturesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemBanners(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemBannersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemBannersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemBannersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemBanners(ctx context.Context, body PostSystemBannersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemBannersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemBannersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemBannersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemBannersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemBannersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemBannersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemBannersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemBannersId(ctx context.Context, id string, body PatchSystemBannersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemBannersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemCaptureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemCaptureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemCapture(ctx context.Context, body PostSystemCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemCaptureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemCertificatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemCertificatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemCertificates(ctx context.Context, body PostSystemCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemCertificatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemCertificatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemCertificatesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemCertificatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemCertificatesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemCertificatesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemCertificatesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemCertificatesId(ctx context.Context, id string, body PatchSystemCertificatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemCertificatesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemDiag(ctx context.Context, params *DeleteSystemDiagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemDiagRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemDiagDownload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemDiagDownloadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDiagSendWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDiagSendRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDiagSend(ctx context.Context, body PostSystemDiagSendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDiagSendRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDistributedUpgradeCancelGroup(ctx context.Context, group string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDistributedUpgradeCancelGroupRequest(c.Server, group)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemDistributedUpgradeDownloadFile(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemDistributedUpgradeDownloadFileRequest(c.Server, file)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDistributedUpgradeStageGroup(ctx context.Context, group string, params *PostSystemDistributedUpgradeStageGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDistributedUpgradeStageGroupRequest(c.Server, group, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDistributedUpgradeGroupWithBody(ctx context.Context, group string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDistributedUpgradeGroupRequestWithBody(c.Server, group, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemDistributedUpgradeGroup(ctx context.Context, group string, body PostSystemDistributedUpgradeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemDistributedUpgradeGroupRequest(c.Server, group, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemInputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemInputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemInputs(ctx context.Context, body PostSystemInputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemInputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemInputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemInputsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemInputsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemInputsId(ctx context.Context, id string, body PatchSystemInputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemInputsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemInputsIdHectokenWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemInputsIdHectokenRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemInputsIdHectoken(ctx context.Context, id string, body PostSystemInputsIdHectokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemInputsIdHectokenRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemInputsIdHectokenTokenWithBody(ctx context.Context, id string, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemInputsIdHectokenTokenRequestWithBody(c.Server, id, token, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemInputsIdHectokenToken(ctx context.Context, id string, token string, body PatchSystemInputsIdHectokenTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemInputsIdHectokenTokenRequest(c.Server, id, token, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemJobsLogsIdGroupId(ctx context.Context, id string, groupId string, params *GetSystemJobsLogsIdGroupIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemJobsLogsIdGroupIdRequest(c.Server, id, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemKeys(ctx context.Context, body PostSystemKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemKeysIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemKeysIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemKeysIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemKeysIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemKeysId(ctx context.Context, id string, body PatchSystemKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemKeysIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemLicensesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemLicensesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemLicenses(ctx context.Context, body PostSystemLicensesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemLicensesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLicensesUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLicensesUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemLicensesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemLicensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLicensesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLicensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLogger(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLoggerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemLoggerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemLoggerIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLoggerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLoggerIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemLoggerIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemLoggerIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemLoggerId(ctx context.Context, id string, body PatchSystemLoggerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemLoggerIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLogsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLogsSearch(ctx context.Context, params *GetSystemLogsSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLogsSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLogsId(ctx context.Context, id string, params *GetSystemLogsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLogsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLookups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLookupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemLookupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemLookupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemLookups(ctx context.Context, body PostSystemLookupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemLookupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSystemLookupsWithBody(ctx context.Context, params *PutSystemLookupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSystemLookupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemLookupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemLookupsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemLookupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemLookupsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemLookupsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemLookupsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemLookupsId(ctx context.Context, id string, body PatchSystemLookupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemLookupsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemMessages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemMessagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMessagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMessages(ctx context.Context, body PostSystemMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMessagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemMessagesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemMessagesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemMessagesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemMessagesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemMetrics(ctx context.Context, params *GetSystemMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMetricsEnumWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMetricsEnumRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMetricsEnum(ctx context.Context, body PostSystemMetricsEnumJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMetricsEnumRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMetricsQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMetricsQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemMetricsQuery(ctx context.Context, body PostSystemMetricsQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemMetricsQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemOutputs(ctx context.Context, body PostSystemOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemOutputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemOutputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemOutputsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemOutputsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemOutputsId(ctx context.Context, id string, body PatchSystemOutputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemOutputsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemOutputsIdPq(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemOutputsIdPqRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemOutputsIdPq(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemOutputsIdPqRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemOutputsIdSamples(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemOutputsIdSamplesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemOutputsIdTestWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemOutputsIdTestRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemOutputsIdTest(ctx context.Context, id string, body PostSystemOutputsIdTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemOutputsIdTestRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemPolicies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemPoliciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemPoliciesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemPolicies(ctx context.Context, body PostSystemPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemPoliciesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemPoliciesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemPoliciesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemPoliciesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemPoliciesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemPoliciesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemPoliciesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemPoliciesId(ctx context.Context, id string, body PatchSystemPoliciesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemPoliciesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProcesses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProcessesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProfiler(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProfilerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProfilerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProfilerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProfiler(ctx context.Context, body PostSystemProfilerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProfilerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemProfilerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemProfilerIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProfilerId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProfilerIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemProfilerIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemProfilerIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemProfilerId(ctx context.Context, id string, body PatchSystemProfilerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemProfilerIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjects(ctx context.Context, body PostSystemProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemProjectsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemProjectsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemProjectsId(ctx context.Context, id string, body PatchSystemProjectsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemProjectsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsIdAcl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsIdAclRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsIdAclApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsIdAclApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsIdAclApply(ctx context.Context, id string, body PostSystemProjectsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsIdAclApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsIdAclTeams(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsIdAclTeamsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsIdAclTeamsApplyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsIdAclTeamsApplyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsIdAclTeamsApply(ctx context.Context, id string, body PostSystemProjectsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsIdAclTeamsApplyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdCaptureWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdCaptureRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdCapture(ctx context.Context, projectId string, body PostSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdCaptureRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdDestinations(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdDestinationsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdSubscriptions(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdSubscriptionsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx context.Context, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(c.Server, projectId, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx context.Context, projectId string, subscriptionId string, body PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest(c.Server, projectId, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdVersionCommitWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdVersionCommitRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdVersionCommit(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdVersionCommitRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdVersionCount(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdVersionCountRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdVersionDiff(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdVersionDiffRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdVersionFiles(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdVersionFilesRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdVersionRevertWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdVersionRevertRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemProjectsProjectIdVersionRevert(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemProjectsProjectIdVersionRevertRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemProjectsProjectIdVersionShow(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemProjectsProjectIdVersionShowRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemRolesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemRolesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemRoles(ctx context.Context, body PostSystemRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemRolesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemRolesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemRolesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemRolesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemRolesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemRolesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemRolesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemRolesId(ctx context.Context, id string, body PatchSystemRolesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemRolesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSamples(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSamplesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSamplesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSamplesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSamples(ctx context.Context, body PostSystemSamplesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSamplesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemSamplesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemSamplesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSamplesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSamplesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSamplesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSamplesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSamplesId(ctx context.Context, id string, body PatchSystemSamplesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSamplesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSamplesIdContent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSamplesIdContentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemScripts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemScriptsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemScriptsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemScriptsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemScripts(ctx context.Context, body PostSystemScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemScriptsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemScriptsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemScriptsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemScriptsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemScriptsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemScriptsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemScriptsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemScriptsId(ctx context.Context, id string, body PatchSystemScriptsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemScriptsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSecretsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSecretsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSecretsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSecrets(ctx context.Context, body PostSystemSecretsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSecretsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemSecretsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemSecretsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSecretsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSecretsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSecretsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSecretsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSecretsId(ctx context.Context, id string, body PatchSystemSecretsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSecretsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSettingsAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSettingsAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsConf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsConfRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSettingsConfWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSettingsConfRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSettingsConf(ctx context.Context, body PatchSystemSettingsConfJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSettingsConfRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsCribl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsCriblRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsGitSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSettingsGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSettingsGitSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSettingsReload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSettingsReloadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSettingsRestart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSettingsRestartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsSearchLimits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsSearchLimitsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSettingsUpgrade(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSettingsUpgradeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSettingsUpgradeFromPackageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSettingsUpgradeFromPackageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSettingsUpgradeFromPackage(ctx context.Context, body PostSystemSettingsUpgradeFromPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSettingsUpgradeFromPackageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSettingsUpgradeVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSettingsUpgradeVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatusInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusInputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatusInputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusInputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatusOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatusOutputsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusOutputsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSubscriptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemSubscriptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemSubscriptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemSubscriptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemSubscriptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemTeams(ctx context.Context, params *GetSystemTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemTeamsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemTeamsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemTeams(ctx context.Context, body PostSystemTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemTeamsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemTeamsUsersIdRoles(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemTeamsUsersIdRolesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemTeamsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemTeamsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemTeamsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemTeamsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemTeamsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemTeamsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemTeamsId(ctx context.Context, id string, body PatchSystemTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemTeamsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemTeamsIdAcl(ctx context.Context, id string, params *GetSystemTeamsIdAclParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemTeamsIdAclRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemTeamsIdUsers(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemTeamsIdUsersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemTeamsIdUsersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemTeamsIdUsersRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemTeamsIdUsers(ctx context.Context, id string, body PostSystemTeamsIdUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemTeamsIdUsersRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSystemUsers(ctx context.Context, body PostSystemUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSystemUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSystemUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSystemUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemUsersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemUsersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemUsersId(ctx context.Context, id string, body PatchSystemUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemUsersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemUsersIdInfoWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemUsersIdInfoRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSystemUsersIdInfo(ctx context.Context, id string, body PatchSystemUsersIdInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSystemUsersIdInfoRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUiKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUiKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUiKeyWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUiKeyRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUiKey(ctx context.Context, key string, body PatchUiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUiKeyRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionBranchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionCommitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionCommitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionCommit(ctx context.Context, body PostVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionCommitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionCount(ctx context.Context, params *GetVersionCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionCurrentBranch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionCurrentBranchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionDiff(ctx context.Context, params *GetVersionDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionDiffRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionFiles(ctx context.Context, params *GetVersionFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionPush(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionPushRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionRevertWithBody(ctx context.Context, params *PostVersionRevertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionRevertRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionRevert(ctx context.Context, params *PostVersionRevertParams, body PostVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionRevertRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionShow(ctx context.Context, params *GetVersionShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionShowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersionStatus(ctx context.Context, params *GetVersionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionSync(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionSyncRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVersionUndo(ctx context.Context, params *PostVersionUndoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVersionUndoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAiConsentRequest generates requests for GetAiConsent
func NewGetAiConsentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ai/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAiConsentRequest generates requests for PostAiConsent
func NewPostAiConsentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ai/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthAuthorizationCodeCallbackRequest generates requests for GetAuthAuthorizationCodeCallback
func NewGetAuthAuthorizationCodeCallbackRequest(server string, params *GetAuthAuthorizationCodeCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/authorization-code/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthGroupsRequest generates requests for GetAuthGroups
func NewGetAuthGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthLoginRequest calls the generic PostAuthLogin builder with application/json body
func NewPostAuthLoginRequest(server string, body PostAuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthLoginRequestWithBody generates requests for PostAuthLogin with any type of body
func NewPostAuthLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAuthLogoutRequest generates requests for PostAuthLogout
func NewPostAuthLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthMetadataRequest generates requests for GetAuthMetadata
func NewGetAuthMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthMultiFactorRequest generates requests for GetAuthMultiFactor
func NewGetAuthMultiFactorRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/multi-factor")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthSloRequest generates requests for GetAuthSlo
func NewGetAuthSloRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/slo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthSloCallbackRequest generates requests for GetAuthSloCallback
func NewGetAuthSloCallbackRequest(server string, params *GetAuthSloCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/slo/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SAMLResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SAMLResponse", runtime.ParamLocationQuery, *params.SAMLResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelayState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "RelayState", runtime.ParamLocationQuery, *params.RelayState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthSloCallbackRequestWithFormdataBody calls the generic PostAuthSloCallback builder with application/x-www-form-urlencoded body
func NewPostAuthSloCallbackRequestWithFormdataBody(server string, body PostAuthSloCallbackFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostAuthSloCallbackRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostAuthSloCallbackRequestWithBody generates requests for PostAuthSloCallback with any type of body
func NewPostAuthSloCallbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/slo/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuthSsoRequest generates requests for GetAuthSso
func NewGetAuthSsoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthSsoCallbackRequest generates requests for GetAuthSsoCallback
func NewGetAuthSsoCallbackRequest(server string, params *GetAuthSsoCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sso/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SAMLResponse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SAMLResponse", runtime.ParamLocationQuery, *params.SAMLResponse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelayState != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "RelayState", runtime.ParamLocationQuery, *params.RelayState); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthSsoCallbackRequestWithFormdataBody calls the generic PostAuthSsoCallback builder with application/x-www-form-urlencoded body
func NewPostAuthSsoCallbackRequestWithFormdataBody(server string, body PostAuthSsoCallbackFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostAuthSsoCallbackRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostAuthSsoCallbackRequestWithBody generates requests for PostAuthSsoCallback with any type of body
func NewPostAuthSsoCallbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sso/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthUsersIdTokenRequest generates requests for DeleteAuthUsersIdToken
func NewDeleteAuthUsersIdTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizePolicyRequest generates requests for GetAuthorizePolicy
func NewGetAuthorizePolicyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/policy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorizeRolesRequest generates requests for GetAuthorizeRoles
func NewGetAuthorizeRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChangelogViewedRequest generates requests for GetChangelogViewed
func NewGetChangelogViewedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/changelog/viewed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchChangelogViewedRequest generates requests for PatchChangelogViewed
func NewPatchChangelogViewedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/changelog/viewed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCluiRequest generates requests for GetClui
func NewGetCluiRequest(server string, params *GetCluiParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clui")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectorsRequest generates requests for GetCollectors
func NewGetCollectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectorsIdRequest generates requests for GetCollectorsId
func NewGetCollectorsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConditionsRequest generates requests for GetConditions
func NewGetConditionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conditions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConditionsIdRequest generates requests for GetConditionsId
func NewGetConditionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conditions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeAppscopeProcessesRequest generates requests for GetEdgeAppscopeProcesses
func NewGetEdgeAppscopeProcessesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/appscope/processes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEdgeAppscopeProcessesRequest generates requests for PostEdgeAppscopeProcesses
func NewPostEdgeAppscopeProcessesRequest(server string, params *PostEdgeAppscopeProcessesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/appscope/processes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pid", runtime.ParamLocationQuery, params.Pid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEdgeAppscopeProcessesPidRequest generates requests for DeleteEdgeAppscopeProcessesPid
func NewDeleteEdgeAppscopeProcessesPidRequest(server string, pid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pid", runtime.ParamLocationPath, pid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/appscope/processes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeAppscopeProcessesPidRequest generates requests for GetEdgeAppscopeProcessesPid
func NewGetEdgeAppscopeProcessesPidRequest(server string, pid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pid", runtime.ParamLocationPath, pid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/appscope/processes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutEdgeAppscopeProcessesPidRequest generates requests for PutEdgeAppscopeProcessesPid
func NewPutEdgeAppscopeProcessesPidRequest(server string, pid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pid", runtime.ParamLocationPath, pid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/appscope/processes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeContainersRequest generates requests for GetEdgeContainers
func NewGetEdgeContainersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/containers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeContainersIdRequest generates requests for GetEdgeContainersId
func NewGetEdgeContainersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeEventsCollectorsRequest generates requests for GetEdgeEventsCollectors
func NewGetEdgeEventsCollectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/events/collectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeEventsQueryRequest generates requests for GetEdgeEventsQuery
func NewGetEdgeEventsQueryRequest(server string, params *GetEdgeEventsQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/events/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Files", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Et != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "et", runtime.ParamLocationQuery, *params.Et); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lt", runtime.ParamLocationQuery, *params.Lt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEdgeFileIngestRequest generates requests for PostEdgeFileIngest
func NewPostEdgeFileIngestRequest(server string, params *PostEdgeFileIngestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/file/ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filePath", runtime.ParamLocationQuery, *params.FilePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipelineId", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutputId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputId", runtime.ParamLocationQuery, *params.OutputId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreProcessingPipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preProcessingPipelineId", runtime.ParamLocationQuery, *params.PreProcessingPipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SendToRoutes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sendToRoutes", runtime.ParamLocationQuery, *params.SendToRoutes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakerRuleSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakerRuleSet", runtime.ParamLocationQuery, *params.BreakerRuleSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeFileSampleRequest generates requests for GetEdgeFileSample
func NewGetEdgeFileSampleRequest(server string, params *GetEdgeFileSampleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/file/sample")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.BytesRequested != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bytesRequested", runtime.ParamLocationQuery, *params.BytesRequested); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeFileinspectRequest generates requests for GetEdgeFileinspect
func NewGetEdgeFileinspectRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/fileinspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEdgeKubeLogsRequest generates requests for PostEdgeKubeLogs
func NewPostEdgeKubeLogsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/kube-logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeKubeProxyRequest generates requests for GetEdgeKubeProxy
func NewGetEdgeKubeProxyRequest(server string, params *GetEdgeKubeProxyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/kube_proxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeLogsRequest generates requests for GetEdgeLogs
func NewGetEdgeLogsRequest(server string, params *GetEdgeLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Allow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow", runtime.ParamLocationQuery, *params.Allow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeLsPathRequest generates requests for GetEdgeLsPath
func NewGetEdgeLsPathRequest(server string, path string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/ls%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeMetadataRequest generates requests for GetEdgeMetadata
func NewGetEdgeMetadataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeProcessesRequest generates requests for GetEdgeProcesses
func NewGetEdgeProcessesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/processes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEdgeProcessesPidRequest generates requests for GetEdgeProcessesPid
func NewGetEdgeProcessesPidRequest(server string, pid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pid", runtime.ParamLocationPath, pid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/edge/processes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExecutorsRequest generates requests for GetExecutors
func NewGetExecutorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/executors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExecutorsIdRequest generates requests for GetExecutorsId
func NewGetExecutorsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/executors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionsRequest generates requests for GetFunctions
func NewGetFunctionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionsIdRequest generates requests for GetFunctionsId
func NewGetFunctionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsRequest generates requests for GetJobs
func NewGetJobsRequest(server string, params *GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runType", runtime.ParamLocationQuery, *params.RunType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectorId", runtime.ParamLocationQuery, *params.CollectorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupId", runtime.ParamLocationQuery, *params.GroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostJobsRequest calls the generic PostJobs builder with application/json body
func NewPostJobsRequest(server string, body PostJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostJobsRequestWithBody generates requests for PostJobs with any type of body
func NewPostJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobsIdRequest generates requests for DeleteJobsId
func NewDeleteJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsIdRequest generates requests for GetJobsId
func NewGetJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchJobsIdCancelRequest generates requests for PatchJobsIdCancel
func NewPatchJobsIdCancelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsIdErrorsRequest generates requests for GetJobsIdErrors
func NewGetJobsIdErrorsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/errors/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsIdErrorsGroupRequest generates requests for GetJobsIdErrorsGroup
func NewGetJobsIdErrorsGroupRequest(server string, id string, group string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/errors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchJobsIdKeepRequest generates requests for PatchJobsIdKeep
func NewPatchJobsIdKeepRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/keep", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchJobsIdPauseRequest generates requests for PatchJobsIdPause
func NewPatchJobsIdPauseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsIdResultsRequest generates requests for GetJobsIdResults
func NewGetJobsIdResultsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/results/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobsIdResultsGroupRequest generates requests for GetJobsIdResultsGroup
func NewGetJobsIdResultsGroupRequest(server string, id string, group string, params *GetJobsIdResultsGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/results/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxFiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFiles", runtime.ParamLocationQuery, *params.MaxFiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchJobsIdResumeRequest generates requests for PatchJobsIdResume
func NewPatchJobsIdResumeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibAppscopeConfigsRequest generates requests for GetLibAppscopeConfigs
func NewGetLibAppscopeConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/appscope-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibAppscopeConfigsRequest calls the generic PostLibAppscopeConfigs builder with application/json body
func NewPostLibAppscopeConfigsRequest(server string, body PostLibAppscopeConfigsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibAppscopeConfigsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibAppscopeConfigsRequestWithBody generates requests for PostLibAppscopeConfigs with any type of body
func NewPostLibAppscopeConfigsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/appscope-configs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibAppscopeConfigsIdRequest generates requests for DeleteLibAppscopeConfigsId
func NewDeleteLibAppscopeConfigsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/appscope-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibAppscopeConfigsIdRequest generates requests for GetLibAppscopeConfigsId
func NewGetLibAppscopeConfigsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/appscope-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibAppscopeConfigsIdRequest calls the generic PatchLibAppscopeConfigsId builder with application/json body
func NewPatchLibAppscopeConfigsIdRequest(server string, id string, body PatchLibAppscopeConfigsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibAppscopeConfigsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibAppscopeConfigsIdRequestWithBody generates requests for PatchLibAppscopeConfigsId with any type of body
func NewPatchLibAppscopeConfigsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/appscope-configs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibBreakersRequest generates requests for GetLibBreakers
func NewGetLibBreakersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/breakers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibBreakersRequest calls the generic PostLibBreakers builder with application/json body
func NewPostLibBreakersRequest(server string, body PostLibBreakersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibBreakersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibBreakersRequestWithBody generates requests for PostLibBreakers with any type of body
func NewPostLibBreakersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/breakers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibBreakersIdRequest generates requests for DeleteLibBreakersId
func NewDeleteLibBreakersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/breakers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibBreakersIdRequest generates requests for GetLibBreakersId
func NewGetLibBreakersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/breakers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibBreakersIdRequest calls the generic PatchLibBreakersId builder with application/json body
func NewPatchLibBreakersIdRequest(server string, id string, body PatchLibBreakersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibBreakersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibBreakersIdRequestWithBody generates requests for PatchLibBreakersId with any type of body
func NewPatchLibBreakersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/breakers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibDatabaseConnectionsRequest generates requests for GetLibDatabaseConnections
func NewGetLibDatabaseConnectionsRequest(server string, params *GetLibDatabaseConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatabaseType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "databaseType", runtime.ParamLocationQuery, *params.DatabaseType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibDatabaseConnectionsRequest calls the generic PostLibDatabaseConnections builder with application/json body
func NewPostLibDatabaseConnectionsRequest(server string, body PostLibDatabaseConnectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibDatabaseConnectionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibDatabaseConnectionsRequestWithBody generates requests for PostLibDatabaseConnections with any type of body
func NewPostLibDatabaseConnectionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostLibDatabaseConnectionsTestRequest calls the generic PostLibDatabaseConnectionsTest builder with application/json body
func NewPostLibDatabaseConnectionsTestRequest(server string, body PostLibDatabaseConnectionsTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibDatabaseConnectionsTestRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibDatabaseConnectionsTestRequestWithBody generates requests for PostLibDatabaseConnectionsTest with any type of body
func NewPostLibDatabaseConnectionsTestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibDatabaseConnectionsIdRequest generates requests for DeleteLibDatabaseConnectionsId
func NewDeleteLibDatabaseConnectionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibDatabaseConnectionsIdRequest generates requests for GetLibDatabaseConnectionsId
func NewGetLibDatabaseConnectionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibDatabaseConnectionsIdRequest calls the generic PatchLibDatabaseConnectionsId builder with application/json body
func NewPatchLibDatabaseConnectionsIdRequest(server string, id string, body PatchLibDatabaseConnectionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibDatabaseConnectionsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibDatabaseConnectionsIdRequestWithBody generates requests for PatchLibDatabaseConnectionsId with any type of body
func NewPatchLibDatabaseConnectionsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/database-connections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostLibExpressionRequest generates requests for PostLibExpression
func NewPostLibExpressionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/expression")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibGrokRequest generates requests for GetLibGrok
func NewGetLibGrokRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/grok")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibGrokRequest calls the generic PostLibGrok builder with application/json body
func NewPostLibGrokRequest(server string, body PostLibGrokJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibGrokRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibGrokRequestWithBody generates requests for PostLibGrok with any type of body
func NewPostLibGrokRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/grok")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibGrokIdRequest generates requests for DeleteLibGrokId
func NewDeleteLibGrokIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/grok/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibGrokIdRequest generates requests for GetLibGrokId
func NewGetLibGrokIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/grok/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibGrokIdRequest calls the generic PatchLibGrokId builder with application/json body
func NewPatchLibGrokIdRequest(server string, id string, body PatchLibGrokIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibGrokIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibGrokIdRequestWithBody generates requests for PatchLibGrokId with any type of body
func NewPatchLibGrokIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/grok/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibHmacFunctionsRequest generates requests for GetLibHmacFunctions
func NewGetLibHmacFunctionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/hmac-functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibHmacFunctionsRequest calls the generic PostLibHmacFunctions builder with application/json body
func NewPostLibHmacFunctionsRequest(server string, body PostLibHmacFunctionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibHmacFunctionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibHmacFunctionsRequestWithBody generates requests for PostLibHmacFunctions with any type of body
func NewPostLibHmacFunctionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/hmac-functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibHmacFunctionsIdRequest generates requests for DeleteLibHmacFunctionsId
func NewDeleteLibHmacFunctionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/hmac-functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibHmacFunctionsIdRequest generates requests for GetLibHmacFunctionsId
func NewGetLibHmacFunctionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/hmac-functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibHmacFunctionsIdRequest calls the generic PatchLibHmacFunctionsId builder with application/json body
func NewPatchLibHmacFunctionsIdRequest(server string, id string, body PatchLibHmacFunctionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibHmacFunctionsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibHmacFunctionsIdRequestWithBody generates requests for PatchLibHmacFunctionsId with any type of body
func NewPatchLibHmacFunctionsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/hmac-functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibJobsRequest generates requests for GetLibJobs
func NewGetLibJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibJobsRequest calls the generic PostLibJobs builder with application/json body
func NewPostLibJobsRequest(server string, body PostLibJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibJobsRequestWithBody generates requests for PostLibJobs with any type of body
func NewPostLibJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibJobsIdRequest generates requests for DeleteLibJobsId
func NewDeleteLibJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibJobsIdRequest generates requests for GetLibJobsId
func NewGetLibJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibJobsIdRequest calls the generic PatchLibJobsId builder with application/json body
func NewPatchLibJobsIdRequest(server string, id string, body PatchLibJobsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibJobsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibJobsIdRequestWithBody generates requests for PatchLibJobsId with any type of body
func NewPatchLibJobsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibParquetSchemasRequest generates requests for GetLibParquetSchemas
func NewGetLibParquetSchemasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parquet-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibParquetSchemasRequest calls the generic PostLibParquetSchemas builder with application/json body
func NewPostLibParquetSchemasRequest(server string, body PostLibParquetSchemasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibParquetSchemasRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibParquetSchemasRequestWithBody generates requests for PostLibParquetSchemas with any type of body
func NewPostLibParquetSchemasRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parquet-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibParquetSchemasIdRequest generates requests for DeleteLibParquetSchemasId
func NewDeleteLibParquetSchemasIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parquet-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibParquetSchemasIdRequest generates requests for GetLibParquetSchemasId
func NewGetLibParquetSchemasIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parquet-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibParquetSchemasIdRequest calls the generic PatchLibParquetSchemasId builder with application/json body
func NewPatchLibParquetSchemasIdRequest(server string, id string, body PatchLibParquetSchemasIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibParquetSchemasIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibParquetSchemasIdRequestWithBody generates requests for PatchLibParquetSchemasId with any type of body
func NewPatchLibParquetSchemasIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parquet-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibParsersRequest generates requests for GetLibParsers
func NewGetLibParsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parsers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibParsersRequest calls the generic PostLibParsers builder with application/json body
func NewPostLibParsersRequest(server string, body PostLibParsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibParsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibParsersRequestWithBody generates requests for PostLibParsers with any type of body
func NewPostLibParsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parsers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibParsersIdRequest generates requests for DeleteLibParsersId
func NewDeleteLibParsersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parsers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibParsersIdRequest generates requests for GetLibParsersId
func NewGetLibParsersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parsers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibParsersIdRequest calls the generic PatchLibParsersId builder with application/json body
func NewPatchLibParsersIdRequest(server string, id string, body PatchLibParsersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibParsersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibParsersIdRequestWithBody generates requests for PatchLibParsersId with any type of body
func NewPatchLibParsersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/parsers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibProtobufLibrariesRequest generates requests for GetLibProtobufLibraries
func NewGetLibProtobufLibrariesRequest(server string, params *GetLibProtobufLibrariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/protobuf-libraries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "onlyWithEncodings", runtime.ParamLocationQuery, params.OnlyWithEncodings); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibProtobufLibrariesIdRequest generates requests for GetLibProtobufLibrariesId
func NewGetLibProtobufLibrariesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/protobuf-libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibProtobufLibrariesIdEncodingsRequest generates requests for GetLibProtobufLibrariesIdEncodings
func NewGetLibProtobufLibrariesIdEncodingsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/protobuf-libraries/%s/encodings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibProtobufLibrariesIdEncodingsEncidRequest generates requests for GetLibProtobufLibrariesIdEncodingsEncid
func NewGetLibProtobufLibrariesIdEncodingsEncidRequest(server string, id string, encid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "encid", runtime.ParamLocationPath, encid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/protobuf-libraries/%s/encodings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibRegexRequest generates requests for GetLibRegex
func NewGetLibRegexRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/regex")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibRegexRequest calls the generic PostLibRegex builder with application/json body
func NewPostLibRegexRequest(server string, body PostLibRegexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibRegexRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibRegexRequestWithBody generates requests for PostLibRegex with any type of body
func NewPostLibRegexRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/regex")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibRegexIdRequest generates requests for DeleteLibRegexId
func NewDeleteLibRegexIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/regex/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibRegexIdRequest generates requests for GetLibRegexId
func NewGetLibRegexIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/regex/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibRegexIdRequest calls the generic PatchLibRegexId builder with application/json body
func NewPatchLibRegexIdRequest(server string, id string, body PatchLibRegexIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibRegexIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibRegexIdRequestWithBody generates requests for PatchLibRegexId with any type of body
func NewPatchLibRegexIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/regex/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibSchemasRequest generates requests for GetLibSchemas
func NewGetLibSchemasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibSchemasRequest calls the generic PostLibSchemas builder with application/json body
func NewPostLibSchemasRequest(server string, body PostLibSchemasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibSchemasRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibSchemasRequestWithBody generates requests for PostLibSchemas with any type of body
func NewPostLibSchemasRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibSchemasIdRequest generates requests for DeleteLibSchemasId
func NewDeleteLibSchemasIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibSchemasIdRequest generates requests for GetLibSchemasId
func NewGetLibSchemasIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibSchemasIdRequest calls the generic PatchLibSchemasId builder with application/json body
func NewPatchLibSchemasIdRequest(server string, id string, body PatchLibSchemasIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibSchemasIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibSchemasIdRequestWithBody generates requests for PatchLibSchemasId with any type of body
func NewPatchLibSchemasIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibVarsRequest generates requests for GetLibVars
func NewGetLibVarsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/vars")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLibVarsRequest calls the generic PostLibVars builder with application/json body
func NewPostLibVarsRequest(server string, body PostLibVarsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLibVarsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostLibVarsRequestWithBody generates requests for PostLibVars with any type of body
func NewPostLibVarsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/vars")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLibVarsIdRequest generates requests for DeleteLibVarsId
func NewDeleteLibVarsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/vars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLibVarsIdRequest generates requests for GetLibVarsId
func NewGetLibVarsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/vars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLibVarsIdRequest calls the generic PatchLibVarsId builder with application/json body
func NewPatchLibVarsIdRequest(server string, id string, body PatchLibVarsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLibVarsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLibVarsIdRequestWithBody generates requests for PatchLibVarsId with any type of body
func NewPatchLibVarsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lib/vars/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMGroupIdSystemProjectsProjectIdCaptureRequest calls the generic PostMGroupIdSystemProjectsProjectIdCapture builder with application/json body
func NewPostMGroupIdSystemProjectsProjectIdCaptureRequest(server string, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMGroupIdSystemProjectsProjectIdCaptureRequestWithBody(server, groupId, projectId, "application/json", bodyReader)
}

// NewPostMGroupIdSystemProjectsProjectIdCaptureRequestWithBody generates requests for PostMGroupIdSystemProjectsProjectIdCapture with any type of body
func NewPostMGroupIdSystemProjectsProjectIdCaptureRequestWithBody(server string, groupId string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/capture", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdPipelinesRequest generates requests for GetMGroupIdSystemProjectsProjectIdPipelines
func NewGetMGroupIdSystemProjectsProjectIdPipelinesRequest(server string, groupId string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/pipelines", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMGroupIdSystemProjectsProjectIdPipelinesRequest calls the generic PostMGroupIdSystemProjectsProjectIdPipelines builder with application/json body
func NewPostMGroupIdSystemProjectsProjectIdPipelinesRequest(server string, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMGroupIdSystemProjectsProjectIdPipelinesRequestWithBody(server, groupId, projectId, "application/json", bodyReader)
}

// NewPostMGroupIdSystemProjectsProjectIdPipelinesRequestWithBody generates requests for PostMGroupIdSystemProjectsProjectIdPipelines with any type of body
func NewPostMGroupIdSystemProjectsProjectIdPipelinesRequestWithBody(server string, groupId string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/pipelines", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest generates requests for DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId
func NewDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(server string, groupId string, projectId string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/pipelines/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest generates requests for GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId
func NewGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(server string, groupId string, projectId string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/pipelines/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest calls the generic PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId builder with application/json body
func NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequest(server string, groupId string, projectId string, pipelineId string, body PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequestWithBody(server, groupId, projectId, pipelineId, "application/json", bodyReader)
}

// NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequestWithBody generates requests for PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId with any type of body
func NewPatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdRequestWithBody(server string, groupId string, projectId string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/pipelines/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMGroupIdSystemProjectsProjectIdPreviewRequest calls the generic PostMGroupIdSystemProjectsProjectIdPreview builder with application/json body
func NewPostMGroupIdSystemProjectsProjectIdPreviewRequest(server string, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMGroupIdSystemProjectsProjectIdPreviewRequestWithBody(server, groupId, projectId, "application/json", bodyReader)
}

// NewPostMGroupIdSystemProjectsProjectIdPreviewRequestWithBody generates requests for PostMGroupIdSystemProjectsProjectIdPreview with any type of body
func NewPostMGroupIdSystemProjectsProjectIdPreviewRequestWithBody(server string, groupId string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/preview", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdSubscriptionsRequest generates requests for GetMGroupIdSystemProjectsProjectIdSubscriptions
func NewGetMGroupIdSystemProjectsProjectIdSubscriptionsRequest(server string, groupId string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/subscriptions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest calls the generic PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture builder with application/json body
func NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest(server string, groupId string, projectId string, subscriptionId string, body PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(server, groupId, projectId, subscriptionId, "application/json", bodyReader)
}

// NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody generates requests for PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture with any type of body
func NewPostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(server string, groupId string, projectId string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/subscriptions/%s/capture", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequest calls the generic PostMGroupIdSystemProjectsProjectIdVersionCommit builder with application/json body
func NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequest(server string, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequestWithBody(server, groupId, projectId, "application/json", bodyReader)
}

// NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequestWithBody generates requests for PostMGroupIdSystemProjectsProjectIdVersionCommit with any type of body
func NewPostMGroupIdSystemProjectsProjectIdVersionCommitRequestWithBody(server string, groupId string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/version/commit", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdVersionCountRequest generates requests for GetMGroupIdSystemProjectsProjectIdVersionCount
func NewGetMGroupIdSystemProjectsProjectIdVersionCountRequest(server string, groupId string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/version/count", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdVersionDiffRequest generates requests for GetMGroupIdSystemProjectsProjectIdVersionDiff
func NewGetMGroupIdSystemProjectsProjectIdVersionDiffRequest(server string, groupId string, projectId string, params *GetMGroupIdSystemProjectsProjectIdVersionDiffParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/version/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Commit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMGroupIdSystemProjectsProjectIdVersionFilesRequest generates requests for GetMGroupIdSystemProjectsProjectIdVersionFiles
func NewGetMGroupIdSystemProjectsProjectIdVersionFilesRequest(server string, groupId string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/m/%s/system/projects/%s/version/files", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterBundlesGroupVersionRequest generates requests for GetMasterBundlesGroupVersion
func NewGetMasterBundlesGroupVersionRequest(server string, group string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/bundles/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterGroupsIdRequest generates requests for GetMasterGroupsId
func NewGetMasterGroupsIdRequest(server string, id string, params *GetMasterGroupsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterGroupsIdAclRequest generates requests for GetMasterGroupsIdAcl
func NewGetMasterGroupsIdAclRequest(server string, id string, params *GetMasterGroupsIdAclParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterGroupsIdConfigVersionRequest generates requests for GetMasterGroupsIdConfigVersion
func NewGetMasterGroupsIdConfigVersionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/groups/%s/configVersion", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchMasterGroupsIdDeployRequest calls the generic PatchMasterGroupsIdDeploy builder with application/json body
func NewPatchMasterGroupsIdDeployRequest(server string, id string, body PatchMasterGroupsIdDeployJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchMasterGroupsIdDeployRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchMasterGroupsIdDeployRequestWithBody generates requests for PatchMasterGroupsIdDeploy with any type of body
func NewPatchMasterGroupsIdDeployRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/groups/%s/deploy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMasterSummaryRequest generates requests for GetMasterSummary
func NewGetMasterSummaryRequest(server string, params *GetMasterSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterSummaryWorkersRequest generates requests for GetMasterSummaryWorkers
func NewGetMasterSummaryWorkersRequest(server string, params *GetMasterSummaryWorkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/summary/workers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterExp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterExp", runtime.ParamLocationQuery, *params.FilterExp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterWorkersRequest generates requests for GetMasterWorkers
func NewGetMasterWorkersRequest(server string, params *GetMasterWorkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/workers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterExp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterExp", runtime.ParamLocationQuery, *params.FilterExp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortExp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortExp", runtime.ParamLocationQuery, *params.SortExp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchMasterWorkersRestartRequest generates requests for PatchMasterWorkersRestart
func NewPatchMasterWorkersRestartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/master/workers/restart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationTargetsRequest generates requests for GetNotificationTargets
func NewGetNotificationTargetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notification-targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNotificationTargetsRequest calls the generic PostNotificationTargets builder with application/json body
func NewPostNotificationTargetsRequest(server string, body PostNotificationTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNotificationTargetsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNotificationTargetsRequestWithBody generates requests for PostNotificationTargets with any type of body
func NewPostNotificationTargetsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notification-targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationTargetsIdRequest generates requests for DeleteNotificationTargetsId
func NewDeleteNotificationTargetsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notification-targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationTargetsIdRequest generates requests for GetNotificationTargetsId
func NewGetNotificationTargetsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notification-targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchNotificationTargetsIdRequest calls the generic PatchNotificationTargetsId builder with application/json body
func NewPatchNotificationTargetsIdRequest(server string, id string, body PatchNotificationTargetsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchNotificationTargetsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchNotificationTargetsIdRequestWithBody generates requests for PatchNotificationTargetsId with any type of body
func NewPatchNotificationTargetsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notification-targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationsRequest generates requests for GetNotifications
func NewGetNotificationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNotificationsRequest calls the generic PostNotifications builder with application/json body
func NewPostNotificationsRequest(server string, body PostNotificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNotificationsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNotificationsRequestWithBody generates requests for PostNotifications with any type of body
func NewPostNotificationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationsIdRequest generates requests for DeleteNotificationsId
func NewDeleteNotificationsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationsIdRequest generates requests for GetNotificationsId
func NewGetNotificationsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchNotificationsIdRequest calls the generic PatchNotificationsId builder with application/json body
func NewPatchNotificationsIdRequest(server string, id string, body PatchNotificationsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchNotificationsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchNotificationsIdRequestWithBody generates requests for PatchNotificationsId with any type of body
func NewPatchNotificationsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOutputClickHouseDescribeTableRequest calls the generic PostOutputClickHouseDescribeTable builder with application/json body
func NewPostOutputClickHouseDescribeTableRequest(server string, body PostOutputClickHouseDescribeTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOutputClickHouseDescribeTableRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOutputClickHouseDescribeTableRequestWithBody generates requests for PostOutputClickHouseDescribeTable with any type of body
func NewPostOutputClickHouseDescribeTableRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/output/click-house/describe-table")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPPackFunctionsRequest generates requests for GetPPackFunctions
func NewGetPPackFunctionsRequest(server string, pack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/functions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackFunctionsIdRequest generates requests for GetPPackFunctionsId
func NewGetPPackFunctionsIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/functions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackLibSchemasRequest generates requests for GetPPackLibSchemas
func NewGetPPackLibSchemasRequest(server string, pack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPPackLibSchemasRequest calls the generic PostPPackLibSchemas builder with application/json body
func NewPostPPackLibSchemasRequest(server string, pack string, body PostPPackLibSchemasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPPackLibSchemasRequestWithBody(server, pack, "application/json", bodyReader)
}

// NewPostPPackLibSchemasRequestWithBody generates requests for PostPPackLibSchemas with any type of body
func NewPostPPackLibSchemasRequestWithBody(server string, pack string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePPackLibSchemasIdRequest generates requests for DeletePPackLibSchemasId
func NewDeletePPackLibSchemasIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/schemas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackLibSchemasIdRequest generates requests for GetPPackLibSchemasId
func NewGetPPackLibSchemasIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/schemas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPPackLibSchemasIdRequest calls the generic PatchPPackLibSchemasId builder with application/json body
func NewPatchPPackLibSchemasIdRequest(server string, pack string, id string, body PatchPPackLibSchemasIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPPackLibSchemasIdRequestWithBody(server, pack, id, "application/json", bodyReader)
}

// NewPatchPPackLibSchemasIdRequestWithBody generates requests for PatchPPackLibSchemasId with any type of body
func NewPatchPPackLibSchemasIdRequestWithBody(server string, pack string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/schemas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPPackLibVarsRequest generates requests for GetPPackLibVars
func NewGetPPackLibVarsRequest(server string, pack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/vars", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPPackLibVarsRequest calls the generic PostPPackLibVars builder with application/json body
func NewPostPPackLibVarsRequest(server string, pack string, body PostPPackLibVarsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPPackLibVarsRequestWithBody(server, pack, "application/json", bodyReader)
}

// NewPostPPackLibVarsRequestWithBody generates requests for PostPPackLibVars with any type of body
func NewPostPPackLibVarsRequestWithBody(server string, pack string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/vars", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePPackLibVarsIdRequest generates requests for DeletePPackLibVarsId
func NewDeletePPackLibVarsIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/vars/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackLibVarsIdRequest generates requests for GetPPackLibVarsId
func NewGetPPackLibVarsIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/vars/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPPackLibVarsIdRequest calls the generic PatchPPackLibVarsId builder with application/json body
func NewPatchPPackLibVarsIdRequest(server string, pack string, id string, body PatchPPackLibVarsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPPackLibVarsIdRequestWithBody(server, pack, id, "application/json", bodyReader)
}

// NewPatchPPackLibVarsIdRequestWithBody generates requests for PatchPPackLibVarsId with any type of body
func NewPatchPPackLibVarsIdRequestWithBody(server string, pack string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/lib/vars/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPPackPipelinesRequest generates requests for GetPPackPipelines
func NewGetPPackPipelinesRequest(server string, pack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPPackPipelinesRequest calls the generic PostPPackPipelines builder with application/json body
func NewPostPPackPipelinesRequest(server string, pack string, body PostPPackPipelinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPPackPipelinesRequestWithBody(server, pack, "application/json", bodyReader)
}

// NewPostPPackPipelinesRequestWithBody generates requests for PostPPackPipelines with any type of body
func NewPostPPackPipelinesRequestWithBody(server string, pack string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePPackPipelinesIdRequest generates requests for DeletePPackPipelinesId
func NewDeletePPackPipelinesIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/pipelines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackPipelinesIdRequest generates requests for GetPPackPipelinesId
func NewGetPPackPipelinesIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/pipelines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPPackPipelinesIdRequest calls the generic PatchPPackPipelinesId builder with application/json body
func NewPatchPPackPipelinesIdRequest(server string, pack string, id string, body PatchPPackPipelinesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPPackPipelinesIdRequestWithBody(server, pack, id, "application/json", bodyReader)
}

// NewPatchPPackPipelinesIdRequestWithBody generates requests for PatchPPackPipelinesId with any type of body
func NewPatchPPackPipelinesIdRequestWithBody(server string, pack string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/pipelines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPPackRoutesRequest generates requests for GetPPackRoutes
func NewGetPPackRoutesRequest(server string, pack string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPPackRoutesIdRequest generates requests for GetPPackRoutesId
func NewGetPPackRoutesIdRequest(server string, pack string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPPackRoutesIdRequest calls the generic PatchPPackRoutesId builder with application/json body
func NewPatchPPackRoutesIdRequest(server string, pack string, id string, body PatchPPackRoutesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPPackRoutesIdRequestWithBody(server, pack, id, "application/json", bodyReader)
}

// NewPatchPPackRoutesIdRequestWithBody generates requests for PatchPPackRoutesId with any type of body
func NewPatchPPackRoutesIdRequestWithBody(server string, pack string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/routes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPPackRoutesIdAppendRequest calls the generic PostPPackRoutesIdAppend builder with application/json body
func NewPostPPackRoutesIdAppendRequest(server string, pack string, id string, body PostPPackRoutesIdAppendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPPackRoutesIdAppendRequestWithBody(server, pack, id, "application/json", bodyReader)
}

// NewPostPPackRoutesIdAppendRequestWithBody generates requests for PostPPackRoutesIdAppend with any type of body
func NewPostPPackRoutesIdAppendRequestWithBody(server string, pack string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack", runtime.ParamLocationPath, pack)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/p/%s/routes/%s/append", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPacksRequest generates requests for GetPacks
func NewGetPacksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPacksRequest calls the generic PostPacks builder with application/json body
func NewPostPacksRequest(server string, body PostPacksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPacksRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPacksRequestWithBody generates requests for PostPacks with any type of body
func NewPostPacksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutPacksRequest generates requests for PutPacks
func NewPutPacksRequest(server string, params *PutPacksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPacksCloneRequest calls the generic PostPacksClone builder with application/json body
func NewPostPacksCloneRequest(server string, body PostPacksCloneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPacksCloneRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPacksCloneRequestWithBody generates requests for PostPacksClone with any type of body
func NewPostPacksCloneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/__clone__")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePacksIdRequest generates requests for DeletePacksId
func NewDeletePacksIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPacksIdRequest generates requests for PatchPacksId
func NewPatchPacksIdRequest(server string, id string, params *PatchPacksIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Minor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minor", runtime.ParamLocationQuery, *params.Minor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spec", runtime.ParamLocationQuery, *params.Spec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPacksIdExportRequest generates requests for GetPacksIdExport
func NewGetPacksIdExportRequest(server string, id string, params *GetPacksIdExportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelinesRequest generates requests for GetPipelines
func NewGetPipelinesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPipelinesRequest calls the generic PostPipelines builder with application/json body
func NewPostPipelinesRequest(server string, body PostPipelinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPipelinesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPipelinesRequestWithBody generates requests for PostPipelines with any type of body
func NewPostPipelinesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePipelinesIdRequest generates requests for DeletePipelinesId
func NewDeletePipelinesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelinesIdRequest generates requests for GetPipelinesId
func NewGetPipelinesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPipelinesIdRequest calls the generic PatchPipelinesId builder with application/json body
func NewPatchPipelinesIdRequest(server string, id string, body PatchPipelinesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPipelinesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchPipelinesIdRequestWithBody generates requests for PatchPipelinesId with any type of body
func NewPatchPipelinesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPreviewRequest calls the generic PostPreview builder with application/json body
func NewPostPreviewRequest(server string, body PostPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPreviewRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPreviewRequestWithBody generates requests for PostPreview with any type of body
func NewPostPreviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsEdgeMapQueryRequest generates requests for PostProductsEdgeMapQuery
func NewPostProductsEdgeMapQueryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/edge/map/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsLakeLakesLakeIdDatasetsRequest generates requests for GetProductsLakeLakesLakeIdDatasets
func NewGetProductsLakeLakesLakeIdDatasetsRequest(server string, lakeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lakeId", runtime.ParamLocationPath, lakeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/lake/lakes/%s/datasets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsLakeLakesLakeIdDatasetsRequest calls the generic PostProductsLakeLakesLakeIdDatasets builder with application/json body
func NewPostProductsLakeLakesLakeIdDatasetsRequest(server string, lakeId string, body PostProductsLakeLakesLakeIdDatasetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsLakeLakesLakeIdDatasetsRequestWithBody(server, lakeId, "application/json", bodyReader)
}

// NewPostProductsLakeLakesLakeIdDatasetsRequestWithBody generates requests for PostProductsLakeLakesLakeIdDatasets with any type of body
func NewPostProductsLakeLakesLakeIdDatasetsRequestWithBody(server string, lakeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lakeId", runtime.ParamLocationPath, lakeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/lake/lakes/%s/datasets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsLakeLakesLakeIdDatasetsIdRequest generates requests for DeleteProductsLakeLakesLakeIdDatasetsId
func NewDeleteProductsLakeLakesLakeIdDatasetsIdRequest(server string, lakeId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lakeId", runtime.ParamLocationPath, lakeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/lake/lakes/%s/datasets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsLakeLakesLakeIdDatasetsIdRequest generates requests for GetProductsLakeLakesLakeIdDatasetsId
func NewGetProductsLakeLakesLakeIdDatasetsIdRequest(server string, lakeId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lakeId", runtime.ParamLocationPath, lakeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/lake/lakes/%s/datasets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchProductsLakeLakesLakeIdDatasetsIdRequest calls the generic PatchProductsLakeLakesLakeIdDatasetsId builder with application/json body
func NewPatchProductsLakeLakesLakeIdDatasetsIdRequest(server string, lakeId string, id string, body PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchProductsLakeLakesLakeIdDatasetsIdRequestWithBody(server, lakeId, id, "application/json", bodyReader)
}

// NewPatchProductsLakeLakesLakeIdDatasetsIdRequestWithBody generates requests for PatchProductsLakeLakesLakeIdDatasetsId with any type of body
func NewPatchProductsLakeLakesLakeIdDatasetsIdRequestWithBody(server string, lakeId string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lakeId", runtime.ParamLocationPath, lakeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/lake/lakes/%s/datasets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsProductGroupsRequest generates requests for GetProductsProductGroups
func NewGetProductsProductGroupsRequest(server string, product GetProductsProductGroupsParamsProduct, params *GetProductsProductGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsProductGroupsRequest calls the generic PostProductsProductGroups builder with application/json body
func NewPostProductsProductGroupsRequest(server string, product PostProductsProductGroupsParamsProduct, body PostProductsProductGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductGroupsRequestWithBody(server, product, "application/json", bodyReader)
}

// NewPostProductsProductGroupsRequestWithBody generates requests for PostProductsProductGroups with any type of body
func NewPostProductsProductGroupsRequestWithBody(server string, product PostProductsProductGroupsParamsProduct, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsProductGroupsIdAclTeamsRequest generates requests for GetProductsProductGroupsIdAclTeams
func NewGetProductsProductGroupsIdAclTeamsRequest(server string, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params *GetProductsProductGroupsIdAclTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/groups/%s/acl/teams", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsProductUsersRequest generates requests for GetProductsProductUsers
func NewGetProductsProductUsersRequest(server string, product GetProductsProductUsersParamsProduct, params *GetProductsProductUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupId", runtime.ParamLocationQuery, *params.GroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductsProductUsersCacheRequest generates requests for DeleteProductsProductUsersCache
func NewDeleteProductsProductUsersCacheRequest(server string, product DeleteProductsProductUsersCacheParamsProduct) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/users/__cache__", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsProductUsersIdAclRequest generates requests for GetProductsProductUsersIdAcl
func NewGetProductsProductUsersIdAclRequest(server string, product GetProductsProductUsersIdAclParamsProduct, id string, params *GetProductsProductUsersIdAclParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "product", runtime.ParamLocationPath, product)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoutesRequest generates requests for GetRoutes
func NewGetRoutesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoutesIdRequest generates requests for GetRoutesId
func NewGetRoutesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRoutesIdRequest calls the generic PatchRoutesId builder with application/json body
func NewPatchRoutesIdRequest(server string, id string, body PatchRoutesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRoutesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchRoutesIdRequestWithBody generates requests for PatchRoutesId with any type of body
func NewPatchRoutesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRoutesIdAppendRequest calls the generic PostRoutesIdAppend builder with application/json body
func NewPostRoutesIdAppendRequest(server string, id string, body PostRoutesIdAppendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRoutesIdAppendRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostRoutesIdAppendRequestWithBody generates requests for PostRoutesIdAppend with any type of body
func NewPostRoutesIdAppendRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s/append", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDashboardCategoriesRequest generates requests for GetSearchDashboardCategories
func NewGetSearchDashboardCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboard-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDashboardCategoriesRequest calls the generic PostSearchDashboardCategories builder with application/json body
func NewPostSearchDashboardCategoriesRequest(server string, body PostSearchDashboardCategoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDashboardCategoriesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchDashboardCategoriesRequestWithBody generates requests for PostSearchDashboardCategories with any type of body
func NewPostSearchDashboardCategoriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboard-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchDashboardCategoriesIdRequest generates requests for DeleteSearchDashboardCategoriesId
func NewDeleteSearchDashboardCategoriesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboard-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDashboardCategoriesIdRequest generates requests for GetSearchDashboardCategoriesId
func NewGetSearchDashboardCategoriesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboard-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchDashboardCategoriesIdRequest calls the generic PatchSearchDashboardCategoriesId builder with application/json body
func NewPatchSearchDashboardCategoriesIdRequest(server string, id string, body PatchSearchDashboardCategoriesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchDashboardCategoriesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchDashboardCategoriesIdRequestWithBody generates requests for PatchSearchDashboardCategoriesId with any type of body
func NewPatchSearchDashboardCategoriesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboard-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDashboardsRequest generates requests for GetSearchDashboards
func NewGetSearchDashboardsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDashboardsRequest calls the generic PostSearchDashboards builder with application/json body
func NewPostSearchDashboardsRequest(server string, body PostSearchDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDashboardsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchDashboardsRequestWithBody generates requests for PostSearchDashboards with any type of body
func NewPostSearchDashboardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchDashboardsIdRequest generates requests for DeleteSearchDashboardsId
func NewDeleteSearchDashboardsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDashboardsIdRequest generates requests for GetSearchDashboardsId
func NewGetSearchDashboardsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchDashboardsIdRequest calls the generic PatchSearchDashboardsId builder with application/json body
func NewPatchSearchDashboardsIdRequest(server string, id string, body PatchSearchDashboardsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchDashboardsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchDashboardsIdRequestWithBody generates requests for PatchSearchDashboardsId with any type of body
func NewPatchSearchDashboardsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDashboardsIdAclRequest generates requests for GetSearchDashboardsIdAcl
func NewGetSearchDashboardsIdAclRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDashboardsIdAclApplyRequest calls the generic PostSearchDashboardsIdAclApply builder with application/json body
func NewPostSearchDashboardsIdAclApplyRequest(server string, id string, body PostSearchDashboardsIdAclApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDashboardsIdAclApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSearchDashboardsIdAclApplyRequestWithBody generates requests for PostSearchDashboardsIdAclApply with any type of body
func NewPostSearchDashboardsIdAclApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s/acl/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDashboardsIdAclTeamsRequest generates requests for GetSearchDashboardsIdAclTeams
func NewGetSearchDashboardsIdAclTeamsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s/acl/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDashboardsIdAclTeamsApplyRequest calls the generic PostSearchDashboardsIdAclTeamsApply builder with application/json body
func NewPostSearchDashboardsIdAclTeamsApplyRequest(server string, id string, body PostSearchDashboardsIdAclTeamsApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDashboardsIdAclTeamsApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSearchDashboardsIdAclTeamsApplyRequestWithBody generates requests for PostSearchDashboardsIdAclTeamsApply with any type of body
func NewPostSearchDashboardsIdAclTeamsApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dashboards/%s/acl/teams/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDatasetProviderTypesRequest generates requests for GetSearchDatasetProviderTypes
func NewGetSearchDatasetProviderTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-provider-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDatasetProviderTypesRequest calls the generic PostSearchDatasetProviderTypes builder with application/json body
func NewPostSearchDatasetProviderTypesRequest(server string, body PostSearchDatasetProviderTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDatasetProviderTypesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchDatasetProviderTypesRequestWithBody generates requests for PostSearchDatasetProviderTypes with any type of body
func NewPostSearchDatasetProviderTypesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-provider-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchDatasetProviderTypesIdRequest generates requests for DeleteSearchDatasetProviderTypesId
func NewDeleteSearchDatasetProviderTypesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-provider-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDatasetProviderTypesIdRequest generates requests for GetSearchDatasetProviderTypesId
func NewGetSearchDatasetProviderTypesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-provider-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchDatasetProviderTypesIdRequest calls the generic PatchSearchDatasetProviderTypesId builder with application/json body
func NewPatchSearchDatasetProviderTypesIdRequest(server string, id string, body PatchSearchDatasetProviderTypesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchDatasetProviderTypesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchDatasetProviderTypesIdRequestWithBody generates requests for PatchSearchDatasetProviderTypesId with any type of body
func NewPatchSearchDatasetProviderTypesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-provider-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDatasetProvidersRequest generates requests for GetSearchDatasetProviders
func NewGetSearchDatasetProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDatasetProvidersRequest calls the generic PostSearchDatasetProviders builder with application/json body
func NewPostSearchDatasetProvidersRequest(server string, body PostSearchDatasetProvidersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDatasetProvidersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchDatasetProvidersRequestWithBody generates requests for PostSearchDatasetProviders with any type of body
func NewPostSearchDatasetProvidersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchDatasetProvidersIdRequest generates requests for DeleteSearchDatasetProvidersId
func NewDeleteSearchDatasetProvidersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDatasetProvidersIdRequest generates requests for GetSearchDatasetProvidersId
func NewGetSearchDatasetProvidersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchDatasetProvidersIdRequest calls the generic PatchSearchDatasetProvidersId builder with application/json body
func NewPatchSearchDatasetProvidersIdRequest(server string, id string, body PatchSearchDatasetProvidersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchDatasetProvidersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchDatasetProvidersIdRequestWithBody generates requests for PatchSearchDatasetProvidersId with any type of body
func NewPatchSearchDatasetProvidersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dataset-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDatasetsRequest generates requests for GetSearchDatasets
func NewGetSearchDatasetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDatasetsRequest calls the generic PostSearchDatasets builder with application/json body
func NewPostSearchDatasetsRequest(server string, body PostSearchDatasetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDatasetsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchDatasetsRequestWithBody generates requests for PostSearchDatasets with any type of body
func NewPostSearchDatasetsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchDatasetsIdRequest generates requests for DeleteSearchDatasetsId
func NewDeleteSearchDatasetsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDatasetsIdRequest generates requests for GetSearchDatasetsId
func NewGetSearchDatasetsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchDatasetsIdRequest calls the generic PatchSearchDatasetsId builder with application/json body
func NewPatchSearchDatasetsIdRequest(server string, id string, body PatchSearchDatasetsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchDatasetsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchDatasetsIdRequestWithBody generates requests for PatchSearchDatasetsId with any type of body
func NewPatchSearchDatasetsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDatasetsIdAclRequest generates requests for GetSearchDatasetsIdAcl
func NewGetSearchDatasetsIdAclRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDatasetsIdAclApplyRequest calls the generic PostSearchDatasetsIdAclApply builder with application/json body
func NewPostSearchDatasetsIdAclApplyRequest(server string, id string, body PostSearchDatasetsIdAclApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDatasetsIdAclApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSearchDatasetsIdAclApplyRequestWithBody generates requests for PostSearchDatasetsIdAclApply with any type of body
func NewPostSearchDatasetsIdAclApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s/acl/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchDatasetsIdAclTeamsRequest generates requests for GetSearchDatasetsIdAclTeams
func NewGetSearchDatasetsIdAclTeamsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s/acl/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchDatasetsIdAclTeamsApplyRequest calls the generic PostSearchDatasetsIdAclTeamsApply builder with application/json body
func NewPostSearchDatasetsIdAclTeamsApplyRequest(server string, id string, body PostSearchDatasetsIdAclTeamsApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchDatasetsIdAclTeamsApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSearchDatasetsIdAclTeamsApplyRequestWithBody generates requests for PostSearchDatasetsIdAclTeamsApply with any type of body
func NewPostSearchDatasetsIdAclTeamsApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/datasets/%s/acl/teams/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSearchEventBreakerPreviewRequest calls the generic PostSearchEventBreakerPreview builder with application/json body
func NewPostSearchEventBreakerPreviewRequest(server string, body PostSearchEventBreakerPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchEventBreakerPreviewRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchEventBreakerPreviewRequestWithBody generates requests for PostSearchEventBreakerPreview with any type of body
func NewPostSearchEventBreakerPreviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/event-breaker-preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchHealthcheckRequest generates requests for GetSearchHealthcheck
func NewGetSearchHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobMetricsRequest generates requests for GetSearchJobMetrics
func NewGetSearchJobMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/job-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsRequest generates requests for GetSearchJobs
func NewGetSearchJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchJobsRequest calls the generic PostSearchJobs builder with application/json body
func NewPostSearchJobsRequest(server string, body PostSearchJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchJobsRequestWithBody generates requests for PostSearchJobs with any type of body
func NewPostSearchJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchJobsIdRequest generates requests for DeleteSearchJobsId
func NewDeleteSearchJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdRequest generates requests for GetSearchJobsId
func NewGetSearchJobsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchJobsIdRequest calls the generic PatchSearchJobsId builder with application/json body
func NewPatchSearchJobsIdRequest(server string, id string, body PatchSearchJobsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchJobsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchJobsIdRequestWithBody generates requests for PatchSearchJobsId with any type of body
func NewPatchSearchJobsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSearchJobsIdDispatchExecutorsRequest generates requests for PostSearchJobsIdDispatchExecutors
func NewPostSearchJobsIdDispatchExecutorsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/dispatch-executors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdLogsRequest generates requests for GetSearchJobsIdLogs
func NewGetSearchJobsIdLogsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdMetricsRequest generates requests for GetSearchJobsIdMetrics
func NewGetSearchJobsIdMetricsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdResultsRequest generates requests for GetSearchJobsIdResults
func NewGetSearchJobsIdResultsRequest(server string, id string, params *GetSearchJobsIdResultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/results", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LowerBound != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lowerBound", runtime.ParamLocationQuery, *params.LowerBound); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpperBound != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upperBound", runtime.ParamLocationQuery, *params.UpperBound); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdResultsPollRequest generates requests for GetSearchJobsIdResultsPoll
func NewGetSearchJobsIdResultsPollRequest(server string, id string, params *GetSearchJobsIdResultsPollParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/results-poll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LowerBound != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lowerBound", runtime.ParamLocationQuery, *params.LowerBound); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpperBound != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upperBound", runtime.ParamLocationQuery, *params.UpperBound); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastJobStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastJobStatus", runtime.ParamLocationQuery, *params.LastJobStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchJobsIdStagesStageIdResultsRequest generates requests for GetSearchJobsIdStagesStageIdResults
func NewGetSearchJobsIdStagesStageIdResultsRequest(server string, id string, stageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "stageId", runtime.ParamLocationPath, stageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/jobs/%s/stages/%s/results", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchMacrosRequest generates requests for GetSearchMacros
func NewGetSearchMacrosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/macros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchMacrosRequest calls the generic PostSearchMacros builder with application/json body
func NewPostSearchMacrosRequest(server string, body PostSearchMacrosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchMacrosRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchMacrosRequestWithBody generates requests for PostSearchMacros with any type of body
func NewPostSearchMacrosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/macros")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchMacrosIdRequest generates requests for DeleteSearchMacrosId
func NewDeleteSearchMacrosIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/macros/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchMacrosIdRequest generates requests for GetSearchMacrosId
func NewGetSearchMacrosIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/macros/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchMacrosIdRequest calls the generic PatchSearchMacrosId builder with application/json body
func NewPatchSearchMacrosIdRequest(server string, id string, body PatchSearchMacrosIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchMacrosIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchMacrosIdRequestWithBody generates requests for PatchSearchMacrosId with any type of body
func NewPatchSearchMacrosIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/macros/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSearchPreviewRequest calls the generic PostSearchPreview builder with application/json body
func NewPostSearchPreviewRequest(server string, body PostSearchPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchPreviewRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchPreviewRequestWithBody generates requests for PostSearchPreview with any type of body
func NewPostSearchPreviewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchSavedRequest generates requests for GetSearchSaved
func NewGetSearchSavedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/saved")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchSavedRequest calls the generic PostSearchSaved builder with application/json body
func NewPostSearchSavedRequest(server string, body PostSearchSavedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchSavedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchSavedRequestWithBody generates requests for PostSearchSaved with any type of body
func NewPostSearchSavedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/saved")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchSavedIdRequest generates requests for DeleteSearchSavedId
func NewDeleteSearchSavedIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/saved/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchSavedIdRequest generates requests for GetSearchSavedId
func NewGetSearchSavedIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/saved/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchSavedIdRequest calls the generic PatchSearchSavedId builder with application/json body
func NewPatchSearchSavedIdRequest(server string, id string, body PatchSearchSavedIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchSavedIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchSavedIdRequestWithBody generates requests for PatchSearchSavedId with any type of body
func NewPatchSearchSavedIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/saved/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchTrustPoliciesRequest generates requests for GetSearchTrustPolicies
func NewGetSearchTrustPoliciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/trust-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchUsageGroupsRequest generates requests for GetSearchUsageGroups
func NewGetSearchUsageGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/usage-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSearchUsageGroupsRequest calls the generic PostSearchUsageGroups builder with application/json body
func NewPostSearchUsageGroupsRequest(server string, body PostSearchUsageGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSearchUsageGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSearchUsageGroupsRequestWithBody generates requests for PostSearchUsageGroups with any type of body
func NewPostSearchUsageGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/usage-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSearchUsageGroupsIdRequest generates requests for DeleteSearchUsageGroupsId
func NewDeleteSearchUsageGroupsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/usage-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchUsageGroupsIdRequest generates requests for GetSearchUsageGroupsId
func NewGetSearchUsageGroupsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/usage-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSearchUsageGroupsIdRequest calls the generic PatchSearchUsageGroupsId builder with application/json body
func NewPatchSearchUsageGroupsIdRequest(server string, id string, body PatchSearchUsageGroupsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSearchUsageGroupsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSearchUsageGroupsIdRequestWithBody generates requests for PatchSearchUsageGroupsId with any type of body
func NewPatchSearchUsageGroupsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/usage-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSecurityKmsConfigRequest generates requests for GetSecurityKmsConfig
func NewGetSecurityKmsConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/kms/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSecurityKmsConfigRequest calls the generic PatchSecurityKmsConfig builder with application/json body
func NewPatchSecurityKmsConfigRequest(server string, body PatchSecurityKmsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSecurityKmsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchSecurityKmsConfigRequestWithBody generates requests for PatchSecurityKmsConfig with any type of body
func NewPatchSecurityKmsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/kms/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSecurityKmsHealthRequest generates requests for GetSecurityKmsHealth
func NewGetSecurityKmsHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/security/kms/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettingsFeaturesRequest generates requests for GetSettingsFeatures
func NewGetSettingsFeaturesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettingsFeaturesIdRequest generates requests for GetSettingsFeaturesId
func NewGetSettingsFeaturesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemBannersRequest generates requests for GetSystemBanners
func NewGetSystemBannersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/banners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemBannersRequest calls the generic PostSystemBanners builder with application/json body
func NewPostSystemBannersRequest(server string, body PostSystemBannersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemBannersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemBannersRequestWithBody generates requests for PostSystemBanners with any type of body
func NewPostSystemBannersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/banners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemBannersIdRequest generates requests for DeleteSystemBannersId
func NewDeleteSystemBannersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/banners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemBannersIdRequest generates requests for GetSystemBannersId
func NewGetSystemBannersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/banners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemBannersIdRequest calls the generic PatchSystemBannersId builder with application/json body
func NewPatchSystemBannersIdRequest(server string, id string, body PatchSystemBannersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemBannersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemBannersIdRequestWithBody generates requests for PatchSystemBannersId with any type of body
func NewPatchSystemBannersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/banners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemCaptureRequest calls the generic PostSystemCapture builder with application/json body
func NewPostSystemCaptureRequest(server string, body PostSystemCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemCaptureRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemCaptureRequestWithBody generates requests for PostSystemCapture with any type of body
func NewPostSystemCaptureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/capture")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemCertificatesRequest generates requests for GetSystemCertificates
func NewGetSystemCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemCertificatesRequest calls the generic PostSystemCertificates builder with application/json body
func NewPostSystemCertificatesRequest(server string, body PostSystemCertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemCertificatesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemCertificatesRequestWithBody generates requests for PostSystemCertificates with any type of body
func NewPostSystemCertificatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemCertificatesIdRequest generates requests for DeleteSystemCertificatesId
func NewDeleteSystemCertificatesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemCertificatesIdRequest generates requests for GetSystemCertificatesId
func NewGetSystemCertificatesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemCertificatesIdRequest calls the generic PatchSystemCertificatesId builder with application/json body
func NewPatchSystemCertificatesIdRequest(server string, id string, body PatchSystemCertificatesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemCertificatesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemCertificatesIdRequestWithBody generates requests for PatchSystemCertificatesId with any type of body
func NewPatchSystemCertificatesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemDiagRequest generates requests for DeleteSystemDiag
func NewDeleteSystemDiagRequest(server string, params *DeleteSystemDiagParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemDiagRequest generates requests for GetSystemDiag
func NewGetSystemDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemDiagDownloadRequest generates requests for GetSystemDiagDownload
func NewGetSystemDiagDownloadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diag/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemDiagSendRequest calls the generic PostSystemDiagSend builder with application/json body
func NewPostSystemDiagSendRequest(server string, body PostSystemDiagSendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemDiagSendRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemDiagSendRequestWithBody generates requests for PostSystemDiagSend with any type of body
func NewPostSystemDiagSendRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diag/send")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemDistributedUpgradeCancelGroupRequest generates requests for PostSystemDistributedUpgradeCancelGroup
func NewPostSystemDistributedUpgradeCancelGroupRequest(server string, group string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/distributed/upgrade/cancel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemDistributedUpgradeDownloadFileRequest generates requests for GetSystemDistributedUpgradeDownloadFile
func NewGetSystemDistributedUpgradeDownloadFileRequest(server string, file string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file", runtime.ParamLocationPath, file)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/distributed/upgrade/download/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemDistributedUpgradeStageGroupRequest generates requests for PostSystemDistributedUpgradeStageGroup
func NewPostSystemDistributedUpgradeStageGroupRequest(server string, group string, params *PostSystemDistributedUpgradeStageGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/distributed/upgrade/stage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpgradePercentage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upgradePercentage", runtime.ParamLocationQuery, *params.UpgradePercentage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemDistributedUpgradeGroupRequest calls the generic PostSystemDistributedUpgradeGroup builder with application/json body
func NewPostSystemDistributedUpgradeGroupRequest(server string, group string, body PostSystemDistributedUpgradeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemDistributedUpgradeGroupRequestWithBody(server, group, "application/json", bodyReader)
}

// NewPostSystemDistributedUpgradeGroupRequestWithBody generates requests for PostSystemDistributedUpgradeGroup with any type of body
func NewPostSystemDistributedUpgradeGroupRequestWithBody(server string, group string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/distributed/upgrade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemInfoRequest generates requests for GetSystemInfo
func NewGetSystemInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemInputsRequest generates requests for GetSystemInputs
func NewGetSystemInputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemInputsRequest calls the generic PostSystemInputs builder with application/json body
func NewPostSystemInputsRequest(server string, body PostSystemInputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemInputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemInputsRequestWithBody generates requests for PostSystemInputs with any type of body
func NewPostSystemInputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemInputsIdRequest generates requests for DeleteSystemInputsId
func NewDeleteSystemInputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemInputsIdRequest generates requests for GetSystemInputsId
func NewGetSystemInputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemInputsIdRequest calls the generic PatchSystemInputsId builder with application/json body
func NewPatchSystemInputsIdRequest(server string, id string, body PatchSystemInputsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemInputsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemInputsIdRequestWithBody generates requests for PatchSystemInputsId with any type of body
func NewPatchSystemInputsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemInputsIdHectokenRequest calls the generic PostSystemInputsIdHectoken builder with application/json body
func NewPostSystemInputsIdHectokenRequest(server string, id string, body PostSystemInputsIdHectokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemInputsIdHectokenRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSystemInputsIdHectokenRequestWithBody generates requests for PostSystemInputsIdHectoken with any type of body
func NewPostSystemInputsIdHectokenRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs/%s/hectoken", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchSystemInputsIdHectokenTokenRequest calls the generic PatchSystemInputsIdHectokenToken builder with application/json body
func NewPatchSystemInputsIdHectokenTokenRequest(server string, id string, token string, body PatchSystemInputsIdHectokenTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemInputsIdHectokenTokenRequestWithBody(server, id, token, "application/json", bodyReader)
}

// NewPatchSystemInputsIdHectokenTokenRequestWithBody generates requests for PatchSystemInputsIdHectokenToken with any type of body
func NewPatchSystemInputsIdHectokenTokenRequestWithBody(server string, id string, token string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/inputs/%s/hectoken/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemJobsLogsIdGroupIdRequest generates requests for GetSystemJobsLogsIdGroupId
func NewGetSystemJobsLogsIdGroupIdRequest(server string, id string, groupId string, params *GetSystemJobsLogsIdGroupIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/jobs/logs/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endOffset", runtime.ParamLocationQuery, *params.EndOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Et != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "et", runtime.ParamLocationQuery, *params.Et); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lt", runtime.ParamLocationQuery, *params.Lt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemKeysRequest generates requests for GetSystemKeys
func NewGetSystemKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemKeysRequest calls the generic PostSystemKeys builder with application/json body
func NewPostSystemKeysRequest(server string, body PostSystemKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemKeysRequestWithBody generates requests for PostSystemKeys with any type of body
func NewPostSystemKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemKeysIdRequest generates requests for DeleteSystemKeysId
func NewDeleteSystemKeysIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemKeysIdRequest generates requests for GetSystemKeysId
func NewGetSystemKeysIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemKeysIdRequest calls the generic PatchSystemKeysId builder with application/json body
func NewPatchSystemKeysIdRequest(server string, id string, body PatchSystemKeysIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemKeysIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemKeysIdRequestWithBody generates requests for PatchSystemKeysId with any type of body
func NewPatchSystemKeysIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemLicensesRequest generates requests for GetSystemLicenses
func NewGetSystemLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/licenses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemLicensesRequest calls the generic PostSystemLicenses builder with application/json body
func NewPostSystemLicensesRequest(server string, body PostSystemLicensesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemLicensesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemLicensesRequestWithBody generates requests for PostSystemLicenses with any type of body
func NewPostSystemLicensesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/licenses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemLicensesUsageRequest generates requests for GetSystemLicensesUsage
func NewGetSystemLicensesUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/licenses/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSystemLicensesIdRequest generates requests for DeleteSystemLicensesId
func NewDeleteSystemLicensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLicensesIdRequest generates requests for GetSystemLicensesId
func NewGetSystemLicensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLoggerRequest generates requests for GetSystemLogger
func NewGetSystemLoggerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logger")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSystemLoggerIdRequest generates requests for DeleteSystemLoggerId
func NewDeleteSystemLoggerIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logger/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLoggerIdRequest generates requests for GetSystemLoggerId
func NewGetSystemLoggerIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logger/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemLoggerIdRequest calls the generic PatchSystemLoggerId builder with application/json body
func NewPatchSystemLoggerIdRequest(server string, id string, body PatchSystemLoggerIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemLoggerIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemLoggerIdRequestWithBody generates requests for PatchSystemLoggerId with any type of body
func NewPatchSystemLoggerIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logger/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemLogsRequest generates requests for GetSystemLogs
func NewGetSystemLogsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLogsSearchRequest generates requests for GetSystemLogsSearch
func NewGetSystemLogsSearchRequest(server string, params *GetSystemLogsSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logs/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.GroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupId", runtime.ParamLocationQuery, *params.GroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Files != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "files", runtime.ParamLocationQuery, *params.Files); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Et != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "et", runtime.ParamLocationQuery, *params.Et); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lt", runtime.ParamLocationQuery, *params.Lt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLogsIdRequest generates requests for GetSystemLogsId
func NewGetSystemLogsIdRequest(server string, id string, params *GetSystemLogsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endOffset", runtime.ParamLocationQuery, *params.EndOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Et != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "et", runtime.ParamLocationQuery, *params.Et); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lt", runtime.ParamLocationQuery, *params.Lt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLookupsRequest generates requests for GetSystemLookups
func NewGetSystemLookupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemLookupsRequest calls the generic PostSystemLookups builder with application/json body
func NewPostSystemLookupsRequest(server string, body PostSystemLookupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemLookupsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemLookupsRequestWithBody generates requests for PostSystemLookups with any type of body
func NewPostSystemLookupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutSystemLookupsRequestWithBody generates requests for PutSystemLookups with any type of body
func NewPutSystemLookupsRequestWithBody(server string, params *PutSystemLookupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemLookupsIdRequest generates requests for DeleteSystemLookupsId
func NewDeleteSystemLookupsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemLookupsIdRequest generates requests for GetSystemLookupsId
func NewGetSystemLookupsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemLookupsIdRequest calls the generic PatchSystemLookupsId builder with application/json body
func NewPatchSystemLookupsIdRequest(server string, id string, body PatchSystemLookupsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemLookupsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemLookupsIdRequestWithBody generates requests for PatchSystemLookupsId with any type of body
func NewPatchSystemLookupsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/lookups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemMessagesRequest generates requests for GetSystemMessages
func NewGetSystemMessagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemMessagesRequest calls the generic PostSystemMessages builder with application/json body
func NewPostSystemMessagesRequest(server string, body PostSystemMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemMessagesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemMessagesRequestWithBody generates requests for PostSystemMessages with any type of body
func NewPostSystemMessagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemMessagesIdRequest generates requests for DeleteSystemMessagesId
func NewDeleteSystemMessagesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemMessagesIdRequest generates requests for GetSystemMessagesId
func NewGetSystemMessagesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemMetricsRequest generates requests for GetSystemMetrics
func NewGetSystemMetricsRequest(server string, params *GetSystemMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Wp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wp", runtime.ParamLocationQuery, *params.Wp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NumBuckets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "numBuckets", runtime.ParamLocationQuery, *params.NumBuckets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Earliest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earliest", runtime.ParamLocationQuery, *params.Earliest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Latest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "latest", runtime.ParamLocationQuery, *params.Latest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MetricNameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metricNameFilter", runtime.ParamLocationQuery, *params.MetricNameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterExpr != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterExpr", runtime.ParamLocationQuery, *params.FilterExpr); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemMetricsEnumRequest calls the generic PostSystemMetricsEnum builder with application/json body
func NewPostSystemMetricsEnumRequest(server string, body PostSystemMetricsEnumJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemMetricsEnumRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemMetricsEnumRequestWithBody generates requests for PostSystemMetricsEnum with any type of body
func NewPostSystemMetricsEnumRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/metrics/enum")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemMetricsQueryRequest calls the generic PostSystemMetricsQuery builder with application/json body
func NewPostSystemMetricsQueryRequest(server string, body PostSystemMetricsQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemMetricsQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemMetricsQueryRequestWithBody generates requests for PostSystemMetricsQuery with any type of body
func NewPostSystemMetricsQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/metrics/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemOutputsRequest generates requests for GetSystemOutputs
func NewGetSystemOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemOutputsRequest calls the generic PostSystemOutputs builder with application/json body
func NewPostSystemOutputsRequest(server string, body PostSystemOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemOutputsRequestWithBody generates requests for PostSystemOutputs with any type of body
func NewPostSystemOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemOutputsIdRequest generates requests for DeleteSystemOutputsId
func NewDeleteSystemOutputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemOutputsIdRequest generates requests for GetSystemOutputsId
func NewGetSystemOutputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemOutputsIdRequest calls the generic PatchSystemOutputsId builder with application/json body
func NewPatchSystemOutputsIdRequest(server string, id string, body PatchSystemOutputsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemOutputsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemOutputsIdRequestWithBody generates requests for PatchSystemOutputsId with any type of body
func NewPatchSystemOutputsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemOutputsIdPqRequest generates requests for DeleteSystemOutputsIdPq
func NewDeleteSystemOutputsIdPqRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s/pq", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemOutputsIdPqRequest generates requests for GetSystemOutputsIdPq
func NewGetSystemOutputsIdPqRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s/pq", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemOutputsIdSamplesRequest generates requests for GetSystemOutputsIdSamples
func NewGetSystemOutputsIdSamplesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s/samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemOutputsIdTestRequest calls the generic PostSystemOutputsIdTest builder with application/json body
func NewPostSystemOutputsIdTestRequest(server string, id string, body PostSystemOutputsIdTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemOutputsIdTestRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSystemOutputsIdTestRequestWithBody generates requests for PostSystemOutputsIdTest with any type of body
func NewPostSystemOutputsIdTestRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/outputs/%s/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemPoliciesRequest generates requests for GetSystemPolicies
func NewGetSystemPoliciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemPoliciesRequest calls the generic PostSystemPolicies builder with application/json body
func NewPostSystemPoliciesRequest(server string, body PostSystemPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemPoliciesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemPoliciesRequestWithBody generates requests for PostSystemPolicies with any type of body
func NewPostSystemPoliciesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemPoliciesIdRequest generates requests for DeleteSystemPoliciesId
func NewDeleteSystemPoliciesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemPoliciesIdRequest generates requests for GetSystemPoliciesId
func NewGetSystemPoliciesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemPoliciesIdRequest calls the generic PatchSystemPoliciesId builder with application/json body
func NewPatchSystemPoliciesIdRequest(server string, id string, body PatchSystemPoliciesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemPoliciesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemPoliciesIdRequestWithBody generates requests for PatchSystemPoliciesId with any type of body
func NewPatchSystemPoliciesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProcessesRequest generates requests for GetSystemProcesses
func NewGetSystemProcessesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/processes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProfilerRequest generates requests for GetSystemProfiler
func NewGetSystemProfilerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/profiler")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProfilerRequest calls the generic PostSystemProfiler builder with application/json body
func NewPostSystemProfilerRequest(server string, body PostSystemProfilerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProfilerRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemProfilerRequestWithBody generates requests for PostSystemProfiler with any type of body
func NewPostSystemProfilerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/profiler")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemProfilerIdRequest generates requests for DeleteSystemProfilerId
func NewDeleteSystemProfilerIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/profiler/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProfilerIdRequest generates requests for GetSystemProfilerId
func NewGetSystemProfilerIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/profiler/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemProfilerIdRequest calls the generic PatchSystemProfilerId builder with application/json body
func NewPatchSystemProfilerIdRequest(server string, id string, body PatchSystemProfilerIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemProfilerIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemProfilerIdRequestWithBody generates requests for PatchSystemProfilerId with any type of body
func NewPatchSystemProfilerIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/profiler/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsRequest generates requests for GetSystemProjects
func NewGetSystemProjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProjectsRequest calls the generic PostSystemProjects builder with application/json body
func NewPostSystemProjectsRequest(server string, body PostSystemProjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemProjectsRequestWithBody generates requests for PostSystemProjects with any type of body
func NewPostSystemProjectsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemProjectsIdRequest generates requests for DeleteSystemProjectsId
func NewDeleteSystemProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProjectsIdRequest generates requests for GetSystemProjectsId
func NewGetSystemProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemProjectsIdRequest calls the generic PatchSystemProjectsId builder with application/json body
func NewPatchSystemProjectsIdRequest(server string, id string, body PatchSystemProjectsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemProjectsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemProjectsIdRequestWithBody generates requests for PatchSystemProjectsId with any type of body
func NewPatchSystemProjectsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsIdAclRequest generates requests for GetSystemProjectsIdAcl
func NewGetSystemProjectsIdAclRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProjectsIdAclApplyRequest calls the generic PostSystemProjectsIdAclApply builder with application/json body
func NewPostSystemProjectsIdAclApplyRequest(server string, id string, body PostSystemProjectsIdAclApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsIdAclApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSystemProjectsIdAclApplyRequestWithBody generates requests for PostSystemProjectsIdAclApply with any type of body
func NewPostSystemProjectsIdAclApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/acl/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsIdAclTeamsRequest generates requests for GetSystemProjectsIdAclTeams
func NewGetSystemProjectsIdAclTeamsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/acl/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProjectsIdAclTeamsApplyRequest calls the generic PostSystemProjectsIdAclTeamsApply builder with application/json body
func NewPostSystemProjectsIdAclTeamsApplyRequest(server string, id string, body PostSystemProjectsIdAclTeamsApplyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsIdAclTeamsApplyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSystemProjectsIdAclTeamsApplyRequestWithBody generates requests for PostSystemProjectsIdAclTeamsApply with any type of body
func NewPostSystemProjectsIdAclTeamsApplyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/acl/teams/apply", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemProjectsProjectIdCaptureRequest calls the generic PostSystemProjectsProjectIdCapture builder with application/json body
func NewPostSystemProjectsProjectIdCaptureRequest(server string, projectId string, body PostSystemProjectsProjectIdCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsProjectIdCaptureRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewPostSystemProjectsProjectIdCaptureRequestWithBody generates requests for PostSystemProjectsProjectIdCapture with any type of body
func NewPostSystemProjectsProjectIdCaptureRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsProjectIdDestinationsRequest generates requests for GetSystemProjectsProjectIdDestinations
func NewGetSystemProjectsProjectIdDestinationsRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/destinations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProjectsProjectIdSubscriptionsRequest generates requests for GetSystemProjectsProjectIdSubscriptions
func NewGetSystemProjectsProjectIdSubscriptionsRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/subscriptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest calls the generic PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture builder with application/json body
func NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequest(server string, projectId string, subscriptionId string, body PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(server, projectId, subscriptionId, "application/json", bodyReader)
}

// NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody generates requests for PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture with any type of body
func NewPostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureRequestWithBody(server string, projectId string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subscriptionId", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/subscriptions/%s/capture", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemProjectsProjectIdVersionCommitRequest calls the generic PostSystemProjectsProjectIdVersionCommit builder with application/json body
func NewPostSystemProjectsProjectIdVersionCommitRequest(server string, projectId string, body PostSystemProjectsProjectIdVersionCommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsProjectIdVersionCommitRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewPostSystemProjectsProjectIdVersionCommitRequestWithBody generates requests for PostSystemProjectsProjectIdVersionCommit with any type of body
func NewPostSystemProjectsProjectIdVersionCommitRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsProjectIdVersionCountRequest generates requests for GetSystemProjectsProjectIdVersionCount
func NewGetSystemProjectsProjectIdVersionCountRequest(server string, projectId string, params *GetSystemProjectsProjectIdVersionCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ID", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProjectsProjectIdVersionDiffRequest generates requests for GetSystemProjectsProjectIdVersionDiff
func NewGetSystemProjectsProjectIdVersionDiffRequest(server string, projectId string, params *GetSystemProjectsProjectIdVersionDiffParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/diff", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Commit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffLineLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffLineLimit", runtime.ParamLocationQuery, *params.DiffLineLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemProjectsProjectIdVersionFilesRequest generates requests for GetSystemProjectsProjectIdVersionFiles
func NewGetSystemProjectsProjectIdVersionFilesRequest(server string, projectId string, params *GetSystemProjectsProjectIdVersionFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ID", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemProjectsProjectIdVersionRevertRequest calls the generic PostSystemProjectsProjectIdVersionRevert builder with application/json body
func NewPostSystemProjectsProjectIdVersionRevertRequest(server string, projectId string, body PostSystemProjectsProjectIdVersionRevertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemProjectsProjectIdVersionRevertRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewPostSystemProjectsProjectIdVersionRevertRequestWithBody generates requests for PostSystemProjectsProjectIdVersionRevert with any type of body
func NewPostSystemProjectsProjectIdVersionRevertRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/revert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemProjectsProjectIdVersionShowRequest generates requests for GetSystemProjectsProjectIdVersionShow
func NewGetSystemProjectsProjectIdVersionShowRequest(server string, projectId string, params *GetSystemProjectsProjectIdVersionShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/projects/%s/version/show", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ID", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffLineLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffLineLimit", runtime.ParamLocationQuery, *params.DiffLineLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemRolesRequest generates requests for GetSystemRoles
func NewGetSystemRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemRolesRequest calls the generic PostSystemRoles builder with application/json body
func NewPostSystemRolesRequest(server string, body PostSystemRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemRolesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemRolesRequestWithBody generates requests for PostSystemRoles with any type of body
func NewPostSystemRolesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemRolesIdRequest generates requests for DeleteSystemRolesId
func NewDeleteSystemRolesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemRolesIdRequest generates requests for GetSystemRolesId
func NewGetSystemRolesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemRolesIdRequest calls the generic PatchSystemRolesId builder with application/json body
func NewPatchSystemRolesIdRequest(server string, id string, body PatchSystemRolesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemRolesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemRolesIdRequestWithBody generates requests for PatchSystemRolesId with any type of body
func NewPatchSystemRolesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemSamplesRequest generates requests for GetSystemSamples
func NewGetSystemSamplesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSamplesRequest calls the generic PostSystemSamples builder with application/json body
func NewPostSystemSamplesRequest(server string, body PostSystemSamplesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemSamplesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemSamplesRequestWithBody generates requests for PostSystemSamples with any type of body
func NewPostSystemSamplesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemSamplesIdRequest generates requests for DeleteSystemSamplesId
func NewDeleteSystemSamplesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSamplesIdRequest generates requests for GetSystemSamplesId
func NewGetSystemSamplesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSamplesIdRequest calls the generic PatchSystemSamplesId builder with application/json body
func NewPatchSystemSamplesIdRequest(server string, id string, body PatchSystemSamplesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemSamplesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemSamplesIdRequestWithBody generates requests for PatchSystemSamplesId with any type of body
func NewPatchSystemSamplesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemSamplesIdContentRequest generates requests for GetSystemSamplesIdContent
func NewGetSystemSamplesIdContentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/samples/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemScriptsRequest generates requests for GetSystemScripts
func NewGetSystemScriptsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemScriptsRequest calls the generic PostSystemScripts builder with application/json body
func NewPostSystemScriptsRequest(server string, body PostSystemScriptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemScriptsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemScriptsRequestWithBody generates requests for PostSystemScripts with any type of body
func NewPostSystemScriptsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemScriptsIdRequest generates requests for DeleteSystemScriptsId
func NewDeleteSystemScriptsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemScriptsIdRequest generates requests for GetSystemScriptsId
func NewGetSystemScriptsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemScriptsIdRequest calls the generic PatchSystemScriptsId builder with application/json body
func NewPatchSystemScriptsIdRequest(server string, id string, body PatchSystemScriptsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemScriptsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemScriptsIdRequestWithBody generates requests for PatchSystemScriptsId with any type of body
func NewPatchSystemScriptsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemSecretsRequest generates requests for GetSystemSecrets
func NewGetSystemSecretsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSecretsRequest calls the generic PostSystemSecrets builder with application/json body
func NewPostSystemSecretsRequest(server string, body PostSystemSecretsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemSecretsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemSecretsRequestWithBody generates requests for PostSystemSecrets with any type of body
func NewPostSystemSecretsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemSecretsIdRequest generates requests for DeleteSystemSecretsId
func NewDeleteSystemSecretsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSecretsIdRequest generates requests for GetSystemSecretsId
func NewGetSystemSecretsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSecretsIdRequest calls the generic PatchSystemSecretsId builder with application/json body
func NewPatchSystemSecretsIdRequest(server string, id string, body PatchSystemSecretsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemSecretsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemSecretsIdRequestWithBody generates requests for PatchSystemSecretsId with any type of body
func NewPatchSystemSecretsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemSettingsRequest generates requests for GetSystemSettings
func NewGetSystemSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSettingsRequest generates requests for PatchSystemSettings
func NewPatchSystemSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSettingsAuthRequest generates requests for GetSystemSettingsAuth
func NewGetSystemSettingsAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSettingsAuthRequest generates requests for PatchSystemSettingsAuth
func NewPatchSystemSettingsAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSettingsConfRequest generates requests for GetSystemSettingsConf
func NewGetSystemSettingsConfRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/conf")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSettingsConfRequest calls the generic PatchSystemSettingsConf builder with application/json body
func NewPatchSystemSettingsConfRequest(server string, body PatchSystemSettingsConfJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemSettingsConfRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchSystemSettingsConfRequestWithBody generates requests for PatchSystemSettingsConf with any type of body
func NewPatchSystemSettingsConfRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/conf")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemSettingsCriblRequest generates requests for GetSystemSettingsCribl
func NewGetSystemSettingsCriblRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/cribl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSettingsGitSettingsRequest generates requests for GetSystemSettingsGitSettings
func NewGetSystemSettingsGitSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/git-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSettingsGitSettingsRequest generates requests for PatchSystemSettingsGitSettings
func NewPatchSystemSettingsGitSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/git-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSettingsReloadRequest generates requests for PostSystemSettingsReload
func NewPostSystemSettingsReloadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/reload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSettingsRestartRequest generates requests for PostSystemSettingsRestart
func NewPostSystemSettingsRestartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/restart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSettingsSearchLimitsRequest generates requests for GetSystemSettingsSearchLimits
func NewGetSystemSettingsSearchLimitsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/search-limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSettingsUpgradeRequest generates requests for GetSystemSettingsUpgrade
func NewGetSystemSettingsUpgradeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/upgrade")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSettingsUpgradeFromPackageRequest calls the generic PostSystemSettingsUpgradeFromPackage builder with application/json body
func NewPostSystemSettingsUpgradeFromPackageRequest(server string, body PostSystemSettingsUpgradeFromPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemSettingsUpgradeFromPackageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemSettingsUpgradeFromPackageRequestWithBody generates requests for PostSystemSettingsUpgradeFromPackage with any type of body
func NewPostSystemSettingsUpgradeFromPackageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/upgrade-from-package")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSystemSettingsUpgradeVersionRequest generates requests for PostSystemSettingsUpgradeVersion
func NewPostSystemSettingsUpgradeVersionRequest(server string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/settings/upgrade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusInputsRequest generates requests for GetSystemStatusInputs
func NewGetSystemStatusInputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status/inputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusInputsIdRequest generates requests for GetSystemStatusInputsId
func NewGetSystemStatusInputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusOutputsRequest generates requests for GetSystemStatusOutputs
func NewGetSystemStatusOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusOutputsIdRequest generates requests for GetSystemStatusOutputsId
func NewGetSystemStatusOutputsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSubscriptionsRequest generates requests for GetSystemSubscriptions
func NewGetSystemSubscriptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemSubscriptionsRequest generates requests for PostSystemSubscriptions
func NewPostSystemSubscriptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSystemSubscriptionsIdRequest generates requests for DeleteSystemSubscriptionsId
func NewDeleteSystemSubscriptionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemSubscriptionsIdRequest generates requests for GetSystemSubscriptionsId
func NewGetSystemSubscriptionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemSubscriptionsIdRequest generates requests for PatchSystemSubscriptionsId
func NewPatchSystemSubscriptionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemTeamsRequest generates requests for GetSystemTeams
func NewGetSystemTeamsRequest(server string, params *GetSystemTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Product != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemTeamsRequest calls the generic PostSystemTeams builder with application/json body
func NewPostSystemTeamsRequest(server string, body PostSystemTeamsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemTeamsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemTeamsRequestWithBody generates requests for PostSystemTeams with any type of body
func NewPostSystemTeamsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemTeamsUsersIdRolesRequest generates requests for GetSystemTeamsUsersIdRoles
func NewGetSystemTeamsUsersIdRolesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/users/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSystemTeamsIdRequest generates requests for DeleteSystemTeamsId
func NewDeleteSystemTeamsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemTeamsIdRequest generates requests for GetSystemTeamsId
func NewGetSystemTeamsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemTeamsIdRequest calls the generic PatchSystemTeamsId builder with application/json body
func NewPatchSystemTeamsIdRequest(server string, id string, body PatchSystemTeamsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemTeamsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemTeamsIdRequestWithBody generates requests for PatchSystemTeamsId with any type of body
func NewPatchSystemTeamsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemTeamsIdAclRequest generates requests for GetSystemTeamsIdAcl
func NewGetSystemTeamsIdAclRequest(server string, id string, params *GetSystemTeamsIdAclParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemTeamsIdUsersRequest generates requests for GetSystemTeamsIdUsers
func NewGetSystemTeamsIdUsersRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemTeamsIdUsersRequest calls the generic PostSystemTeamsIdUsers builder with application/json body
func NewPostSystemTeamsIdUsersRequest(server string, id string, body PostSystemTeamsIdUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemTeamsIdUsersRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSystemTeamsIdUsersRequestWithBody generates requests for PostSystemTeamsIdUsers with any type of body
func NewPostSystemTeamsIdUsersRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemUsersRequest generates requests for GetSystemUsers
func NewGetSystemUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSystemUsersRequest calls the generic PostSystemUsers builder with application/json body
func NewPostSystemUsersRequest(server string, body PostSystemUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSystemUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSystemUsersRequestWithBody generates requests for PostSystemUsers with any type of body
func NewPostSystemUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSystemUsersIdRequest generates requests for DeleteSystemUsersId
func NewDeleteSystemUsersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemUsersIdRequest generates requests for GetSystemUsersId
func NewGetSystemUsersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSystemUsersIdRequest calls the generic PatchSystemUsersId builder with application/json body
func NewPatchSystemUsersIdRequest(server string, id string, body PatchSystemUsersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemUsersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemUsersIdRequestWithBody generates requests for PatchSystemUsersId with any type of body
func NewPatchSystemUsersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPatchSystemUsersIdInfoRequest calls the generic PatchSystemUsersIdInfo builder with application/json body
func NewPatchSystemUsersIdInfoRequest(server string, id string, body PatchSystemUsersIdInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSystemUsersIdInfoRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchSystemUsersIdInfoRequestWithBody generates requests for PatchSystemUsersIdInfo with any type of body
func NewPatchSystemUsersIdInfoRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/users/%s/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUiKeyRequest generates requests for GetUiKey
func NewGetUiKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUiKeyRequest calls the generic PatchUiKey builder with application/json body
func NewPatchUiKeyRequest(server string, key string, body PatchUiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUiKeyRequestWithBody(server, key, "application/json", bodyReader)
}

// NewPatchUiKeyRequestWithBody generates requests for PatchUiKey with any type of body
func NewPatchUiKeyRequestWithBody(server string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionBranchRequest generates requests for GetVersionBranch
func NewGetVersionBranchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/branch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVersionCommitRequest calls the generic PostVersionCommit builder with application/json body
func NewPostVersionCommitRequest(server string, body PostVersionCommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVersionCommitRequestWithBody(server, "application/json", bodyReader)
}

// NewPostVersionCommitRequestWithBody generates requests for PostVersionCommit with any type of body
func NewPostVersionCommitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/commit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionCountRequest generates requests for GetVersionCount
func NewGetVersionCountRequest(server string, params *GetVersionCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ID", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionCurrentBranchRequest generates requests for GetVersionCurrentBranch
func NewGetVersionCurrentBranchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/current-branch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionDiffRequest generates requests for GetVersionDiff
func NewGetVersionDiffRequest(server string, params *GetVersionDiffParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/diff")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Commit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffLineLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffLineLimit", runtime.ParamLocationQuery, *params.DiffLineLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionFilesRequest generates requests for GetVersionFiles
func NewGetVersionFilesRequest(server string, params *GetVersionFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ID", runtime.ParamLocationQuery, *params.ID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionInfoRequest generates requests for GetVersionInfo
func NewGetVersionInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVersionPushRequest generates requests for PostVersionPush
func NewPostVersionPushRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/push")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVersionRevertRequest calls the generic PostVersionRevert builder with application/json body
func NewPostVersionRevertRequest(server string, params *PostVersionRevertParams, body PostVersionRevertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVersionRevertRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostVersionRevertRequestWithBody generates requests for PostVersionRevert with any type of body
func NewPostVersionRevertRequestWithBody(server string, params *PostVersionRevertParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/revert")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionShowRequest generates requests for GetVersionShow
func NewGetVersionShowRequest(server string, params *GetVersionShowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/show")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Commit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiffLineLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "diffLineLimit", runtime.ParamLocationQuery, *params.DiffLineLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionStatusRequest generates requests for GetVersionStatus
func NewGetVersionStatusRequest(server string, params *GetVersionStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVersionSyncRequest generates requests for PostVersionSync
func NewPostVersionSyncRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVersionUndoRequest generates requests for PostVersionUndo
func NewPostVersionUndoRequest(server string, params *PostVersionUndoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version/undo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAiConsentWithResponse request
	GetAiConsentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAiConsentResponse, error)

	// PostAiConsentWithResponse request
	PostAiConsentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAiConsentResponse, error)

	// GetAuthAuthorizationCodeCallbackWithResponse request
	GetAuthAuthorizationCodeCallbackWithResponse(ctx context.Context, params *GetAuthAuthorizationCodeCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthAuthorizationCodeCallbackResponse, error)

	// GetAuthGroupsWithResponse request
	GetAuthGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthGroupsResponse, error)

	// PostAuthLoginWithBodyWithResponse request with any body
	PostAuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error)

	PostAuthLoginWithResponse(ctx context.Context, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error)

	// PostAuthLogoutWithResponse request
	PostAuthLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAuthLogoutResponse, error)

	// GetAuthMetadataWithResponse request
	GetAuthMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthMetadataResponse, error)

	// GetAuthMultiFactorWithResponse request
	GetAuthMultiFactorWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthMultiFactorResponse, error)

	// GetAuthSloWithResponse request
	GetAuthSloWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthSloResponse, error)

	// GetAuthSloCallbackWithResponse request
	GetAuthSloCallbackWithResponse(ctx context.Context, params *GetAuthSloCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthSloCallbackResponse, error)

	// PostAuthSloCallbackWithBodyWithResponse request with any body
	PostAuthSloCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthSloCallbackResponse, error)

	PostAuthSloCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostAuthSloCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostAuthSloCallbackResponse, error)

	// GetAuthSsoWithResponse request
	GetAuthSsoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthSsoResponse, error)

	// GetAuthSsoCallbackWithResponse request
	GetAuthSsoCallbackWithResponse(ctx context.Context, params *GetAuthSsoCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthSsoCallbackResponse, error)

	// PostAuthSsoCallbackWithBodyWithResponse request with any body
	PostAuthSsoCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthSsoCallbackResponse, error)

	PostAuthSsoCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostAuthSsoCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostAuthSsoCallbackResponse, error)

	// DeleteAuthUsersIdTokenWithResponse request
	DeleteAuthUsersIdTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthUsersIdTokenResponse, error)

	// GetAuthorizePolicyWithResponse request
	GetAuthorizePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthorizePolicyResponse, error)

	// GetAuthorizeRolesWithResponse request
	GetAuthorizeRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthorizeRolesResponse, error)

	// GetChangelogViewedWithResponse request
	GetChangelogViewedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChangelogViewedResponse, error)

	// PatchChangelogViewedWithResponse request
	PatchChangelogViewedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchChangelogViewedResponse, error)

	// GetCluiWithResponse request
	GetCluiWithResponse(ctx context.Context, params *GetCluiParams, reqEditors ...RequestEditorFn) (*GetCluiResponse, error)

	// GetCollectorsWithResponse request
	GetCollectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorsResponse, error)

	// GetCollectorsIdWithResponse request
	GetCollectorsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCollectorsIdResponse, error)

	// GetConditionsWithResponse request
	GetConditionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConditionsResponse, error)

	// GetConditionsIdWithResponse request
	GetConditionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConditionsIdResponse, error)

	// GetEdgeAppscopeProcessesWithResponse request
	GetEdgeAppscopeProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeAppscopeProcessesResponse, error)

	// PostEdgeAppscopeProcessesWithResponse request
	PostEdgeAppscopeProcessesWithResponse(ctx context.Context, params *PostEdgeAppscopeProcessesParams, reqEditors ...RequestEditorFn) (*PostEdgeAppscopeProcessesResponse, error)

	// DeleteEdgeAppscopeProcessesPidWithResponse request
	DeleteEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*DeleteEdgeAppscopeProcessesPidResponse, error)

	// GetEdgeAppscopeProcessesPidWithResponse request
	GetEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*GetEdgeAppscopeProcessesPidResponse, error)

	// PutEdgeAppscopeProcessesPidWithResponse request
	PutEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*PutEdgeAppscopeProcessesPidResponse, error)

	// GetEdgeContainersWithResponse request
	GetEdgeContainersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeContainersResponse, error)

	// GetEdgeContainersIdWithResponse request
	GetEdgeContainersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeContainersIdResponse, error)

	// GetEdgeEventsCollectorsWithResponse request
	GetEdgeEventsCollectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeEventsCollectorsResponse, error)

	// GetEdgeEventsQueryWithResponse request
	GetEdgeEventsQueryWithResponse(ctx context.Context, params *GetEdgeEventsQueryParams, reqEditors ...RequestEditorFn) (*GetEdgeEventsQueryResponse, error)

	// PostEdgeFileIngestWithResponse request
	PostEdgeFileIngestWithResponse(ctx context.Context, params *PostEdgeFileIngestParams, reqEditors ...RequestEditorFn) (*PostEdgeFileIngestResponse, error)

	// GetEdgeFileSampleWithResponse request
	GetEdgeFileSampleWithResponse(ctx context.Context, params *GetEdgeFileSampleParams, reqEditors ...RequestEditorFn) (*GetEdgeFileSampleResponse, error)

	// GetEdgeFileinspectWithResponse request
	GetEdgeFileinspectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeFileinspectResponse, error)

	// PostEdgeKubeLogsWithResponse request
	PostEdgeKubeLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostEdgeKubeLogsResponse, error)

	// GetEdgeKubeProxyWithResponse request
	GetEdgeKubeProxyWithResponse(ctx context.Context, params *GetEdgeKubeProxyParams, reqEditors ...RequestEditorFn) (*GetEdgeKubeProxyResponse, error)

	// GetEdgeLogsWithResponse request
	GetEdgeLogsWithResponse(ctx context.Context, params *GetEdgeLogsParams, reqEditors ...RequestEditorFn) (*GetEdgeLogsResponse, error)

	// GetEdgeLsPathWithResponse request
	GetEdgeLsPathWithResponse(ctx context.Context, path string, reqEditors ...RequestEditorFn) (*GetEdgeLsPathResponse, error)

	// GetEdgeMetadataWithResponse request
	GetEdgeMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeMetadataResponse, error)

	// GetEdgeProcessesWithResponse request
	GetEdgeProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeProcessesResponse, error)

	// GetEdgeProcessesPidWithResponse request
	GetEdgeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*GetEdgeProcessesPidResponse, error)

	// GetExecutorsWithResponse request
	GetExecutorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExecutorsResponse, error)

	// GetExecutorsIdWithResponse request
	GetExecutorsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExecutorsIdResponse, error)

	// GetFunctionsWithResponse request
	GetFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFunctionsResponse, error)

	// GetFunctionsIdWithResponse request
	GetFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFunctionsIdResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetJobsWithResponse request
	GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error)

	// PostJobsWithBodyWithResponse request with any body
	PostJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostJobsResponse, error)

	PostJobsWithResponse(ctx context.Context, body PostJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostJobsResponse, error)

	// DeleteJobsIdWithResponse request
	DeleteJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteJobsIdResponse, error)

	// GetJobsIdWithResponse request
	GetJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdResponse, error)

	// PatchJobsIdCancelWithResponse request
	PatchJobsIdCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdCancelResponse, error)

	// GetJobsIdErrorsWithResponse request
	GetJobsIdErrorsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdErrorsResponse, error)

	// GetJobsIdErrorsGroupWithResponse request
	GetJobsIdErrorsGroupWithResponse(ctx context.Context, id string, group string, reqEditors ...RequestEditorFn) (*GetJobsIdErrorsGroupResponse, error)

	// PatchJobsIdKeepWithResponse request
	PatchJobsIdKeepWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdKeepResponse, error)

	// PatchJobsIdPauseWithResponse request
	PatchJobsIdPauseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdPauseResponse, error)

	// GetJobsIdResultsWithResponse request
	GetJobsIdResultsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdResultsResponse, error)

	// GetJobsIdResultsGroupWithResponse request
	GetJobsIdResultsGroupWithResponse(ctx context.Context, id string, group string, params *GetJobsIdResultsGroupParams, reqEditors ...RequestEditorFn) (*GetJobsIdResultsGroupResponse, error)

	// PatchJobsIdResumeWithResponse request
	PatchJobsIdResumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdResumeResponse, error)

	// GetLibAppscopeConfigsWithResponse request
	GetLibAppscopeConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibAppscopeConfigsResponse, error)

	// PostLibAppscopeConfigsWithBodyWithResponse request with any body
	PostLibAppscopeConfigsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibAppscopeConfigsResponse, error)

	PostLibAppscopeConfigsWithResponse(ctx context.Context, body PostLibAppscopeConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibAppscopeConfigsResponse, error)

	// DeleteLibAppscopeConfigsIdWithResponse request
	DeleteLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibAppscopeConfigsIdResponse, error)

	// GetLibAppscopeConfigsIdWithResponse request
	GetLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibAppscopeConfigsIdResponse, error)

	// PatchLibAppscopeConfigsIdWithBodyWithResponse request with any body
	PatchLibAppscopeConfigsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibAppscopeConfigsIdResponse, error)

	PatchLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, body PatchLibAppscopeConfigsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibAppscopeConfigsIdResponse, error)

	// GetLibBreakersWithResponse request
	GetLibBreakersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibBreakersResponse, error)

	// PostLibBreakersWithBodyWithResponse request with any body
	PostLibBreakersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibBreakersResponse, error)

	PostLibBreakersWithResponse(ctx context.Context, body PostLibBreakersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibBreakersResponse, error)

	// DeleteLibBreakersIdWithResponse request
	DeleteLibBreakersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibBreakersIdResponse, error)

	// GetLibBreakersIdWithResponse request
	GetLibBreakersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibBreakersIdResponse, error)

	// PatchLibBreakersIdWithBodyWithResponse request with any body
	PatchLibBreakersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibBreakersIdResponse, error)

	PatchLibBreakersIdWithResponse(ctx context.Context, id string, body PatchLibBreakersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibBreakersIdResponse, error)

	// GetLibDatabaseConnectionsWithResponse request
	GetLibDatabaseConnectionsWithResponse(ctx context.Context, params *GetLibDatabaseConnectionsParams, reqEditors ...RequestEditorFn) (*GetLibDatabaseConnectionsResponse, error)

	// PostLibDatabaseConnectionsWithBodyWithResponse request with any body
	PostLibDatabaseConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsResponse, error)

	PostLibDatabaseConnectionsWithResponse(ctx context.Context, body PostLibDatabaseConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsResponse, error)

	// PostLibDatabaseConnectionsTestWithBodyWithResponse request with any body
	PostLibDatabaseConnectionsTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsTestResponse, error)

	PostLibDatabaseConnectionsTestWithResponse(ctx context.Context, body PostLibDatabaseConnectionsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsTestResponse, error)

	// DeleteLibDatabaseConnectionsIdWithResponse request
	DeleteLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibDatabaseConnectionsIdResponse, error)

	// GetLibDatabaseConnectionsIdWithResponse request
	GetLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibDatabaseConnectionsIdResponse, error)

	// PatchLibDatabaseConnectionsIdWithBodyWithResponse request with any body
	PatchLibDatabaseConnectionsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibDatabaseConnectionsIdResponse, error)

	PatchLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, body PatchLibDatabaseConnectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibDatabaseConnectionsIdResponse, error)

	// PostLibExpressionWithResponse request
	PostLibExpressionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLibExpressionResponse, error)

	// GetLibGrokWithResponse request
	GetLibGrokWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibGrokResponse, error)

	// PostLibGrokWithBodyWithResponse request with any body
	PostLibGrokWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibGrokResponse, error)

	PostLibGrokWithResponse(ctx context.Context, body PostLibGrokJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibGrokResponse, error)

	// DeleteLibGrokIdWithResponse request
	DeleteLibGrokIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibGrokIdResponse, error)

	// GetLibGrokIdWithResponse request
	GetLibGrokIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibGrokIdResponse, error)

	// PatchLibGrokIdWithBodyWithResponse request with any body
	PatchLibGrokIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibGrokIdResponse, error)

	PatchLibGrokIdWithResponse(ctx context.Context, id string, body PatchLibGrokIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibGrokIdResponse, error)

	// GetLibHmacFunctionsWithResponse request
	GetLibHmacFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibHmacFunctionsResponse, error)

	// PostLibHmacFunctionsWithBodyWithResponse request with any body
	PostLibHmacFunctionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibHmacFunctionsResponse, error)

	PostLibHmacFunctionsWithResponse(ctx context.Context, body PostLibHmacFunctionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibHmacFunctionsResponse, error)

	// DeleteLibHmacFunctionsIdWithResponse request
	DeleteLibHmacFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibHmacFunctionsIdResponse, error)

	// GetLibHmacFunctionsIdWithResponse request
	GetLibHmacFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibHmacFunctionsIdResponse, error)

	// PatchLibHmacFunctionsIdWithBodyWithResponse request with any body
	PatchLibHmacFunctionsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibHmacFunctionsIdResponse, error)

	PatchLibHmacFunctionsIdWithResponse(ctx context.Context, id string, body PatchLibHmacFunctionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibHmacFunctionsIdResponse, error)

	// GetLibJobsWithResponse request
	GetLibJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibJobsResponse, error)

	// PostLibJobsWithBodyWithResponse request with any body
	PostLibJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibJobsResponse, error)

	PostLibJobsWithResponse(ctx context.Context, body PostLibJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibJobsResponse, error)

	// DeleteLibJobsIdWithResponse request
	DeleteLibJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibJobsIdResponse, error)

	// GetLibJobsIdWithResponse request
	GetLibJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibJobsIdResponse, error)

	// PatchLibJobsIdWithBodyWithResponse request with any body
	PatchLibJobsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibJobsIdResponse, error)

	PatchLibJobsIdWithResponse(ctx context.Context, id string, body PatchLibJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibJobsIdResponse, error)

	// GetLibParquetSchemasWithResponse request
	GetLibParquetSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibParquetSchemasResponse, error)

	// PostLibParquetSchemasWithBodyWithResponse request with any body
	PostLibParquetSchemasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibParquetSchemasResponse, error)

	PostLibParquetSchemasWithResponse(ctx context.Context, body PostLibParquetSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibParquetSchemasResponse, error)

	// DeleteLibParquetSchemasIdWithResponse request
	DeleteLibParquetSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibParquetSchemasIdResponse, error)

	// GetLibParquetSchemasIdWithResponse request
	GetLibParquetSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibParquetSchemasIdResponse, error)

	// PatchLibParquetSchemasIdWithBodyWithResponse request with any body
	PatchLibParquetSchemasIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibParquetSchemasIdResponse, error)

	PatchLibParquetSchemasIdWithResponse(ctx context.Context, id string, body PatchLibParquetSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibParquetSchemasIdResponse, error)

	// GetLibParsersWithResponse request
	GetLibParsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibParsersResponse, error)

	// PostLibParsersWithBodyWithResponse request with any body
	PostLibParsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibParsersResponse, error)

	PostLibParsersWithResponse(ctx context.Context, body PostLibParsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibParsersResponse, error)

	// DeleteLibParsersIdWithResponse request
	DeleteLibParsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibParsersIdResponse, error)

	// GetLibParsersIdWithResponse request
	GetLibParsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibParsersIdResponse, error)

	// PatchLibParsersIdWithBodyWithResponse request with any body
	PatchLibParsersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibParsersIdResponse, error)

	PatchLibParsersIdWithResponse(ctx context.Context, id string, body PatchLibParsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibParsersIdResponse, error)

	// GetLibProtobufLibrariesWithResponse request
	GetLibProtobufLibrariesWithResponse(ctx context.Context, params *GetLibProtobufLibrariesParams, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesResponse, error)

	// GetLibProtobufLibrariesIdWithResponse request
	GetLibProtobufLibrariesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdResponse, error)

	// GetLibProtobufLibrariesIdEncodingsWithResponse request
	GetLibProtobufLibrariesIdEncodingsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdEncodingsResponse, error)

	// GetLibProtobufLibrariesIdEncodingsEncidWithResponse request
	GetLibProtobufLibrariesIdEncodingsEncidWithResponse(ctx context.Context, id string, encid string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdEncodingsEncidResponse, error)

	// GetLibRegexWithResponse request
	GetLibRegexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibRegexResponse, error)

	// PostLibRegexWithBodyWithResponse request with any body
	PostLibRegexWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibRegexResponse, error)

	PostLibRegexWithResponse(ctx context.Context, body PostLibRegexJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibRegexResponse, error)

	// DeleteLibRegexIdWithResponse request
	DeleteLibRegexIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibRegexIdResponse, error)

	// GetLibRegexIdWithResponse request
	GetLibRegexIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibRegexIdResponse, error)

	// PatchLibRegexIdWithBodyWithResponse request with any body
	PatchLibRegexIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibRegexIdResponse, error)

	PatchLibRegexIdWithResponse(ctx context.Context, id string, body PatchLibRegexIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibRegexIdResponse, error)

	// GetLibSchemasWithResponse request
	GetLibSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibSchemasResponse, error)

	// PostLibSchemasWithBodyWithResponse request with any body
	PostLibSchemasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibSchemasResponse, error)

	PostLibSchemasWithResponse(ctx context.Context, body PostLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibSchemasResponse, error)

	// DeleteLibSchemasIdWithResponse request
	DeleteLibSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibSchemasIdResponse, error)

	// GetLibSchemasIdWithResponse request
	GetLibSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibSchemasIdResponse, error)

	// PatchLibSchemasIdWithBodyWithResponse request with any body
	PatchLibSchemasIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibSchemasIdResponse, error)

	PatchLibSchemasIdWithResponse(ctx context.Context, id string, body PatchLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibSchemasIdResponse, error)

	// GetLibVarsWithResponse request
	GetLibVarsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibVarsResponse, error)

	// PostLibVarsWithBodyWithResponse request with any body
	PostLibVarsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibVarsResponse, error)

	PostLibVarsWithResponse(ctx context.Context, body PostLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibVarsResponse, error)

	// DeleteLibVarsIdWithResponse request
	DeleteLibVarsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibVarsIdResponse, error)

	// GetLibVarsIdWithResponse request
	GetLibVarsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibVarsIdResponse, error)

	// PatchLibVarsIdWithBodyWithResponse request with any body
	PatchLibVarsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibVarsIdResponse, error)

	PatchLibVarsIdWithResponse(ctx context.Context, id string, body PatchLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibVarsIdResponse, error)

	// PostMGroupIdSystemProjectsProjectIdCaptureWithBodyWithResponse request with any body
	PostMGroupIdSystemProjectsProjectIdCaptureWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdCaptureResponse, error)

	PostMGroupIdSystemProjectsProjectIdCaptureWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdCaptureResponse, error)

	// GetMGroupIdSystemProjectsProjectIdPipelinesWithResponse request
	GetMGroupIdSystemProjectsProjectIdPipelinesWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdPipelinesResponse, error)

	// PostMGroupIdSystemProjectsProjectIdPipelinesWithBodyWithResponse request with any body
	PostMGroupIdSystemProjectsProjectIdPipelinesWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPipelinesResponse, error)

	PostMGroupIdSystemProjectsProjectIdPipelinesWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPipelinesResponse, error)

	// DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse request
	DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error)

	// GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse request
	GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error)

	// PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBodyWithResponse request with any body
	PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBodyWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error)

	PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, body PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error)

	// PostMGroupIdSystemProjectsProjectIdPreviewWithBodyWithResponse request with any body
	PostMGroupIdSystemProjectsProjectIdPreviewWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPreviewResponse, error)

	PostMGroupIdSystemProjectsProjectIdPreviewWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPreviewResponse, error)

	// GetMGroupIdSystemProjectsProjectIdSubscriptionsWithResponse request
	GetMGroupIdSystemProjectsProjectIdSubscriptionsWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse, error)

	// PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse request with any body
	PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse(ctx context.Context, groupId string, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error)

	PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse(ctx context.Context, groupId string, projectId string, subscriptionId string, body PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error)

	// PostMGroupIdSystemProjectsProjectIdVersionCommitWithBodyWithResponse request with any body
	PostMGroupIdSystemProjectsProjectIdVersionCommitWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdVersionCommitResponse, error)

	PostMGroupIdSystemProjectsProjectIdVersionCommitWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdVersionCommitResponse, error)

	// GetMGroupIdSystemProjectsProjectIdVersionCountWithResponse request
	GetMGroupIdSystemProjectsProjectIdVersionCountWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionCountResponse, error)

	// GetMGroupIdSystemProjectsProjectIdVersionDiffWithResponse request
	GetMGroupIdSystemProjectsProjectIdVersionDiffWithResponse(ctx context.Context, groupId string, projectId string, params *GetMGroupIdSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionDiffResponse, error)

	// GetMGroupIdSystemProjectsProjectIdVersionFilesWithResponse request
	GetMGroupIdSystemProjectsProjectIdVersionFilesWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionFilesResponse, error)

	// GetMasterBundlesGroupVersionWithResponse request
	GetMasterBundlesGroupVersionWithResponse(ctx context.Context, group string, version string, reqEditors ...RequestEditorFn) (*GetMasterBundlesGroupVersionResponse, error)

	// GetMasterGroupsIdWithResponse request
	GetMasterGroupsIdWithResponse(ctx context.Context, id string, params *GetMasterGroupsIdParams, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdResponse, error)

	// GetMasterGroupsIdAclWithResponse request
	GetMasterGroupsIdAclWithResponse(ctx context.Context, id string, params *GetMasterGroupsIdAclParams, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdAclResponse, error)

	// GetMasterGroupsIdConfigVersionWithResponse request
	GetMasterGroupsIdConfigVersionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdConfigVersionResponse, error)

	// PatchMasterGroupsIdDeployWithBodyWithResponse request with any body
	PatchMasterGroupsIdDeployWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMasterGroupsIdDeployResponse, error)

	PatchMasterGroupsIdDeployWithResponse(ctx context.Context, id string, body PatchMasterGroupsIdDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMasterGroupsIdDeployResponse, error)

	// GetMasterSummaryWithResponse request
	GetMasterSummaryWithResponse(ctx context.Context, params *GetMasterSummaryParams, reqEditors ...RequestEditorFn) (*GetMasterSummaryResponse, error)

	// GetMasterSummaryWorkersWithResponse request
	GetMasterSummaryWorkersWithResponse(ctx context.Context, params *GetMasterSummaryWorkersParams, reqEditors ...RequestEditorFn) (*GetMasterSummaryWorkersResponse, error)

	// GetMasterWorkersWithResponse request
	GetMasterWorkersWithResponse(ctx context.Context, params *GetMasterWorkersParams, reqEditors ...RequestEditorFn) (*GetMasterWorkersResponse, error)

	// PatchMasterWorkersRestartWithResponse request
	PatchMasterWorkersRestartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchMasterWorkersRestartResponse, error)

	// GetNotificationTargetsWithResponse request
	GetNotificationTargetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationTargetsResponse, error)

	// PostNotificationTargetsWithBodyWithResponse request with any body
	PostNotificationTargetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationTargetsResponse, error)

	PostNotificationTargetsWithResponse(ctx context.Context, body PostNotificationTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationTargetsResponse, error)

	// DeleteNotificationTargetsIdWithResponse request
	DeleteNotificationTargetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotificationTargetsIdResponse, error)

	// GetNotificationTargetsIdWithResponse request
	GetNotificationTargetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotificationTargetsIdResponse, error)

	// PatchNotificationTargetsIdWithBodyWithResponse request with any body
	PatchNotificationTargetsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchNotificationTargetsIdResponse, error)

	PatchNotificationTargetsIdWithResponse(ctx context.Context, id string, body PatchNotificationTargetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchNotificationTargetsIdResponse, error)

	// GetNotificationsWithResponse request
	GetNotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error)

	// PostNotificationsWithBodyWithResponse request with any body
	PostNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationsResponse, error)

	PostNotificationsWithResponse(ctx context.Context, body PostNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationsResponse, error)

	// DeleteNotificationsIdWithResponse request
	DeleteNotificationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotificationsIdResponse, error)

	// GetNotificationsIdWithResponse request
	GetNotificationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotificationsIdResponse, error)

	// PatchNotificationsIdWithBodyWithResponse request with any body
	PatchNotificationsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchNotificationsIdResponse, error)

	PatchNotificationsIdWithResponse(ctx context.Context, id string, body PatchNotificationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchNotificationsIdResponse, error)

	// PostOutputClickHouseDescribeTableWithBodyWithResponse request with any body
	PostOutputClickHouseDescribeTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputClickHouseDescribeTableResponse, error)

	PostOutputClickHouseDescribeTableWithResponse(ctx context.Context, body PostOutputClickHouseDescribeTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputClickHouseDescribeTableResponse, error)

	// GetPPackFunctionsWithResponse request
	GetPPackFunctionsWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackFunctionsResponse, error)

	// GetPPackFunctionsIdWithResponse request
	GetPPackFunctionsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackFunctionsIdResponse, error)

	// GetPPackLibSchemasWithResponse request
	GetPPackLibSchemasWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackLibSchemasResponse, error)

	// PostPPackLibSchemasWithBodyWithResponse request with any body
	PostPPackLibSchemasWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackLibSchemasResponse, error)

	PostPPackLibSchemasWithResponse(ctx context.Context, pack string, body PostPPackLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackLibSchemasResponse, error)

	// DeletePPackLibSchemasIdWithResponse request
	DeletePPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackLibSchemasIdResponse, error)

	// GetPPackLibSchemasIdWithResponse request
	GetPPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackLibSchemasIdResponse, error)

	// PatchPPackLibSchemasIdWithBodyWithResponse request with any body
	PatchPPackLibSchemasIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackLibSchemasIdResponse, error)

	PatchPPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackLibSchemasIdResponse, error)

	// GetPPackLibVarsWithResponse request
	GetPPackLibVarsWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackLibVarsResponse, error)

	// PostPPackLibVarsWithBodyWithResponse request with any body
	PostPPackLibVarsWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackLibVarsResponse, error)

	PostPPackLibVarsWithResponse(ctx context.Context, pack string, body PostPPackLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackLibVarsResponse, error)

	// DeletePPackLibVarsIdWithResponse request
	DeletePPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackLibVarsIdResponse, error)

	// GetPPackLibVarsIdWithResponse request
	GetPPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackLibVarsIdResponse, error)

	// PatchPPackLibVarsIdWithBodyWithResponse request with any body
	PatchPPackLibVarsIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackLibVarsIdResponse, error)

	PatchPPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackLibVarsIdResponse, error)

	// GetPPackPipelinesWithResponse request
	GetPPackPipelinesWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackPipelinesResponse, error)

	// PostPPackPipelinesWithBodyWithResponse request with any body
	PostPPackPipelinesWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackPipelinesResponse, error)

	PostPPackPipelinesWithResponse(ctx context.Context, pack string, body PostPPackPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackPipelinesResponse, error)

	// DeletePPackPipelinesIdWithResponse request
	DeletePPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackPipelinesIdResponse, error)

	// GetPPackPipelinesIdWithResponse request
	GetPPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackPipelinesIdResponse, error)

	// PatchPPackPipelinesIdWithBodyWithResponse request with any body
	PatchPPackPipelinesIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackPipelinesIdResponse, error)

	PatchPPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackPipelinesIdResponse, error)

	// GetPPackRoutesWithResponse request
	GetPPackRoutesWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackRoutesResponse, error)

	// GetPPackRoutesIdWithResponse request
	GetPPackRoutesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackRoutesIdResponse, error)

	// PatchPPackRoutesIdWithBodyWithResponse request with any body
	PatchPPackRoutesIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackRoutesIdResponse, error)

	PatchPPackRoutesIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackRoutesIdResponse, error)

	// PostPPackRoutesIdAppendWithBodyWithResponse request with any body
	PostPPackRoutesIdAppendWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackRoutesIdAppendResponse, error)

	PostPPackRoutesIdAppendWithResponse(ctx context.Context, pack string, id string, body PostPPackRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackRoutesIdAppendResponse, error)

	// GetPacksWithResponse request
	GetPacksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPacksResponse, error)

	// PostPacksWithBodyWithResponse request with any body
	PostPacksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPacksResponse, error)

	PostPacksWithResponse(ctx context.Context, body PostPacksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPacksResponse, error)

	// PutPacksWithResponse request
	PutPacksWithResponse(ctx context.Context, params *PutPacksParams, reqEditors ...RequestEditorFn) (*PutPacksResponse, error)

	// PostPacksCloneWithBodyWithResponse request with any body
	PostPacksCloneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPacksCloneResponse, error)

	PostPacksCloneWithResponse(ctx context.Context, body PostPacksCloneJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPacksCloneResponse, error)

	// DeletePacksIdWithResponse request
	DeletePacksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePacksIdResponse, error)

	// PatchPacksIdWithResponse request
	PatchPacksIdWithResponse(ctx context.Context, id string, params *PatchPacksIdParams, reqEditors ...RequestEditorFn) (*PatchPacksIdResponse, error)

	// GetPacksIdExportWithResponse request
	GetPacksIdExportWithResponse(ctx context.Context, id string, params *GetPacksIdExportParams, reqEditors ...RequestEditorFn) (*GetPacksIdExportResponse, error)

	// GetPipelinesWithResponse request
	GetPipelinesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error)

	// PostPipelinesWithBodyWithResponse request with any body
	PostPipelinesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPipelinesResponse, error)

	PostPipelinesWithResponse(ctx context.Context, body PostPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPipelinesResponse, error)

	// DeletePipelinesIdWithResponse request
	DeletePipelinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePipelinesIdResponse, error)

	// GetPipelinesIdWithResponse request
	GetPipelinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPipelinesIdResponse, error)

	// PatchPipelinesIdWithBodyWithResponse request with any body
	PatchPipelinesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPipelinesIdResponse, error)

	PatchPipelinesIdWithResponse(ctx context.Context, id string, body PatchPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPipelinesIdResponse, error)

	// PostPreviewWithBodyWithResponse request with any body
	PostPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPreviewResponse, error)

	PostPreviewWithResponse(ctx context.Context, body PostPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPreviewResponse, error)

	// PostProductsEdgeMapQueryWithResponse request
	PostProductsEdgeMapQueryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostProductsEdgeMapQueryResponse, error)

	// GetProductsLakeLakesLakeIdDatasetsWithResponse request
	GetProductsLakeLakesLakeIdDatasetsWithResponse(ctx context.Context, lakeId string, reqEditors ...RequestEditorFn) (*GetProductsLakeLakesLakeIdDatasetsResponse, error)

	// PostProductsLakeLakesLakeIdDatasetsWithBodyWithResponse request with any body
	PostProductsLakeLakesLakeIdDatasetsWithBodyWithResponse(ctx context.Context, lakeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsLakeLakesLakeIdDatasetsResponse, error)

	PostProductsLakeLakesLakeIdDatasetsWithResponse(ctx context.Context, lakeId string, body PostProductsLakeLakesLakeIdDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsLakeLakesLakeIdDatasetsResponse, error)

	// DeleteProductsLakeLakesLakeIdDatasetsIdWithResponse request
	DeleteProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*DeleteProductsLakeLakesLakeIdDatasetsIdResponse, error)

	// GetProductsLakeLakesLakeIdDatasetsIdWithResponse request
	GetProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*GetProductsLakeLakesLakeIdDatasetsIdResponse, error)

	// PatchProductsLakeLakesLakeIdDatasetsIdWithBodyWithResponse request with any body
	PatchProductsLakeLakesLakeIdDatasetsIdWithBodyWithResponse(ctx context.Context, lakeId string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProductsLakeLakesLakeIdDatasetsIdResponse, error)

	PatchProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, body PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProductsLakeLakesLakeIdDatasetsIdResponse, error)

	// GetProductsProductGroupsWithResponse request
	GetProductsProductGroupsWithResponse(ctx context.Context, product GetProductsProductGroupsParamsProduct, params *GetProductsProductGroupsParams, reqEditors ...RequestEditorFn) (*GetProductsProductGroupsResponse, error)

	// PostProductsProductGroupsWithBodyWithResponse request with any body
	PostProductsProductGroupsWithBodyWithResponse(ctx context.Context, product PostProductsProductGroupsParamsProduct, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductGroupsResponse, error)

	PostProductsProductGroupsWithResponse(ctx context.Context, product PostProductsProductGroupsParamsProduct, body PostProductsProductGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductGroupsResponse, error)

	// GetProductsProductGroupsIdAclTeamsWithResponse request
	GetProductsProductGroupsIdAclTeamsWithResponse(ctx context.Context, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params *GetProductsProductGroupsIdAclTeamsParams, reqEditors ...RequestEditorFn) (*GetProductsProductGroupsIdAclTeamsResponse, error)

	// GetProductsProductUsersWithResponse request
	GetProductsProductUsersWithResponse(ctx context.Context, product GetProductsProductUsersParamsProduct, params *GetProductsProductUsersParams, reqEditors ...RequestEditorFn) (*GetProductsProductUsersResponse, error)

	// DeleteProductsProductUsersCacheWithResponse request
	DeleteProductsProductUsersCacheWithResponse(ctx context.Context, product DeleteProductsProductUsersCacheParamsProduct, reqEditors ...RequestEditorFn) (*DeleteProductsProductUsersCacheResponse, error)

	// GetProductsProductUsersIdAclWithResponse request
	GetProductsProductUsersIdAclWithResponse(ctx context.Context, product GetProductsProductUsersIdAclParamsProduct, id string, params *GetProductsProductUsersIdAclParams, reqEditors ...RequestEditorFn) (*GetProductsProductUsersIdAclResponse, error)

	// GetRoutesWithResponse request
	GetRoutesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRoutesResponse, error)

	// GetRoutesIdWithResponse request
	GetRoutesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRoutesIdResponse, error)

	// PatchRoutesIdWithBodyWithResponse request with any body
	PatchRoutesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoutesIdResponse, error)

	PatchRoutesIdWithResponse(ctx context.Context, id string, body PatchRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoutesIdResponse, error)

	// PostRoutesIdAppendWithBodyWithResponse request with any body
	PostRoutesIdAppendWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRoutesIdAppendResponse, error)

	PostRoutesIdAppendWithResponse(ctx context.Context, id string, body PostRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRoutesIdAppendResponse, error)

	// GetSearchDashboardCategoriesWithResponse request
	GetSearchDashboardCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDashboardCategoriesResponse, error)

	// PostSearchDashboardCategoriesWithBodyWithResponse request with any body
	PostSearchDashboardCategoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardCategoriesResponse, error)

	PostSearchDashboardCategoriesWithResponse(ctx context.Context, body PostSearchDashboardCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardCategoriesResponse, error)

	// DeleteSearchDashboardCategoriesIdWithResponse request
	DeleteSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDashboardCategoriesIdResponse, error)

	// GetSearchDashboardCategoriesIdWithResponse request
	GetSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardCategoriesIdResponse, error)

	// PatchSearchDashboardCategoriesIdWithBodyWithResponse request with any body
	PatchSearchDashboardCategoriesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDashboardCategoriesIdResponse, error)

	PatchSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, body PatchSearchDashboardCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDashboardCategoriesIdResponse, error)

	// GetSearchDashboardsWithResponse request
	GetSearchDashboardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDashboardsResponse, error)

	// PostSearchDashboardsWithBodyWithResponse request with any body
	PostSearchDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsResponse, error)

	PostSearchDashboardsWithResponse(ctx context.Context, body PostSearchDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsResponse, error)

	// DeleteSearchDashboardsIdWithResponse request
	DeleteSearchDashboardsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDashboardsIdResponse, error)

	// GetSearchDashboardsIdWithResponse request
	GetSearchDashboardsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdResponse, error)

	// PatchSearchDashboardsIdWithBodyWithResponse request with any body
	PatchSearchDashboardsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDashboardsIdResponse, error)

	PatchSearchDashboardsIdWithResponse(ctx context.Context, id string, body PatchSearchDashboardsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDashboardsIdResponse, error)

	// GetSearchDashboardsIdAclWithResponse request
	GetSearchDashboardsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdAclResponse, error)

	// PostSearchDashboardsIdAclApplyWithBodyWithResponse request with any body
	PostSearchDashboardsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclApplyResponse, error)

	PostSearchDashboardsIdAclApplyWithResponse(ctx context.Context, id string, body PostSearchDashboardsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclApplyResponse, error)

	// GetSearchDashboardsIdAclTeamsWithResponse request
	GetSearchDashboardsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdAclTeamsResponse, error)

	// PostSearchDashboardsIdAclTeamsApplyWithBodyWithResponse request with any body
	PostSearchDashboardsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclTeamsApplyResponse, error)

	PostSearchDashboardsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSearchDashboardsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclTeamsApplyResponse, error)

	// GetSearchDatasetProviderTypesWithResponse request
	GetSearchDatasetProviderTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetProviderTypesResponse, error)

	// PostSearchDatasetProviderTypesWithBodyWithResponse request with any body
	PostSearchDatasetProviderTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetProviderTypesResponse, error)

	PostSearchDatasetProviderTypesWithResponse(ctx context.Context, body PostSearchDatasetProviderTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetProviderTypesResponse, error)

	// DeleteSearchDatasetProviderTypesIdWithResponse request
	DeleteSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetProviderTypesIdResponse, error)

	// GetSearchDatasetProviderTypesIdWithResponse request
	GetSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetProviderTypesIdResponse, error)

	// PatchSearchDatasetProviderTypesIdWithBodyWithResponse request with any body
	PatchSearchDatasetProviderTypesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProviderTypesIdResponse, error)

	PatchSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetProviderTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProviderTypesIdResponse, error)

	// GetSearchDatasetProvidersWithResponse request
	GetSearchDatasetProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetProvidersResponse, error)

	// PostSearchDatasetProvidersWithBodyWithResponse request with any body
	PostSearchDatasetProvidersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetProvidersResponse, error)

	PostSearchDatasetProvidersWithResponse(ctx context.Context, body PostSearchDatasetProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetProvidersResponse, error)

	// DeleteSearchDatasetProvidersIdWithResponse request
	DeleteSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetProvidersIdResponse, error)

	// GetSearchDatasetProvidersIdWithResponse request
	GetSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetProvidersIdResponse, error)

	// PatchSearchDatasetProvidersIdWithBodyWithResponse request with any body
	PatchSearchDatasetProvidersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProvidersIdResponse, error)

	PatchSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetProvidersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProvidersIdResponse, error)

	// GetSearchDatasetsWithResponse request
	GetSearchDatasetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetsResponse, error)

	// PostSearchDatasetsWithBodyWithResponse request with any body
	PostSearchDatasetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsResponse, error)

	PostSearchDatasetsWithResponse(ctx context.Context, body PostSearchDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsResponse, error)

	// DeleteSearchDatasetsIdWithResponse request
	DeleteSearchDatasetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetsIdResponse, error)

	// GetSearchDatasetsIdWithResponse request
	GetSearchDatasetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdResponse, error)

	// PatchSearchDatasetsIdWithBodyWithResponse request with any body
	PatchSearchDatasetsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetsIdResponse, error)

	PatchSearchDatasetsIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetsIdResponse, error)

	// GetSearchDatasetsIdAclWithResponse request
	GetSearchDatasetsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdAclResponse, error)

	// PostSearchDatasetsIdAclApplyWithBodyWithResponse request with any body
	PostSearchDatasetsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclApplyResponse, error)

	PostSearchDatasetsIdAclApplyWithResponse(ctx context.Context, id string, body PostSearchDatasetsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclApplyResponse, error)

	// GetSearchDatasetsIdAclTeamsWithResponse request
	GetSearchDatasetsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdAclTeamsResponse, error)

	// PostSearchDatasetsIdAclTeamsApplyWithBodyWithResponse request with any body
	PostSearchDatasetsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclTeamsApplyResponse, error)

	PostSearchDatasetsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSearchDatasetsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclTeamsApplyResponse, error)

	// PostSearchEventBreakerPreviewWithBodyWithResponse request with any body
	PostSearchEventBreakerPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchEventBreakerPreviewResponse, error)

	PostSearchEventBreakerPreviewWithResponse(ctx context.Context, body PostSearchEventBreakerPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchEventBreakerPreviewResponse, error)

	// GetSearchHealthcheckWithResponse request
	GetSearchHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchHealthcheckResponse, error)

	// GetSearchJobMetricsWithResponse request
	GetSearchJobMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchJobMetricsResponse, error)

	// GetSearchJobsWithResponse request
	GetSearchJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchJobsResponse, error)

	// PostSearchJobsWithBodyWithResponse request with any body
	PostSearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchJobsResponse, error)

	PostSearchJobsWithResponse(ctx context.Context, body PostSearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchJobsResponse, error)

	// DeleteSearchJobsIdWithResponse request
	DeleteSearchJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchJobsIdResponse, error)

	// GetSearchJobsIdWithResponse request
	GetSearchJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResponse, error)

	// PatchSearchJobsIdWithBodyWithResponse request with any body
	PatchSearchJobsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchJobsIdResponse, error)

	PatchSearchJobsIdWithResponse(ctx context.Context, id string, body PatchSearchJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchJobsIdResponse, error)

	// PostSearchJobsIdDispatchExecutorsWithResponse request
	PostSearchJobsIdDispatchExecutorsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostSearchJobsIdDispatchExecutorsResponse, error)

	// GetSearchJobsIdLogsWithResponse request
	GetSearchJobsIdLogsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdLogsResponse, error)

	// GetSearchJobsIdMetricsWithResponse request
	GetSearchJobsIdMetricsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdMetricsResponse, error)

	// GetSearchJobsIdResultsWithResponse request
	GetSearchJobsIdResultsWithResponse(ctx context.Context, id string, params *GetSearchJobsIdResultsParams, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResultsResponse, error)

	// GetSearchJobsIdResultsPollWithResponse request
	GetSearchJobsIdResultsPollWithResponse(ctx context.Context, id string, params *GetSearchJobsIdResultsPollParams, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResultsPollResponse, error)

	// GetSearchJobsIdStagesStageIdResultsWithResponse request
	GetSearchJobsIdStagesStageIdResultsWithResponse(ctx context.Context, id string, stageId string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdStagesStageIdResultsResponse, error)

	// GetSearchMacrosWithResponse request
	GetSearchMacrosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchMacrosResponse, error)

	// PostSearchMacrosWithBodyWithResponse request with any body
	PostSearchMacrosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchMacrosResponse, error)

	PostSearchMacrosWithResponse(ctx context.Context, body PostSearchMacrosJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchMacrosResponse, error)

	// DeleteSearchMacrosIdWithResponse request
	DeleteSearchMacrosIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchMacrosIdResponse, error)

	// GetSearchMacrosIdWithResponse request
	GetSearchMacrosIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchMacrosIdResponse, error)

	// PatchSearchMacrosIdWithBodyWithResponse request with any body
	PatchSearchMacrosIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchMacrosIdResponse, error)

	PatchSearchMacrosIdWithResponse(ctx context.Context, id string, body PatchSearchMacrosIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchMacrosIdResponse, error)

	// PostSearchPreviewWithBodyWithResponse request with any body
	PostSearchPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchPreviewResponse, error)

	PostSearchPreviewWithResponse(ctx context.Context, body PostSearchPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchPreviewResponse, error)

	// GetSearchSavedWithResponse request
	GetSearchSavedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchSavedResponse, error)

	// PostSearchSavedWithBodyWithResponse request with any body
	PostSearchSavedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchSavedResponse, error)

	PostSearchSavedWithResponse(ctx context.Context, body PostSearchSavedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchSavedResponse, error)

	// DeleteSearchSavedIdWithResponse request
	DeleteSearchSavedIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchSavedIdResponse, error)

	// GetSearchSavedIdWithResponse request
	GetSearchSavedIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchSavedIdResponse, error)

	// PatchSearchSavedIdWithBodyWithResponse request with any body
	PatchSearchSavedIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchSavedIdResponse, error)

	PatchSearchSavedIdWithResponse(ctx context.Context, id string, body PatchSearchSavedIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchSavedIdResponse, error)

	// GetSearchTrustPoliciesWithResponse request
	GetSearchTrustPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchTrustPoliciesResponse, error)

	// GetSearchUsageGroupsWithResponse request
	GetSearchUsageGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchUsageGroupsResponse, error)

	// PostSearchUsageGroupsWithBodyWithResponse request with any body
	PostSearchUsageGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchUsageGroupsResponse, error)

	PostSearchUsageGroupsWithResponse(ctx context.Context, body PostSearchUsageGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchUsageGroupsResponse, error)

	// DeleteSearchUsageGroupsIdWithResponse request
	DeleteSearchUsageGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchUsageGroupsIdResponse, error)

	// GetSearchUsageGroupsIdWithResponse request
	GetSearchUsageGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchUsageGroupsIdResponse, error)

	// PatchSearchUsageGroupsIdWithBodyWithResponse request with any body
	PatchSearchUsageGroupsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchUsageGroupsIdResponse, error)

	PatchSearchUsageGroupsIdWithResponse(ctx context.Context, id string, body PatchSearchUsageGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchUsageGroupsIdResponse, error)

	// GetSecurityKmsConfigWithResponse request
	GetSecurityKmsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityKmsConfigResponse, error)

	// PatchSecurityKmsConfigWithBodyWithResponse request with any body
	PatchSecurityKmsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSecurityKmsConfigResponse, error)

	PatchSecurityKmsConfigWithResponse(ctx context.Context, body PatchSecurityKmsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSecurityKmsConfigResponse, error)

	// GetSecurityKmsHealthWithResponse request
	GetSecurityKmsHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityKmsHealthResponse, error)

	// GetSettingsFeaturesWithResponse request
	GetSettingsFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsFeaturesResponse, error)

	// GetSettingsFeaturesIdWithResponse request
	GetSettingsFeaturesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSettingsFeaturesIdResponse, error)

	// GetSystemBannersWithResponse request
	GetSystemBannersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemBannersResponse, error)

	// PostSystemBannersWithBodyWithResponse request with any body
	PostSystemBannersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemBannersResponse, error)

	PostSystemBannersWithResponse(ctx context.Context, body PostSystemBannersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemBannersResponse, error)

	// DeleteSystemBannersIdWithResponse request
	DeleteSystemBannersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemBannersIdResponse, error)

	// GetSystemBannersIdWithResponse request
	GetSystemBannersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemBannersIdResponse, error)

	// PatchSystemBannersIdWithBodyWithResponse request with any body
	PatchSystemBannersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemBannersIdResponse, error)

	PatchSystemBannersIdWithResponse(ctx context.Context, id string, body PatchSystemBannersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemBannersIdResponse, error)

	// PostSystemCaptureWithBodyWithResponse request with any body
	PostSystemCaptureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemCaptureResponse, error)

	PostSystemCaptureWithResponse(ctx context.Context, body PostSystemCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemCaptureResponse, error)

	// GetSystemCertificatesWithResponse request
	GetSystemCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemCertificatesResponse, error)

	// PostSystemCertificatesWithBodyWithResponse request with any body
	PostSystemCertificatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemCertificatesResponse, error)

	PostSystemCertificatesWithResponse(ctx context.Context, body PostSystemCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemCertificatesResponse, error)

	// DeleteSystemCertificatesIdWithResponse request
	DeleteSystemCertificatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemCertificatesIdResponse, error)

	// GetSystemCertificatesIdWithResponse request
	GetSystemCertificatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemCertificatesIdResponse, error)

	// PatchSystemCertificatesIdWithBodyWithResponse request with any body
	PatchSystemCertificatesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemCertificatesIdResponse, error)

	PatchSystemCertificatesIdWithResponse(ctx context.Context, id string, body PatchSystemCertificatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemCertificatesIdResponse, error)

	// DeleteSystemDiagWithResponse request
	DeleteSystemDiagWithResponse(ctx context.Context, params *DeleteSystemDiagParams, reqEditors ...RequestEditorFn) (*DeleteSystemDiagResponse, error)

	// GetSystemDiagWithResponse request
	GetSystemDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemDiagResponse, error)

	// GetSystemDiagDownloadWithResponse request
	GetSystemDiagDownloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemDiagDownloadResponse, error)

	// PostSystemDiagSendWithBodyWithResponse request with any body
	PostSystemDiagSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemDiagSendResponse, error)

	PostSystemDiagSendWithResponse(ctx context.Context, body PostSystemDiagSendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemDiagSendResponse, error)

	// PostSystemDistributedUpgradeCancelGroupWithResponse request
	PostSystemDistributedUpgradeCancelGroupWithResponse(ctx context.Context, group string, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeCancelGroupResponse, error)

	// GetSystemDistributedUpgradeDownloadFileWithResponse request
	GetSystemDistributedUpgradeDownloadFileWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*GetSystemDistributedUpgradeDownloadFileResponse, error)

	// PostSystemDistributedUpgradeStageGroupWithResponse request
	PostSystemDistributedUpgradeStageGroupWithResponse(ctx context.Context, group string, params *PostSystemDistributedUpgradeStageGroupParams, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeStageGroupResponse, error)

	// PostSystemDistributedUpgradeGroupWithBodyWithResponse request with any body
	PostSystemDistributedUpgradeGroupWithBodyWithResponse(ctx context.Context, group string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeGroupResponse, error)

	PostSystemDistributedUpgradeGroupWithResponse(ctx context.Context, group string, body PostSystemDistributedUpgradeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeGroupResponse, error)

	// GetSystemInfoWithResponse request
	GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error)

	// GetSystemInputsWithResponse request
	GetSystemInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInputsResponse, error)

	// PostSystemInputsWithBodyWithResponse request with any body
	PostSystemInputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemInputsResponse, error)

	PostSystemInputsWithResponse(ctx context.Context, body PostSystemInputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemInputsResponse, error)

	// DeleteSystemInputsIdWithResponse request
	DeleteSystemInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemInputsIdResponse, error)

	// GetSystemInputsIdWithResponse request
	GetSystemInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemInputsIdResponse, error)

	// PatchSystemInputsIdWithBodyWithResponse request with any body
	PatchSystemInputsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdResponse, error)

	PatchSystemInputsIdWithResponse(ctx context.Context, id string, body PatchSystemInputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdResponse, error)

	// PostSystemInputsIdHectokenWithBodyWithResponse request with any body
	PostSystemInputsIdHectokenWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemInputsIdHectokenResponse, error)

	PostSystemInputsIdHectokenWithResponse(ctx context.Context, id string, body PostSystemInputsIdHectokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemInputsIdHectokenResponse, error)

	// PatchSystemInputsIdHectokenTokenWithBodyWithResponse request with any body
	PatchSystemInputsIdHectokenTokenWithBodyWithResponse(ctx context.Context, id string, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdHectokenTokenResponse, error)

	PatchSystemInputsIdHectokenTokenWithResponse(ctx context.Context, id string, token string, body PatchSystemInputsIdHectokenTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdHectokenTokenResponse, error)

	// GetSystemJobsLogsIdGroupIdWithResponse request
	GetSystemJobsLogsIdGroupIdWithResponse(ctx context.Context, id string, groupId string, params *GetSystemJobsLogsIdGroupIdParams, reqEditors ...RequestEditorFn) (*GetSystemJobsLogsIdGroupIdResponse, error)

	// GetSystemKeysWithResponse request
	GetSystemKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemKeysResponse, error)

	// PostSystemKeysWithBodyWithResponse request with any body
	PostSystemKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemKeysResponse, error)

	PostSystemKeysWithResponse(ctx context.Context, body PostSystemKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemKeysResponse, error)

	// DeleteSystemKeysIdWithResponse request
	DeleteSystemKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemKeysIdResponse, error)

	// GetSystemKeysIdWithResponse request
	GetSystemKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemKeysIdResponse, error)

	// PatchSystemKeysIdWithBodyWithResponse request with any body
	PatchSystemKeysIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemKeysIdResponse, error)

	PatchSystemKeysIdWithResponse(ctx context.Context, id string, body PatchSystemKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemKeysIdResponse, error)

	// GetSystemLicensesWithResponse request
	GetSystemLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensesResponse, error)

	// PostSystemLicensesWithBodyWithResponse request with any body
	PostSystemLicensesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemLicensesResponse, error)

	PostSystemLicensesWithResponse(ctx context.Context, body PostSystemLicensesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemLicensesResponse, error)

	// GetSystemLicensesUsageWithResponse request
	GetSystemLicensesUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensesUsageResponse, error)

	// DeleteSystemLicensesIdWithResponse request
	DeleteSystemLicensesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLicensesIdResponse, error)

	// GetSystemLicensesIdWithResponse request
	GetSystemLicensesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLicensesIdResponse, error)

	// GetSystemLoggerWithResponse request
	GetSystemLoggerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLoggerResponse, error)

	// DeleteSystemLoggerIdWithResponse request
	DeleteSystemLoggerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLoggerIdResponse, error)

	// GetSystemLoggerIdWithResponse request
	GetSystemLoggerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLoggerIdResponse, error)

	// PatchSystemLoggerIdWithBodyWithResponse request with any body
	PatchSystemLoggerIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemLoggerIdResponse, error)

	PatchSystemLoggerIdWithResponse(ctx context.Context, id string, body PatchSystemLoggerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemLoggerIdResponse, error)

	// GetSystemLogsWithResponse request
	GetSystemLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLogsResponse, error)

	// GetSystemLogsSearchWithResponse request
	GetSystemLogsSearchWithResponse(ctx context.Context, params *GetSystemLogsSearchParams, reqEditors ...RequestEditorFn) (*GetSystemLogsSearchResponse, error)

	// GetSystemLogsIdWithResponse request
	GetSystemLogsIdWithResponse(ctx context.Context, id string, params *GetSystemLogsIdParams, reqEditors ...RequestEditorFn) (*GetSystemLogsIdResponse, error)

	// GetSystemLookupsWithResponse request
	GetSystemLookupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLookupsResponse, error)

	// PostSystemLookupsWithBodyWithResponse request with any body
	PostSystemLookupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemLookupsResponse, error)

	PostSystemLookupsWithResponse(ctx context.Context, body PostSystemLookupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemLookupsResponse, error)

	// PutSystemLookupsWithBodyWithResponse request with any body
	PutSystemLookupsWithBodyWithResponse(ctx context.Context, params *PutSystemLookupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSystemLookupsResponse, error)

	// DeleteSystemLookupsIdWithResponse request
	DeleteSystemLookupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLookupsIdResponse, error)

	// GetSystemLookupsIdWithResponse request
	GetSystemLookupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLookupsIdResponse, error)

	// PatchSystemLookupsIdWithBodyWithResponse request with any body
	PatchSystemLookupsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemLookupsIdResponse, error)

	PatchSystemLookupsIdWithResponse(ctx context.Context, id string, body PatchSystemLookupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemLookupsIdResponse, error)

	// GetSystemMessagesWithResponse request
	GetSystemMessagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemMessagesResponse, error)

	// PostSystemMessagesWithBodyWithResponse request with any body
	PostSystemMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMessagesResponse, error)

	PostSystemMessagesWithResponse(ctx context.Context, body PostSystemMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMessagesResponse, error)

	// DeleteSystemMessagesIdWithResponse request
	DeleteSystemMessagesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemMessagesIdResponse, error)

	// GetSystemMessagesIdWithResponse request
	GetSystemMessagesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemMessagesIdResponse, error)

	// GetSystemMetricsWithResponse request
	GetSystemMetricsWithResponse(ctx context.Context, params *GetSystemMetricsParams, reqEditors ...RequestEditorFn) (*GetSystemMetricsResponse, error)

	// PostSystemMetricsEnumWithBodyWithResponse request with any body
	PostSystemMetricsEnumWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMetricsEnumResponse, error)

	PostSystemMetricsEnumWithResponse(ctx context.Context, body PostSystemMetricsEnumJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMetricsEnumResponse, error)

	// PostSystemMetricsQueryWithBodyWithResponse request with any body
	PostSystemMetricsQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMetricsQueryResponse, error)

	PostSystemMetricsQueryWithResponse(ctx context.Context, body PostSystemMetricsQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMetricsQueryResponse, error)

	// GetSystemOutputsWithResponse request
	GetSystemOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemOutputsResponse, error)

	// PostSystemOutputsWithBodyWithResponse request with any body
	PostSystemOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemOutputsResponse, error)

	PostSystemOutputsWithResponse(ctx context.Context, body PostSystemOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemOutputsResponse, error)

	// DeleteSystemOutputsIdWithResponse request
	DeleteSystemOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemOutputsIdResponse, error)

	// GetSystemOutputsIdWithResponse request
	GetSystemOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdResponse, error)

	// PatchSystemOutputsIdWithBodyWithResponse request with any body
	PatchSystemOutputsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemOutputsIdResponse, error)

	PatchSystemOutputsIdWithResponse(ctx context.Context, id string, body PatchSystemOutputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemOutputsIdResponse, error)

	// DeleteSystemOutputsIdPqWithResponse request
	DeleteSystemOutputsIdPqWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemOutputsIdPqResponse, error)

	// GetSystemOutputsIdPqWithResponse request
	GetSystemOutputsIdPqWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdPqResponse, error)

	// GetSystemOutputsIdSamplesWithResponse request
	GetSystemOutputsIdSamplesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdSamplesResponse, error)

	// PostSystemOutputsIdTestWithBodyWithResponse request with any body
	PostSystemOutputsIdTestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemOutputsIdTestResponse, error)

	PostSystemOutputsIdTestWithResponse(ctx context.Context, id string, body PostSystemOutputsIdTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemOutputsIdTestResponse, error)

	// GetSystemPoliciesWithResponse request
	GetSystemPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemPoliciesResponse, error)

	// PostSystemPoliciesWithBodyWithResponse request with any body
	PostSystemPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemPoliciesResponse, error)

	PostSystemPoliciesWithResponse(ctx context.Context, body PostSystemPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemPoliciesResponse, error)

	// DeleteSystemPoliciesIdWithResponse request
	DeleteSystemPoliciesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemPoliciesIdResponse, error)

	// GetSystemPoliciesIdWithResponse request
	GetSystemPoliciesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemPoliciesIdResponse, error)

	// PatchSystemPoliciesIdWithBodyWithResponse request with any body
	PatchSystemPoliciesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemPoliciesIdResponse, error)

	PatchSystemPoliciesIdWithResponse(ctx context.Context, id string, body PatchSystemPoliciesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemPoliciesIdResponse, error)

	// GetSystemProcessesWithResponse request
	GetSystemProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProcessesResponse, error)

	// GetSystemProfilerWithResponse request
	GetSystemProfilerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProfilerResponse, error)

	// PostSystemProfilerWithBodyWithResponse request with any body
	PostSystemProfilerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProfilerResponse, error)

	PostSystemProfilerWithResponse(ctx context.Context, body PostSystemProfilerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProfilerResponse, error)

	// DeleteSystemProfilerIdWithResponse request
	DeleteSystemProfilerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemProfilerIdResponse, error)

	// GetSystemProfilerIdWithResponse request
	GetSystemProfilerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProfilerIdResponse, error)

	// PatchSystemProfilerIdWithBodyWithResponse request with any body
	PatchSystemProfilerIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemProfilerIdResponse, error)

	PatchSystemProfilerIdWithResponse(ctx context.Context, id string, body PatchSystemProfilerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemProfilerIdResponse, error)

	// GetSystemProjectsWithResponse request
	GetSystemProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProjectsResponse, error)

	// PostSystemProjectsWithBodyWithResponse request with any body
	PostSystemProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsResponse, error)

	PostSystemProjectsWithResponse(ctx context.Context, body PostSystemProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsResponse, error)

	// DeleteSystemProjectsIdWithResponse request
	DeleteSystemProjectsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemProjectsIdResponse, error)

	// GetSystemProjectsIdWithResponse request
	GetSystemProjectsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdResponse, error)

	// PatchSystemProjectsIdWithBodyWithResponse request with any body
	PatchSystemProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemProjectsIdResponse, error)

	PatchSystemProjectsIdWithResponse(ctx context.Context, id string, body PatchSystemProjectsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemProjectsIdResponse, error)

	// GetSystemProjectsIdAclWithResponse request
	GetSystemProjectsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdAclResponse, error)

	// PostSystemProjectsIdAclApplyWithBodyWithResponse request with any body
	PostSystemProjectsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclApplyResponse, error)

	PostSystemProjectsIdAclApplyWithResponse(ctx context.Context, id string, body PostSystemProjectsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclApplyResponse, error)

	// GetSystemProjectsIdAclTeamsWithResponse request
	GetSystemProjectsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdAclTeamsResponse, error)

	// PostSystemProjectsIdAclTeamsApplyWithBodyWithResponse request with any body
	PostSystemProjectsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclTeamsApplyResponse, error)

	PostSystemProjectsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSystemProjectsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclTeamsApplyResponse, error)

	// PostSystemProjectsProjectIdCaptureWithBodyWithResponse request with any body
	PostSystemProjectsProjectIdCaptureWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdCaptureResponse, error)

	PostSystemProjectsProjectIdCaptureWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdCaptureResponse, error)

	// GetSystemProjectsProjectIdDestinationsWithResponse request
	GetSystemProjectsProjectIdDestinationsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdDestinationsResponse, error)

	// GetSystemProjectsProjectIdSubscriptionsWithResponse request
	GetSystemProjectsProjectIdSubscriptionsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdSubscriptionsResponse, error)

	// PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse request with any body
	PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse(ctx context.Context, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error)

	PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse(ctx context.Context, projectId string, subscriptionId string, body PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error)

	// PostSystemProjectsProjectIdVersionCommitWithBodyWithResponse request with any body
	PostSystemProjectsProjectIdVersionCommitWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionCommitResponse, error)

	PostSystemProjectsProjectIdVersionCommitWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionCommitResponse, error)

	// GetSystemProjectsProjectIdVersionCountWithResponse request
	GetSystemProjectsProjectIdVersionCountWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionCountParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionCountResponse, error)

	// GetSystemProjectsProjectIdVersionDiffWithResponse request
	GetSystemProjectsProjectIdVersionDiffWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionDiffResponse, error)

	// GetSystemProjectsProjectIdVersionFilesWithResponse request
	GetSystemProjectsProjectIdVersionFilesWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionFilesParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionFilesResponse, error)

	// PostSystemProjectsProjectIdVersionRevertWithBodyWithResponse request with any body
	PostSystemProjectsProjectIdVersionRevertWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionRevertResponse, error)

	PostSystemProjectsProjectIdVersionRevertWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionRevertResponse, error)

	// GetSystemProjectsProjectIdVersionShowWithResponse request
	GetSystemProjectsProjectIdVersionShowWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionShowParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionShowResponse, error)

	// GetSystemRolesWithResponse request
	GetSystemRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemRolesResponse, error)

	// PostSystemRolesWithBodyWithResponse request with any body
	PostSystemRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemRolesResponse, error)

	PostSystemRolesWithResponse(ctx context.Context, body PostSystemRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemRolesResponse, error)

	// DeleteSystemRolesIdWithResponse request
	DeleteSystemRolesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemRolesIdResponse, error)

	// GetSystemRolesIdWithResponse request
	GetSystemRolesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemRolesIdResponse, error)

	// PatchSystemRolesIdWithBodyWithResponse request with any body
	PatchSystemRolesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemRolesIdResponse, error)

	PatchSystemRolesIdWithResponse(ctx context.Context, id string, body PatchSystemRolesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemRolesIdResponse, error)

	// GetSystemSamplesWithResponse request
	GetSystemSamplesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSamplesResponse, error)

	// PostSystemSamplesWithBodyWithResponse request with any body
	PostSystemSamplesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSamplesResponse, error)

	PostSystemSamplesWithResponse(ctx context.Context, body PostSystemSamplesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSamplesResponse, error)

	// DeleteSystemSamplesIdWithResponse request
	DeleteSystemSamplesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSamplesIdResponse, error)

	// GetSystemSamplesIdWithResponse request
	GetSystemSamplesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSamplesIdResponse, error)

	// PatchSystemSamplesIdWithBodyWithResponse request with any body
	PatchSystemSamplesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSamplesIdResponse, error)

	PatchSystemSamplesIdWithResponse(ctx context.Context, id string, body PatchSystemSamplesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSamplesIdResponse, error)

	// GetSystemSamplesIdContentWithResponse request
	GetSystemSamplesIdContentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSamplesIdContentResponse, error)

	// GetSystemScriptsWithResponse request
	GetSystemScriptsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemScriptsResponse, error)

	// PostSystemScriptsWithBodyWithResponse request with any body
	PostSystemScriptsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemScriptsResponse, error)

	PostSystemScriptsWithResponse(ctx context.Context, body PostSystemScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemScriptsResponse, error)

	// DeleteSystemScriptsIdWithResponse request
	DeleteSystemScriptsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemScriptsIdResponse, error)

	// GetSystemScriptsIdWithResponse request
	GetSystemScriptsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemScriptsIdResponse, error)

	// PatchSystemScriptsIdWithBodyWithResponse request with any body
	PatchSystemScriptsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemScriptsIdResponse, error)

	PatchSystemScriptsIdWithResponse(ctx context.Context, id string, body PatchSystemScriptsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemScriptsIdResponse, error)

	// GetSystemSecretsWithResponse request
	GetSystemSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSecretsResponse, error)

	// PostSystemSecretsWithBodyWithResponse request with any body
	PostSystemSecretsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSecretsResponse, error)

	PostSystemSecretsWithResponse(ctx context.Context, body PostSystemSecretsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSecretsResponse, error)

	// DeleteSystemSecretsIdWithResponse request
	DeleteSystemSecretsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSecretsIdResponse, error)

	// GetSystemSecretsIdWithResponse request
	GetSystemSecretsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSecretsIdResponse, error)

	// PatchSystemSecretsIdWithBodyWithResponse request with any body
	PatchSystemSecretsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSecretsIdResponse, error)

	PatchSystemSecretsIdWithResponse(ctx context.Context, id string, body PatchSystemSecretsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSecretsIdResponse, error)

	// GetSystemSettingsWithResponse request
	GetSystemSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsResponse, error)

	// PatchSystemSettingsWithResponse request
	PatchSystemSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsResponse, error)

	// GetSystemSettingsAuthWithResponse request
	GetSystemSettingsAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsAuthResponse, error)

	// PatchSystemSettingsAuthWithResponse request
	PatchSystemSettingsAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsAuthResponse, error)

	// GetSystemSettingsConfWithResponse request
	GetSystemSettingsConfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsConfResponse, error)

	// PatchSystemSettingsConfWithBodyWithResponse request with any body
	PatchSystemSettingsConfWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSettingsConfResponse, error)

	PatchSystemSettingsConfWithResponse(ctx context.Context, body PatchSystemSettingsConfJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSettingsConfResponse, error)

	// GetSystemSettingsCriblWithResponse request
	GetSystemSettingsCriblWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsCriblResponse, error)

	// GetSystemSettingsGitSettingsWithResponse request
	GetSystemSettingsGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsGitSettingsResponse, error)

	// PatchSystemSettingsGitSettingsWithResponse request
	PatchSystemSettingsGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsGitSettingsResponse, error)

	// PostSystemSettingsReloadWithResponse request
	PostSystemSettingsReloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSettingsReloadResponse, error)

	// PostSystemSettingsRestartWithResponse request
	PostSystemSettingsRestartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSettingsRestartResponse, error)

	// GetSystemSettingsSearchLimitsWithResponse request
	GetSystemSettingsSearchLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsSearchLimitsResponse, error)

	// GetSystemSettingsUpgradeWithResponse request
	GetSystemSettingsUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsUpgradeResponse, error)

	// PostSystemSettingsUpgradeFromPackageWithBodyWithResponse request with any body
	PostSystemSettingsUpgradeFromPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeFromPackageResponse, error)

	PostSystemSettingsUpgradeFromPackageWithResponse(ctx context.Context, body PostSystemSettingsUpgradeFromPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeFromPackageResponse, error)

	// PostSystemSettingsUpgradeVersionWithResponse request
	PostSystemSettingsUpgradeVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeVersionResponse, error)

	// GetSystemStatusInputsWithResponse request
	GetSystemStatusInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusInputsResponse, error)

	// GetSystemStatusInputsIdWithResponse request
	GetSystemStatusInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemStatusInputsIdResponse, error)

	// GetSystemStatusOutputsWithResponse request
	GetSystemStatusOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusOutputsResponse, error)

	// GetSystemStatusOutputsIdWithResponse request
	GetSystemStatusOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemStatusOutputsIdResponse, error)

	// GetSystemSubscriptionsWithResponse request
	GetSystemSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSubscriptionsResponse, error)

	// PostSystemSubscriptionsWithResponse request
	PostSystemSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSubscriptionsResponse, error)

	// DeleteSystemSubscriptionsIdWithResponse request
	DeleteSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSubscriptionsIdResponse, error)

	// GetSystemSubscriptionsIdWithResponse request
	GetSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSubscriptionsIdResponse, error)

	// PatchSystemSubscriptionsIdWithResponse request
	PatchSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchSystemSubscriptionsIdResponse, error)

	// GetSystemTeamsWithResponse request
	GetSystemTeamsWithResponse(ctx context.Context, params *GetSystemTeamsParams, reqEditors ...RequestEditorFn) (*GetSystemTeamsResponse, error)

	// PostSystemTeamsWithBodyWithResponse request with any body
	PostSystemTeamsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemTeamsResponse, error)

	PostSystemTeamsWithResponse(ctx context.Context, body PostSystemTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemTeamsResponse, error)

	// GetSystemTeamsUsersIdRolesWithResponse request
	GetSystemTeamsUsersIdRolesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsUsersIdRolesResponse, error)

	// DeleteSystemTeamsIdWithResponse request
	DeleteSystemTeamsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemTeamsIdResponse, error)

	// GetSystemTeamsIdWithResponse request
	GetSystemTeamsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdResponse, error)

	// PatchSystemTeamsIdWithBodyWithResponse request with any body
	PatchSystemTeamsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemTeamsIdResponse, error)

	PatchSystemTeamsIdWithResponse(ctx context.Context, id string, body PatchSystemTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemTeamsIdResponse, error)

	// GetSystemTeamsIdAclWithResponse request
	GetSystemTeamsIdAclWithResponse(ctx context.Context, id string, params *GetSystemTeamsIdAclParams, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdAclResponse, error)

	// GetSystemTeamsIdUsersWithResponse request
	GetSystemTeamsIdUsersWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdUsersResponse, error)

	// PostSystemTeamsIdUsersWithBodyWithResponse request with any body
	PostSystemTeamsIdUsersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemTeamsIdUsersResponse, error)

	PostSystemTeamsIdUsersWithResponse(ctx context.Context, id string, body PostSystemTeamsIdUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemTeamsIdUsersResponse, error)

	// GetSystemUsersWithResponse request
	GetSystemUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemUsersResponse, error)

	// PostSystemUsersWithBodyWithResponse request with any body
	PostSystemUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemUsersResponse, error)

	PostSystemUsersWithResponse(ctx context.Context, body PostSystemUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemUsersResponse, error)

	// DeleteSystemUsersIdWithResponse request
	DeleteSystemUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemUsersIdResponse, error)

	// GetSystemUsersIdWithResponse request
	GetSystemUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemUsersIdResponse, error)

	// PatchSystemUsersIdWithBodyWithResponse request with any body
	PatchSystemUsersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdResponse, error)

	PatchSystemUsersIdWithResponse(ctx context.Context, id string, body PatchSystemUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdResponse, error)

	// PatchSystemUsersIdInfoWithBodyWithResponse request with any body
	PatchSystemUsersIdInfoWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdInfoResponse, error)

	PatchSystemUsersIdInfoWithResponse(ctx context.Context, id string, body PatchSystemUsersIdInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdInfoResponse, error)

	// GetUiKeyWithResponse request
	GetUiKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetUiKeyResponse, error)

	// PatchUiKeyWithBodyWithResponse request with any body
	PatchUiKeyWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUiKeyResponse, error)

	PatchUiKeyWithResponse(ctx context.Context, key string, body PatchUiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUiKeyResponse, error)

	// GetVersionBranchWithResponse request
	GetVersionBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionBranchResponse, error)

	// PostVersionCommitWithBodyWithResponse request with any body
	PostVersionCommitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVersionCommitResponse, error)

	PostVersionCommitWithResponse(ctx context.Context, body PostVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVersionCommitResponse, error)

	// GetVersionCountWithResponse request
	GetVersionCountWithResponse(ctx context.Context, params *GetVersionCountParams, reqEditors ...RequestEditorFn) (*GetVersionCountResponse, error)

	// GetVersionCurrentBranchWithResponse request
	GetVersionCurrentBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionCurrentBranchResponse, error)

	// GetVersionDiffWithResponse request
	GetVersionDiffWithResponse(ctx context.Context, params *GetVersionDiffParams, reqEditors ...RequestEditorFn) (*GetVersionDiffResponse, error)

	// GetVersionFilesWithResponse request
	GetVersionFilesWithResponse(ctx context.Context, params *GetVersionFilesParams, reqEditors ...RequestEditorFn) (*GetVersionFilesResponse, error)

	// GetVersionInfoWithResponse request
	GetVersionInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionInfoResponse, error)

	// PostVersionPushWithResponse request
	PostVersionPushWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostVersionPushResponse, error)

	// PostVersionRevertWithBodyWithResponse request with any body
	PostVersionRevertWithBodyWithResponse(ctx context.Context, params *PostVersionRevertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVersionRevertResponse, error)

	PostVersionRevertWithResponse(ctx context.Context, params *PostVersionRevertParams, body PostVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVersionRevertResponse, error)

	// GetVersionShowWithResponse request
	GetVersionShowWithResponse(ctx context.Context, params *GetVersionShowParams, reqEditors ...RequestEditorFn) (*GetVersionShowResponse, error)

	// GetVersionStatusWithResponse request
	GetVersionStatusWithResponse(ctx context.Context, params *GetVersionStatusParams, reqEditors ...RequestEditorFn) (*GetVersionStatusResponse, error)

	// PostVersionSyncWithResponse request
	PostVersionSyncWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostVersionSyncResponse, error)

	// PostVersionUndoWithResponse request
	PostVersionUndoWithResponse(ctx context.Context, params *PostVersionUndoParams, reqEditors ...RequestEditorFn) (*PostVersionUndoResponse, error)
}

type GetAiConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetAiConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAiConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostAiConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAiConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthAuthorizationCodeCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAuthAuthorizationCodeCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthAuthorizationCodeCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]CrudEntityBase `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
}

// Status returns HTTPResponse.Status
func (r PostAuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAuthLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *string
}

// Status returns HTTPResponse.Status
func (r GetAuthMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthMultiFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]MultiFactorAuthSchema `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthMultiFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthMultiFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthSloResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAuthSloResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthSloResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthSloCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAuthSloCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthSloCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthSloCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAuthSloCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthSloCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthSsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RedirectInfo
}

// Status returns HTTPResponse.Status
func (r GetAuthSsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthSsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthSsoCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAuthSsoCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthSsoCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthSsoCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAuthSsoCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthSsoCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthUsersIdTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAuthUsersIdTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthUsersIdTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AuthPolicyEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthorizePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorizeRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthorizeRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorizeRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangelogViewedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ChangelogState `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetChangelogViewedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangelogViewedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchChangelogViewedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ChangelogState `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchChangelogViewedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchChangelogViewedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCluiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]CluiItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetCluiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCluiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Collector `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetCollectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Collector `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetCollectorsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Condition `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConditionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Condition `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetConditionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConditionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeAppscopeProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AppScopeProcess `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeAppscopeProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeAppscopeProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEdgeAppscopeProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AppScopeProcess `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostEdgeAppscopeProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEdgeAppscopeProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEdgeAppscopeProcessesPidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AppScopeProcess `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEdgeAppscopeProcessesPidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEdgeAppscopeProcessesPidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeAppscopeProcessesPidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AppScopeProcess `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeAppscopeProcessesPidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeAppscopeProcessesPidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutEdgeAppscopeProcessesPidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]AppScopeProcess `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PutEdgeAppscopeProcessesPidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutEdgeAppscopeProcessesPidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Container `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeContainersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]Container `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeContainersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeContainersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeEventsCollectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeEventsCollectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeEventsCollectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeEventsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeEventsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeEventsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEdgeFileIngestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostEdgeFileIngestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEdgeFileIngestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeFileSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SampleFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeFileSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeFileSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeFileinspectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                       `json:"count,omitempty"`
		Items *[]EdgeFileInspectResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeFileinspectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeFileinspectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEdgeKubeLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Object `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostEdgeKubeLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEdgeKubeLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeKubeProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Object `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeKubeProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeKubeProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]EdgeFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeLsPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]FilesystemEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeLsPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeLsPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Metadata `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Process `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEdgeProcessesPidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Process `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetEdgeProcessesPidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEdgeProcessesPidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExecutorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Executor `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetExecutorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExecutorsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Executor `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetExecutorsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutorsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Function `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Function `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetFunctionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceHealthStatus
	JSON420      *ServiceHealthStatus
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items the pre-limited items in the list of results
		Items *[]JobInfo `json:"items,omitempty"`

		// Limit number of items present in the items array
		Limit *int `json:"limit,omitempty"`

		// Offset pagination offset
		Offset *int `json:"offset,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]JobInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchJobsIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]JobState `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchJobsIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchJobsIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsIdErrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetJobsIdErrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsIdErrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsIdErrorsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetJobsIdErrorsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsIdErrorsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchJobsIdKeepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]JobInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchJobsIdKeepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchJobsIdKeepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchJobsIdPauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]JobState `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchJobsIdPauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchJobsIdPauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsIdResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJobsIdResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsIdResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsIdResultsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetJobsIdResultsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsIdResultsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchJobsIdResumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]JobState `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchJobsIdResumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchJobsIdResumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibAppscopeConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]AppscopeLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibAppscopeConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibAppscopeConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibAppscopeConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]AppscopeLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibAppscopeConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibAppscopeConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibAppscopeConfigsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]AppscopeLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibAppscopeConfigsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibAppscopeConfigsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibAppscopeConfigsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]AppscopeLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibAppscopeConfigsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibAppscopeConfigsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibAppscopeConfigsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]AppscopeLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibAppscopeConfigsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibAppscopeConfigsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibBreakersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]EventBreakerRuleset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibBreakersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibBreakersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibBreakersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]EventBreakerRuleset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibBreakersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibBreakersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibBreakersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]EventBreakerRuleset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibBreakersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibBreakersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibBreakersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]EventBreakerRuleset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibBreakersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibBreakersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibBreakersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]EventBreakerRuleset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibBreakersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibBreakersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibDatabaseConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                        `json:"count,omitempty"`
		Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibDatabaseConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibDatabaseConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibDatabaseConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                        `json:"count,omitempty"`
		Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibDatabaseConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibDatabaseConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibDatabaseConnectionsTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                            `json:"count,omitempty"`
		Items *[]DatabaseConnectionTestResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibDatabaseConnectionsTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibDatabaseConnectionsTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibDatabaseConnectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                        `json:"count,omitempty"`
		Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibDatabaseConnectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibDatabaseConnectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibDatabaseConnectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                        `json:"count,omitempty"`
		Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibDatabaseConnectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibDatabaseConnectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibDatabaseConnectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                        `json:"count,omitempty"`
		Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibDatabaseConnectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibDatabaseConnectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibExpressionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ExprLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibExpressionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibExpressionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibGrokResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]GrokFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibGrokResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibGrokResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibGrokResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]GrokFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibGrokResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibGrokResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibGrokIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]GrokFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibGrokIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibGrokIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibGrokIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]GrokFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibGrokIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibGrokIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibGrokIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]GrokFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibGrokIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibGrokIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibHmacFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]HmacFunction `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibHmacFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibHmacFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibHmacFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]HmacFunction `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibHmacFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibHmacFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibHmacFunctionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]HmacFunction `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibHmacFunctionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibHmacFunctionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibHmacFunctionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]HmacFunction `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibHmacFunctionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibHmacFunctionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibHmacFunctionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]HmacFunction `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibHmacFunctionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibHmacFunctionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]SavedJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]SavedJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]SavedJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]SavedJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]SavedJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibParquetSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibParquetSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibParquetSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibParquetSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibParquetSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibParquetSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibParquetSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibParquetSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibParquetSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibParquetSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibParquetSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibParquetSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibParquetSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibParquetSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibParquetSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibParsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ParserLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibParsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibParsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibParsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ParserLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibParsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibParsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibParsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ParserLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibParsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibParsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibParsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ParserLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibParsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibParsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibParsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ParserLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibParsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibParsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibProtobufLibrariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibProtobufLibrariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibProtobufLibrariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibProtobufLibrariesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]ProtobufLibraryConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibProtobufLibrariesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibProtobufLibrariesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibProtobufLibrariesIdEncodingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibProtobufLibrariesIdEncodingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibProtobufLibrariesIdEncodingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibProtobufLibrariesIdEncodingsEncidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibProtobufLibrariesIdEncodingsEncidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibProtobufLibrariesIdEncodingsEncidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibRegexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]RegexLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibRegexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibRegexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibRegexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]RegexLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibRegexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibRegexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibRegexIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]RegexLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibRegexIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibRegexIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibRegexIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]RegexLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibRegexIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibRegexIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibRegexIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]RegexLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibRegexIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibRegexIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibVarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibVarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibVarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLibVarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostLibVarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLibVarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMGroupIdSystemProjectsProjectIdCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostMGroupIdSystemProjectsProjectIdCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMGroupIdSystemProjectsProjectIdCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMGroupIdSystemProjectsProjectIdPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostMGroupIdSystemProjectsProjectIdPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMGroupIdSystemProjectsProjectIdPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMGroupIdSystemProjectsProjectIdPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostMGroupIdSystemProjectsProjectIdPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMGroupIdSystemProjectsProjectIdPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMGroupIdSystemProjectsProjectIdVersionCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitCommitSummary `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostMGroupIdSystemProjectsProjectIdVersionCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMGroupIdSystemProjectsProjectIdVersionCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdVersionCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdVersionCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdVersionCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdVersionDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdVersionDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdVersionDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMGroupIdSystemProjectsProjectIdVersionFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count Number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitFilesResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMGroupIdSystemProjectsProjectIdVersionFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMGroupIdSystemProjectsProjectIdVersionFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterBundlesGroupVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMasterBundlesGroupVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterBundlesGroupVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]ConfigGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterGroupsIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterGroupsIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterGroupsIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterGroupsIdConfigVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterGroupsIdConfigVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterGroupsIdConfigVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMasterGroupsIdDeployResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]ConfigGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchMasterGroupsIdDeployResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMasterGroupsIdDeployResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]DistributedSummary `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterSummaryWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]float32 `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterSummaryWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterSummaryWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]MasterWorkerEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetMasterWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchMasterWorkersRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]RestartResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchMasterWorkersRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchMasterWorkersRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]NotificationTarget `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNotificationTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]NotificationTarget `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostNotificationTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNotificationTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationTargetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]NotificationTarget `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationTargetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationTargetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationTargetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]NotificationTarget `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationTargetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationTargetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchNotificationTargetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]NotificationTarget `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchNotificationTargetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchNotificationTargetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Notification `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Notification `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Notification `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Notification `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchNotificationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Notification `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchNotificationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchNotificationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOutputClickHouseDescribeTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                           `json:"count,omitempty"`
		Items *[]ClickHouseDescriptionResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostOutputClickHouseDescribeTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOutputClickHouseDescribeTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackFunctionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Function `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackFunctionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackFunctionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackFunctionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Function `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackFunctionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackFunctionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackLibSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackLibSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackLibSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPPackLibSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPPackLibSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPPackLibSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePPackLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePPackLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePPackLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPPackLibSchemasIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SchemaLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPPackLibSchemasIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPPackLibSchemasIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackLibVarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackLibVarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackLibVarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPPackLibVarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPPackLibVarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPPackLibVarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePPackLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePPackLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePPackLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPPackLibVarsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]GlobalVar `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPPackLibVarsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPPackLibVarsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPPackPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPPackPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPPackPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePPackPipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePPackPipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePPackPipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackPipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackPipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackPipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPPackPipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPPackPipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPPackPipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackRoutesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackRoutesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackRoutesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPPackRoutesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPPackRoutesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPPackRoutesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPPackRoutesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPPackRoutesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPPackRoutesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPPackRoutesIdAppendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPPackRoutesIdAppendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPPackRoutesIdAppendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]PackInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]PackInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PutPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPacksCloneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPacksCloneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPacksCloneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePacksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]PackInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePacksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePacksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPacksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]PackInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPacksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPacksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPacksIdExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPacksIdExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPacksIdExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPipelinesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int        `json:"count,omitempty"`
		Items *[]Pipeline `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchPipelinesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPipelinesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsEdgeMapQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]EdgeMapQueryResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostProductsEdgeMapQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsEdgeMapQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsLakeLakesLakeIdDatasetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]CriblLakeDataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsLakeLakesLakeIdDatasetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsLakeLakesLakeIdDatasetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsLakeLakesLakeIdDatasetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]CriblLakeDataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostProductsLakeLakesLakeIdDatasetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsLakeLakesLakeIdDatasetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsLakeLakesLakeIdDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]CriblLakeDataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsLakeLakesLakeIdDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsLakeLakesLakeIdDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsLakeLakesLakeIdDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]CriblLakeDataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsLakeLakesLakeIdDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsLakeLakesLakeIdDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchProductsLakeLakesLakeIdDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]CriblLakeDataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchProductsLakeLakesLakeIdDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchProductsLakeLakesLakeIdDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]ConfigGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]ConfigGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductGroupsIdAclTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]TeamAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductGroupsIdAclTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductGroupsIdAclTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]User `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsProductUsersCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsProductUsersCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsProductUsersCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductUsersIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ResourcePolicy `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductUsersIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductUsersIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoutesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoutesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRoutesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Routes `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchRoutesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRoutesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRoutesIdAppendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostRoutesIdAppendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRoutesIdAppendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DashboardCategory `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDashboardCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DashboardCategory `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDashboardCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDashboardCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchDashboardCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DashboardCategory `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchDashboardCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchDashboardCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DashboardCategory `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchDashboardCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DashboardCategory `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchDashboardCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchDashboardCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]SearchDashboard `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]SearchDashboard `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchDashboardsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]SearchDashboard `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchDashboardsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchDashboardsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]SearchDashboard `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchDashboardsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]SearchDashboard `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchDashboardsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchDashboardsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardsIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardsIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardsIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDashboardsIdAclApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDashboardsIdAclApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDashboardsIdAclApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDashboardsIdAclTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDashboardsIdAclTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDashboardsIdAclTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDashboardsIdAclTeamsApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDashboardsIdAclTeamsApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDashboardsIdAclTeamsApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetProviderTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]DatasetProviderType `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetProviderTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetProviderTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDatasetProviderTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]DatasetProviderType `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDatasetProviderTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDatasetProviderTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchDatasetProviderTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]DatasetProviderType `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchDatasetProviderTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchDatasetProviderTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetProviderTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]DatasetProviderType `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetProviderTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetProviderTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchDatasetProviderTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]DatasetProviderType `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchDatasetProviderTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchDatasetProviderTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]DatasetProvider `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDatasetProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]DatasetProvider `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDatasetProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDatasetProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchDatasetProvidersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]DatasetProvider `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchDatasetProvidersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchDatasetProvidersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetProvidersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]DatasetProvider `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetProvidersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetProvidersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchDatasetProvidersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]DatasetProvider `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchDatasetProvidersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchDatasetProvidersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Dataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDatasetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Dataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDatasetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDatasetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Dataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Dataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchDatasetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]Dataset `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchDatasetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchDatasetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetsIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetsIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetsIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDatasetsIdAclApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDatasetsIdAclApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDatasetsIdAclApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDatasetsIdAclTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchDatasetsIdAclTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDatasetsIdAclTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchDatasetsIdAclTeamsApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchDatasetsIdAclTeamsApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchDatasetsIdAclTeamsApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchEventBreakerPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]PreviewResponseBody `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchEventBreakerPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchEventBreakerPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchHealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                       `json:"count,omitempty"`
		Items *[]SearchHealthCheckStatus `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchHealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchHealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]SearchJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]SearchJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]SearchJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]SearchJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchJobsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]SearchJob `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchJobsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchJobsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchJobsIdDispatchExecutorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchJobsIdDispatchExecutorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchJobsIdDispatchExecutorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchJobResults
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdResultsPollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchJobResults
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdResultsPollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdResultsPollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchJobsIdStagesStageIdResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchJobsIdStagesStageIdResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchJobsIdStagesStageIdResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchMacrosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]SearchMacro `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchMacrosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchMacrosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchMacrosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]SearchMacro `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchMacrosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchMacrosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchMacrosIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]SearchMacro `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchMacrosIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchMacrosIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchMacrosIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]SearchMacro `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchMacrosIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchMacrosIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchMacrosIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]SearchMacro `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchMacrosIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchMacrosIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                   `json:"count,omitempty"`
		Items *[]PreviewResponseBody `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchSavedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SavedQuery `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchSavedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchSavedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchSavedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SavedQuery `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchSavedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchSavedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchSavedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SavedQuery `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchSavedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchSavedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchSavedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SavedQuery `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchSavedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchSavedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchSavedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SavedQuery `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchSavedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchSavedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchTrustPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]TrustPolicy `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchTrustPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchTrustPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchUsageGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]UsageGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchUsageGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchUsageGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSearchUsageGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]UsageGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSearchUsageGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSearchUsageGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSearchUsageGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]UsageGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSearchUsageGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSearchUsageGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchUsageGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]UsageGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSearchUsageGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchUsageGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSearchUsageGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]UsageGroup `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSearchUsageGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSearchUsageGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityKmsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KMSProviderConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSecurityKmsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityKmsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSecurityKmsConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KMSProviderConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSecurityKmsConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSecurityKmsConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityKmsHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int         `json:"count,omitempty"`
		Items *[]KMSHealth `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSecurityKmsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityKmsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]FeaturesEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSettingsFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsFeaturesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]FeaturesEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSettingsFeaturesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsFeaturesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemBannersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]BannerMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemBannersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemBannersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemBannersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]BannerMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemBannersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemBannersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemBannersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]BannerMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemBannersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemBannersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemBannersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]BannerMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemBannersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemBannersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemBannersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]BannerMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemBannersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemBannersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]Certificate `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]Certificate `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemCertificatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]Certificate `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemCertificatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemCertificatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemCertificatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]Certificate `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemCertificatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemCertificatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemCertificatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]Certificate `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemCertificatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemCertificatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Diag `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemDiagDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSystemDiagDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemDiagDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemDiagSendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemDiagSendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemDiagSendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemDistributedUpgradeCancelGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemDistributedUpgradeCancelGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemDistributedUpgradeCancelGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemDistributedUpgradeDownloadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemDistributedUpgradeDownloadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemDistributedUpgradeDownloadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemDistributedUpgradeStageGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemDistributedUpgradeStageGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemDistributedUpgradeStageGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemDistributedUpgradeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemDistributedUpgradeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemDistributedUpgradeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]SystemInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int     `json:"count,omitempty"`
		Items *[]Input `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int     `json:"count,omitempty"`
		Items *[]Input `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemInputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int     `json:"count,omitempty"`
		Items *[]Input `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemInputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemInputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int     `json:"count,omitempty"`
		Items *[]Input `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemInputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemInputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int     `json:"count,omitempty"`
		Items *[]Input `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemInputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemInputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemInputsIdHectokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemInputsIdHectokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemInputsIdHectokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemInputsIdHectokenTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemInputsIdHectokenTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemInputsIdHectokenTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemJobsLogsIdGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemJobsLogsIdGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemJobsLogsIdGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KeyMetadataEntity `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KeyMetadataEntity `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KeyMetadataEntity `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KeyMetadataEntity `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]KeyMetadataEntity `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]License `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]License `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLicensesUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                 `json:"count,omitempty"`
		Items *[]DailyUsageMetrics `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLicensesUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLicensesUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemLicensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]License `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemLicensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemLicensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLicensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]License `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLicensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLicensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLoggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]LoggerConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLoggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLoggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemLoggerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]LoggerConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemLoggerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemLoggerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLoggerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]LoggerConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLoggerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLoggerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemLoggerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]LoggerConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemLoggerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemLoggerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]LogFileInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLogsSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLogsSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLogsSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLogsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLogsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLogsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLookupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]LookupFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLookupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLookupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemLookupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]LookupFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemLookupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemLookupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutSystemLookupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LookupFileInfoResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PutSystemLookupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutSystemLookupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemLookupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]LookupFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemLookupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemLookupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemLookupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]LookupFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemLookupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemLookupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemLookupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]LookupFile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemLookupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemLookupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]BulletinMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]BulletinMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemMessagesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]BulletinMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemMessagesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemMessagesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemMessagesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]BulletinMessage `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemMessagesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemMessagesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemMetricsEnumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]MetricNameInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemMetricsEnumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemMetricsEnumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemMetricsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemMetricsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemMetricsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Output `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Output `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemOutputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Output `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemOutputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemOutputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemOutputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Output `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemOutputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemOutputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemOutputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]Output `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemOutputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemOutputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemOutputsIdPqResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemOutputsIdPqResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemOutputsIdPqResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemOutputsIdPqResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemOutputsIdPqResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemOutputsIdPqResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemOutputsIdSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]OutputSamplesResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemOutputsIdSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemOutputsIdSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemOutputsIdTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]OutputTestResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemOutputsIdTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemOutputsIdTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]PolicyRule `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]PolicyRule `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemPoliciesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]PolicyRule `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemPoliciesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemPoliciesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemPoliciesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]PolicyRule `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemPoliciesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemPoliciesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemPoliciesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]PolicyRule `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemPoliciesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemPoliciesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProcessEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProfilerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProfilerItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProfilerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProfilerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProfilerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProfilerItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProfilerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProfilerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemProfilerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProfilerItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemProfilerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemProfilerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProfilerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProfilerItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProfilerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProfilerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemProfilerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]ProfilerItem `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemProfilerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemProfilerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]ProjectConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]ProjectConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]ProjectConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]ProjectConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]ProjectConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsIdAclApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsIdAclApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsIdAclApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsIdAclTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                     `json:"count,omitempty"`
		Items *[]UserAccessControlList `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsIdAclTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsIdAclTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsIdAclTeamsApplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsIdAclTeamsApplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsIdAclTeamsApplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsProjectIdCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsProjectIdCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsProjectIdCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]ProjectDestination `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsProjectIdVersionCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitCommitSummary `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsProjectIdVersionCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsProjectIdVersionCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdVersionCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdVersionCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdVersionCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdVersionDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdVersionDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdVersionDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdVersionFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitFilesResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdVersionFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdVersionFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemProjectsProjectIdVersionRevertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]GitRevertResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemProjectsProjectIdVersionRevertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemProjectsProjectIdVersionRevertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemProjectsProjectIdVersionShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemProjectsProjectIdVersionShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemProjectsProjectIdVersionShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Role `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Role `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemRolesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Role `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemRolesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemRolesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemRolesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Role `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemRolesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemRolesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemRolesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Role `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemRolesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemRolesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]DataSample `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]DataSample `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemSamplesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]DataSample `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemSamplesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemSamplesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSamplesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]DataSample `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSamplesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSamplesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSamplesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]DataSample `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSamplesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSamplesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSamplesIdContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]SampleContent `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSamplesIdContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSamplesIdContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ScriptLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ScriptLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemScriptsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ScriptLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemScriptsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemScriptsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemScriptsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ScriptLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemScriptsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemScriptsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemScriptsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ScriptLibEntry `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemScriptsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemScriptsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]RestSecret `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]RestSecret `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemSecretsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]RestSecret `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemSecretsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemSecretsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSecretsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]RestSecret `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSecretsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSecretsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSecretsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]RestSecret `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSecretsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSecretsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SystemSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SystemSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]AuthConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSettingsAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int          `json:"count,omitempty"`
		Items *[]AuthConfig `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSettingsAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSettingsAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsConfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                  `json:"count,omitempty"`
		Items *[]SystemSettingsConf `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsConfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsConfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSettingsConfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SystemSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSettingsConfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSettingsConfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsCriblResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]PublicSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsCriblResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsCriblResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsGitSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]GitSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsGitSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsGitSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSettingsGitSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]GitSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSettingsGitSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSettingsGitSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSettingsReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostSystemSettingsReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSettingsReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSettingsRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostSystemSettingsRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSettingsRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsSearchLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]SearchSettings `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsSearchLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsSearchLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSettingsUpgradeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int             `json:"count,omitempty"`
		Items *[]UpgradeResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSettingsUpgradeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSettingsUpgradeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSettingsUpgradeFromPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemSettingsUpgradeFromPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSettingsUpgradeFromPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSettingsUpgradeVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemSettingsUpgradeVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSettingsUpgradeVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]InputStatus `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusInputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]InputStatus `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusInputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusInputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]OutputStatus `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusOutputsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]OutputStatus `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusOutputsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusOutputsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemSubscriptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int            `json:"count,omitempty"`
		Items *[]Subscription `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemSubscriptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemSubscriptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Team `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Team `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemTeamsUsersIdRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemTeamsUsersIdRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemTeamsUsersIdRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Team `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Team `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]Team `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemTeamsIdAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int              `json:"count,omitempty"`
		Items *[]ResourcePolicy `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemTeamsIdAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemTeamsIdAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemTeamsIdUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemTeamsIdUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemTeamsIdUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemTeamsIdUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int      `json:"count,omitempty"`
		Items *[]string `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemTeamsIdUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemTeamsIdUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]User `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSystemUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]UserProfile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostSystemUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSystemUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSystemUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]User `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSystemUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSystemUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]User `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSystemUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int           `json:"count,omitempty"`
		Items *[]UserProfile `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSystemUsersIdInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int    `json:"count,omitempty"`
		Items *[]User `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchSystemUsersIdInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSystemUsersIdInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVersionCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitCommitSummary `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostVersionCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVersionCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionCurrentBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionCurrentBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionCurrentBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                `json:"count,omitempty"`
		Items *[]GitFilesResponse `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int       `json:"count,omitempty"`
		Items *[]GitInfo `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVersionPushResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostVersionPushResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVersionPushResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVersionRevertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]GitRevertResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostVersionRevertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVersionRevertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int               `json:"count,omitempty"`
		Items *[]GitStatusResult `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVersionSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count number of items present in the items array
		Count *int                      `json:"count,omitempty"`
		Items *[]map[string]interface{} `json:"items,omitempty"`
	}
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PostVersionSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVersionSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVersionUndoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostVersionUndoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVersionUndoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAiConsentWithResponse request returning *GetAiConsentResponse
func (c *ClientWithResponses) GetAiConsentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAiConsentResponse, error) {
	rsp, err := c.GetAiConsent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiConsentResponse(rsp)
}

// PostAiConsentWithResponse request returning *PostAiConsentResponse
func (c *ClientWithResponses) PostAiConsentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAiConsentResponse, error) {
	rsp, err := c.PostAiConsent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAiConsentResponse(rsp)
}

// GetAuthAuthorizationCodeCallbackWithResponse request returning *GetAuthAuthorizationCodeCallbackResponse
func (c *ClientWithResponses) GetAuthAuthorizationCodeCallbackWithResponse(ctx context.Context, params *GetAuthAuthorizationCodeCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthAuthorizationCodeCallbackResponse, error) {
	rsp, err := c.GetAuthAuthorizationCodeCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthAuthorizationCodeCallbackResponse(rsp)
}

// GetAuthGroupsWithResponse request returning *GetAuthGroupsResponse
func (c *ClientWithResponses) GetAuthGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthGroupsResponse, error) {
	rsp, err := c.GetAuthGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthGroupsResponse(rsp)
}

// PostAuthLoginWithBodyWithResponse request with arbitrary body returning *PostAuthLoginResponse
func (c *ClientWithResponses) PostAuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error) {
	rsp, err := c.PostAuthLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) PostAuthLoginWithResponse(ctx context.Context, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error) {
	rsp, err := c.PostAuthLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLoginResponse(rsp)
}

// PostAuthLogoutWithResponse request returning *PostAuthLogoutResponse
func (c *ClientWithResponses) PostAuthLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAuthLogoutResponse, error) {
	rsp, err := c.PostAuthLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLogoutResponse(rsp)
}

// GetAuthMetadataWithResponse request returning *GetAuthMetadataResponse
func (c *ClientWithResponses) GetAuthMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthMetadataResponse, error) {
	rsp, err := c.GetAuthMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthMetadataResponse(rsp)
}

// GetAuthMultiFactorWithResponse request returning *GetAuthMultiFactorResponse
func (c *ClientWithResponses) GetAuthMultiFactorWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthMultiFactorResponse, error) {
	rsp, err := c.GetAuthMultiFactor(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthMultiFactorResponse(rsp)
}

// GetAuthSloWithResponse request returning *GetAuthSloResponse
func (c *ClientWithResponses) GetAuthSloWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthSloResponse, error) {
	rsp, err := c.GetAuthSlo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthSloResponse(rsp)
}

// GetAuthSloCallbackWithResponse request returning *GetAuthSloCallbackResponse
func (c *ClientWithResponses) GetAuthSloCallbackWithResponse(ctx context.Context, params *GetAuthSloCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthSloCallbackResponse, error) {
	rsp, err := c.GetAuthSloCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthSloCallbackResponse(rsp)
}

// PostAuthSloCallbackWithBodyWithResponse request with arbitrary body returning *PostAuthSloCallbackResponse
func (c *ClientWithResponses) PostAuthSloCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthSloCallbackResponse, error) {
	rsp, err := c.PostAuthSloCallbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthSloCallbackResponse(rsp)
}

func (c *ClientWithResponses) PostAuthSloCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostAuthSloCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostAuthSloCallbackResponse, error) {
	rsp, err := c.PostAuthSloCallbackWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthSloCallbackResponse(rsp)
}

// GetAuthSsoWithResponse request returning *GetAuthSsoResponse
func (c *ClientWithResponses) GetAuthSsoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthSsoResponse, error) {
	rsp, err := c.GetAuthSso(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthSsoResponse(rsp)
}

// GetAuthSsoCallbackWithResponse request returning *GetAuthSsoCallbackResponse
func (c *ClientWithResponses) GetAuthSsoCallbackWithResponse(ctx context.Context, params *GetAuthSsoCallbackParams, reqEditors ...RequestEditorFn) (*GetAuthSsoCallbackResponse, error) {
	rsp, err := c.GetAuthSsoCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthSsoCallbackResponse(rsp)
}

// PostAuthSsoCallbackWithBodyWithResponse request with arbitrary body returning *PostAuthSsoCallbackResponse
func (c *ClientWithResponses) PostAuthSsoCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthSsoCallbackResponse, error) {
	rsp, err := c.PostAuthSsoCallbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthSsoCallbackResponse(rsp)
}

func (c *ClientWithResponses) PostAuthSsoCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostAuthSsoCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostAuthSsoCallbackResponse, error) {
	rsp, err := c.PostAuthSsoCallbackWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthSsoCallbackResponse(rsp)
}

// DeleteAuthUsersIdTokenWithResponse request returning *DeleteAuthUsersIdTokenResponse
func (c *ClientWithResponses) DeleteAuthUsersIdTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAuthUsersIdTokenResponse, error) {
	rsp, err := c.DeleteAuthUsersIdToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthUsersIdTokenResponse(rsp)
}

// GetAuthorizePolicyWithResponse request returning *GetAuthorizePolicyResponse
func (c *ClientWithResponses) GetAuthorizePolicyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthorizePolicyResponse, error) {
	rsp, err := c.GetAuthorizePolicy(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizePolicyResponse(rsp)
}

// GetAuthorizeRolesWithResponse request returning *GetAuthorizeRolesResponse
func (c *ClientWithResponses) GetAuthorizeRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthorizeRolesResponse, error) {
	rsp, err := c.GetAuthorizeRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorizeRolesResponse(rsp)
}

// GetChangelogViewedWithResponse request returning *GetChangelogViewedResponse
func (c *ClientWithResponses) GetChangelogViewedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChangelogViewedResponse, error) {
	rsp, err := c.GetChangelogViewed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangelogViewedResponse(rsp)
}

// PatchChangelogViewedWithResponse request returning *PatchChangelogViewedResponse
func (c *ClientWithResponses) PatchChangelogViewedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchChangelogViewedResponse, error) {
	rsp, err := c.PatchChangelogViewed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChangelogViewedResponse(rsp)
}

// GetCluiWithResponse request returning *GetCluiResponse
func (c *ClientWithResponses) GetCluiWithResponse(ctx context.Context, params *GetCluiParams, reqEditors ...RequestEditorFn) (*GetCluiResponse, error) {
	rsp, err := c.GetClui(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCluiResponse(rsp)
}

// GetCollectorsWithResponse request returning *GetCollectorsResponse
func (c *ClientWithResponses) GetCollectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorsResponse, error) {
	rsp, err := c.GetCollectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorsResponse(rsp)
}

// GetCollectorsIdWithResponse request returning *GetCollectorsIdResponse
func (c *ClientWithResponses) GetCollectorsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCollectorsIdResponse, error) {
	rsp, err := c.GetCollectorsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorsIdResponse(rsp)
}

// GetConditionsWithResponse request returning *GetConditionsResponse
func (c *ClientWithResponses) GetConditionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConditionsResponse, error) {
	rsp, err := c.GetConditions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConditionsResponse(rsp)
}

// GetConditionsIdWithResponse request returning *GetConditionsIdResponse
func (c *ClientWithResponses) GetConditionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConditionsIdResponse, error) {
	rsp, err := c.GetConditionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConditionsIdResponse(rsp)
}

// GetEdgeAppscopeProcessesWithResponse request returning *GetEdgeAppscopeProcessesResponse
func (c *ClientWithResponses) GetEdgeAppscopeProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeAppscopeProcessesResponse, error) {
	rsp, err := c.GetEdgeAppscopeProcesses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeAppscopeProcessesResponse(rsp)
}

// PostEdgeAppscopeProcessesWithResponse request returning *PostEdgeAppscopeProcessesResponse
func (c *ClientWithResponses) PostEdgeAppscopeProcessesWithResponse(ctx context.Context, params *PostEdgeAppscopeProcessesParams, reqEditors ...RequestEditorFn) (*PostEdgeAppscopeProcessesResponse, error) {
	rsp, err := c.PostEdgeAppscopeProcesses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEdgeAppscopeProcessesResponse(rsp)
}

// DeleteEdgeAppscopeProcessesPidWithResponse request returning *DeleteEdgeAppscopeProcessesPidResponse
func (c *ClientWithResponses) DeleteEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*DeleteEdgeAppscopeProcessesPidResponse, error) {
	rsp, err := c.DeleteEdgeAppscopeProcessesPid(ctx, pid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEdgeAppscopeProcessesPidResponse(rsp)
}

// GetEdgeAppscopeProcessesPidWithResponse request returning *GetEdgeAppscopeProcessesPidResponse
func (c *ClientWithResponses) GetEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*GetEdgeAppscopeProcessesPidResponse, error) {
	rsp, err := c.GetEdgeAppscopeProcessesPid(ctx, pid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeAppscopeProcessesPidResponse(rsp)
}

// PutEdgeAppscopeProcessesPidWithResponse request returning *PutEdgeAppscopeProcessesPidResponse
func (c *ClientWithResponses) PutEdgeAppscopeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*PutEdgeAppscopeProcessesPidResponse, error) {
	rsp, err := c.PutEdgeAppscopeProcessesPid(ctx, pid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEdgeAppscopeProcessesPidResponse(rsp)
}

// GetEdgeContainersWithResponse request returning *GetEdgeContainersResponse
func (c *ClientWithResponses) GetEdgeContainersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeContainersResponse, error) {
	rsp, err := c.GetEdgeContainers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeContainersResponse(rsp)
}

// GetEdgeContainersIdWithResponse request returning *GetEdgeContainersIdResponse
func (c *ClientWithResponses) GetEdgeContainersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEdgeContainersIdResponse, error) {
	rsp, err := c.GetEdgeContainersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeContainersIdResponse(rsp)
}

// GetEdgeEventsCollectorsWithResponse request returning *GetEdgeEventsCollectorsResponse
func (c *ClientWithResponses) GetEdgeEventsCollectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeEventsCollectorsResponse, error) {
	rsp, err := c.GetEdgeEventsCollectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeEventsCollectorsResponse(rsp)
}

// GetEdgeEventsQueryWithResponse request returning *GetEdgeEventsQueryResponse
func (c *ClientWithResponses) GetEdgeEventsQueryWithResponse(ctx context.Context, params *GetEdgeEventsQueryParams, reqEditors ...RequestEditorFn) (*GetEdgeEventsQueryResponse, error) {
	rsp, err := c.GetEdgeEventsQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeEventsQueryResponse(rsp)
}

// PostEdgeFileIngestWithResponse request returning *PostEdgeFileIngestResponse
func (c *ClientWithResponses) PostEdgeFileIngestWithResponse(ctx context.Context, params *PostEdgeFileIngestParams, reqEditors ...RequestEditorFn) (*PostEdgeFileIngestResponse, error) {
	rsp, err := c.PostEdgeFileIngest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEdgeFileIngestResponse(rsp)
}

// GetEdgeFileSampleWithResponse request returning *GetEdgeFileSampleResponse
func (c *ClientWithResponses) GetEdgeFileSampleWithResponse(ctx context.Context, params *GetEdgeFileSampleParams, reqEditors ...RequestEditorFn) (*GetEdgeFileSampleResponse, error) {
	rsp, err := c.GetEdgeFileSample(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeFileSampleResponse(rsp)
}

// GetEdgeFileinspectWithResponse request returning *GetEdgeFileinspectResponse
func (c *ClientWithResponses) GetEdgeFileinspectWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeFileinspectResponse, error) {
	rsp, err := c.GetEdgeFileinspect(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeFileinspectResponse(rsp)
}

// PostEdgeKubeLogsWithResponse request returning *PostEdgeKubeLogsResponse
func (c *ClientWithResponses) PostEdgeKubeLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostEdgeKubeLogsResponse, error) {
	rsp, err := c.PostEdgeKubeLogs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEdgeKubeLogsResponse(rsp)
}

// GetEdgeKubeProxyWithResponse request returning *GetEdgeKubeProxyResponse
func (c *ClientWithResponses) GetEdgeKubeProxyWithResponse(ctx context.Context, params *GetEdgeKubeProxyParams, reqEditors ...RequestEditorFn) (*GetEdgeKubeProxyResponse, error) {
	rsp, err := c.GetEdgeKubeProxy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeKubeProxyResponse(rsp)
}

// GetEdgeLogsWithResponse request returning *GetEdgeLogsResponse
func (c *ClientWithResponses) GetEdgeLogsWithResponse(ctx context.Context, params *GetEdgeLogsParams, reqEditors ...RequestEditorFn) (*GetEdgeLogsResponse, error) {
	rsp, err := c.GetEdgeLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeLogsResponse(rsp)
}

// GetEdgeLsPathWithResponse request returning *GetEdgeLsPathResponse
func (c *ClientWithResponses) GetEdgeLsPathWithResponse(ctx context.Context, path string, reqEditors ...RequestEditorFn) (*GetEdgeLsPathResponse, error) {
	rsp, err := c.GetEdgeLsPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeLsPathResponse(rsp)
}

// GetEdgeMetadataWithResponse request returning *GetEdgeMetadataResponse
func (c *ClientWithResponses) GetEdgeMetadataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeMetadataResponse, error) {
	rsp, err := c.GetEdgeMetadata(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeMetadataResponse(rsp)
}

// GetEdgeProcessesWithResponse request returning *GetEdgeProcessesResponse
func (c *ClientWithResponses) GetEdgeProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEdgeProcessesResponse, error) {
	rsp, err := c.GetEdgeProcesses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeProcessesResponse(rsp)
}

// GetEdgeProcessesPidWithResponse request returning *GetEdgeProcessesPidResponse
func (c *ClientWithResponses) GetEdgeProcessesPidWithResponse(ctx context.Context, pid string, reqEditors ...RequestEditorFn) (*GetEdgeProcessesPidResponse, error) {
	rsp, err := c.GetEdgeProcessesPid(ctx, pid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEdgeProcessesPidResponse(rsp)
}

// GetExecutorsWithResponse request returning *GetExecutorsResponse
func (c *ClientWithResponses) GetExecutorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExecutorsResponse, error) {
	rsp, err := c.GetExecutors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutorsResponse(rsp)
}

// GetExecutorsIdWithResponse request returning *GetExecutorsIdResponse
func (c *ClientWithResponses) GetExecutorsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetExecutorsIdResponse, error) {
	rsp, err := c.GetExecutorsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutorsIdResponse(rsp)
}

// GetFunctionsWithResponse request returning *GetFunctionsResponse
func (c *ClientWithResponses) GetFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFunctionsResponse, error) {
	rsp, err := c.GetFunctions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionsResponse(rsp)
}

// GetFunctionsIdWithResponse request returning *GetFunctionsIdResponse
func (c *ClientWithResponses) GetFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFunctionsIdResponse, error) {
	rsp, err := c.GetFunctionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionsIdResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetJobsWithResponse request returning *GetJobsResponse
func (c *ClientWithResponses) GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error) {
	rsp, err := c.GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsResponse(rsp)
}

// PostJobsWithBodyWithResponse request with arbitrary body returning *PostJobsResponse
func (c *ClientWithResponses) PostJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostJobsResponse, error) {
	rsp, err := c.PostJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostJobsResponse(rsp)
}

func (c *ClientWithResponses) PostJobsWithResponse(ctx context.Context, body PostJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostJobsResponse, error) {
	rsp, err := c.PostJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostJobsResponse(rsp)
}

// DeleteJobsIdWithResponse request returning *DeleteJobsIdResponse
func (c *ClientWithResponses) DeleteJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteJobsIdResponse, error) {
	rsp, err := c.DeleteJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobsIdResponse(rsp)
}

// GetJobsIdWithResponse request returning *GetJobsIdResponse
func (c *ClientWithResponses) GetJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdResponse, error) {
	rsp, err := c.GetJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsIdResponse(rsp)
}

// PatchJobsIdCancelWithResponse request returning *PatchJobsIdCancelResponse
func (c *ClientWithResponses) PatchJobsIdCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdCancelResponse, error) {
	rsp, err := c.PatchJobsIdCancel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchJobsIdCancelResponse(rsp)
}

// GetJobsIdErrorsWithResponse request returning *GetJobsIdErrorsResponse
func (c *ClientWithResponses) GetJobsIdErrorsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdErrorsResponse, error) {
	rsp, err := c.GetJobsIdErrors(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsIdErrorsResponse(rsp)
}

// GetJobsIdErrorsGroupWithResponse request returning *GetJobsIdErrorsGroupResponse
func (c *ClientWithResponses) GetJobsIdErrorsGroupWithResponse(ctx context.Context, id string, group string, reqEditors ...RequestEditorFn) (*GetJobsIdErrorsGroupResponse, error) {
	rsp, err := c.GetJobsIdErrorsGroup(ctx, id, group, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsIdErrorsGroupResponse(rsp)
}

// PatchJobsIdKeepWithResponse request returning *PatchJobsIdKeepResponse
func (c *ClientWithResponses) PatchJobsIdKeepWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdKeepResponse, error) {
	rsp, err := c.PatchJobsIdKeep(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchJobsIdKeepResponse(rsp)
}

// PatchJobsIdPauseWithResponse request returning *PatchJobsIdPauseResponse
func (c *ClientWithResponses) PatchJobsIdPauseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdPauseResponse, error) {
	rsp, err := c.PatchJobsIdPause(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchJobsIdPauseResponse(rsp)
}

// GetJobsIdResultsWithResponse request returning *GetJobsIdResultsResponse
func (c *ClientWithResponses) GetJobsIdResultsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetJobsIdResultsResponse, error) {
	rsp, err := c.GetJobsIdResults(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsIdResultsResponse(rsp)
}

// GetJobsIdResultsGroupWithResponse request returning *GetJobsIdResultsGroupResponse
func (c *ClientWithResponses) GetJobsIdResultsGroupWithResponse(ctx context.Context, id string, group string, params *GetJobsIdResultsGroupParams, reqEditors ...RequestEditorFn) (*GetJobsIdResultsGroupResponse, error) {
	rsp, err := c.GetJobsIdResultsGroup(ctx, id, group, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsIdResultsGroupResponse(rsp)
}

// PatchJobsIdResumeWithResponse request returning *PatchJobsIdResumeResponse
func (c *ClientWithResponses) PatchJobsIdResumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchJobsIdResumeResponse, error) {
	rsp, err := c.PatchJobsIdResume(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchJobsIdResumeResponse(rsp)
}

// GetLibAppscopeConfigsWithResponse request returning *GetLibAppscopeConfigsResponse
func (c *ClientWithResponses) GetLibAppscopeConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibAppscopeConfigsResponse, error) {
	rsp, err := c.GetLibAppscopeConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibAppscopeConfigsResponse(rsp)
}

// PostLibAppscopeConfigsWithBodyWithResponse request with arbitrary body returning *PostLibAppscopeConfigsResponse
func (c *ClientWithResponses) PostLibAppscopeConfigsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibAppscopeConfigsResponse, error) {
	rsp, err := c.PostLibAppscopeConfigsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibAppscopeConfigsResponse(rsp)
}

func (c *ClientWithResponses) PostLibAppscopeConfigsWithResponse(ctx context.Context, body PostLibAppscopeConfigsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibAppscopeConfigsResponse, error) {
	rsp, err := c.PostLibAppscopeConfigs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibAppscopeConfigsResponse(rsp)
}

// DeleteLibAppscopeConfigsIdWithResponse request returning *DeleteLibAppscopeConfigsIdResponse
func (c *ClientWithResponses) DeleteLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibAppscopeConfigsIdResponse, error) {
	rsp, err := c.DeleteLibAppscopeConfigsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibAppscopeConfigsIdResponse(rsp)
}

// GetLibAppscopeConfigsIdWithResponse request returning *GetLibAppscopeConfigsIdResponse
func (c *ClientWithResponses) GetLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibAppscopeConfigsIdResponse, error) {
	rsp, err := c.GetLibAppscopeConfigsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibAppscopeConfigsIdResponse(rsp)
}

// PatchLibAppscopeConfigsIdWithBodyWithResponse request with arbitrary body returning *PatchLibAppscopeConfigsIdResponse
func (c *ClientWithResponses) PatchLibAppscopeConfigsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibAppscopeConfigsIdResponse, error) {
	rsp, err := c.PatchLibAppscopeConfigsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibAppscopeConfigsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibAppscopeConfigsIdWithResponse(ctx context.Context, id string, body PatchLibAppscopeConfigsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibAppscopeConfigsIdResponse, error) {
	rsp, err := c.PatchLibAppscopeConfigsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibAppscopeConfigsIdResponse(rsp)
}

// GetLibBreakersWithResponse request returning *GetLibBreakersResponse
func (c *ClientWithResponses) GetLibBreakersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibBreakersResponse, error) {
	rsp, err := c.GetLibBreakers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibBreakersResponse(rsp)
}

// PostLibBreakersWithBodyWithResponse request with arbitrary body returning *PostLibBreakersResponse
func (c *ClientWithResponses) PostLibBreakersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibBreakersResponse, error) {
	rsp, err := c.PostLibBreakersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibBreakersResponse(rsp)
}

func (c *ClientWithResponses) PostLibBreakersWithResponse(ctx context.Context, body PostLibBreakersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibBreakersResponse, error) {
	rsp, err := c.PostLibBreakers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibBreakersResponse(rsp)
}

// DeleteLibBreakersIdWithResponse request returning *DeleteLibBreakersIdResponse
func (c *ClientWithResponses) DeleteLibBreakersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibBreakersIdResponse, error) {
	rsp, err := c.DeleteLibBreakersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibBreakersIdResponse(rsp)
}

// GetLibBreakersIdWithResponse request returning *GetLibBreakersIdResponse
func (c *ClientWithResponses) GetLibBreakersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibBreakersIdResponse, error) {
	rsp, err := c.GetLibBreakersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibBreakersIdResponse(rsp)
}

// PatchLibBreakersIdWithBodyWithResponse request with arbitrary body returning *PatchLibBreakersIdResponse
func (c *ClientWithResponses) PatchLibBreakersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibBreakersIdResponse, error) {
	rsp, err := c.PatchLibBreakersIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibBreakersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibBreakersIdWithResponse(ctx context.Context, id string, body PatchLibBreakersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibBreakersIdResponse, error) {
	rsp, err := c.PatchLibBreakersId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibBreakersIdResponse(rsp)
}

// GetLibDatabaseConnectionsWithResponse request returning *GetLibDatabaseConnectionsResponse
func (c *ClientWithResponses) GetLibDatabaseConnectionsWithResponse(ctx context.Context, params *GetLibDatabaseConnectionsParams, reqEditors ...RequestEditorFn) (*GetLibDatabaseConnectionsResponse, error) {
	rsp, err := c.GetLibDatabaseConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibDatabaseConnectionsResponse(rsp)
}

// PostLibDatabaseConnectionsWithBodyWithResponse request with arbitrary body returning *PostLibDatabaseConnectionsResponse
func (c *ClientWithResponses) PostLibDatabaseConnectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsResponse, error) {
	rsp, err := c.PostLibDatabaseConnectionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibDatabaseConnectionsResponse(rsp)
}

func (c *ClientWithResponses) PostLibDatabaseConnectionsWithResponse(ctx context.Context, body PostLibDatabaseConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsResponse, error) {
	rsp, err := c.PostLibDatabaseConnections(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibDatabaseConnectionsResponse(rsp)
}

// PostLibDatabaseConnectionsTestWithBodyWithResponse request with arbitrary body returning *PostLibDatabaseConnectionsTestResponse
func (c *ClientWithResponses) PostLibDatabaseConnectionsTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsTestResponse, error) {
	rsp, err := c.PostLibDatabaseConnectionsTestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibDatabaseConnectionsTestResponse(rsp)
}

func (c *ClientWithResponses) PostLibDatabaseConnectionsTestWithResponse(ctx context.Context, body PostLibDatabaseConnectionsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibDatabaseConnectionsTestResponse, error) {
	rsp, err := c.PostLibDatabaseConnectionsTest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibDatabaseConnectionsTestResponse(rsp)
}

// DeleteLibDatabaseConnectionsIdWithResponse request returning *DeleteLibDatabaseConnectionsIdResponse
func (c *ClientWithResponses) DeleteLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibDatabaseConnectionsIdResponse, error) {
	rsp, err := c.DeleteLibDatabaseConnectionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibDatabaseConnectionsIdResponse(rsp)
}

// GetLibDatabaseConnectionsIdWithResponse request returning *GetLibDatabaseConnectionsIdResponse
func (c *ClientWithResponses) GetLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibDatabaseConnectionsIdResponse, error) {
	rsp, err := c.GetLibDatabaseConnectionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibDatabaseConnectionsIdResponse(rsp)
}

// PatchLibDatabaseConnectionsIdWithBodyWithResponse request with arbitrary body returning *PatchLibDatabaseConnectionsIdResponse
func (c *ClientWithResponses) PatchLibDatabaseConnectionsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibDatabaseConnectionsIdResponse, error) {
	rsp, err := c.PatchLibDatabaseConnectionsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibDatabaseConnectionsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibDatabaseConnectionsIdWithResponse(ctx context.Context, id string, body PatchLibDatabaseConnectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibDatabaseConnectionsIdResponse, error) {
	rsp, err := c.PatchLibDatabaseConnectionsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibDatabaseConnectionsIdResponse(rsp)
}

// PostLibExpressionWithResponse request returning *PostLibExpressionResponse
func (c *ClientWithResponses) PostLibExpressionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostLibExpressionResponse, error) {
	rsp, err := c.PostLibExpression(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibExpressionResponse(rsp)
}

// GetLibGrokWithResponse request returning *GetLibGrokResponse
func (c *ClientWithResponses) GetLibGrokWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibGrokResponse, error) {
	rsp, err := c.GetLibGrok(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibGrokResponse(rsp)
}

// PostLibGrokWithBodyWithResponse request with arbitrary body returning *PostLibGrokResponse
func (c *ClientWithResponses) PostLibGrokWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibGrokResponse, error) {
	rsp, err := c.PostLibGrokWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibGrokResponse(rsp)
}

func (c *ClientWithResponses) PostLibGrokWithResponse(ctx context.Context, body PostLibGrokJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibGrokResponse, error) {
	rsp, err := c.PostLibGrok(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibGrokResponse(rsp)
}

// DeleteLibGrokIdWithResponse request returning *DeleteLibGrokIdResponse
func (c *ClientWithResponses) DeleteLibGrokIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibGrokIdResponse, error) {
	rsp, err := c.DeleteLibGrokId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibGrokIdResponse(rsp)
}

// GetLibGrokIdWithResponse request returning *GetLibGrokIdResponse
func (c *ClientWithResponses) GetLibGrokIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibGrokIdResponse, error) {
	rsp, err := c.GetLibGrokId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibGrokIdResponse(rsp)
}

// PatchLibGrokIdWithBodyWithResponse request with arbitrary body returning *PatchLibGrokIdResponse
func (c *ClientWithResponses) PatchLibGrokIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibGrokIdResponse, error) {
	rsp, err := c.PatchLibGrokIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibGrokIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibGrokIdWithResponse(ctx context.Context, id string, body PatchLibGrokIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibGrokIdResponse, error) {
	rsp, err := c.PatchLibGrokId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibGrokIdResponse(rsp)
}

// GetLibHmacFunctionsWithResponse request returning *GetLibHmacFunctionsResponse
func (c *ClientWithResponses) GetLibHmacFunctionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibHmacFunctionsResponse, error) {
	rsp, err := c.GetLibHmacFunctions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibHmacFunctionsResponse(rsp)
}

// PostLibHmacFunctionsWithBodyWithResponse request with arbitrary body returning *PostLibHmacFunctionsResponse
func (c *ClientWithResponses) PostLibHmacFunctionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibHmacFunctionsResponse, error) {
	rsp, err := c.PostLibHmacFunctionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibHmacFunctionsResponse(rsp)
}

func (c *ClientWithResponses) PostLibHmacFunctionsWithResponse(ctx context.Context, body PostLibHmacFunctionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibHmacFunctionsResponse, error) {
	rsp, err := c.PostLibHmacFunctions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibHmacFunctionsResponse(rsp)
}

// DeleteLibHmacFunctionsIdWithResponse request returning *DeleteLibHmacFunctionsIdResponse
func (c *ClientWithResponses) DeleteLibHmacFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibHmacFunctionsIdResponse, error) {
	rsp, err := c.DeleteLibHmacFunctionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibHmacFunctionsIdResponse(rsp)
}

// GetLibHmacFunctionsIdWithResponse request returning *GetLibHmacFunctionsIdResponse
func (c *ClientWithResponses) GetLibHmacFunctionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibHmacFunctionsIdResponse, error) {
	rsp, err := c.GetLibHmacFunctionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibHmacFunctionsIdResponse(rsp)
}

// PatchLibHmacFunctionsIdWithBodyWithResponse request with arbitrary body returning *PatchLibHmacFunctionsIdResponse
func (c *ClientWithResponses) PatchLibHmacFunctionsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibHmacFunctionsIdResponse, error) {
	rsp, err := c.PatchLibHmacFunctionsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibHmacFunctionsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibHmacFunctionsIdWithResponse(ctx context.Context, id string, body PatchLibHmacFunctionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibHmacFunctionsIdResponse, error) {
	rsp, err := c.PatchLibHmacFunctionsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibHmacFunctionsIdResponse(rsp)
}

// GetLibJobsWithResponse request returning *GetLibJobsResponse
func (c *ClientWithResponses) GetLibJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibJobsResponse, error) {
	rsp, err := c.GetLibJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibJobsResponse(rsp)
}

// PostLibJobsWithBodyWithResponse request with arbitrary body returning *PostLibJobsResponse
func (c *ClientWithResponses) PostLibJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibJobsResponse, error) {
	rsp, err := c.PostLibJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibJobsResponse(rsp)
}

func (c *ClientWithResponses) PostLibJobsWithResponse(ctx context.Context, body PostLibJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibJobsResponse, error) {
	rsp, err := c.PostLibJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibJobsResponse(rsp)
}

// DeleteLibJobsIdWithResponse request returning *DeleteLibJobsIdResponse
func (c *ClientWithResponses) DeleteLibJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibJobsIdResponse, error) {
	rsp, err := c.DeleteLibJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibJobsIdResponse(rsp)
}

// GetLibJobsIdWithResponse request returning *GetLibJobsIdResponse
func (c *ClientWithResponses) GetLibJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibJobsIdResponse, error) {
	rsp, err := c.GetLibJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibJobsIdResponse(rsp)
}

// PatchLibJobsIdWithBodyWithResponse request with arbitrary body returning *PatchLibJobsIdResponse
func (c *ClientWithResponses) PatchLibJobsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibJobsIdResponse, error) {
	rsp, err := c.PatchLibJobsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibJobsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibJobsIdWithResponse(ctx context.Context, id string, body PatchLibJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibJobsIdResponse, error) {
	rsp, err := c.PatchLibJobsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibJobsIdResponse(rsp)
}

// GetLibParquetSchemasWithResponse request returning *GetLibParquetSchemasResponse
func (c *ClientWithResponses) GetLibParquetSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibParquetSchemasResponse, error) {
	rsp, err := c.GetLibParquetSchemas(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibParquetSchemasResponse(rsp)
}

// PostLibParquetSchemasWithBodyWithResponse request with arbitrary body returning *PostLibParquetSchemasResponse
func (c *ClientWithResponses) PostLibParquetSchemasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibParquetSchemasResponse, error) {
	rsp, err := c.PostLibParquetSchemasWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibParquetSchemasResponse(rsp)
}

func (c *ClientWithResponses) PostLibParquetSchemasWithResponse(ctx context.Context, body PostLibParquetSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibParquetSchemasResponse, error) {
	rsp, err := c.PostLibParquetSchemas(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibParquetSchemasResponse(rsp)
}

// DeleteLibParquetSchemasIdWithResponse request returning *DeleteLibParquetSchemasIdResponse
func (c *ClientWithResponses) DeleteLibParquetSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibParquetSchemasIdResponse, error) {
	rsp, err := c.DeleteLibParquetSchemasId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibParquetSchemasIdResponse(rsp)
}

// GetLibParquetSchemasIdWithResponse request returning *GetLibParquetSchemasIdResponse
func (c *ClientWithResponses) GetLibParquetSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibParquetSchemasIdResponse, error) {
	rsp, err := c.GetLibParquetSchemasId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibParquetSchemasIdResponse(rsp)
}

// PatchLibParquetSchemasIdWithBodyWithResponse request with arbitrary body returning *PatchLibParquetSchemasIdResponse
func (c *ClientWithResponses) PatchLibParquetSchemasIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibParquetSchemasIdResponse, error) {
	rsp, err := c.PatchLibParquetSchemasIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibParquetSchemasIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibParquetSchemasIdWithResponse(ctx context.Context, id string, body PatchLibParquetSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibParquetSchemasIdResponse, error) {
	rsp, err := c.PatchLibParquetSchemasId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibParquetSchemasIdResponse(rsp)
}

// GetLibParsersWithResponse request returning *GetLibParsersResponse
func (c *ClientWithResponses) GetLibParsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibParsersResponse, error) {
	rsp, err := c.GetLibParsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibParsersResponse(rsp)
}

// PostLibParsersWithBodyWithResponse request with arbitrary body returning *PostLibParsersResponse
func (c *ClientWithResponses) PostLibParsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibParsersResponse, error) {
	rsp, err := c.PostLibParsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibParsersResponse(rsp)
}

func (c *ClientWithResponses) PostLibParsersWithResponse(ctx context.Context, body PostLibParsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibParsersResponse, error) {
	rsp, err := c.PostLibParsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibParsersResponse(rsp)
}

// DeleteLibParsersIdWithResponse request returning *DeleteLibParsersIdResponse
func (c *ClientWithResponses) DeleteLibParsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibParsersIdResponse, error) {
	rsp, err := c.DeleteLibParsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibParsersIdResponse(rsp)
}

// GetLibParsersIdWithResponse request returning *GetLibParsersIdResponse
func (c *ClientWithResponses) GetLibParsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibParsersIdResponse, error) {
	rsp, err := c.GetLibParsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibParsersIdResponse(rsp)
}

// PatchLibParsersIdWithBodyWithResponse request with arbitrary body returning *PatchLibParsersIdResponse
func (c *ClientWithResponses) PatchLibParsersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibParsersIdResponse, error) {
	rsp, err := c.PatchLibParsersIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibParsersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibParsersIdWithResponse(ctx context.Context, id string, body PatchLibParsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibParsersIdResponse, error) {
	rsp, err := c.PatchLibParsersId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibParsersIdResponse(rsp)
}

// GetLibProtobufLibrariesWithResponse request returning *GetLibProtobufLibrariesResponse
func (c *ClientWithResponses) GetLibProtobufLibrariesWithResponse(ctx context.Context, params *GetLibProtobufLibrariesParams, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesResponse, error) {
	rsp, err := c.GetLibProtobufLibraries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibProtobufLibrariesResponse(rsp)
}

// GetLibProtobufLibrariesIdWithResponse request returning *GetLibProtobufLibrariesIdResponse
func (c *ClientWithResponses) GetLibProtobufLibrariesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdResponse, error) {
	rsp, err := c.GetLibProtobufLibrariesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibProtobufLibrariesIdResponse(rsp)
}

// GetLibProtobufLibrariesIdEncodingsWithResponse request returning *GetLibProtobufLibrariesIdEncodingsResponse
func (c *ClientWithResponses) GetLibProtobufLibrariesIdEncodingsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdEncodingsResponse, error) {
	rsp, err := c.GetLibProtobufLibrariesIdEncodings(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibProtobufLibrariesIdEncodingsResponse(rsp)
}

// GetLibProtobufLibrariesIdEncodingsEncidWithResponse request returning *GetLibProtobufLibrariesIdEncodingsEncidResponse
func (c *ClientWithResponses) GetLibProtobufLibrariesIdEncodingsEncidWithResponse(ctx context.Context, id string, encid string, reqEditors ...RequestEditorFn) (*GetLibProtobufLibrariesIdEncodingsEncidResponse, error) {
	rsp, err := c.GetLibProtobufLibrariesIdEncodingsEncid(ctx, id, encid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibProtobufLibrariesIdEncodingsEncidResponse(rsp)
}

// GetLibRegexWithResponse request returning *GetLibRegexResponse
func (c *ClientWithResponses) GetLibRegexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibRegexResponse, error) {
	rsp, err := c.GetLibRegex(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibRegexResponse(rsp)
}

// PostLibRegexWithBodyWithResponse request with arbitrary body returning *PostLibRegexResponse
func (c *ClientWithResponses) PostLibRegexWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibRegexResponse, error) {
	rsp, err := c.PostLibRegexWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibRegexResponse(rsp)
}

func (c *ClientWithResponses) PostLibRegexWithResponse(ctx context.Context, body PostLibRegexJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibRegexResponse, error) {
	rsp, err := c.PostLibRegex(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibRegexResponse(rsp)
}

// DeleteLibRegexIdWithResponse request returning *DeleteLibRegexIdResponse
func (c *ClientWithResponses) DeleteLibRegexIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibRegexIdResponse, error) {
	rsp, err := c.DeleteLibRegexId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibRegexIdResponse(rsp)
}

// GetLibRegexIdWithResponse request returning *GetLibRegexIdResponse
func (c *ClientWithResponses) GetLibRegexIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibRegexIdResponse, error) {
	rsp, err := c.GetLibRegexId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibRegexIdResponse(rsp)
}

// PatchLibRegexIdWithBodyWithResponse request with arbitrary body returning *PatchLibRegexIdResponse
func (c *ClientWithResponses) PatchLibRegexIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibRegexIdResponse, error) {
	rsp, err := c.PatchLibRegexIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibRegexIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibRegexIdWithResponse(ctx context.Context, id string, body PatchLibRegexIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibRegexIdResponse, error) {
	rsp, err := c.PatchLibRegexId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibRegexIdResponse(rsp)
}

// GetLibSchemasWithResponse request returning *GetLibSchemasResponse
func (c *ClientWithResponses) GetLibSchemasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibSchemasResponse, error) {
	rsp, err := c.GetLibSchemas(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibSchemasResponse(rsp)
}

// PostLibSchemasWithBodyWithResponse request with arbitrary body returning *PostLibSchemasResponse
func (c *ClientWithResponses) PostLibSchemasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibSchemasResponse, error) {
	rsp, err := c.PostLibSchemasWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibSchemasResponse(rsp)
}

func (c *ClientWithResponses) PostLibSchemasWithResponse(ctx context.Context, body PostLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibSchemasResponse, error) {
	rsp, err := c.PostLibSchemas(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibSchemasResponse(rsp)
}

// DeleteLibSchemasIdWithResponse request returning *DeleteLibSchemasIdResponse
func (c *ClientWithResponses) DeleteLibSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibSchemasIdResponse, error) {
	rsp, err := c.DeleteLibSchemasId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibSchemasIdResponse(rsp)
}

// GetLibSchemasIdWithResponse request returning *GetLibSchemasIdResponse
func (c *ClientWithResponses) GetLibSchemasIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibSchemasIdResponse, error) {
	rsp, err := c.GetLibSchemasId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibSchemasIdResponse(rsp)
}

// PatchLibSchemasIdWithBodyWithResponse request with arbitrary body returning *PatchLibSchemasIdResponse
func (c *ClientWithResponses) PatchLibSchemasIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibSchemasIdResponse, error) {
	rsp, err := c.PatchLibSchemasIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibSchemasIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibSchemasIdWithResponse(ctx context.Context, id string, body PatchLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibSchemasIdResponse, error) {
	rsp, err := c.PatchLibSchemasId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibSchemasIdResponse(rsp)
}

// GetLibVarsWithResponse request returning *GetLibVarsResponse
func (c *ClientWithResponses) GetLibVarsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLibVarsResponse, error) {
	rsp, err := c.GetLibVars(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibVarsResponse(rsp)
}

// PostLibVarsWithBodyWithResponse request with arbitrary body returning *PostLibVarsResponse
func (c *ClientWithResponses) PostLibVarsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLibVarsResponse, error) {
	rsp, err := c.PostLibVarsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibVarsResponse(rsp)
}

func (c *ClientWithResponses) PostLibVarsWithResponse(ctx context.Context, body PostLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLibVarsResponse, error) {
	rsp, err := c.PostLibVars(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLibVarsResponse(rsp)
}

// DeleteLibVarsIdWithResponse request returning *DeleteLibVarsIdResponse
func (c *ClientWithResponses) DeleteLibVarsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLibVarsIdResponse, error) {
	rsp, err := c.DeleteLibVarsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLibVarsIdResponse(rsp)
}

// GetLibVarsIdWithResponse request returning *GetLibVarsIdResponse
func (c *ClientWithResponses) GetLibVarsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLibVarsIdResponse, error) {
	rsp, err := c.GetLibVarsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibVarsIdResponse(rsp)
}

// PatchLibVarsIdWithBodyWithResponse request with arbitrary body returning *PatchLibVarsIdResponse
func (c *ClientWithResponses) PatchLibVarsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLibVarsIdResponse, error) {
	rsp, err := c.PatchLibVarsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibVarsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchLibVarsIdWithResponse(ctx context.Context, id string, body PatchLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLibVarsIdResponse, error) {
	rsp, err := c.PatchLibVarsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLibVarsIdResponse(rsp)
}

// PostMGroupIdSystemProjectsProjectIdCaptureWithBodyWithResponse request with arbitrary body returning *PostMGroupIdSystemProjectsProjectIdCaptureResponse
func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdCaptureWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdCaptureResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdCaptureWithBody(ctx, groupId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdCaptureWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdCaptureResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdCapture(ctx, groupId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdCaptureResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdPipelinesWithResponse request returning *GetMGroupIdSystemProjectsProjectIdPipelinesResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdPipelinesWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdPipelinesResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdPipelines(ctx, groupId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdPipelinesResponse(rsp)
}

// PostMGroupIdSystemProjectsProjectIdPipelinesWithBodyWithResponse request with arbitrary body returning *PostMGroupIdSystemProjectsProjectIdPipelinesResponse
func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdPipelinesWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPipelinesResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdPipelinesWithBody(ctx, groupId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdPipelinesResponse(rsp)
}

func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdPipelinesWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPipelinesResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdPipelines(ctx, groupId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdPipelinesResponse(rsp)
}

// DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse request returning *DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse
func (c *ClientWithResponses) DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	rsp, err := c.DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse request returning *GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp)
}

// PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBodyWithResponse request with arbitrary body returning *PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse
func (c *ClientWithResponses) PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBodyWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	rsp, err := c.PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithBody(ctx, groupId, projectId, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp)
}

func (c *ClientWithResponses) PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse(ctx context.Context, groupId string, projectId string, pipelineId string, body PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	rsp, err := c.PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp)
}

// PostMGroupIdSystemProjectsProjectIdPreviewWithBodyWithResponse request with arbitrary body returning *PostMGroupIdSystemProjectsProjectIdPreviewResponse
func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdPreviewWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPreviewResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdPreviewWithBody(ctx, groupId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdPreviewResponse(rsp)
}

func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdPreviewWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdPreviewResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdPreview(ctx, groupId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdPreviewResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdSubscriptionsWithResponse request returning *GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdSubscriptionsWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx, groupId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdSubscriptionsResponse(rsp)
}

// PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse request with arbitrary body returning *PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse
func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse(ctx context.Context, groupId string, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx, groupId, projectId, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse(ctx context.Context, groupId string, projectId string, subscriptionId string, body PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx, groupId, projectId, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp)
}

// PostMGroupIdSystemProjectsProjectIdVersionCommitWithBodyWithResponse request with arbitrary body returning *PostMGroupIdSystemProjectsProjectIdVersionCommitResponse
func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdVersionCommitWithBodyWithResponse(ctx context.Context, groupId string, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdVersionCommitResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdVersionCommitWithBody(ctx, groupId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdVersionCommitResponse(rsp)
}

func (c *ClientWithResponses) PostMGroupIdSystemProjectsProjectIdVersionCommitWithResponse(ctx context.Context, groupId string, projectId string, body PostMGroupIdSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMGroupIdSystemProjectsProjectIdVersionCommitResponse, error) {
	rsp, err := c.PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx, groupId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMGroupIdSystemProjectsProjectIdVersionCommitResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdVersionCountWithResponse request returning *GetMGroupIdSystemProjectsProjectIdVersionCountResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdVersionCountWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionCountResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdVersionCount(ctx, groupId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdVersionCountResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdVersionDiffWithResponse request returning *GetMGroupIdSystemProjectsProjectIdVersionDiffResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdVersionDiffWithResponse(ctx context.Context, groupId string, projectId string, params *GetMGroupIdSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionDiffResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx, groupId, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdVersionDiffResponse(rsp)
}

// GetMGroupIdSystemProjectsProjectIdVersionFilesWithResponse request returning *GetMGroupIdSystemProjectsProjectIdVersionFilesResponse
func (c *ClientWithResponses) GetMGroupIdSystemProjectsProjectIdVersionFilesWithResponse(ctx context.Context, groupId string, projectId string, reqEditors ...RequestEditorFn) (*GetMGroupIdSystemProjectsProjectIdVersionFilesResponse, error) {
	rsp, err := c.GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx, groupId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMGroupIdSystemProjectsProjectIdVersionFilesResponse(rsp)
}

// GetMasterBundlesGroupVersionWithResponse request returning *GetMasterBundlesGroupVersionResponse
func (c *ClientWithResponses) GetMasterBundlesGroupVersionWithResponse(ctx context.Context, group string, version string, reqEditors ...RequestEditorFn) (*GetMasterBundlesGroupVersionResponse, error) {
	rsp, err := c.GetMasterBundlesGroupVersion(ctx, group, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterBundlesGroupVersionResponse(rsp)
}

// GetMasterGroupsIdWithResponse request returning *GetMasterGroupsIdResponse
func (c *ClientWithResponses) GetMasterGroupsIdWithResponse(ctx context.Context, id string, params *GetMasterGroupsIdParams, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdResponse, error) {
	rsp, err := c.GetMasterGroupsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterGroupsIdResponse(rsp)
}

// GetMasterGroupsIdAclWithResponse request returning *GetMasterGroupsIdAclResponse
func (c *ClientWithResponses) GetMasterGroupsIdAclWithResponse(ctx context.Context, id string, params *GetMasterGroupsIdAclParams, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdAclResponse, error) {
	rsp, err := c.GetMasterGroupsIdAcl(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterGroupsIdAclResponse(rsp)
}

// GetMasterGroupsIdConfigVersionWithResponse request returning *GetMasterGroupsIdConfigVersionResponse
func (c *ClientWithResponses) GetMasterGroupsIdConfigVersionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMasterGroupsIdConfigVersionResponse, error) {
	rsp, err := c.GetMasterGroupsIdConfigVersion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterGroupsIdConfigVersionResponse(rsp)
}

// PatchMasterGroupsIdDeployWithBodyWithResponse request with arbitrary body returning *PatchMasterGroupsIdDeployResponse
func (c *ClientWithResponses) PatchMasterGroupsIdDeployWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchMasterGroupsIdDeployResponse, error) {
	rsp, err := c.PatchMasterGroupsIdDeployWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMasterGroupsIdDeployResponse(rsp)
}

func (c *ClientWithResponses) PatchMasterGroupsIdDeployWithResponse(ctx context.Context, id string, body PatchMasterGroupsIdDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchMasterGroupsIdDeployResponse, error) {
	rsp, err := c.PatchMasterGroupsIdDeploy(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMasterGroupsIdDeployResponse(rsp)
}

// GetMasterSummaryWithResponse request returning *GetMasterSummaryResponse
func (c *ClientWithResponses) GetMasterSummaryWithResponse(ctx context.Context, params *GetMasterSummaryParams, reqEditors ...RequestEditorFn) (*GetMasterSummaryResponse, error) {
	rsp, err := c.GetMasterSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterSummaryResponse(rsp)
}

// GetMasterSummaryWorkersWithResponse request returning *GetMasterSummaryWorkersResponse
func (c *ClientWithResponses) GetMasterSummaryWorkersWithResponse(ctx context.Context, params *GetMasterSummaryWorkersParams, reqEditors ...RequestEditorFn) (*GetMasterSummaryWorkersResponse, error) {
	rsp, err := c.GetMasterSummaryWorkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterSummaryWorkersResponse(rsp)
}

// GetMasterWorkersWithResponse request returning *GetMasterWorkersResponse
func (c *ClientWithResponses) GetMasterWorkersWithResponse(ctx context.Context, params *GetMasterWorkersParams, reqEditors ...RequestEditorFn) (*GetMasterWorkersResponse, error) {
	rsp, err := c.GetMasterWorkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterWorkersResponse(rsp)
}

// PatchMasterWorkersRestartWithResponse request returning *PatchMasterWorkersRestartResponse
func (c *ClientWithResponses) PatchMasterWorkersRestartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchMasterWorkersRestartResponse, error) {
	rsp, err := c.PatchMasterWorkersRestart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchMasterWorkersRestartResponse(rsp)
}

// GetNotificationTargetsWithResponse request returning *GetNotificationTargetsResponse
func (c *ClientWithResponses) GetNotificationTargetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationTargetsResponse, error) {
	rsp, err := c.GetNotificationTargets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationTargetsResponse(rsp)
}

// PostNotificationTargetsWithBodyWithResponse request with arbitrary body returning *PostNotificationTargetsResponse
func (c *ClientWithResponses) PostNotificationTargetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationTargetsResponse, error) {
	rsp, err := c.PostNotificationTargetsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationTargetsResponse(rsp)
}

func (c *ClientWithResponses) PostNotificationTargetsWithResponse(ctx context.Context, body PostNotificationTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationTargetsResponse, error) {
	rsp, err := c.PostNotificationTargets(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationTargetsResponse(rsp)
}

// DeleteNotificationTargetsIdWithResponse request returning *DeleteNotificationTargetsIdResponse
func (c *ClientWithResponses) DeleteNotificationTargetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotificationTargetsIdResponse, error) {
	rsp, err := c.DeleteNotificationTargetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationTargetsIdResponse(rsp)
}

// GetNotificationTargetsIdWithResponse request returning *GetNotificationTargetsIdResponse
func (c *ClientWithResponses) GetNotificationTargetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotificationTargetsIdResponse, error) {
	rsp, err := c.GetNotificationTargetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationTargetsIdResponse(rsp)
}

// PatchNotificationTargetsIdWithBodyWithResponse request with arbitrary body returning *PatchNotificationTargetsIdResponse
func (c *ClientWithResponses) PatchNotificationTargetsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchNotificationTargetsIdResponse, error) {
	rsp, err := c.PatchNotificationTargetsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchNotificationTargetsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchNotificationTargetsIdWithResponse(ctx context.Context, id string, body PatchNotificationTargetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchNotificationTargetsIdResponse, error) {
	rsp, err := c.PatchNotificationTargetsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchNotificationTargetsIdResponse(rsp)
}

// GetNotificationsWithResponse request returning *GetNotificationsResponse
func (c *ClientWithResponses) GetNotificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error) {
	rsp, err := c.GetNotifications(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsResponse(rsp)
}

// PostNotificationsWithBodyWithResponse request with arbitrary body returning *PostNotificationsResponse
func (c *ClientWithResponses) PostNotificationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationsResponse, error) {
	rsp, err := c.PostNotificationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationsResponse(rsp)
}

func (c *ClientWithResponses) PostNotificationsWithResponse(ctx context.Context, body PostNotificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationsResponse, error) {
	rsp, err := c.PostNotifications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationsResponse(rsp)
}

// DeleteNotificationsIdWithResponse request returning *DeleteNotificationsIdResponse
func (c *ClientWithResponses) DeleteNotificationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotificationsIdResponse, error) {
	rsp, err := c.DeleteNotificationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsIdResponse(rsp)
}

// GetNotificationsIdWithResponse request returning *GetNotificationsIdResponse
func (c *ClientWithResponses) GetNotificationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotificationsIdResponse, error) {
	rsp, err := c.GetNotificationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsIdResponse(rsp)
}

// PatchNotificationsIdWithBodyWithResponse request with arbitrary body returning *PatchNotificationsIdResponse
func (c *ClientWithResponses) PatchNotificationsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchNotificationsIdResponse, error) {
	rsp, err := c.PatchNotificationsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchNotificationsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchNotificationsIdWithResponse(ctx context.Context, id string, body PatchNotificationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchNotificationsIdResponse, error) {
	rsp, err := c.PatchNotificationsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchNotificationsIdResponse(rsp)
}

// PostOutputClickHouseDescribeTableWithBodyWithResponse request with arbitrary body returning *PostOutputClickHouseDescribeTableResponse
func (c *ClientWithResponses) PostOutputClickHouseDescribeTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputClickHouseDescribeTableResponse, error) {
	rsp, err := c.PostOutputClickHouseDescribeTableWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputClickHouseDescribeTableResponse(rsp)
}

func (c *ClientWithResponses) PostOutputClickHouseDescribeTableWithResponse(ctx context.Context, body PostOutputClickHouseDescribeTableJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputClickHouseDescribeTableResponse, error) {
	rsp, err := c.PostOutputClickHouseDescribeTable(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputClickHouseDescribeTableResponse(rsp)
}

// GetPPackFunctionsWithResponse request returning *GetPPackFunctionsResponse
func (c *ClientWithResponses) GetPPackFunctionsWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackFunctionsResponse, error) {
	rsp, err := c.GetPPackFunctions(ctx, pack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackFunctionsResponse(rsp)
}

// GetPPackFunctionsIdWithResponse request returning *GetPPackFunctionsIdResponse
func (c *ClientWithResponses) GetPPackFunctionsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackFunctionsIdResponse, error) {
	rsp, err := c.GetPPackFunctionsId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackFunctionsIdResponse(rsp)
}

// GetPPackLibSchemasWithResponse request returning *GetPPackLibSchemasResponse
func (c *ClientWithResponses) GetPPackLibSchemasWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackLibSchemasResponse, error) {
	rsp, err := c.GetPPackLibSchemas(ctx, pack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackLibSchemasResponse(rsp)
}

// PostPPackLibSchemasWithBodyWithResponse request with arbitrary body returning *PostPPackLibSchemasResponse
func (c *ClientWithResponses) PostPPackLibSchemasWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackLibSchemasResponse, error) {
	rsp, err := c.PostPPackLibSchemasWithBody(ctx, pack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackLibSchemasResponse(rsp)
}

func (c *ClientWithResponses) PostPPackLibSchemasWithResponse(ctx context.Context, pack string, body PostPPackLibSchemasJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackLibSchemasResponse, error) {
	rsp, err := c.PostPPackLibSchemas(ctx, pack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackLibSchemasResponse(rsp)
}

// DeletePPackLibSchemasIdWithResponse request returning *DeletePPackLibSchemasIdResponse
func (c *ClientWithResponses) DeletePPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackLibSchemasIdResponse, error) {
	rsp, err := c.DeletePPackLibSchemasId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePPackLibSchemasIdResponse(rsp)
}

// GetPPackLibSchemasIdWithResponse request returning *GetPPackLibSchemasIdResponse
func (c *ClientWithResponses) GetPPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackLibSchemasIdResponse, error) {
	rsp, err := c.GetPPackLibSchemasId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackLibSchemasIdResponse(rsp)
}

// PatchPPackLibSchemasIdWithBodyWithResponse request with arbitrary body returning *PatchPPackLibSchemasIdResponse
func (c *ClientWithResponses) PatchPPackLibSchemasIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackLibSchemasIdResponse, error) {
	rsp, err := c.PatchPPackLibSchemasIdWithBody(ctx, pack, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackLibSchemasIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPPackLibSchemasIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackLibSchemasIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackLibSchemasIdResponse, error) {
	rsp, err := c.PatchPPackLibSchemasId(ctx, pack, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackLibSchemasIdResponse(rsp)
}

// GetPPackLibVarsWithResponse request returning *GetPPackLibVarsResponse
func (c *ClientWithResponses) GetPPackLibVarsWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackLibVarsResponse, error) {
	rsp, err := c.GetPPackLibVars(ctx, pack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackLibVarsResponse(rsp)
}

// PostPPackLibVarsWithBodyWithResponse request with arbitrary body returning *PostPPackLibVarsResponse
func (c *ClientWithResponses) PostPPackLibVarsWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackLibVarsResponse, error) {
	rsp, err := c.PostPPackLibVarsWithBody(ctx, pack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackLibVarsResponse(rsp)
}

func (c *ClientWithResponses) PostPPackLibVarsWithResponse(ctx context.Context, pack string, body PostPPackLibVarsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackLibVarsResponse, error) {
	rsp, err := c.PostPPackLibVars(ctx, pack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackLibVarsResponse(rsp)
}

// DeletePPackLibVarsIdWithResponse request returning *DeletePPackLibVarsIdResponse
func (c *ClientWithResponses) DeletePPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackLibVarsIdResponse, error) {
	rsp, err := c.DeletePPackLibVarsId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePPackLibVarsIdResponse(rsp)
}

// GetPPackLibVarsIdWithResponse request returning *GetPPackLibVarsIdResponse
func (c *ClientWithResponses) GetPPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackLibVarsIdResponse, error) {
	rsp, err := c.GetPPackLibVarsId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackLibVarsIdResponse(rsp)
}

// PatchPPackLibVarsIdWithBodyWithResponse request with arbitrary body returning *PatchPPackLibVarsIdResponse
func (c *ClientWithResponses) PatchPPackLibVarsIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackLibVarsIdResponse, error) {
	rsp, err := c.PatchPPackLibVarsIdWithBody(ctx, pack, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackLibVarsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPPackLibVarsIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackLibVarsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackLibVarsIdResponse, error) {
	rsp, err := c.PatchPPackLibVarsId(ctx, pack, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackLibVarsIdResponse(rsp)
}

// GetPPackPipelinesWithResponse request returning *GetPPackPipelinesResponse
func (c *ClientWithResponses) GetPPackPipelinesWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackPipelinesResponse, error) {
	rsp, err := c.GetPPackPipelines(ctx, pack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackPipelinesResponse(rsp)
}

// PostPPackPipelinesWithBodyWithResponse request with arbitrary body returning *PostPPackPipelinesResponse
func (c *ClientWithResponses) PostPPackPipelinesWithBodyWithResponse(ctx context.Context, pack string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackPipelinesResponse, error) {
	rsp, err := c.PostPPackPipelinesWithBody(ctx, pack, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackPipelinesResponse(rsp)
}

func (c *ClientWithResponses) PostPPackPipelinesWithResponse(ctx context.Context, pack string, body PostPPackPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackPipelinesResponse, error) {
	rsp, err := c.PostPPackPipelines(ctx, pack, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackPipelinesResponse(rsp)
}

// DeletePPackPipelinesIdWithResponse request returning *DeletePPackPipelinesIdResponse
func (c *ClientWithResponses) DeletePPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*DeletePPackPipelinesIdResponse, error) {
	rsp, err := c.DeletePPackPipelinesId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePPackPipelinesIdResponse(rsp)
}

// GetPPackPipelinesIdWithResponse request returning *GetPPackPipelinesIdResponse
func (c *ClientWithResponses) GetPPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackPipelinesIdResponse, error) {
	rsp, err := c.GetPPackPipelinesId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackPipelinesIdResponse(rsp)
}

// PatchPPackPipelinesIdWithBodyWithResponse request with arbitrary body returning *PatchPPackPipelinesIdResponse
func (c *ClientWithResponses) PatchPPackPipelinesIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackPipelinesIdResponse, error) {
	rsp, err := c.PatchPPackPipelinesIdWithBody(ctx, pack, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackPipelinesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPPackPipelinesIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackPipelinesIdResponse, error) {
	rsp, err := c.PatchPPackPipelinesId(ctx, pack, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackPipelinesIdResponse(rsp)
}

// GetPPackRoutesWithResponse request returning *GetPPackRoutesResponse
func (c *ClientWithResponses) GetPPackRoutesWithResponse(ctx context.Context, pack string, reqEditors ...RequestEditorFn) (*GetPPackRoutesResponse, error) {
	rsp, err := c.GetPPackRoutes(ctx, pack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackRoutesResponse(rsp)
}

// GetPPackRoutesIdWithResponse request returning *GetPPackRoutesIdResponse
func (c *ClientWithResponses) GetPPackRoutesIdWithResponse(ctx context.Context, pack string, id string, reqEditors ...RequestEditorFn) (*GetPPackRoutesIdResponse, error) {
	rsp, err := c.GetPPackRoutesId(ctx, pack, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPPackRoutesIdResponse(rsp)
}

// PatchPPackRoutesIdWithBodyWithResponse request with arbitrary body returning *PatchPPackRoutesIdResponse
func (c *ClientWithResponses) PatchPPackRoutesIdWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPPackRoutesIdResponse, error) {
	rsp, err := c.PatchPPackRoutesIdWithBody(ctx, pack, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackRoutesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPPackRoutesIdWithResponse(ctx context.Context, pack string, id string, body PatchPPackRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPPackRoutesIdResponse, error) {
	rsp, err := c.PatchPPackRoutesId(ctx, pack, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPPackRoutesIdResponse(rsp)
}

// PostPPackRoutesIdAppendWithBodyWithResponse request with arbitrary body returning *PostPPackRoutesIdAppendResponse
func (c *ClientWithResponses) PostPPackRoutesIdAppendWithBodyWithResponse(ctx context.Context, pack string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPPackRoutesIdAppendResponse, error) {
	rsp, err := c.PostPPackRoutesIdAppendWithBody(ctx, pack, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackRoutesIdAppendResponse(rsp)
}

func (c *ClientWithResponses) PostPPackRoutesIdAppendWithResponse(ctx context.Context, pack string, id string, body PostPPackRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPPackRoutesIdAppendResponse, error) {
	rsp, err := c.PostPPackRoutesIdAppend(ctx, pack, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPPackRoutesIdAppendResponse(rsp)
}

// GetPacksWithResponse request returning *GetPacksResponse
func (c *ClientWithResponses) GetPacksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPacksResponse, error) {
	rsp, err := c.GetPacks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPacksResponse(rsp)
}

// PostPacksWithBodyWithResponse request with arbitrary body returning *PostPacksResponse
func (c *ClientWithResponses) PostPacksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPacksResponse, error) {
	rsp, err := c.PostPacksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPacksResponse(rsp)
}

func (c *ClientWithResponses) PostPacksWithResponse(ctx context.Context, body PostPacksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPacksResponse, error) {
	rsp, err := c.PostPacks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPacksResponse(rsp)
}

// PutPacksWithResponse request returning *PutPacksResponse
func (c *ClientWithResponses) PutPacksWithResponse(ctx context.Context, params *PutPacksParams, reqEditors ...RequestEditorFn) (*PutPacksResponse, error) {
	rsp, err := c.PutPacks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPacksResponse(rsp)
}

// PostPacksCloneWithBodyWithResponse request with arbitrary body returning *PostPacksCloneResponse
func (c *ClientWithResponses) PostPacksCloneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPacksCloneResponse, error) {
	rsp, err := c.PostPacksCloneWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPacksCloneResponse(rsp)
}

func (c *ClientWithResponses) PostPacksCloneWithResponse(ctx context.Context, body PostPacksCloneJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPacksCloneResponse, error) {
	rsp, err := c.PostPacksClone(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPacksCloneResponse(rsp)
}

// DeletePacksIdWithResponse request returning *DeletePacksIdResponse
func (c *ClientWithResponses) DeletePacksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePacksIdResponse, error) {
	rsp, err := c.DeletePacksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePacksIdResponse(rsp)
}

// PatchPacksIdWithResponse request returning *PatchPacksIdResponse
func (c *ClientWithResponses) PatchPacksIdWithResponse(ctx context.Context, id string, params *PatchPacksIdParams, reqEditors ...RequestEditorFn) (*PatchPacksIdResponse, error) {
	rsp, err := c.PatchPacksId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPacksIdResponse(rsp)
}

// GetPacksIdExportWithResponse request returning *GetPacksIdExportResponse
func (c *ClientWithResponses) GetPacksIdExportWithResponse(ctx context.Context, id string, params *GetPacksIdExportParams, reqEditors ...RequestEditorFn) (*GetPacksIdExportResponse, error) {
	rsp, err := c.GetPacksIdExport(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPacksIdExportResponse(rsp)
}

// GetPipelinesWithResponse request returning *GetPipelinesResponse
func (c *ClientWithResponses) GetPipelinesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error) {
	rsp, err := c.GetPipelines(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelinesResponse(rsp)
}

// PostPipelinesWithBodyWithResponse request with arbitrary body returning *PostPipelinesResponse
func (c *ClientWithResponses) PostPipelinesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPipelinesResponse, error) {
	rsp, err := c.PostPipelinesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPipelinesResponse(rsp)
}

func (c *ClientWithResponses) PostPipelinesWithResponse(ctx context.Context, body PostPipelinesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPipelinesResponse, error) {
	rsp, err := c.PostPipelines(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPipelinesResponse(rsp)
}

// DeletePipelinesIdWithResponse request returning *DeletePipelinesIdResponse
func (c *ClientWithResponses) DeletePipelinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePipelinesIdResponse, error) {
	rsp, err := c.DeletePipelinesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePipelinesIdResponse(rsp)
}

// GetPipelinesIdWithResponse request returning *GetPipelinesIdResponse
func (c *ClientWithResponses) GetPipelinesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPipelinesIdResponse, error) {
	rsp, err := c.GetPipelinesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelinesIdResponse(rsp)
}

// PatchPipelinesIdWithBodyWithResponse request with arbitrary body returning *PatchPipelinesIdResponse
func (c *ClientWithResponses) PatchPipelinesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPipelinesIdResponse, error) {
	rsp, err := c.PatchPipelinesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPipelinesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchPipelinesIdWithResponse(ctx context.Context, id string, body PatchPipelinesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPipelinesIdResponse, error) {
	rsp, err := c.PatchPipelinesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPipelinesIdResponse(rsp)
}

// PostPreviewWithBodyWithResponse request with arbitrary body returning *PostPreviewResponse
func (c *ClientWithResponses) PostPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPreviewResponse, error) {
	rsp, err := c.PostPreviewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPreviewResponse(rsp)
}

func (c *ClientWithResponses) PostPreviewWithResponse(ctx context.Context, body PostPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPreviewResponse, error) {
	rsp, err := c.PostPreview(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPreviewResponse(rsp)
}

// PostProductsEdgeMapQueryWithResponse request returning *PostProductsEdgeMapQueryResponse
func (c *ClientWithResponses) PostProductsEdgeMapQueryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostProductsEdgeMapQueryResponse, error) {
	rsp, err := c.PostProductsEdgeMapQuery(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsEdgeMapQueryResponse(rsp)
}

// GetProductsLakeLakesLakeIdDatasetsWithResponse request returning *GetProductsLakeLakesLakeIdDatasetsResponse
func (c *ClientWithResponses) GetProductsLakeLakesLakeIdDatasetsWithResponse(ctx context.Context, lakeId string, reqEditors ...RequestEditorFn) (*GetProductsLakeLakesLakeIdDatasetsResponse, error) {
	rsp, err := c.GetProductsLakeLakesLakeIdDatasets(ctx, lakeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsLakeLakesLakeIdDatasetsResponse(rsp)
}

// PostProductsLakeLakesLakeIdDatasetsWithBodyWithResponse request with arbitrary body returning *PostProductsLakeLakesLakeIdDatasetsResponse
func (c *ClientWithResponses) PostProductsLakeLakesLakeIdDatasetsWithBodyWithResponse(ctx context.Context, lakeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsLakeLakesLakeIdDatasetsResponse, error) {
	rsp, err := c.PostProductsLakeLakesLakeIdDatasetsWithBody(ctx, lakeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsLakeLakesLakeIdDatasetsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsLakeLakesLakeIdDatasetsWithResponse(ctx context.Context, lakeId string, body PostProductsLakeLakesLakeIdDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsLakeLakesLakeIdDatasetsResponse, error) {
	rsp, err := c.PostProductsLakeLakesLakeIdDatasets(ctx, lakeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsLakeLakesLakeIdDatasetsResponse(rsp)
}

// DeleteProductsLakeLakesLakeIdDatasetsIdWithResponse request returning *DeleteProductsLakeLakesLakeIdDatasetsIdResponse
func (c *ClientWithResponses) DeleteProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*DeleteProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	rsp, err := c.DeleteProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsLakeLakesLakeIdDatasetsIdResponse(rsp)
}

// GetProductsLakeLakesLakeIdDatasetsIdWithResponse request returning *GetProductsLakeLakesLakeIdDatasetsIdResponse
func (c *ClientWithResponses) GetProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, reqEditors ...RequestEditorFn) (*GetProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	rsp, err := c.GetProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsLakeLakesLakeIdDatasetsIdResponse(rsp)
}

// PatchProductsLakeLakesLakeIdDatasetsIdWithBodyWithResponse request with arbitrary body returning *PatchProductsLakeLakesLakeIdDatasetsIdResponse
func (c *ClientWithResponses) PatchProductsLakeLakesLakeIdDatasetsIdWithBodyWithResponse(ctx context.Context, lakeId string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	rsp, err := c.PatchProductsLakeLakesLakeIdDatasetsIdWithBody(ctx, lakeId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProductsLakeLakesLakeIdDatasetsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchProductsLakeLakesLakeIdDatasetsIdWithResponse(ctx context.Context, lakeId string, id string, body PatchProductsLakeLakesLakeIdDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	rsp, err := c.PatchProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProductsLakeLakesLakeIdDatasetsIdResponse(rsp)
}

// GetProductsProductGroupsWithResponse request returning *GetProductsProductGroupsResponse
func (c *ClientWithResponses) GetProductsProductGroupsWithResponse(ctx context.Context, product GetProductsProductGroupsParamsProduct, params *GetProductsProductGroupsParams, reqEditors ...RequestEditorFn) (*GetProductsProductGroupsResponse, error) {
	rsp, err := c.GetProductsProductGroups(ctx, product, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductGroupsResponse(rsp)
}

// PostProductsProductGroupsWithBodyWithResponse request with arbitrary body returning *PostProductsProductGroupsResponse
func (c *ClientWithResponses) PostProductsProductGroupsWithBodyWithResponse(ctx context.Context, product PostProductsProductGroupsParamsProduct, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductGroupsResponse, error) {
	rsp, err := c.PostProductsProductGroupsWithBody(ctx, product, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductGroupsWithResponse(ctx context.Context, product PostProductsProductGroupsParamsProduct, body PostProductsProductGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductGroupsResponse, error) {
	rsp, err := c.PostProductsProductGroups(ctx, product, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductGroupsResponse(rsp)
}

// GetProductsProductGroupsIdAclTeamsWithResponse request returning *GetProductsProductGroupsIdAclTeamsResponse
func (c *ClientWithResponses) GetProductsProductGroupsIdAclTeamsWithResponse(ctx context.Context, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params *GetProductsProductGroupsIdAclTeamsParams, reqEditors ...RequestEditorFn) (*GetProductsProductGroupsIdAclTeamsResponse, error) {
	rsp, err := c.GetProductsProductGroupsIdAclTeams(ctx, product, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductGroupsIdAclTeamsResponse(rsp)
}

// GetProductsProductUsersWithResponse request returning *GetProductsProductUsersResponse
func (c *ClientWithResponses) GetProductsProductUsersWithResponse(ctx context.Context, product GetProductsProductUsersParamsProduct, params *GetProductsProductUsersParams, reqEditors ...RequestEditorFn) (*GetProductsProductUsersResponse, error) {
	rsp, err := c.GetProductsProductUsers(ctx, product, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductUsersResponse(rsp)
}

// DeleteProductsProductUsersCacheWithResponse request returning *DeleteProductsProductUsersCacheResponse
func (c *ClientWithResponses) DeleteProductsProductUsersCacheWithResponse(ctx context.Context, product DeleteProductsProductUsersCacheParamsProduct, reqEditors ...RequestEditorFn) (*DeleteProductsProductUsersCacheResponse, error) {
	rsp, err := c.DeleteProductsProductUsersCache(ctx, product, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsProductUsersCacheResponse(rsp)
}

// GetProductsProductUsersIdAclWithResponse request returning *GetProductsProductUsersIdAclResponse
func (c *ClientWithResponses) GetProductsProductUsersIdAclWithResponse(ctx context.Context, product GetProductsProductUsersIdAclParamsProduct, id string, params *GetProductsProductUsersIdAclParams, reqEditors ...RequestEditorFn) (*GetProductsProductUsersIdAclResponse, error) {
	rsp, err := c.GetProductsProductUsersIdAcl(ctx, product, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductUsersIdAclResponse(rsp)
}

// GetRoutesWithResponse request returning *GetRoutesResponse
func (c *ClientWithResponses) GetRoutesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRoutesResponse, error) {
	rsp, err := c.GetRoutes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesResponse(rsp)
}

// GetRoutesIdWithResponse request returning *GetRoutesIdResponse
func (c *ClientWithResponses) GetRoutesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRoutesIdResponse, error) {
	rsp, err := c.GetRoutesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesIdResponse(rsp)
}

// PatchRoutesIdWithBodyWithResponse request with arbitrary body returning *PatchRoutesIdResponse
func (c *ClientWithResponses) PatchRoutesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRoutesIdResponse, error) {
	rsp, err := c.PatchRoutesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoutesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchRoutesIdWithResponse(ctx context.Context, id string, body PatchRoutesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRoutesIdResponse, error) {
	rsp, err := c.PatchRoutesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRoutesIdResponse(rsp)
}

// PostRoutesIdAppendWithBodyWithResponse request with arbitrary body returning *PostRoutesIdAppendResponse
func (c *ClientWithResponses) PostRoutesIdAppendWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRoutesIdAppendResponse, error) {
	rsp, err := c.PostRoutesIdAppendWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRoutesIdAppendResponse(rsp)
}

func (c *ClientWithResponses) PostRoutesIdAppendWithResponse(ctx context.Context, id string, body PostRoutesIdAppendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRoutesIdAppendResponse, error) {
	rsp, err := c.PostRoutesIdAppend(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRoutesIdAppendResponse(rsp)
}

// GetSearchDashboardCategoriesWithResponse request returning *GetSearchDashboardCategoriesResponse
func (c *ClientWithResponses) GetSearchDashboardCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDashboardCategoriesResponse, error) {
	rsp, err := c.GetSearchDashboardCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardCategoriesResponse(rsp)
}

// PostSearchDashboardCategoriesWithBodyWithResponse request with arbitrary body returning *PostSearchDashboardCategoriesResponse
func (c *ClientWithResponses) PostSearchDashboardCategoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardCategoriesResponse, error) {
	rsp, err := c.PostSearchDashboardCategoriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardCategoriesResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDashboardCategoriesWithResponse(ctx context.Context, body PostSearchDashboardCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardCategoriesResponse, error) {
	rsp, err := c.PostSearchDashboardCategories(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardCategoriesResponse(rsp)
}

// DeleteSearchDashboardCategoriesIdWithResponse request returning *DeleteSearchDashboardCategoriesIdResponse
func (c *ClientWithResponses) DeleteSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDashboardCategoriesIdResponse, error) {
	rsp, err := c.DeleteSearchDashboardCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchDashboardCategoriesIdResponse(rsp)
}

// GetSearchDashboardCategoriesIdWithResponse request returning *GetSearchDashboardCategoriesIdResponse
func (c *ClientWithResponses) GetSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardCategoriesIdResponse, error) {
	rsp, err := c.GetSearchDashboardCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardCategoriesIdResponse(rsp)
}

// PatchSearchDashboardCategoriesIdWithBodyWithResponse request with arbitrary body returning *PatchSearchDashboardCategoriesIdResponse
func (c *ClientWithResponses) PatchSearchDashboardCategoriesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDashboardCategoriesIdResponse, error) {
	rsp, err := c.PatchSearchDashboardCategoriesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDashboardCategoriesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchDashboardCategoriesIdWithResponse(ctx context.Context, id string, body PatchSearchDashboardCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDashboardCategoriesIdResponse, error) {
	rsp, err := c.PatchSearchDashboardCategoriesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDashboardCategoriesIdResponse(rsp)
}

// GetSearchDashboardsWithResponse request returning *GetSearchDashboardsResponse
func (c *ClientWithResponses) GetSearchDashboardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDashboardsResponse, error) {
	rsp, err := c.GetSearchDashboards(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardsResponse(rsp)
}

// PostSearchDashboardsWithBodyWithResponse request with arbitrary body returning *PostSearchDashboardsResponse
func (c *ClientWithResponses) PostSearchDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsResponse, error) {
	rsp, err := c.PostSearchDashboardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDashboardsWithResponse(ctx context.Context, body PostSearchDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsResponse, error) {
	rsp, err := c.PostSearchDashboards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsResponse(rsp)
}

// DeleteSearchDashboardsIdWithResponse request returning *DeleteSearchDashboardsIdResponse
func (c *ClientWithResponses) DeleteSearchDashboardsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDashboardsIdResponse, error) {
	rsp, err := c.DeleteSearchDashboardsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchDashboardsIdResponse(rsp)
}

// GetSearchDashboardsIdWithResponse request returning *GetSearchDashboardsIdResponse
func (c *ClientWithResponses) GetSearchDashboardsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdResponse, error) {
	rsp, err := c.GetSearchDashboardsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardsIdResponse(rsp)
}

// PatchSearchDashboardsIdWithBodyWithResponse request with arbitrary body returning *PatchSearchDashboardsIdResponse
func (c *ClientWithResponses) PatchSearchDashboardsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDashboardsIdResponse, error) {
	rsp, err := c.PatchSearchDashboardsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDashboardsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchDashboardsIdWithResponse(ctx context.Context, id string, body PatchSearchDashboardsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDashboardsIdResponse, error) {
	rsp, err := c.PatchSearchDashboardsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDashboardsIdResponse(rsp)
}

// GetSearchDashboardsIdAclWithResponse request returning *GetSearchDashboardsIdAclResponse
func (c *ClientWithResponses) GetSearchDashboardsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdAclResponse, error) {
	rsp, err := c.GetSearchDashboardsIdAcl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardsIdAclResponse(rsp)
}

// PostSearchDashboardsIdAclApplyWithBodyWithResponse request with arbitrary body returning *PostSearchDashboardsIdAclApplyResponse
func (c *ClientWithResponses) PostSearchDashboardsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclApplyResponse, error) {
	rsp, err := c.PostSearchDashboardsIdAclApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsIdAclApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDashboardsIdAclApplyWithResponse(ctx context.Context, id string, body PostSearchDashboardsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclApplyResponse, error) {
	rsp, err := c.PostSearchDashboardsIdAclApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsIdAclApplyResponse(rsp)
}

// GetSearchDashboardsIdAclTeamsWithResponse request returning *GetSearchDashboardsIdAclTeamsResponse
func (c *ClientWithResponses) GetSearchDashboardsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDashboardsIdAclTeamsResponse, error) {
	rsp, err := c.GetSearchDashboardsIdAclTeams(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDashboardsIdAclTeamsResponse(rsp)
}

// PostSearchDashboardsIdAclTeamsApplyWithBodyWithResponse request with arbitrary body returning *PostSearchDashboardsIdAclTeamsApplyResponse
func (c *ClientWithResponses) PostSearchDashboardsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSearchDashboardsIdAclTeamsApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsIdAclTeamsApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDashboardsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSearchDashboardsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDashboardsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSearchDashboardsIdAclTeamsApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDashboardsIdAclTeamsApplyResponse(rsp)
}

// GetSearchDatasetProviderTypesWithResponse request returning *GetSearchDatasetProviderTypesResponse
func (c *ClientWithResponses) GetSearchDatasetProviderTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetProviderTypesResponse, error) {
	rsp, err := c.GetSearchDatasetProviderTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetProviderTypesResponse(rsp)
}

// PostSearchDatasetProviderTypesWithBodyWithResponse request with arbitrary body returning *PostSearchDatasetProviderTypesResponse
func (c *ClientWithResponses) PostSearchDatasetProviderTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetProviderTypesResponse, error) {
	rsp, err := c.PostSearchDatasetProviderTypesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetProviderTypesResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDatasetProviderTypesWithResponse(ctx context.Context, body PostSearchDatasetProviderTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetProviderTypesResponse, error) {
	rsp, err := c.PostSearchDatasetProviderTypes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetProviderTypesResponse(rsp)
}

// DeleteSearchDatasetProviderTypesIdWithResponse request returning *DeleteSearchDatasetProviderTypesIdResponse
func (c *ClientWithResponses) DeleteSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetProviderTypesIdResponse, error) {
	rsp, err := c.DeleteSearchDatasetProviderTypesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchDatasetProviderTypesIdResponse(rsp)
}

// GetSearchDatasetProviderTypesIdWithResponse request returning *GetSearchDatasetProviderTypesIdResponse
func (c *ClientWithResponses) GetSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetProviderTypesIdResponse, error) {
	rsp, err := c.GetSearchDatasetProviderTypesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetProviderTypesIdResponse(rsp)
}

// PatchSearchDatasetProviderTypesIdWithBodyWithResponse request with arbitrary body returning *PatchSearchDatasetProviderTypesIdResponse
func (c *ClientWithResponses) PatchSearchDatasetProviderTypesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProviderTypesIdResponse, error) {
	rsp, err := c.PatchSearchDatasetProviderTypesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetProviderTypesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchDatasetProviderTypesIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetProviderTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProviderTypesIdResponse, error) {
	rsp, err := c.PatchSearchDatasetProviderTypesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetProviderTypesIdResponse(rsp)
}

// GetSearchDatasetProvidersWithResponse request returning *GetSearchDatasetProvidersResponse
func (c *ClientWithResponses) GetSearchDatasetProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetProvidersResponse, error) {
	rsp, err := c.GetSearchDatasetProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetProvidersResponse(rsp)
}

// PostSearchDatasetProvidersWithBodyWithResponse request with arbitrary body returning *PostSearchDatasetProvidersResponse
func (c *ClientWithResponses) PostSearchDatasetProvidersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetProvidersResponse, error) {
	rsp, err := c.PostSearchDatasetProvidersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetProvidersResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDatasetProvidersWithResponse(ctx context.Context, body PostSearchDatasetProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetProvidersResponse, error) {
	rsp, err := c.PostSearchDatasetProviders(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetProvidersResponse(rsp)
}

// DeleteSearchDatasetProvidersIdWithResponse request returning *DeleteSearchDatasetProvidersIdResponse
func (c *ClientWithResponses) DeleteSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetProvidersIdResponse, error) {
	rsp, err := c.DeleteSearchDatasetProvidersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchDatasetProvidersIdResponse(rsp)
}

// GetSearchDatasetProvidersIdWithResponse request returning *GetSearchDatasetProvidersIdResponse
func (c *ClientWithResponses) GetSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetProvidersIdResponse, error) {
	rsp, err := c.GetSearchDatasetProvidersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetProvidersIdResponse(rsp)
}

// PatchSearchDatasetProvidersIdWithBodyWithResponse request with arbitrary body returning *PatchSearchDatasetProvidersIdResponse
func (c *ClientWithResponses) PatchSearchDatasetProvidersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProvidersIdResponse, error) {
	rsp, err := c.PatchSearchDatasetProvidersIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetProvidersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchDatasetProvidersIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetProvidersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetProvidersIdResponse, error) {
	rsp, err := c.PatchSearchDatasetProvidersId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetProvidersIdResponse(rsp)
}

// GetSearchDatasetsWithResponse request returning *GetSearchDatasetsResponse
func (c *ClientWithResponses) GetSearchDatasetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchDatasetsResponse, error) {
	rsp, err := c.GetSearchDatasets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetsResponse(rsp)
}

// PostSearchDatasetsWithBodyWithResponse request with arbitrary body returning *PostSearchDatasetsResponse
func (c *ClientWithResponses) PostSearchDatasetsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsResponse, error) {
	rsp, err := c.PostSearchDatasetsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDatasetsWithResponse(ctx context.Context, body PostSearchDatasetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsResponse, error) {
	rsp, err := c.PostSearchDatasets(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsResponse(rsp)
}

// DeleteSearchDatasetsIdWithResponse request returning *DeleteSearchDatasetsIdResponse
func (c *ClientWithResponses) DeleteSearchDatasetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchDatasetsIdResponse, error) {
	rsp, err := c.DeleteSearchDatasetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchDatasetsIdResponse(rsp)
}

// GetSearchDatasetsIdWithResponse request returning *GetSearchDatasetsIdResponse
func (c *ClientWithResponses) GetSearchDatasetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdResponse, error) {
	rsp, err := c.GetSearchDatasetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetsIdResponse(rsp)
}

// PatchSearchDatasetsIdWithBodyWithResponse request with arbitrary body returning *PatchSearchDatasetsIdResponse
func (c *ClientWithResponses) PatchSearchDatasetsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchDatasetsIdResponse, error) {
	rsp, err := c.PatchSearchDatasetsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchDatasetsIdWithResponse(ctx context.Context, id string, body PatchSearchDatasetsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchDatasetsIdResponse, error) {
	rsp, err := c.PatchSearchDatasetsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchDatasetsIdResponse(rsp)
}

// GetSearchDatasetsIdAclWithResponse request returning *GetSearchDatasetsIdAclResponse
func (c *ClientWithResponses) GetSearchDatasetsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdAclResponse, error) {
	rsp, err := c.GetSearchDatasetsIdAcl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetsIdAclResponse(rsp)
}

// PostSearchDatasetsIdAclApplyWithBodyWithResponse request with arbitrary body returning *PostSearchDatasetsIdAclApplyResponse
func (c *ClientWithResponses) PostSearchDatasetsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclApplyResponse, error) {
	rsp, err := c.PostSearchDatasetsIdAclApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsIdAclApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDatasetsIdAclApplyWithResponse(ctx context.Context, id string, body PostSearchDatasetsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclApplyResponse, error) {
	rsp, err := c.PostSearchDatasetsIdAclApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsIdAclApplyResponse(rsp)
}

// GetSearchDatasetsIdAclTeamsWithResponse request returning *GetSearchDatasetsIdAclTeamsResponse
func (c *ClientWithResponses) GetSearchDatasetsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchDatasetsIdAclTeamsResponse, error) {
	rsp, err := c.GetSearchDatasetsIdAclTeams(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDatasetsIdAclTeamsResponse(rsp)
}

// PostSearchDatasetsIdAclTeamsApplyWithBodyWithResponse request with arbitrary body returning *PostSearchDatasetsIdAclTeamsApplyResponse
func (c *ClientWithResponses) PostSearchDatasetsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSearchDatasetsIdAclTeamsApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsIdAclTeamsApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSearchDatasetsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSearchDatasetsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchDatasetsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSearchDatasetsIdAclTeamsApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchDatasetsIdAclTeamsApplyResponse(rsp)
}

// PostSearchEventBreakerPreviewWithBodyWithResponse request with arbitrary body returning *PostSearchEventBreakerPreviewResponse
func (c *ClientWithResponses) PostSearchEventBreakerPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchEventBreakerPreviewResponse, error) {
	rsp, err := c.PostSearchEventBreakerPreviewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchEventBreakerPreviewResponse(rsp)
}

func (c *ClientWithResponses) PostSearchEventBreakerPreviewWithResponse(ctx context.Context, body PostSearchEventBreakerPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchEventBreakerPreviewResponse, error) {
	rsp, err := c.PostSearchEventBreakerPreview(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchEventBreakerPreviewResponse(rsp)
}

// GetSearchHealthcheckWithResponse request returning *GetSearchHealthcheckResponse
func (c *ClientWithResponses) GetSearchHealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchHealthcheckResponse, error) {
	rsp, err := c.GetSearchHealthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchHealthcheckResponse(rsp)
}

// GetSearchJobMetricsWithResponse request returning *GetSearchJobMetricsResponse
func (c *ClientWithResponses) GetSearchJobMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchJobMetricsResponse, error) {
	rsp, err := c.GetSearchJobMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobMetricsResponse(rsp)
}

// GetSearchJobsWithResponse request returning *GetSearchJobsResponse
func (c *ClientWithResponses) GetSearchJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchJobsResponse, error) {
	rsp, err := c.GetSearchJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsResponse(rsp)
}

// PostSearchJobsWithBodyWithResponse request with arbitrary body returning *PostSearchJobsResponse
func (c *ClientWithResponses) PostSearchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchJobsResponse, error) {
	rsp, err := c.PostSearchJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchJobsResponse(rsp)
}

func (c *ClientWithResponses) PostSearchJobsWithResponse(ctx context.Context, body PostSearchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchJobsResponse, error) {
	rsp, err := c.PostSearchJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchJobsResponse(rsp)
}

// DeleteSearchJobsIdWithResponse request returning *DeleteSearchJobsIdResponse
func (c *ClientWithResponses) DeleteSearchJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchJobsIdResponse, error) {
	rsp, err := c.DeleteSearchJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchJobsIdResponse(rsp)
}

// GetSearchJobsIdWithResponse request returning *GetSearchJobsIdResponse
func (c *ClientWithResponses) GetSearchJobsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResponse, error) {
	rsp, err := c.GetSearchJobsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdResponse(rsp)
}

// PatchSearchJobsIdWithBodyWithResponse request with arbitrary body returning *PatchSearchJobsIdResponse
func (c *ClientWithResponses) PatchSearchJobsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchJobsIdResponse, error) {
	rsp, err := c.PatchSearchJobsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchJobsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchJobsIdWithResponse(ctx context.Context, id string, body PatchSearchJobsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchJobsIdResponse, error) {
	rsp, err := c.PatchSearchJobsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchJobsIdResponse(rsp)
}

// PostSearchJobsIdDispatchExecutorsWithResponse request returning *PostSearchJobsIdDispatchExecutorsResponse
func (c *ClientWithResponses) PostSearchJobsIdDispatchExecutorsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostSearchJobsIdDispatchExecutorsResponse, error) {
	rsp, err := c.PostSearchJobsIdDispatchExecutors(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchJobsIdDispatchExecutorsResponse(rsp)
}

// GetSearchJobsIdLogsWithResponse request returning *GetSearchJobsIdLogsResponse
func (c *ClientWithResponses) GetSearchJobsIdLogsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdLogsResponse, error) {
	rsp, err := c.GetSearchJobsIdLogs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdLogsResponse(rsp)
}

// GetSearchJobsIdMetricsWithResponse request returning *GetSearchJobsIdMetricsResponse
func (c *ClientWithResponses) GetSearchJobsIdMetricsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdMetricsResponse, error) {
	rsp, err := c.GetSearchJobsIdMetrics(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdMetricsResponse(rsp)
}

// GetSearchJobsIdResultsWithResponse request returning *GetSearchJobsIdResultsResponse
func (c *ClientWithResponses) GetSearchJobsIdResultsWithResponse(ctx context.Context, id string, params *GetSearchJobsIdResultsParams, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResultsResponse, error) {
	rsp, err := c.GetSearchJobsIdResults(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdResultsResponse(rsp)
}

// GetSearchJobsIdResultsPollWithResponse request returning *GetSearchJobsIdResultsPollResponse
func (c *ClientWithResponses) GetSearchJobsIdResultsPollWithResponse(ctx context.Context, id string, params *GetSearchJobsIdResultsPollParams, reqEditors ...RequestEditorFn) (*GetSearchJobsIdResultsPollResponse, error) {
	rsp, err := c.GetSearchJobsIdResultsPoll(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdResultsPollResponse(rsp)
}

// GetSearchJobsIdStagesStageIdResultsWithResponse request returning *GetSearchJobsIdStagesStageIdResultsResponse
func (c *ClientWithResponses) GetSearchJobsIdStagesStageIdResultsWithResponse(ctx context.Context, id string, stageId string, reqEditors ...RequestEditorFn) (*GetSearchJobsIdStagesStageIdResultsResponse, error) {
	rsp, err := c.GetSearchJobsIdStagesStageIdResults(ctx, id, stageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchJobsIdStagesStageIdResultsResponse(rsp)
}

// GetSearchMacrosWithResponse request returning *GetSearchMacrosResponse
func (c *ClientWithResponses) GetSearchMacrosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchMacrosResponse, error) {
	rsp, err := c.GetSearchMacros(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchMacrosResponse(rsp)
}

// PostSearchMacrosWithBodyWithResponse request with arbitrary body returning *PostSearchMacrosResponse
func (c *ClientWithResponses) PostSearchMacrosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchMacrosResponse, error) {
	rsp, err := c.PostSearchMacrosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchMacrosResponse(rsp)
}

func (c *ClientWithResponses) PostSearchMacrosWithResponse(ctx context.Context, body PostSearchMacrosJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchMacrosResponse, error) {
	rsp, err := c.PostSearchMacros(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchMacrosResponse(rsp)
}

// DeleteSearchMacrosIdWithResponse request returning *DeleteSearchMacrosIdResponse
func (c *ClientWithResponses) DeleteSearchMacrosIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchMacrosIdResponse, error) {
	rsp, err := c.DeleteSearchMacrosId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchMacrosIdResponse(rsp)
}

// GetSearchMacrosIdWithResponse request returning *GetSearchMacrosIdResponse
func (c *ClientWithResponses) GetSearchMacrosIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchMacrosIdResponse, error) {
	rsp, err := c.GetSearchMacrosId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchMacrosIdResponse(rsp)
}

// PatchSearchMacrosIdWithBodyWithResponse request with arbitrary body returning *PatchSearchMacrosIdResponse
func (c *ClientWithResponses) PatchSearchMacrosIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchMacrosIdResponse, error) {
	rsp, err := c.PatchSearchMacrosIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchMacrosIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchMacrosIdWithResponse(ctx context.Context, id string, body PatchSearchMacrosIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchMacrosIdResponse, error) {
	rsp, err := c.PatchSearchMacrosId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchMacrosIdResponse(rsp)
}

// PostSearchPreviewWithBodyWithResponse request with arbitrary body returning *PostSearchPreviewResponse
func (c *ClientWithResponses) PostSearchPreviewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchPreviewResponse, error) {
	rsp, err := c.PostSearchPreviewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchPreviewResponse(rsp)
}

func (c *ClientWithResponses) PostSearchPreviewWithResponse(ctx context.Context, body PostSearchPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchPreviewResponse, error) {
	rsp, err := c.PostSearchPreview(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchPreviewResponse(rsp)
}

// GetSearchSavedWithResponse request returning *GetSearchSavedResponse
func (c *ClientWithResponses) GetSearchSavedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchSavedResponse, error) {
	rsp, err := c.GetSearchSaved(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchSavedResponse(rsp)
}

// PostSearchSavedWithBodyWithResponse request with arbitrary body returning *PostSearchSavedResponse
func (c *ClientWithResponses) PostSearchSavedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchSavedResponse, error) {
	rsp, err := c.PostSearchSavedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchSavedResponse(rsp)
}

func (c *ClientWithResponses) PostSearchSavedWithResponse(ctx context.Context, body PostSearchSavedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchSavedResponse, error) {
	rsp, err := c.PostSearchSaved(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchSavedResponse(rsp)
}

// DeleteSearchSavedIdWithResponse request returning *DeleteSearchSavedIdResponse
func (c *ClientWithResponses) DeleteSearchSavedIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchSavedIdResponse, error) {
	rsp, err := c.DeleteSearchSavedId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchSavedIdResponse(rsp)
}

// GetSearchSavedIdWithResponse request returning *GetSearchSavedIdResponse
func (c *ClientWithResponses) GetSearchSavedIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchSavedIdResponse, error) {
	rsp, err := c.GetSearchSavedId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchSavedIdResponse(rsp)
}

// PatchSearchSavedIdWithBodyWithResponse request with arbitrary body returning *PatchSearchSavedIdResponse
func (c *ClientWithResponses) PatchSearchSavedIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchSavedIdResponse, error) {
	rsp, err := c.PatchSearchSavedIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchSavedIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchSavedIdWithResponse(ctx context.Context, id string, body PatchSearchSavedIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchSavedIdResponse, error) {
	rsp, err := c.PatchSearchSavedId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchSavedIdResponse(rsp)
}

// GetSearchTrustPoliciesWithResponse request returning *GetSearchTrustPoliciesResponse
func (c *ClientWithResponses) GetSearchTrustPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchTrustPoliciesResponse, error) {
	rsp, err := c.GetSearchTrustPolicies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchTrustPoliciesResponse(rsp)
}

// GetSearchUsageGroupsWithResponse request returning *GetSearchUsageGroupsResponse
func (c *ClientWithResponses) GetSearchUsageGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchUsageGroupsResponse, error) {
	rsp, err := c.GetSearchUsageGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchUsageGroupsResponse(rsp)
}

// PostSearchUsageGroupsWithBodyWithResponse request with arbitrary body returning *PostSearchUsageGroupsResponse
func (c *ClientWithResponses) PostSearchUsageGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSearchUsageGroupsResponse, error) {
	rsp, err := c.PostSearchUsageGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchUsageGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostSearchUsageGroupsWithResponse(ctx context.Context, body PostSearchUsageGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSearchUsageGroupsResponse, error) {
	rsp, err := c.PostSearchUsageGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSearchUsageGroupsResponse(rsp)
}

// DeleteSearchUsageGroupsIdWithResponse request returning *DeleteSearchUsageGroupsIdResponse
func (c *ClientWithResponses) DeleteSearchUsageGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSearchUsageGroupsIdResponse, error) {
	rsp, err := c.DeleteSearchUsageGroupsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSearchUsageGroupsIdResponse(rsp)
}

// GetSearchUsageGroupsIdWithResponse request returning *GetSearchUsageGroupsIdResponse
func (c *ClientWithResponses) GetSearchUsageGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSearchUsageGroupsIdResponse, error) {
	rsp, err := c.GetSearchUsageGroupsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchUsageGroupsIdResponse(rsp)
}

// PatchSearchUsageGroupsIdWithBodyWithResponse request with arbitrary body returning *PatchSearchUsageGroupsIdResponse
func (c *ClientWithResponses) PatchSearchUsageGroupsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSearchUsageGroupsIdResponse, error) {
	rsp, err := c.PatchSearchUsageGroupsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchUsageGroupsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSearchUsageGroupsIdWithResponse(ctx context.Context, id string, body PatchSearchUsageGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSearchUsageGroupsIdResponse, error) {
	rsp, err := c.PatchSearchUsageGroupsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSearchUsageGroupsIdResponse(rsp)
}

// GetSecurityKmsConfigWithResponse request returning *GetSecurityKmsConfigResponse
func (c *ClientWithResponses) GetSecurityKmsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityKmsConfigResponse, error) {
	rsp, err := c.GetSecurityKmsConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityKmsConfigResponse(rsp)
}

// PatchSecurityKmsConfigWithBodyWithResponse request with arbitrary body returning *PatchSecurityKmsConfigResponse
func (c *ClientWithResponses) PatchSecurityKmsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSecurityKmsConfigResponse, error) {
	rsp, err := c.PatchSecurityKmsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSecurityKmsConfigResponse(rsp)
}

func (c *ClientWithResponses) PatchSecurityKmsConfigWithResponse(ctx context.Context, body PatchSecurityKmsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSecurityKmsConfigResponse, error) {
	rsp, err := c.PatchSecurityKmsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSecurityKmsConfigResponse(rsp)
}

// GetSecurityKmsHealthWithResponse request returning *GetSecurityKmsHealthResponse
func (c *ClientWithResponses) GetSecurityKmsHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecurityKmsHealthResponse, error) {
	rsp, err := c.GetSecurityKmsHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityKmsHealthResponse(rsp)
}

// GetSettingsFeaturesWithResponse request returning *GetSettingsFeaturesResponse
func (c *ClientWithResponses) GetSettingsFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsFeaturesResponse, error) {
	rsp, err := c.GetSettingsFeatures(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsFeaturesResponse(rsp)
}

// GetSettingsFeaturesIdWithResponse request returning *GetSettingsFeaturesIdResponse
func (c *ClientWithResponses) GetSettingsFeaturesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSettingsFeaturesIdResponse, error) {
	rsp, err := c.GetSettingsFeaturesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsFeaturesIdResponse(rsp)
}

// GetSystemBannersWithResponse request returning *GetSystemBannersResponse
func (c *ClientWithResponses) GetSystemBannersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemBannersResponse, error) {
	rsp, err := c.GetSystemBanners(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemBannersResponse(rsp)
}

// PostSystemBannersWithBodyWithResponse request with arbitrary body returning *PostSystemBannersResponse
func (c *ClientWithResponses) PostSystemBannersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemBannersResponse, error) {
	rsp, err := c.PostSystemBannersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemBannersResponse(rsp)
}

func (c *ClientWithResponses) PostSystemBannersWithResponse(ctx context.Context, body PostSystemBannersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemBannersResponse, error) {
	rsp, err := c.PostSystemBanners(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemBannersResponse(rsp)
}

// DeleteSystemBannersIdWithResponse request returning *DeleteSystemBannersIdResponse
func (c *ClientWithResponses) DeleteSystemBannersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemBannersIdResponse, error) {
	rsp, err := c.DeleteSystemBannersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemBannersIdResponse(rsp)
}

// GetSystemBannersIdWithResponse request returning *GetSystemBannersIdResponse
func (c *ClientWithResponses) GetSystemBannersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemBannersIdResponse, error) {
	rsp, err := c.GetSystemBannersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemBannersIdResponse(rsp)
}

// PatchSystemBannersIdWithBodyWithResponse request with arbitrary body returning *PatchSystemBannersIdResponse
func (c *ClientWithResponses) PatchSystemBannersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemBannersIdResponse, error) {
	rsp, err := c.PatchSystemBannersIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemBannersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemBannersIdWithResponse(ctx context.Context, id string, body PatchSystemBannersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemBannersIdResponse, error) {
	rsp, err := c.PatchSystemBannersId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemBannersIdResponse(rsp)
}

// PostSystemCaptureWithBodyWithResponse request with arbitrary body returning *PostSystemCaptureResponse
func (c *ClientWithResponses) PostSystemCaptureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemCaptureResponse, error) {
	rsp, err := c.PostSystemCaptureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostSystemCaptureWithResponse(ctx context.Context, body PostSystemCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemCaptureResponse, error) {
	rsp, err := c.PostSystemCapture(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemCaptureResponse(rsp)
}

// GetSystemCertificatesWithResponse request returning *GetSystemCertificatesResponse
func (c *ClientWithResponses) GetSystemCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemCertificatesResponse, error) {
	rsp, err := c.GetSystemCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemCertificatesResponse(rsp)
}

// PostSystemCertificatesWithBodyWithResponse request with arbitrary body returning *PostSystemCertificatesResponse
func (c *ClientWithResponses) PostSystemCertificatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemCertificatesResponse, error) {
	rsp, err := c.PostSystemCertificatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemCertificatesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemCertificatesWithResponse(ctx context.Context, body PostSystemCertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemCertificatesResponse, error) {
	rsp, err := c.PostSystemCertificates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemCertificatesResponse(rsp)
}

// DeleteSystemCertificatesIdWithResponse request returning *DeleteSystemCertificatesIdResponse
func (c *ClientWithResponses) DeleteSystemCertificatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemCertificatesIdResponse, error) {
	rsp, err := c.DeleteSystemCertificatesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemCertificatesIdResponse(rsp)
}

// GetSystemCertificatesIdWithResponse request returning *GetSystemCertificatesIdResponse
func (c *ClientWithResponses) GetSystemCertificatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemCertificatesIdResponse, error) {
	rsp, err := c.GetSystemCertificatesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemCertificatesIdResponse(rsp)
}

// PatchSystemCertificatesIdWithBodyWithResponse request with arbitrary body returning *PatchSystemCertificatesIdResponse
func (c *ClientWithResponses) PatchSystemCertificatesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemCertificatesIdResponse, error) {
	rsp, err := c.PatchSystemCertificatesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemCertificatesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemCertificatesIdWithResponse(ctx context.Context, id string, body PatchSystemCertificatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemCertificatesIdResponse, error) {
	rsp, err := c.PatchSystemCertificatesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemCertificatesIdResponse(rsp)
}

// DeleteSystemDiagWithResponse request returning *DeleteSystemDiagResponse
func (c *ClientWithResponses) DeleteSystemDiagWithResponse(ctx context.Context, params *DeleteSystemDiagParams, reqEditors ...RequestEditorFn) (*DeleteSystemDiagResponse, error) {
	rsp, err := c.DeleteSystemDiag(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemDiagResponse(rsp)
}

// GetSystemDiagWithResponse request returning *GetSystemDiagResponse
func (c *ClientWithResponses) GetSystemDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemDiagResponse, error) {
	rsp, err := c.GetSystemDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemDiagResponse(rsp)
}

// GetSystemDiagDownloadWithResponse request returning *GetSystemDiagDownloadResponse
func (c *ClientWithResponses) GetSystemDiagDownloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemDiagDownloadResponse, error) {
	rsp, err := c.GetSystemDiagDownload(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemDiagDownloadResponse(rsp)
}

// PostSystemDiagSendWithBodyWithResponse request with arbitrary body returning *PostSystemDiagSendResponse
func (c *ClientWithResponses) PostSystemDiagSendWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemDiagSendResponse, error) {
	rsp, err := c.PostSystemDiagSendWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDiagSendResponse(rsp)
}

func (c *ClientWithResponses) PostSystemDiagSendWithResponse(ctx context.Context, body PostSystemDiagSendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemDiagSendResponse, error) {
	rsp, err := c.PostSystemDiagSend(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDiagSendResponse(rsp)
}

// PostSystemDistributedUpgradeCancelGroupWithResponse request returning *PostSystemDistributedUpgradeCancelGroupResponse
func (c *ClientWithResponses) PostSystemDistributedUpgradeCancelGroupWithResponse(ctx context.Context, group string, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeCancelGroupResponse, error) {
	rsp, err := c.PostSystemDistributedUpgradeCancelGroup(ctx, group, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDistributedUpgradeCancelGroupResponse(rsp)
}

// GetSystemDistributedUpgradeDownloadFileWithResponse request returning *GetSystemDistributedUpgradeDownloadFileResponse
func (c *ClientWithResponses) GetSystemDistributedUpgradeDownloadFileWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*GetSystemDistributedUpgradeDownloadFileResponse, error) {
	rsp, err := c.GetSystemDistributedUpgradeDownloadFile(ctx, file, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemDistributedUpgradeDownloadFileResponse(rsp)
}

// PostSystemDistributedUpgradeStageGroupWithResponse request returning *PostSystemDistributedUpgradeStageGroupResponse
func (c *ClientWithResponses) PostSystemDistributedUpgradeStageGroupWithResponse(ctx context.Context, group string, params *PostSystemDistributedUpgradeStageGroupParams, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeStageGroupResponse, error) {
	rsp, err := c.PostSystemDistributedUpgradeStageGroup(ctx, group, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDistributedUpgradeStageGroupResponse(rsp)
}

// PostSystemDistributedUpgradeGroupWithBodyWithResponse request with arbitrary body returning *PostSystemDistributedUpgradeGroupResponse
func (c *ClientWithResponses) PostSystemDistributedUpgradeGroupWithBodyWithResponse(ctx context.Context, group string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeGroupResponse, error) {
	rsp, err := c.PostSystemDistributedUpgradeGroupWithBody(ctx, group, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDistributedUpgradeGroupResponse(rsp)
}

func (c *ClientWithResponses) PostSystemDistributedUpgradeGroupWithResponse(ctx context.Context, group string, body PostSystemDistributedUpgradeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemDistributedUpgradeGroupResponse, error) {
	rsp, err := c.PostSystemDistributedUpgradeGroup(ctx, group, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemDistributedUpgradeGroupResponse(rsp)
}

// GetSystemInfoWithResponse request returning *GetSystemInfoResponse
func (c *ClientWithResponses) GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error) {
	rsp, err := c.GetSystemInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInfoResponse(rsp)
}

// GetSystemInputsWithResponse request returning *GetSystemInputsResponse
func (c *ClientWithResponses) GetSystemInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInputsResponse, error) {
	rsp, err := c.GetSystemInputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInputsResponse(rsp)
}

// PostSystemInputsWithBodyWithResponse request with arbitrary body returning *PostSystemInputsResponse
func (c *ClientWithResponses) PostSystemInputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemInputsResponse, error) {
	rsp, err := c.PostSystemInputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemInputsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemInputsWithResponse(ctx context.Context, body PostSystemInputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemInputsResponse, error) {
	rsp, err := c.PostSystemInputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemInputsResponse(rsp)
}

// DeleteSystemInputsIdWithResponse request returning *DeleteSystemInputsIdResponse
func (c *ClientWithResponses) DeleteSystemInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemInputsIdResponse, error) {
	rsp, err := c.DeleteSystemInputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemInputsIdResponse(rsp)
}

// GetSystemInputsIdWithResponse request returning *GetSystemInputsIdResponse
func (c *ClientWithResponses) GetSystemInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemInputsIdResponse, error) {
	rsp, err := c.GetSystemInputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInputsIdResponse(rsp)
}

// PatchSystemInputsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemInputsIdResponse
func (c *ClientWithResponses) PatchSystemInputsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdResponse, error) {
	rsp, err := c.PatchSystemInputsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemInputsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemInputsIdWithResponse(ctx context.Context, id string, body PatchSystemInputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdResponse, error) {
	rsp, err := c.PatchSystemInputsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemInputsIdResponse(rsp)
}

// PostSystemInputsIdHectokenWithBodyWithResponse request with arbitrary body returning *PostSystemInputsIdHectokenResponse
func (c *ClientWithResponses) PostSystemInputsIdHectokenWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemInputsIdHectokenResponse, error) {
	rsp, err := c.PostSystemInputsIdHectokenWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemInputsIdHectokenResponse(rsp)
}

func (c *ClientWithResponses) PostSystemInputsIdHectokenWithResponse(ctx context.Context, id string, body PostSystemInputsIdHectokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemInputsIdHectokenResponse, error) {
	rsp, err := c.PostSystemInputsIdHectoken(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemInputsIdHectokenResponse(rsp)
}

// PatchSystemInputsIdHectokenTokenWithBodyWithResponse request with arbitrary body returning *PatchSystemInputsIdHectokenTokenResponse
func (c *ClientWithResponses) PatchSystemInputsIdHectokenTokenWithBodyWithResponse(ctx context.Context, id string, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdHectokenTokenResponse, error) {
	rsp, err := c.PatchSystemInputsIdHectokenTokenWithBody(ctx, id, token, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemInputsIdHectokenTokenResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemInputsIdHectokenTokenWithResponse(ctx context.Context, id string, token string, body PatchSystemInputsIdHectokenTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemInputsIdHectokenTokenResponse, error) {
	rsp, err := c.PatchSystemInputsIdHectokenToken(ctx, id, token, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemInputsIdHectokenTokenResponse(rsp)
}

// GetSystemJobsLogsIdGroupIdWithResponse request returning *GetSystemJobsLogsIdGroupIdResponse
func (c *ClientWithResponses) GetSystemJobsLogsIdGroupIdWithResponse(ctx context.Context, id string, groupId string, params *GetSystemJobsLogsIdGroupIdParams, reqEditors ...RequestEditorFn) (*GetSystemJobsLogsIdGroupIdResponse, error) {
	rsp, err := c.GetSystemJobsLogsIdGroupId(ctx, id, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemJobsLogsIdGroupIdResponse(rsp)
}

// GetSystemKeysWithResponse request returning *GetSystemKeysResponse
func (c *ClientWithResponses) GetSystemKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemKeysResponse, error) {
	rsp, err := c.GetSystemKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemKeysResponse(rsp)
}

// PostSystemKeysWithBodyWithResponse request with arbitrary body returning *PostSystemKeysResponse
func (c *ClientWithResponses) PostSystemKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemKeysResponse, error) {
	rsp, err := c.PostSystemKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemKeysResponse(rsp)
}

func (c *ClientWithResponses) PostSystemKeysWithResponse(ctx context.Context, body PostSystemKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemKeysResponse, error) {
	rsp, err := c.PostSystemKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemKeysResponse(rsp)
}

// DeleteSystemKeysIdWithResponse request returning *DeleteSystemKeysIdResponse
func (c *ClientWithResponses) DeleteSystemKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemKeysIdResponse, error) {
	rsp, err := c.DeleteSystemKeysId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemKeysIdResponse(rsp)
}

// GetSystemKeysIdWithResponse request returning *GetSystemKeysIdResponse
func (c *ClientWithResponses) GetSystemKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemKeysIdResponse, error) {
	rsp, err := c.GetSystemKeysId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemKeysIdResponse(rsp)
}

// PatchSystemKeysIdWithBodyWithResponse request with arbitrary body returning *PatchSystemKeysIdResponse
func (c *ClientWithResponses) PatchSystemKeysIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemKeysIdResponse, error) {
	rsp, err := c.PatchSystemKeysIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemKeysIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemKeysIdWithResponse(ctx context.Context, id string, body PatchSystemKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemKeysIdResponse, error) {
	rsp, err := c.PatchSystemKeysId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemKeysIdResponse(rsp)
}

// GetSystemLicensesWithResponse request returning *GetSystemLicensesResponse
func (c *ClientWithResponses) GetSystemLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensesResponse, error) {
	rsp, err := c.GetSystemLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLicensesResponse(rsp)
}

// PostSystemLicensesWithBodyWithResponse request with arbitrary body returning *PostSystemLicensesResponse
func (c *ClientWithResponses) PostSystemLicensesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemLicensesResponse, error) {
	rsp, err := c.PostSystemLicensesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemLicensesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemLicensesWithResponse(ctx context.Context, body PostSystemLicensesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemLicensesResponse, error) {
	rsp, err := c.PostSystemLicenses(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemLicensesResponse(rsp)
}

// GetSystemLicensesUsageWithResponse request returning *GetSystemLicensesUsageResponse
func (c *ClientWithResponses) GetSystemLicensesUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLicensesUsageResponse, error) {
	rsp, err := c.GetSystemLicensesUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLicensesUsageResponse(rsp)
}

// DeleteSystemLicensesIdWithResponse request returning *DeleteSystemLicensesIdResponse
func (c *ClientWithResponses) DeleteSystemLicensesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLicensesIdResponse, error) {
	rsp, err := c.DeleteSystemLicensesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemLicensesIdResponse(rsp)
}

// GetSystemLicensesIdWithResponse request returning *GetSystemLicensesIdResponse
func (c *ClientWithResponses) GetSystemLicensesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLicensesIdResponse, error) {
	rsp, err := c.GetSystemLicensesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLicensesIdResponse(rsp)
}

// GetSystemLoggerWithResponse request returning *GetSystemLoggerResponse
func (c *ClientWithResponses) GetSystemLoggerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLoggerResponse, error) {
	rsp, err := c.GetSystemLogger(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLoggerResponse(rsp)
}

// DeleteSystemLoggerIdWithResponse request returning *DeleteSystemLoggerIdResponse
func (c *ClientWithResponses) DeleteSystemLoggerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLoggerIdResponse, error) {
	rsp, err := c.DeleteSystemLoggerId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemLoggerIdResponse(rsp)
}

// GetSystemLoggerIdWithResponse request returning *GetSystemLoggerIdResponse
func (c *ClientWithResponses) GetSystemLoggerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLoggerIdResponse, error) {
	rsp, err := c.GetSystemLoggerId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLoggerIdResponse(rsp)
}

// PatchSystemLoggerIdWithBodyWithResponse request with arbitrary body returning *PatchSystemLoggerIdResponse
func (c *ClientWithResponses) PatchSystemLoggerIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemLoggerIdResponse, error) {
	rsp, err := c.PatchSystemLoggerIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemLoggerIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemLoggerIdWithResponse(ctx context.Context, id string, body PatchSystemLoggerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemLoggerIdResponse, error) {
	rsp, err := c.PatchSystemLoggerId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemLoggerIdResponse(rsp)
}

// GetSystemLogsWithResponse request returning *GetSystemLogsResponse
func (c *ClientWithResponses) GetSystemLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLogsResponse, error) {
	rsp, err := c.GetSystemLogs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLogsResponse(rsp)
}

// GetSystemLogsSearchWithResponse request returning *GetSystemLogsSearchResponse
func (c *ClientWithResponses) GetSystemLogsSearchWithResponse(ctx context.Context, params *GetSystemLogsSearchParams, reqEditors ...RequestEditorFn) (*GetSystemLogsSearchResponse, error) {
	rsp, err := c.GetSystemLogsSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLogsSearchResponse(rsp)
}

// GetSystemLogsIdWithResponse request returning *GetSystemLogsIdResponse
func (c *ClientWithResponses) GetSystemLogsIdWithResponse(ctx context.Context, id string, params *GetSystemLogsIdParams, reqEditors ...RequestEditorFn) (*GetSystemLogsIdResponse, error) {
	rsp, err := c.GetSystemLogsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLogsIdResponse(rsp)
}

// GetSystemLookupsWithResponse request returning *GetSystemLookupsResponse
func (c *ClientWithResponses) GetSystemLookupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemLookupsResponse, error) {
	rsp, err := c.GetSystemLookups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLookupsResponse(rsp)
}

// PostSystemLookupsWithBodyWithResponse request with arbitrary body returning *PostSystemLookupsResponse
func (c *ClientWithResponses) PostSystemLookupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemLookupsResponse, error) {
	rsp, err := c.PostSystemLookupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemLookupsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemLookupsWithResponse(ctx context.Context, body PostSystemLookupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemLookupsResponse, error) {
	rsp, err := c.PostSystemLookups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemLookupsResponse(rsp)
}

// PutSystemLookupsWithBodyWithResponse request with arbitrary body returning *PutSystemLookupsResponse
func (c *ClientWithResponses) PutSystemLookupsWithBodyWithResponse(ctx context.Context, params *PutSystemLookupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSystemLookupsResponse, error) {
	rsp, err := c.PutSystemLookupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSystemLookupsResponse(rsp)
}

// DeleteSystemLookupsIdWithResponse request returning *DeleteSystemLookupsIdResponse
func (c *ClientWithResponses) DeleteSystemLookupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemLookupsIdResponse, error) {
	rsp, err := c.DeleteSystemLookupsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemLookupsIdResponse(rsp)
}

// GetSystemLookupsIdWithResponse request returning *GetSystemLookupsIdResponse
func (c *ClientWithResponses) GetSystemLookupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemLookupsIdResponse, error) {
	rsp, err := c.GetSystemLookupsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemLookupsIdResponse(rsp)
}

// PatchSystemLookupsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemLookupsIdResponse
func (c *ClientWithResponses) PatchSystemLookupsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemLookupsIdResponse, error) {
	rsp, err := c.PatchSystemLookupsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemLookupsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemLookupsIdWithResponse(ctx context.Context, id string, body PatchSystemLookupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemLookupsIdResponse, error) {
	rsp, err := c.PatchSystemLookupsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemLookupsIdResponse(rsp)
}

// GetSystemMessagesWithResponse request returning *GetSystemMessagesResponse
func (c *ClientWithResponses) GetSystemMessagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemMessagesResponse, error) {
	rsp, err := c.GetSystemMessages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemMessagesResponse(rsp)
}

// PostSystemMessagesWithBodyWithResponse request with arbitrary body returning *PostSystemMessagesResponse
func (c *ClientWithResponses) PostSystemMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMessagesResponse, error) {
	rsp, err := c.PostSystemMessagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMessagesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemMessagesWithResponse(ctx context.Context, body PostSystemMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMessagesResponse, error) {
	rsp, err := c.PostSystemMessages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMessagesResponse(rsp)
}

// DeleteSystemMessagesIdWithResponse request returning *DeleteSystemMessagesIdResponse
func (c *ClientWithResponses) DeleteSystemMessagesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemMessagesIdResponse, error) {
	rsp, err := c.DeleteSystemMessagesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemMessagesIdResponse(rsp)
}

// GetSystemMessagesIdWithResponse request returning *GetSystemMessagesIdResponse
func (c *ClientWithResponses) GetSystemMessagesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemMessagesIdResponse, error) {
	rsp, err := c.GetSystemMessagesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemMessagesIdResponse(rsp)
}

// GetSystemMetricsWithResponse request returning *GetSystemMetricsResponse
func (c *ClientWithResponses) GetSystemMetricsWithResponse(ctx context.Context, params *GetSystemMetricsParams, reqEditors ...RequestEditorFn) (*GetSystemMetricsResponse, error) {
	rsp, err := c.GetSystemMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemMetricsResponse(rsp)
}

// PostSystemMetricsEnumWithBodyWithResponse request with arbitrary body returning *PostSystemMetricsEnumResponse
func (c *ClientWithResponses) PostSystemMetricsEnumWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMetricsEnumResponse, error) {
	rsp, err := c.PostSystemMetricsEnumWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMetricsEnumResponse(rsp)
}

func (c *ClientWithResponses) PostSystemMetricsEnumWithResponse(ctx context.Context, body PostSystemMetricsEnumJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMetricsEnumResponse, error) {
	rsp, err := c.PostSystemMetricsEnum(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMetricsEnumResponse(rsp)
}

// PostSystemMetricsQueryWithBodyWithResponse request with arbitrary body returning *PostSystemMetricsQueryResponse
func (c *ClientWithResponses) PostSystemMetricsQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemMetricsQueryResponse, error) {
	rsp, err := c.PostSystemMetricsQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMetricsQueryResponse(rsp)
}

func (c *ClientWithResponses) PostSystemMetricsQueryWithResponse(ctx context.Context, body PostSystemMetricsQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemMetricsQueryResponse, error) {
	rsp, err := c.PostSystemMetricsQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemMetricsQueryResponse(rsp)
}

// GetSystemOutputsWithResponse request returning *GetSystemOutputsResponse
func (c *ClientWithResponses) GetSystemOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemOutputsResponse, error) {
	rsp, err := c.GetSystemOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemOutputsResponse(rsp)
}

// PostSystemOutputsWithBodyWithResponse request with arbitrary body returning *PostSystemOutputsResponse
func (c *ClientWithResponses) PostSystemOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemOutputsResponse, error) {
	rsp, err := c.PostSystemOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemOutputsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemOutputsWithResponse(ctx context.Context, body PostSystemOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemOutputsResponse, error) {
	rsp, err := c.PostSystemOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemOutputsResponse(rsp)
}

// DeleteSystemOutputsIdWithResponse request returning *DeleteSystemOutputsIdResponse
func (c *ClientWithResponses) DeleteSystemOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemOutputsIdResponse, error) {
	rsp, err := c.DeleteSystemOutputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemOutputsIdResponse(rsp)
}

// GetSystemOutputsIdWithResponse request returning *GetSystemOutputsIdResponse
func (c *ClientWithResponses) GetSystemOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdResponse, error) {
	rsp, err := c.GetSystemOutputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemOutputsIdResponse(rsp)
}

// PatchSystemOutputsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemOutputsIdResponse
func (c *ClientWithResponses) PatchSystemOutputsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemOutputsIdResponse, error) {
	rsp, err := c.PatchSystemOutputsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemOutputsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemOutputsIdWithResponse(ctx context.Context, id string, body PatchSystemOutputsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemOutputsIdResponse, error) {
	rsp, err := c.PatchSystemOutputsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemOutputsIdResponse(rsp)
}

// DeleteSystemOutputsIdPqWithResponse request returning *DeleteSystemOutputsIdPqResponse
func (c *ClientWithResponses) DeleteSystemOutputsIdPqWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemOutputsIdPqResponse, error) {
	rsp, err := c.DeleteSystemOutputsIdPq(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemOutputsIdPqResponse(rsp)
}

// GetSystemOutputsIdPqWithResponse request returning *GetSystemOutputsIdPqResponse
func (c *ClientWithResponses) GetSystemOutputsIdPqWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdPqResponse, error) {
	rsp, err := c.GetSystemOutputsIdPq(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemOutputsIdPqResponse(rsp)
}

// GetSystemOutputsIdSamplesWithResponse request returning *GetSystemOutputsIdSamplesResponse
func (c *ClientWithResponses) GetSystemOutputsIdSamplesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemOutputsIdSamplesResponse, error) {
	rsp, err := c.GetSystemOutputsIdSamples(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemOutputsIdSamplesResponse(rsp)
}

// PostSystemOutputsIdTestWithBodyWithResponse request with arbitrary body returning *PostSystemOutputsIdTestResponse
func (c *ClientWithResponses) PostSystemOutputsIdTestWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemOutputsIdTestResponse, error) {
	rsp, err := c.PostSystemOutputsIdTestWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemOutputsIdTestResponse(rsp)
}

func (c *ClientWithResponses) PostSystemOutputsIdTestWithResponse(ctx context.Context, id string, body PostSystemOutputsIdTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemOutputsIdTestResponse, error) {
	rsp, err := c.PostSystemOutputsIdTest(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemOutputsIdTestResponse(rsp)
}

// GetSystemPoliciesWithResponse request returning *GetSystemPoliciesResponse
func (c *ClientWithResponses) GetSystemPoliciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemPoliciesResponse, error) {
	rsp, err := c.GetSystemPolicies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemPoliciesResponse(rsp)
}

// PostSystemPoliciesWithBodyWithResponse request with arbitrary body returning *PostSystemPoliciesResponse
func (c *ClientWithResponses) PostSystemPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemPoliciesResponse, error) {
	rsp, err := c.PostSystemPoliciesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemPoliciesWithResponse(ctx context.Context, body PostSystemPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemPoliciesResponse, error) {
	rsp, err := c.PostSystemPolicies(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemPoliciesResponse(rsp)
}

// DeleteSystemPoliciesIdWithResponse request returning *DeleteSystemPoliciesIdResponse
func (c *ClientWithResponses) DeleteSystemPoliciesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemPoliciesIdResponse, error) {
	rsp, err := c.DeleteSystemPoliciesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemPoliciesIdResponse(rsp)
}

// GetSystemPoliciesIdWithResponse request returning *GetSystemPoliciesIdResponse
func (c *ClientWithResponses) GetSystemPoliciesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemPoliciesIdResponse, error) {
	rsp, err := c.GetSystemPoliciesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemPoliciesIdResponse(rsp)
}

// PatchSystemPoliciesIdWithBodyWithResponse request with arbitrary body returning *PatchSystemPoliciesIdResponse
func (c *ClientWithResponses) PatchSystemPoliciesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemPoliciesIdResponse, error) {
	rsp, err := c.PatchSystemPoliciesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemPoliciesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemPoliciesIdWithResponse(ctx context.Context, id string, body PatchSystemPoliciesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemPoliciesIdResponse, error) {
	rsp, err := c.PatchSystemPoliciesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemPoliciesIdResponse(rsp)
}

// GetSystemProcessesWithResponse request returning *GetSystemProcessesResponse
func (c *ClientWithResponses) GetSystemProcessesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProcessesResponse, error) {
	rsp, err := c.GetSystemProcesses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProcessesResponse(rsp)
}

// GetSystemProfilerWithResponse request returning *GetSystemProfilerResponse
func (c *ClientWithResponses) GetSystemProfilerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProfilerResponse, error) {
	rsp, err := c.GetSystemProfiler(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProfilerResponse(rsp)
}

// PostSystemProfilerWithBodyWithResponse request with arbitrary body returning *PostSystemProfilerResponse
func (c *ClientWithResponses) PostSystemProfilerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProfilerResponse, error) {
	rsp, err := c.PostSystemProfilerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProfilerResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProfilerWithResponse(ctx context.Context, body PostSystemProfilerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProfilerResponse, error) {
	rsp, err := c.PostSystemProfiler(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProfilerResponse(rsp)
}

// DeleteSystemProfilerIdWithResponse request returning *DeleteSystemProfilerIdResponse
func (c *ClientWithResponses) DeleteSystemProfilerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemProfilerIdResponse, error) {
	rsp, err := c.DeleteSystemProfilerId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemProfilerIdResponse(rsp)
}

// GetSystemProfilerIdWithResponse request returning *GetSystemProfilerIdResponse
func (c *ClientWithResponses) GetSystemProfilerIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProfilerIdResponse, error) {
	rsp, err := c.GetSystemProfilerId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProfilerIdResponse(rsp)
}

// PatchSystemProfilerIdWithBodyWithResponse request with arbitrary body returning *PatchSystemProfilerIdResponse
func (c *ClientWithResponses) PatchSystemProfilerIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemProfilerIdResponse, error) {
	rsp, err := c.PatchSystemProfilerIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemProfilerIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemProfilerIdWithResponse(ctx context.Context, id string, body PatchSystemProfilerIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemProfilerIdResponse, error) {
	rsp, err := c.PatchSystemProfilerId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemProfilerIdResponse(rsp)
}

// GetSystemProjectsWithResponse request returning *GetSystemProjectsResponse
func (c *ClientWithResponses) GetSystemProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemProjectsResponse, error) {
	rsp, err := c.GetSystemProjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsResponse(rsp)
}

// PostSystemProjectsWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsResponse
func (c *ClientWithResponses) PostSystemProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsResponse, error) {
	rsp, err := c.PostSystemProjectsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsWithResponse(ctx context.Context, body PostSystemProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsResponse, error) {
	rsp, err := c.PostSystemProjects(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsResponse(rsp)
}

// DeleteSystemProjectsIdWithResponse request returning *DeleteSystemProjectsIdResponse
func (c *ClientWithResponses) DeleteSystemProjectsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemProjectsIdResponse, error) {
	rsp, err := c.DeleteSystemProjectsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemProjectsIdResponse(rsp)
}

// GetSystemProjectsIdWithResponse request returning *GetSystemProjectsIdResponse
func (c *ClientWithResponses) GetSystemProjectsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdResponse, error) {
	rsp, err := c.GetSystemProjectsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsIdResponse(rsp)
}

// PatchSystemProjectsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemProjectsIdResponse
func (c *ClientWithResponses) PatchSystemProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemProjectsIdResponse, error) {
	rsp, err := c.PatchSystemProjectsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemProjectsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemProjectsIdWithResponse(ctx context.Context, id string, body PatchSystemProjectsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemProjectsIdResponse, error) {
	rsp, err := c.PatchSystemProjectsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemProjectsIdResponse(rsp)
}

// GetSystemProjectsIdAclWithResponse request returning *GetSystemProjectsIdAclResponse
func (c *ClientWithResponses) GetSystemProjectsIdAclWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdAclResponse, error) {
	rsp, err := c.GetSystemProjectsIdAcl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsIdAclResponse(rsp)
}

// PostSystemProjectsIdAclApplyWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsIdAclApplyResponse
func (c *ClientWithResponses) PostSystemProjectsIdAclApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclApplyResponse, error) {
	rsp, err := c.PostSystemProjectsIdAclApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsIdAclApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsIdAclApplyWithResponse(ctx context.Context, id string, body PostSystemProjectsIdAclApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclApplyResponse, error) {
	rsp, err := c.PostSystemProjectsIdAclApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsIdAclApplyResponse(rsp)
}

// GetSystemProjectsIdAclTeamsWithResponse request returning *GetSystemProjectsIdAclTeamsResponse
func (c *ClientWithResponses) GetSystemProjectsIdAclTeamsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemProjectsIdAclTeamsResponse, error) {
	rsp, err := c.GetSystemProjectsIdAclTeams(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsIdAclTeamsResponse(rsp)
}

// PostSystemProjectsIdAclTeamsApplyWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsIdAclTeamsApplyResponse
func (c *ClientWithResponses) PostSystemProjectsIdAclTeamsApplyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSystemProjectsIdAclTeamsApplyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsIdAclTeamsApplyResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsIdAclTeamsApplyWithResponse(ctx context.Context, id string, body PostSystemProjectsIdAclTeamsApplyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsIdAclTeamsApplyResponse, error) {
	rsp, err := c.PostSystemProjectsIdAclTeamsApply(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsIdAclTeamsApplyResponse(rsp)
}

// PostSystemProjectsProjectIdCaptureWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsProjectIdCaptureResponse
func (c *ClientWithResponses) PostSystemProjectsProjectIdCaptureWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdCaptureResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdCaptureWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsProjectIdCaptureWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdCaptureResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdCapture(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdCaptureResponse(rsp)
}

// GetSystemProjectsProjectIdDestinationsWithResponse request returning *GetSystemProjectsProjectIdDestinationsResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdDestinationsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdDestinationsResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdDestinations(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdDestinationsResponse(rsp)
}

// GetSystemProjectsProjectIdSubscriptionsWithResponse request returning *GetSystemProjectsProjectIdSubscriptionsResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdSubscriptionsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdSubscriptionsResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdSubscriptions(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdSubscriptionsResponse(rsp)
}

// PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse
func (c *ClientWithResponses) PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBodyWithResponse(ctx context.Context, projectId string, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithBody(ctx, projectId, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse(ctx context.Context, projectId string, subscriptionId string, body PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx, projectId, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp)
}

// PostSystemProjectsProjectIdVersionCommitWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsProjectIdVersionCommitResponse
func (c *ClientWithResponses) PostSystemProjectsProjectIdVersionCommitWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionCommitResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdVersionCommitWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdVersionCommitResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsProjectIdVersionCommitWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionCommitResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdVersionCommit(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdVersionCommitResponse(rsp)
}

// GetSystemProjectsProjectIdVersionCountWithResponse request returning *GetSystemProjectsProjectIdVersionCountResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdVersionCountWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionCountParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionCountResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdVersionCount(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdVersionCountResponse(rsp)
}

// GetSystemProjectsProjectIdVersionDiffWithResponse request returning *GetSystemProjectsProjectIdVersionDiffResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdVersionDiffWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionDiffParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionDiffResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdVersionDiff(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdVersionDiffResponse(rsp)
}

// GetSystemProjectsProjectIdVersionFilesWithResponse request returning *GetSystemProjectsProjectIdVersionFilesResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdVersionFilesWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionFilesParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionFilesResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdVersionFiles(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdVersionFilesResponse(rsp)
}

// PostSystemProjectsProjectIdVersionRevertWithBodyWithResponse request with arbitrary body returning *PostSystemProjectsProjectIdVersionRevertResponse
func (c *ClientWithResponses) PostSystemProjectsProjectIdVersionRevertWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionRevertResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdVersionRevertWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdVersionRevertResponse(rsp)
}

func (c *ClientWithResponses) PostSystemProjectsProjectIdVersionRevertWithResponse(ctx context.Context, projectId string, body PostSystemProjectsProjectIdVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemProjectsProjectIdVersionRevertResponse, error) {
	rsp, err := c.PostSystemProjectsProjectIdVersionRevert(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemProjectsProjectIdVersionRevertResponse(rsp)
}

// GetSystemProjectsProjectIdVersionShowWithResponse request returning *GetSystemProjectsProjectIdVersionShowResponse
func (c *ClientWithResponses) GetSystemProjectsProjectIdVersionShowWithResponse(ctx context.Context, projectId string, params *GetSystemProjectsProjectIdVersionShowParams, reqEditors ...RequestEditorFn) (*GetSystemProjectsProjectIdVersionShowResponse, error) {
	rsp, err := c.GetSystemProjectsProjectIdVersionShow(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemProjectsProjectIdVersionShowResponse(rsp)
}

// GetSystemRolesWithResponse request returning *GetSystemRolesResponse
func (c *ClientWithResponses) GetSystemRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemRolesResponse, error) {
	rsp, err := c.GetSystemRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemRolesResponse(rsp)
}

// PostSystemRolesWithBodyWithResponse request with arbitrary body returning *PostSystemRolesResponse
func (c *ClientWithResponses) PostSystemRolesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemRolesResponse, error) {
	rsp, err := c.PostSystemRolesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemRolesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemRolesWithResponse(ctx context.Context, body PostSystemRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemRolesResponse, error) {
	rsp, err := c.PostSystemRoles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemRolesResponse(rsp)
}

// DeleteSystemRolesIdWithResponse request returning *DeleteSystemRolesIdResponse
func (c *ClientWithResponses) DeleteSystemRolesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemRolesIdResponse, error) {
	rsp, err := c.DeleteSystemRolesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemRolesIdResponse(rsp)
}

// GetSystemRolesIdWithResponse request returning *GetSystemRolesIdResponse
func (c *ClientWithResponses) GetSystemRolesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemRolesIdResponse, error) {
	rsp, err := c.GetSystemRolesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemRolesIdResponse(rsp)
}

// PatchSystemRolesIdWithBodyWithResponse request with arbitrary body returning *PatchSystemRolesIdResponse
func (c *ClientWithResponses) PatchSystemRolesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemRolesIdResponse, error) {
	rsp, err := c.PatchSystemRolesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemRolesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemRolesIdWithResponse(ctx context.Context, id string, body PatchSystemRolesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemRolesIdResponse, error) {
	rsp, err := c.PatchSystemRolesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemRolesIdResponse(rsp)
}

// GetSystemSamplesWithResponse request returning *GetSystemSamplesResponse
func (c *ClientWithResponses) GetSystemSamplesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSamplesResponse, error) {
	rsp, err := c.GetSystemSamples(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSamplesResponse(rsp)
}

// PostSystemSamplesWithBodyWithResponse request with arbitrary body returning *PostSystemSamplesResponse
func (c *ClientWithResponses) PostSystemSamplesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSamplesResponse, error) {
	rsp, err := c.PostSystemSamplesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSamplesResponse(rsp)
}

func (c *ClientWithResponses) PostSystemSamplesWithResponse(ctx context.Context, body PostSystemSamplesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSamplesResponse, error) {
	rsp, err := c.PostSystemSamples(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSamplesResponse(rsp)
}

// DeleteSystemSamplesIdWithResponse request returning *DeleteSystemSamplesIdResponse
func (c *ClientWithResponses) DeleteSystemSamplesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSamplesIdResponse, error) {
	rsp, err := c.DeleteSystemSamplesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemSamplesIdResponse(rsp)
}

// GetSystemSamplesIdWithResponse request returning *GetSystemSamplesIdResponse
func (c *ClientWithResponses) GetSystemSamplesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSamplesIdResponse, error) {
	rsp, err := c.GetSystemSamplesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSamplesIdResponse(rsp)
}

// PatchSystemSamplesIdWithBodyWithResponse request with arbitrary body returning *PatchSystemSamplesIdResponse
func (c *ClientWithResponses) PatchSystemSamplesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSamplesIdResponse, error) {
	rsp, err := c.PatchSystemSamplesIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSamplesIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemSamplesIdWithResponse(ctx context.Context, id string, body PatchSystemSamplesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSamplesIdResponse, error) {
	rsp, err := c.PatchSystemSamplesId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSamplesIdResponse(rsp)
}

// GetSystemSamplesIdContentWithResponse request returning *GetSystemSamplesIdContentResponse
func (c *ClientWithResponses) GetSystemSamplesIdContentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSamplesIdContentResponse, error) {
	rsp, err := c.GetSystemSamplesIdContent(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSamplesIdContentResponse(rsp)
}

// GetSystemScriptsWithResponse request returning *GetSystemScriptsResponse
func (c *ClientWithResponses) GetSystemScriptsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemScriptsResponse, error) {
	rsp, err := c.GetSystemScripts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemScriptsResponse(rsp)
}

// PostSystemScriptsWithBodyWithResponse request with arbitrary body returning *PostSystemScriptsResponse
func (c *ClientWithResponses) PostSystemScriptsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemScriptsResponse, error) {
	rsp, err := c.PostSystemScriptsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemScriptsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemScriptsWithResponse(ctx context.Context, body PostSystemScriptsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemScriptsResponse, error) {
	rsp, err := c.PostSystemScripts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemScriptsResponse(rsp)
}

// DeleteSystemScriptsIdWithResponse request returning *DeleteSystemScriptsIdResponse
func (c *ClientWithResponses) DeleteSystemScriptsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemScriptsIdResponse, error) {
	rsp, err := c.DeleteSystemScriptsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemScriptsIdResponse(rsp)
}

// GetSystemScriptsIdWithResponse request returning *GetSystemScriptsIdResponse
func (c *ClientWithResponses) GetSystemScriptsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemScriptsIdResponse, error) {
	rsp, err := c.GetSystemScriptsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemScriptsIdResponse(rsp)
}

// PatchSystemScriptsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemScriptsIdResponse
func (c *ClientWithResponses) PatchSystemScriptsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemScriptsIdResponse, error) {
	rsp, err := c.PatchSystemScriptsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemScriptsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemScriptsIdWithResponse(ctx context.Context, id string, body PatchSystemScriptsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemScriptsIdResponse, error) {
	rsp, err := c.PatchSystemScriptsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemScriptsIdResponse(rsp)
}

// GetSystemSecretsWithResponse request returning *GetSystemSecretsResponse
func (c *ClientWithResponses) GetSystemSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSecretsResponse, error) {
	rsp, err := c.GetSystemSecrets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSecretsResponse(rsp)
}

// PostSystemSecretsWithBodyWithResponse request with arbitrary body returning *PostSystemSecretsResponse
func (c *ClientWithResponses) PostSystemSecretsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSecretsResponse, error) {
	rsp, err := c.PostSystemSecretsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSecretsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemSecretsWithResponse(ctx context.Context, body PostSystemSecretsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSecretsResponse, error) {
	rsp, err := c.PostSystemSecrets(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSecretsResponse(rsp)
}

// DeleteSystemSecretsIdWithResponse request returning *DeleteSystemSecretsIdResponse
func (c *ClientWithResponses) DeleteSystemSecretsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSecretsIdResponse, error) {
	rsp, err := c.DeleteSystemSecretsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemSecretsIdResponse(rsp)
}

// GetSystemSecretsIdWithResponse request returning *GetSystemSecretsIdResponse
func (c *ClientWithResponses) GetSystemSecretsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSecretsIdResponse, error) {
	rsp, err := c.GetSystemSecretsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSecretsIdResponse(rsp)
}

// PatchSystemSecretsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemSecretsIdResponse
func (c *ClientWithResponses) PatchSystemSecretsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSecretsIdResponse, error) {
	rsp, err := c.PatchSystemSecretsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSecretsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemSecretsIdWithResponse(ctx context.Context, id string, body PatchSystemSecretsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSecretsIdResponse, error) {
	rsp, err := c.PatchSystemSecretsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSecretsIdResponse(rsp)
}

// GetSystemSettingsWithResponse request returning *GetSystemSettingsResponse
func (c *ClientWithResponses) GetSystemSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsResponse, error) {
	rsp, err := c.GetSystemSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsResponse(rsp)
}

// PatchSystemSettingsWithResponse request returning *PatchSystemSettingsResponse
func (c *ClientWithResponses) PatchSystemSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsResponse, error) {
	rsp, err := c.PatchSystemSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSettingsResponse(rsp)
}

// GetSystemSettingsAuthWithResponse request returning *GetSystemSettingsAuthResponse
func (c *ClientWithResponses) GetSystemSettingsAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsAuthResponse, error) {
	rsp, err := c.GetSystemSettingsAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsAuthResponse(rsp)
}

// PatchSystemSettingsAuthWithResponse request returning *PatchSystemSettingsAuthResponse
func (c *ClientWithResponses) PatchSystemSettingsAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsAuthResponse, error) {
	rsp, err := c.PatchSystemSettingsAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSettingsAuthResponse(rsp)
}

// GetSystemSettingsConfWithResponse request returning *GetSystemSettingsConfResponse
func (c *ClientWithResponses) GetSystemSettingsConfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsConfResponse, error) {
	rsp, err := c.GetSystemSettingsConf(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsConfResponse(rsp)
}

// PatchSystemSettingsConfWithBodyWithResponse request with arbitrary body returning *PatchSystemSettingsConfResponse
func (c *ClientWithResponses) PatchSystemSettingsConfWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemSettingsConfResponse, error) {
	rsp, err := c.PatchSystemSettingsConfWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSettingsConfResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemSettingsConfWithResponse(ctx context.Context, body PatchSystemSettingsConfJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemSettingsConfResponse, error) {
	rsp, err := c.PatchSystemSettingsConf(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSettingsConfResponse(rsp)
}

// GetSystemSettingsCriblWithResponse request returning *GetSystemSettingsCriblResponse
func (c *ClientWithResponses) GetSystemSettingsCriblWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsCriblResponse, error) {
	rsp, err := c.GetSystemSettingsCribl(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsCriblResponse(rsp)
}

// GetSystemSettingsGitSettingsWithResponse request returning *GetSystemSettingsGitSettingsResponse
func (c *ClientWithResponses) GetSystemSettingsGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsGitSettingsResponse, error) {
	rsp, err := c.GetSystemSettingsGitSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsGitSettingsResponse(rsp)
}

// PatchSystemSettingsGitSettingsWithResponse request returning *PatchSystemSettingsGitSettingsResponse
func (c *ClientWithResponses) PatchSystemSettingsGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PatchSystemSettingsGitSettingsResponse, error) {
	rsp, err := c.PatchSystemSettingsGitSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSettingsGitSettingsResponse(rsp)
}

// PostSystemSettingsReloadWithResponse request returning *PostSystemSettingsReloadResponse
func (c *ClientWithResponses) PostSystemSettingsReloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSettingsReloadResponse, error) {
	rsp, err := c.PostSystemSettingsReload(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSettingsReloadResponse(rsp)
}

// PostSystemSettingsRestartWithResponse request returning *PostSystemSettingsRestartResponse
func (c *ClientWithResponses) PostSystemSettingsRestartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSettingsRestartResponse, error) {
	rsp, err := c.PostSystemSettingsRestart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSettingsRestartResponse(rsp)
}

// GetSystemSettingsSearchLimitsWithResponse request returning *GetSystemSettingsSearchLimitsResponse
func (c *ClientWithResponses) GetSystemSettingsSearchLimitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsSearchLimitsResponse, error) {
	rsp, err := c.GetSystemSettingsSearchLimits(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsSearchLimitsResponse(rsp)
}

// GetSystemSettingsUpgradeWithResponse request returning *GetSystemSettingsUpgradeResponse
func (c *ClientWithResponses) GetSystemSettingsUpgradeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSettingsUpgradeResponse, error) {
	rsp, err := c.GetSystemSettingsUpgrade(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSettingsUpgradeResponse(rsp)
}

// PostSystemSettingsUpgradeFromPackageWithBodyWithResponse request with arbitrary body returning *PostSystemSettingsUpgradeFromPackageResponse
func (c *ClientWithResponses) PostSystemSettingsUpgradeFromPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeFromPackageResponse, error) {
	rsp, err := c.PostSystemSettingsUpgradeFromPackageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSettingsUpgradeFromPackageResponse(rsp)
}

func (c *ClientWithResponses) PostSystemSettingsUpgradeFromPackageWithResponse(ctx context.Context, body PostSystemSettingsUpgradeFromPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeFromPackageResponse, error) {
	rsp, err := c.PostSystemSettingsUpgradeFromPackage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSettingsUpgradeFromPackageResponse(rsp)
}

// PostSystemSettingsUpgradeVersionWithResponse request returning *PostSystemSettingsUpgradeVersionResponse
func (c *ClientWithResponses) PostSystemSettingsUpgradeVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*PostSystemSettingsUpgradeVersionResponse, error) {
	rsp, err := c.PostSystemSettingsUpgradeVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSettingsUpgradeVersionResponse(rsp)
}

// GetSystemStatusInputsWithResponse request returning *GetSystemStatusInputsResponse
func (c *ClientWithResponses) GetSystemStatusInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusInputsResponse, error) {
	rsp, err := c.GetSystemStatusInputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusInputsResponse(rsp)
}

// GetSystemStatusInputsIdWithResponse request returning *GetSystemStatusInputsIdResponse
func (c *ClientWithResponses) GetSystemStatusInputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemStatusInputsIdResponse, error) {
	rsp, err := c.GetSystemStatusInputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusInputsIdResponse(rsp)
}

// GetSystemStatusOutputsWithResponse request returning *GetSystemStatusOutputsResponse
func (c *ClientWithResponses) GetSystemStatusOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusOutputsResponse, error) {
	rsp, err := c.GetSystemStatusOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusOutputsResponse(rsp)
}

// GetSystemStatusOutputsIdWithResponse request returning *GetSystemStatusOutputsIdResponse
func (c *ClientWithResponses) GetSystemStatusOutputsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemStatusOutputsIdResponse, error) {
	rsp, err := c.GetSystemStatusOutputsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusOutputsIdResponse(rsp)
}

// GetSystemSubscriptionsWithResponse request returning *GetSystemSubscriptionsResponse
func (c *ClientWithResponses) GetSystemSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemSubscriptionsResponse, error) {
	rsp, err := c.GetSystemSubscriptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSubscriptionsResponse(rsp)
}

// PostSystemSubscriptionsWithResponse request returning *PostSystemSubscriptionsResponse
func (c *ClientWithResponses) PostSystemSubscriptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSystemSubscriptionsResponse, error) {
	rsp, err := c.PostSystemSubscriptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemSubscriptionsResponse(rsp)
}

// DeleteSystemSubscriptionsIdWithResponse request returning *DeleteSystemSubscriptionsIdResponse
func (c *ClientWithResponses) DeleteSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemSubscriptionsIdResponse, error) {
	rsp, err := c.DeleteSystemSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemSubscriptionsIdResponse(rsp)
}

// GetSystemSubscriptionsIdWithResponse request returning *GetSystemSubscriptionsIdResponse
func (c *ClientWithResponses) GetSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemSubscriptionsIdResponse, error) {
	rsp, err := c.GetSystemSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemSubscriptionsIdResponse(rsp)
}

// PatchSystemSubscriptionsIdWithResponse request returning *PatchSystemSubscriptionsIdResponse
func (c *ClientWithResponses) PatchSystemSubscriptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PatchSystemSubscriptionsIdResponse, error) {
	rsp, err := c.PatchSystemSubscriptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemSubscriptionsIdResponse(rsp)
}

// GetSystemTeamsWithResponse request returning *GetSystemTeamsResponse
func (c *ClientWithResponses) GetSystemTeamsWithResponse(ctx context.Context, params *GetSystemTeamsParams, reqEditors ...RequestEditorFn) (*GetSystemTeamsResponse, error) {
	rsp, err := c.GetSystemTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemTeamsResponse(rsp)
}

// PostSystemTeamsWithBodyWithResponse request with arbitrary body returning *PostSystemTeamsResponse
func (c *ClientWithResponses) PostSystemTeamsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemTeamsResponse, error) {
	rsp, err := c.PostSystemTeamsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemTeamsResponse(rsp)
}

func (c *ClientWithResponses) PostSystemTeamsWithResponse(ctx context.Context, body PostSystemTeamsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemTeamsResponse, error) {
	rsp, err := c.PostSystemTeams(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemTeamsResponse(rsp)
}

// GetSystemTeamsUsersIdRolesWithResponse request returning *GetSystemTeamsUsersIdRolesResponse
func (c *ClientWithResponses) GetSystemTeamsUsersIdRolesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsUsersIdRolesResponse, error) {
	rsp, err := c.GetSystemTeamsUsersIdRoles(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemTeamsUsersIdRolesResponse(rsp)
}

// DeleteSystemTeamsIdWithResponse request returning *DeleteSystemTeamsIdResponse
func (c *ClientWithResponses) DeleteSystemTeamsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemTeamsIdResponse, error) {
	rsp, err := c.DeleteSystemTeamsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemTeamsIdResponse(rsp)
}

// GetSystemTeamsIdWithResponse request returning *GetSystemTeamsIdResponse
func (c *ClientWithResponses) GetSystemTeamsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdResponse, error) {
	rsp, err := c.GetSystemTeamsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemTeamsIdResponse(rsp)
}

// PatchSystemTeamsIdWithBodyWithResponse request with arbitrary body returning *PatchSystemTeamsIdResponse
func (c *ClientWithResponses) PatchSystemTeamsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemTeamsIdResponse, error) {
	rsp, err := c.PatchSystemTeamsIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemTeamsIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemTeamsIdWithResponse(ctx context.Context, id string, body PatchSystemTeamsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemTeamsIdResponse, error) {
	rsp, err := c.PatchSystemTeamsId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemTeamsIdResponse(rsp)
}

// GetSystemTeamsIdAclWithResponse request returning *GetSystemTeamsIdAclResponse
func (c *ClientWithResponses) GetSystemTeamsIdAclWithResponse(ctx context.Context, id string, params *GetSystemTeamsIdAclParams, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdAclResponse, error) {
	rsp, err := c.GetSystemTeamsIdAcl(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemTeamsIdAclResponse(rsp)
}

// GetSystemTeamsIdUsersWithResponse request returning *GetSystemTeamsIdUsersResponse
func (c *ClientWithResponses) GetSystemTeamsIdUsersWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemTeamsIdUsersResponse, error) {
	rsp, err := c.GetSystemTeamsIdUsers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemTeamsIdUsersResponse(rsp)
}

// PostSystemTeamsIdUsersWithBodyWithResponse request with arbitrary body returning *PostSystemTeamsIdUsersResponse
func (c *ClientWithResponses) PostSystemTeamsIdUsersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemTeamsIdUsersResponse, error) {
	rsp, err := c.PostSystemTeamsIdUsersWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemTeamsIdUsersResponse(rsp)
}

func (c *ClientWithResponses) PostSystemTeamsIdUsersWithResponse(ctx context.Context, id string, body PostSystemTeamsIdUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemTeamsIdUsersResponse, error) {
	rsp, err := c.PostSystemTeamsIdUsers(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemTeamsIdUsersResponse(rsp)
}

// GetSystemUsersWithResponse request returning *GetSystemUsersResponse
func (c *ClientWithResponses) GetSystemUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemUsersResponse, error) {
	rsp, err := c.GetSystemUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemUsersResponse(rsp)
}

// PostSystemUsersWithBodyWithResponse request with arbitrary body returning *PostSystemUsersResponse
func (c *ClientWithResponses) PostSystemUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSystemUsersResponse, error) {
	rsp, err := c.PostSystemUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemUsersResponse(rsp)
}

func (c *ClientWithResponses) PostSystemUsersWithResponse(ctx context.Context, body PostSystemUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSystemUsersResponse, error) {
	rsp, err := c.PostSystemUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSystemUsersResponse(rsp)
}

// DeleteSystemUsersIdWithResponse request returning *DeleteSystemUsersIdResponse
func (c *ClientWithResponses) DeleteSystemUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSystemUsersIdResponse, error) {
	rsp, err := c.DeleteSystemUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSystemUsersIdResponse(rsp)
}

// GetSystemUsersIdWithResponse request returning *GetSystemUsersIdResponse
func (c *ClientWithResponses) GetSystemUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSystemUsersIdResponse, error) {
	rsp, err := c.GetSystemUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemUsersIdResponse(rsp)
}

// PatchSystemUsersIdWithBodyWithResponse request with arbitrary body returning *PatchSystemUsersIdResponse
func (c *ClientWithResponses) PatchSystemUsersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdResponse, error) {
	rsp, err := c.PatchSystemUsersIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemUsersIdResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemUsersIdWithResponse(ctx context.Context, id string, body PatchSystemUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdResponse, error) {
	rsp, err := c.PatchSystemUsersId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemUsersIdResponse(rsp)
}

// PatchSystemUsersIdInfoWithBodyWithResponse request with arbitrary body returning *PatchSystemUsersIdInfoResponse
func (c *ClientWithResponses) PatchSystemUsersIdInfoWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdInfoResponse, error) {
	rsp, err := c.PatchSystemUsersIdInfoWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemUsersIdInfoResponse(rsp)
}

func (c *ClientWithResponses) PatchSystemUsersIdInfoWithResponse(ctx context.Context, id string, body PatchSystemUsersIdInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSystemUsersIdInfoResponse, error) {
	rsp, err := c.PatchSystemUsersIdInfo(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSystemUsersIdInfoResponse(rsp)
}

// GetUiKeyWithResponse request returning *GetUiKeyResponse
func (c *ClientWithResponses) GetUiKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetUiKeyResponse, error) {
	rsp, err := c.GetUiKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUiKeyResponse(rsp)
}

// PatchUiKeyWithBodyWithResponse request with arbitrary body returning *PatchUiKeyResponse
func (c *ClientWithResponses) PatchUiKeyWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUiKeyResponse, error) {
	rsp, err := c.PatchUiKeyWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUiKeyResponse(rsp)
}

func (c *ClientWithResponses) PatchUiKeyWithResponse(ctx context.Context, key string, body PatchUiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUiKeyResponse, error) {
	rsp, err := c.PatchUiKey(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUiKeyResponse(rsp)
}

// GetVersionBranchWithResponse request returning *GetVersionBranchResponse
func (c *ClientWithResponses) GetVersionBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionBranchResponse, error) {
	rsp, err := c.GetVersionBranch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionBranchResponse(rsp)
}

// PostVersionCommitWithBodyWithResponse request with arbitrary body returning *PostVersionCommitResponse
func (c *ClientWithResponses) PostVersionCommitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVersionCommitResponse, error) {
	rsp, err := c.PostVersionCommitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionCommitResponse(rsp)
}

func (c *ClientWithResponses) PostVersionCommitWithResponse(ctx context.Context, body PostVersionCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVersionCommitResponse, error) {
	rsp, err := c.PostVersionCommit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionCommitResponse(rsp)
}

// GetVersionCountWithResponse request returning *GetVersionCountResponse
func (c *ClientWithResponses) GetVersionCountWithResponse(ctx context.Context, params *GetVersionCountParams, reqEditors ...RequestEditorFn) (*GetVersionCountResponse, error) {
	rsp, err := c.GetVersionCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionCountResponse(rsp)
}

// GetVersionCurrentBranchWithResponse request returning *GetVersionCurrentBranchResponse
func (c *ClientWithResponses) GetVersionCurrentBranchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionCurrentBranchResponse, error) {
	rsp, err := c.GetVersionCurrentBranch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionCurrentBranchResponse(rsp)
}

// GetVersionDiffWithResponse request returning *GetVersionDiffResponse
func (c *ClientWithResponses) GetVersionDiffWithResponse(ctx context.Context, params *GetVersionDiffParams, reqEditors ...RequestEditorFn) (*GetVersionDiffResponse, error) {
	rsp, err := c.GetVersionDiff(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionDiffResponse(rsp)
}

// GetVersionFilesWithResponse request returning *GetVersionFilesResponse
func (c *ClientWithResponses) GetVersionFilesWithResponse(ctx context.Context, params *GetVersionFilesParams, reqEditors ...RequestEditorFn) (*GetVersionFilesResponse, error) {
	rsp, err := c.GetVersionFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionFilesResponse(rsp)
}

// GetVersionInfoWithResponse request returning *GetVersionInfoResponse
func (c *ClientWithResponses) GetVersionInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionInfoResponse, error) {
	rsp, err := c.GetVersionInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionInfoResponse(rsp)
}

// PostVersionPushWithResponse request returning *PostVersionPushResponse
func (c *ClientWithResponses) PostVersionPushWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostVersionPushResponse, error) {
	rsp, err := c.PostVersionPush(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionPushResponse(rsp)
}

// PostVersionRevertWithBodyWithResponse request with arbitrary body returning *PostVersionRevertResponse
func (c *ClientWithResponses) PostVersionRevertWithBodyWithResponse(ctx context.Context, params *PostVersionRevertParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVersionRevertResponse, error) {
	rsp, err := c.PostVersionRevertWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionRevertResponse(rsp)
}

func (c *ClientWithResponses) PostVersionRevertWithResponse(ctx context.Context, params *PostVersionRevertParams, body PostVersionRevertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVersionRevertResponse, error) {
	rsp, err := c.PostVersionRevert(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionRevertResponse(rsp)
}

// GetVersionShowWithResponse request returning *GetVersionShowResponse
func (c *ClientWithResponses) GetVersionShowWithResponse(ctx context.Context, params *GetVersionShowParams, reqEditors ...RequestEditorFn) (*GetVersionShowResponse, error) {
	rsp, err := c.GetVersionShow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionShowResponse(rsp)
}

// GetVersionStatusWithResponse request returning *GetVersionStatusResponse
func (c *ClientWithResponses) GetVersionStatusWithResponse(ctx context.Context, params *GetVersionStatusParams, reqEditors ...RequestEditorFn) (*GetVersionStatusResponse, error) {
	rsp, err := c.GetVersionStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionStatusResponse(rsp)
}

// PostVersionSyncWithResponse request returning *PostVersionSyncResponse
func (c *ClientWithResponses) PostVersionSyncWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostVersionSyncResponse, error) {
	rsp, err := c.PostVersionSync(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionSyncResponse(rsp)
}

// PostVersionUndoWithResponse request returning *PostVersionUndoResponse
func (c *ClientWithResponses) PostVersionUndoWithResponse(ctx context.Context, params *PostVersionUndoParams, reqEditors ...RequestEditorFn) (*PostVersionUndoResponse, error) {
	rsp, err := c.PostVersionUndo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVersionUndoResponse(rsp)
}

// ParseGetAiConsentResponse parses an HTTP response from a GetAiConsentWithResponse call
func ParseGetAiConsentResponse(rsp *http.Response) (*GetAiConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAiConsentResponse parses an HTTP response from a PostAiConsentWithResponse call
func ParsePostAiConsentResponse(rsp *http.Response) (*PostAiConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAiConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthAuthorizationCodeCallbackResponse parses an HTTP response from a GetAuthAuthorizationCodeCallbackWithResponse call
func ParseGetAuthAuthorizationCodeCallbackResponse(rsp *http.Response) (*GetAuthAuthorizationCodeCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthAuthorizationCodeCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAuthGroupsResponse parses an HTTP response from a GetAuthGroupsWithResponse call
func ParseGetAuthGroupsResponse(rsp *http.Response) (*GetAuthGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]CrudEntityBase `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthLoginResponse parses an HTTP response from a PostAuthLoginWithResponse call
func ParsePostAuthLoginResponse(rsp *http.Response) (*PostAuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthLogoutResponse parses an HTTP response from a PostAuthLogoutWithResponse call
func ParsePostAuthLogoutResponse(rsp *http.Response) (*PostAuthLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAuthMetadataResponse parses an HTTP response from a GetAuthMetadataWithResponse call
func ParseGetAuthMetadataResponse(rsp *http.Response) (*GetAuthMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest string
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetAuthMultiFactorResponse parses an HTTP response from a GetAuthMultiFactorWithResponse call
func ParseGetAuthMultiFactorResponse(rsp *http.Response) (*GetAuthMultiFactorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthMultiFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]MultiFactorAuthSchema `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthSloResponse parses an HTTP response from a GetAuthSloWithResponse call
func ParseGetAuthSloResponse(rsp *http.Response) (*GetAuthSloResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthSloResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAuthSloCallbackResponse parses an HTTP response from a GetAuthSloCallbackWithResponse call
func ParseGetAuthSloCallbackResponse(rsp *http.Response) (*GetAuthSloCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthSloCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostAuthSloCallbackResponse parses an HTTP response from a PostAuthSloCallbackWithResponse call
func ParsePostAuthSloCallbackResponse(rsp *http.Response) (*PostAuthSloCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthSloCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAuthSsoResponse parses an HTTP response from a GetAuthSsoWithResponse call
func ParseGetAuthSsoResponse(rsp *http.Response) (*GetAuthSsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthSsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RedirectInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthSsoCallbackResponse parses an HTTP response from a GetAuthSsoCallbackWithResponse call
func ParseGetAuthSsoCallbackResponse(rsp *http.Response) (*GetAuthSsoCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthSsoCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostAuthSsoCallbackResponse parses an HTTP response from a PostAuthSsoCallbackWithResponse call
func ParsePostAuthSsoCallbackResponse(rsp *http.Response) (*PostAuthSsoCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthSsoCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAuthUsersIdTokenResponse parses an HTTP response from a DeleteAuthUsersIdTokenWithResponse call
func ParseDeleteAuthUsersIdTokenResponse(rsp *http.Response) (*DeleteAuthUsersIdTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthUsersIdTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorizePolicyResponse parses an HTTP response from a GetAuthorizePolicyWithResponse call
func ParseGetAuthorizePolicyResponse(rsp *http.Response) (*GetAuthorizePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AuthPolicyEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthorizeRolesResponse parses an HTTP response from a GetAuthorizeRolesWithResponse call
func ParseGetAuthorizeRolesResponse(rsp *http.Response) (*GetAuthorizeRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorizeRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChangelogViewedResponse parses an HTTP response from a GetChangelogViewedWithResponse call
func ParseGetChangelogViewedResponse(rsp *http.Response) (*GetChangelogViewedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangelogViewedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ChangelogState `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchChangelogViewedResponse parses an HTTP response from a PatchChangelogViewedWithResponse call
func ParsePatchChangelogViewedResponse(rsp *http.Response) (*PatchChangelogViewedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchChangelogViewedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ChangelogState `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCluiResponse parses an HTTP response from a GetCluiWithResponse call
func ParseGetCluiResponse(rsp *http.Response) (*GetCluiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCluiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]CluiItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorsResponse parses an HTTP response from a GetCollectorsWithResponse call
func ParseGetCollectorsResponse(rsp *http.Response) (*GetCollectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Collector `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorsIdResponse parses an HTTP response from a GetCollectorsIdWithResponse call
func ParseGetCollectorsIdResponse(rsp *http.Response) (*GetCollectorsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Collector `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConditionsResponse parses an HTTP response from a GetConditionsWithResponse call
func ParseGetConditionsResponse(rsp *http.Response) (*GetConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Condition `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConditionsIdResponse parses an HTTP response from a GetConditionsIdWithResponse call
func ParseGetConditionsIdResponse(rsp *http.Response) (*GetConditionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConditionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Condition `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeAppscopeProcessesResponse parses an HTTP response from a GetEdgeAppscopeProcessesWithResponse call
func ParseGetEdgeAppscopeProcessesResponse(rsp *http.Response) (*GetEdgeAppscopeProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeAppscopeProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AppScopeProcess `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostEdgeAppscopeProcessesResponse parses an HTTP response from a PostEdgeAppscopeProcessesWithResponse call
func ParsePostEdgeAppscopeProcessesResponse(rsp *http.Response) (*PostEdgeAppscopeProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEdgeAppscopeProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AppScopeProcess `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEdgeAppscopeProcessesPidResponse parses an HTTP response from a DeleteEdgeAppscopeProcessesPidWithResponse call
func ParseDeleteEdgeAppscopeProcessesPidResponse(rsp *http.Response) (*DeleteEdgeAppscopeProcessesPidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEdgeAppscopeProcessesPidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AppScopeProcess `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeAppscopeProcessesPidResponse parses an HTTP response from a GetEdgeAppscopeProcessesPidWithResponse call
func ParseGetEdgeAppscopeProcessesPidResponse(rsp *http.Response) (*GetEdgeAppscopeProcessesPidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeAppscopeProcessesPidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AppScopeProcess `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutEdgeAppscopeProcessesPidResponse parses an HTTP response from a PutEdgeAppscopeProcessesPidWithResponse call
func ParsePutEdgeAppscopeProcessesPidResponse(rsp *http.Response) (*PutEdgeAppscopeProcessesPidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutEdgeAppscopeProcessesPidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]AppScopeProcess `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeContainersResponse parses an HTTP response from a GetEdgeContainersWithResponse call
func ParseGetEdgeContainersResponse(rsp *http.Response) (*GetEdgeContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Container `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeContainersIdResponse parses an HTTP response from a GetEdgeContainersIdWithResponse call
func ParseGetEdgeContainersIdResponse(rsp *http.Response) (*GetEdgeContainersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeContainersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]Container `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeEventsCollectorsResponse parses an HTTP response from a GetEdgeEventsCollectorsWithResponse call
func ParseGetEdgeEventsCollectorsResponse(rsp *http.Response) (*GetEdgeEventsCollectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeEventsCollectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeEventsQueryResponse parses an HTTP response from a GetEdgeEventsQueryWithResponse call
func ParseGetEdgeEventsQueryResponse(rsp *http.Response) (*GetEdgeEventsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeEventsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostEdgeFileIngestResponse parses an HTTP response from a PostEdgeFileIngestWithResponse call
func ParsePostEdgeFileIngestResponse(rsp *http.Response) (*PostEdgeFileIngestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEdgeFileIngestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeFileSampleResponse parses an HTTP response from a GetEdgeFileSampleWithResponse call
func ParseGetEdgeFileSampleResponse(rsp *http.Response) (*GetEdgeFileSampleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeFileSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SampleFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeFileinspectResponse parses an HTTP response from a GetEdgeFileinspectWithResponse call
func ParseGetEdgeFileinspectResponse(rsp *http.Response) (*GetEdgeFileinspectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeFileinspectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                       `json:"count,omitempty"`
			Items *[]EdgeFileInspectResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostEdgeKubeLogsResponse parses an HTTP response from a PostEdgeKubeLogsWithResponse call
func ParsePostEdgeKubeLogsResponse(rsp *http.Response) (*PostEdgeKubeLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEdgeKubeLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Object `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeKubeProxyResponse parses an HTTP response from a GetEdgeKubeProxyWithResponse call
func ParseGetEdgeKubeProxyResponse(rsp *http.Response) (*GetEdgeKubeProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeKubeProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Object `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeLogsResponse parses an HTTP response from a GetEdgeLogsWithResponse call
func ParseGetEdgeLogsResponse(rsp *http.Response) (*GetEdgeLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]EdgeFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeLsPathResponse parses an HTTP response from a GetEdgeLsPathWithResponse call
func ParseGetEdgeLsPathResponse(rsp *http.Response) (*GetEdgeLsPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeLsPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]FilesystemEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeMetadataResponse parses an HTTP response from a GetEdgeMetadataWithResponse call
func ParseGetEdgeMetadataResponse(rsp *http.Response) (*GetEdgeMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Metadata `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeProcessesResponse parses an HTTP response from a GetEdgeProcessesWithResponse call
func ParseGetEdgeProcessesResponse(rsp *http.Response) (*GetEdgeProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Process `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEdgeProcessesPidResponse parses an HTTP response from a GetEdgeProcessesPidWithResponse call
func ParseGetEdgeProcessesPidResponse(rsp *http.Response) (*GetEdgeProcessesPidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEdgeProcessesPidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Process `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExecutorsResponse parses an HTTP response from a GetExecutorsWithResponse call
func ParseGetExecutorsResponse(rsp *http.Response) (*GetExecutorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Executor `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExecutorsIdResponse parses an HTTP response from a GetExecutorsIdWithResponse call
func ParseGetExecutorsIdResponse(rsp *http.Response) (*GetExecutorsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutorsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Executor `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFunctionsResponse parses an HTTP response from a GetFunctionsWithResponse call
func ParseGetFunctionsResponse(rsp *http.Response) (*GetFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Function `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFunctionsIdResponse parses an HTTP response from a GetFunctionsIdWithResponse call
func ParseGetFunctionsIdResponse(rsp *http.Response) (*GetFunctionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Function `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceHealthStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 420:
		var dest ServiceHealthStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON420 = &dest

	}

	return response, nil
}

// ParseGetJobsResponse parses an HTTP response from a GetJobsWithResponse call
func ParseGetJobsResponse(rsp *http.Response) (*GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items the pre-limited items in the list of results
			Items *[]JobInfo `json:"items,omitempty"`

			// Limit number of items present in the items array
			Limit *int `json:"limit,omitempty"`

			// Offset pagination offset
			Offset *int `json:"offset,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostJobsResponse parses an HTTP response from a PostJobsWithResponse call
func ParsePostJobsResponse(rsp *http.Response) (*PostJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteJobsIdResponse parses an HTTP response from a DeleteJobsIdWithResponse call
func ParseDeleteJobsIdResponse(rsp *http.Response) (*DeleteJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJobsIdResponse parses an HTTP response from a GetJobsIdWithResponse call
func ParseGetJobsIdResponse(rsp *http.Response) (*GetJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]JobInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchJobsIdCancelResponse parses an HTTP response from a PatchJobsIdCancelWithResponse call
func ParsePatchJobsIdCancelResponse(rsp *http.Response) (*PatchJobsIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchJobsIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]JobState `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJobsIdErrorsResponse parses an HTTP response from a GetJobsIdErrorsWithResponse call
func ParseGetJobsIdErrorsResponse(rsp *http.Response) (*GetJobsIdErrorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsIdErrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJobsIdErrorsGroupResponse parses an HTTP response from a GetJobsIdErrorsGroupWithResponse call
func ParseGetJobsIdErrorsGroupResponse(rsp *http.Response) (*GetJobsIdErrorsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsIdErrorsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchJobsIdKeepResponse parses an HTTP response from a PatchJobsIdKeepWithResponse call
func ParsePatchJobsIdKeepResponse(rsp *http.Response) (*PatchJobsIdKeepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchJobsIdKeepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]JobInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchJobsIdPauseResponse parses an HTTP response from a PatchJobsIdPauseWithResponse call
func ParsePatchJobsIdPauseResponse(rsp *http.Response) (*PatchJobsIdPauseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchJobsIdPauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]JobState `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJobsIdResultsResponse parses an HTTP response from a GetJobsIdResultsWithResponse call
func ParseGetJobsIdResultsResponse(rsp *http.Response) (*GetJobsIdResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsIdResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobsIdResultsGroupResponse parses an HTTP response from a GetJobsIdResultsGroupWithResponse call
func ParseGetJobsIdResultsGroupResponse(rsp *http.Response) (*GetJobsIdResultsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsIdResultsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchJobsIdResumeResponse parses an HTTP response from a PatchJobsIdResumeWithResponse call
func ParsePatchJobsIdResumeResponse(rsp *http.Response) (*PatchJobsIdResumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchJobsIdResumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]JobState `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibAppscopeConfigsResponse parses an HTTP response from a GetLibAppscopeConfigsWithResponse call
func ParseGetLibAppscopeConfigsResponse(rsp *http.Response) (*GetLibAppscopeConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibAppscopeConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]AppscopeLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibAppscopeConfigsResponse parses an HTTP response from a PostLibAppscopeConfigsWithResponse call
func ParsePostLibAppscopeConfigsResponse(rsp *http.Response) (*PostLibAppscopeConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibAppscopeConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]AppscopeLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibAppscopeConfigsIdResponse parses an HTTP response from a DeleteLibAppscopeConfigsIdWithResponse call
func ParseDeleteLibAppscopeConfigsIdResponse(rsp *http.Response) (*DeleteLibAppscopeConfigsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibAppscopeConfigsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]AppscopeLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibAppscopeConfigsIdResponse parses an HTTP response from a GetLibAppscopeConfigsIdWithResponse call
func ParseGetLibAppscopeConfigsIdResponse(rsp *http.Response) (*GetLibAppscopeConfigsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibAppscopeConfigsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]AppscopeLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibAppscopeConfigsIdResponse parses an HTTP response from a PatchLibAppscopeConfigsIdWithResponse call
func ParsePatchLibAppscopeConfigsIdResponse(rsp *http.Response) (*PatchLibAppscopeConfigsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibAppscopeConfigsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]AppscopeLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibBreakersResponse parses an HTTP response from a GetLibBreakersWithResponse call
func ParseGetLibBreakersResponse(rsp *http.Response) (*GetLibBreakersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibBreakersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]EventBreakerRuleset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibBreakersResponse parses an HTTP response from a PostLibBreakersWithResponse call
func ParsePostLibBreakersResponse(rsp *http.Response) (*PostLibBreakersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibBreakersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]EventBreakerRuleset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibBreakersIdResponse parses an HTTP response from a DeleteLibBreakersIdWithResponse call
func ParseDeleteLibBreakersIdResponse(rsp *http.Response) (*DeleteLibBreakersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibBreakersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]EventBreakerRuleset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibBreakersIdResponse parses an HTTP response from a GetLibBreakersIdWithResponse call
func ParseGetLibBreakersIdResponse(rsp *http.Response) (*GetLibBreakersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibBreakersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]EventBreakerRuleset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibBreakersIdResponse parses an HTTP response from a PatchLibBreakersIdWithResponse call
func ParsePatchLibBreakersIdResponse(rsp *http.Response) (*PatchLibBreakersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibBreakersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]EventBreakerRuleset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibDatabaseConnectionsResponse parses an HTTP response from a GetLibDatabaseConnectionsWithResponse call
func ParseGetLibDatabaseConnectionsResponse(rsp *http.Response) (*GetLibDatabaseConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibDatabaseConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                        `json:"count,omitempty"`
			Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibDatabaseConnectionsResponse parses an HTTP response from a PostLibDatabaseConnectionsWithResponse call
func ParsePostLibDatabaseConnectionsResponse(rsp *http.Response) (*PostLibDatabaseConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibDatabaseConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                        `json:"count,omitempty"`
			Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibDatabaseConnectionsTestResponse parses an HTTP response from a PostLibDatabaseConnectionsTestWithResponse call
func ParsePostLibDatabaseConnectionsTestResponse(rsp *http.Response) (*PostLibDatabaseConnectionsTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibDatabaseConnectionsTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                            `json:"count,omitempty"`
			Items *[]DatabaseConnectionTestResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibDatabaseConnectionsIdResponse parses an HTTP response from a DeleteLibDatabaseConnectionsIdWithResponse call
func ParseDeleteLibDatabaseConnectionsIdResponse(rsp *http.Response) (*DeleteLibDatabaseConnectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibDatabaseConnectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                        `json:"count,omitempty"`
			Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibDatabaseConnectionsIdResponse parses an HTTP response from a GetLibDatabaseConnectionsIdWithResponse call
func ParseGetLibDatabaseConnectionsIdResponse(rsp *http.Response) (*GetLibDatabaseConnectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibDatabaseConnectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                        `json:"count,omitempty"`
			Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibDatabaseConnectionsIdResponse parses an HTTP response from a PatchLibDatabaseConnectionsIdWithResponse call
func ParsePatchLibDatabaseConnectionsIdResponse(rsp *http.Response) (*PatchLibDatabaseConnectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibDatabaseConnectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                        `json:"count,omitempty"`
			Items *[]DatabaseConnectionConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibExpressionResponse parses an HTTP response from a PostLibExpressionWithResponse call
func ParsePostLibExpressionResponse(rsp *http.Response) (*PostLibExpressionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibExpressionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ExprLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibGrokResponse parses an HTTP response from a GetLibGrokWithResponse call
func ParseGetLibGrokResponse(rsp *http.Response) (*GetLibGrokResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibGrokResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]GrokFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibGrokResponse parses an HTTP response from a PostLibGrokWithResponse call
func ParsePostLibGrokResponse(rsp *http.Response) (*PostLibGrokResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibGrokResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]GrokFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibGrokIdResponse parses an HTTP response from a DeleteLibGrokIdWithResponse call
func ParseDeleteLibGrokIdResponse(rsp *http.Response) (*DeleteLibGrokIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibGrokIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]GrokFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibGrokIdResponse parses an HTTP response from a GetLibGrokIdWithResponse call
func ParseGetLibGrokIdResponse(rsp *http.Response) (*GetLibGrokIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibGrokIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]GrokFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibGrokIdResponse parses an HTTP response from a PatchLibGrokIdWithResponse call
func ParsePatchLibGrokIdResponse(rsp *http.Response) (*PatchLibGrokIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibGrokIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]GrokFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibHmacFunctionsResponse parses an HTTP response from a GetLibHmacFunctionsWithResponse call
func ParseGetLibHmacFunctionsResponse(rsp *http.Response) (*GetLibHmacFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibHmacFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]HmacFunction `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibHmacFunctionsResponse parses an HTTP response from a PostLibHmacFunctionsWithResponse call
func ParsePostLibHmacFunctionsResponse(rsp *http.Response) (*PostLibHmacFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibHmacFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]HmacFunction `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibHmacFunctionsIdResponse parses an HTTP response from a DeleteLibHmacFunctionsIdWithResponse call
func ParseDeleteLibHmacFunctionsIdResponse(rsp *http.Response) (*DeleteLibHmacFunctionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibHmacFunctionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]HmacFunction `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibHmacFunctionsIdResponse parses an HTTP response from a GetLibHmacFunctionsIdWithResponse call
func ParseGetLibHmacFunctionsIdResponse(rsp *http.Response) (*GetLibHmacFunctionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibHmacFunctionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]HmacFunction `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibHmacFunctionsIdResponse parses an HTTP response from a PatchLibHmacFunctionsIdWithResponse call
func ParsePatchLibHmacFunctionsIdResponse(rsp *http.Response) (*PatchLibHmacFunctionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibHmacFunctionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]HmacFunction `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibJobsResponse parses an HTTP response from a GetLibJobsWithResponse call
func ParseGetLibJobsResponse(rsp *http.Response) (*GetLibJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]SavedJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibJobsResponse parses an HTTP response from a PostLibJobsWithResponse call
func ParsePostLibJobsResponse(rsp *http.Response) (*PostLibJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]SavedJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibJobsIdResponse parses an HTTP response from a DeleteLibJobsIdWithResponse call
func ParseDeleteLibJobsIdResponse(rsp *http.Response) (*DeleteLibJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]SavedJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibJobsIdResponse parses an HTTP response from a GetLibJobsIdWithResponse call
func ParseGetLibJobsIdResponse(rsp *http.Response) (*GetLibJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]SavedJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibJobsIdResponse parses an HTTP response from a PatchLibJobsIdWithResponse call
func ParsePatchLibJobsIdResponse(rsp *http.Response) (*PatchLibJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]SavedJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibParquetSchemasResponse parses an HTTP response from a GetLibParquetSchemasWithResponse call
func ParseGetLibParquetSchemasResponse(rsp *http.Response) (*GetLibParquetSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibParquetSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibParquetSchemasResponse parses an HTTP response from a PostLibParquetSchemasWithResponse call
func ParsePostLibParquetSchemasResponse(rsp *http.Response) (*PostLibParquetSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibParquetSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibParquetSchemasIdResponse parses an HTTP response from a DeleteLibParquetSchemasIdWithResponse call
func ParseDeleteLibParquetSchemasIdResponse(rsp *http.Response) (*DeleteLibParquetSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibParquetSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibParquetSchemasIdResponse parses an HTTP response from a GetLibParquetSchemasIdWithResponse call
func ParseGetLibParquetSchemasIdResponse(rsp *http.Response) (*GetLibParquetSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibParquetSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibParquetSchemasIdResponse parses an HTTP response from a PatchLibParquetSchemasIdWithResponse call
func ParsePatchLibParquetSchemasIdResponse(rsp *http.Response) (*PatchLibParquetSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibParquetSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibParsersResponse parses an HTTP response from a GetLibParsersWithResponse call
func ParseGetLibParsersResponse(rsp *http.Response) (*GetLibParsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibParsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ParserLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibParsersResponse parses an HTTP response from a PostLibParsersWithResponse call
func ParsePostLibParsersResponse(rsp *http.Response) (*PostLibParsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibParsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ParserLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibParsersIdResponse parses an HTTP response from a DeleteLibParsersIdWithResponse call
func ParseDeleteLibParsersIdResponse(rsp *http.Response) (*DeleteLibParsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibParsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ParserLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibParsersIdResponse parses an HTTP response from a GetLibParsersIdWithResponse call
func ParseGetLibParsersIdResponse(rsp *http.Response) (*GetLibParsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibParsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ParserLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibParsersIdResponse parses an HTTP response from a PatchLibParsersIdWithResponse call
func ParsePatchLibParsersIdResponse(rsp *http.Response) (*PatchLibParsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibParsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ParserLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibProtobufLibrariesResponse parses an HTTP response from a GetLibProtobufLibrariesWithResponse call
func ParseGetLibProtobufLibrariesResponse(rsp *http.Response) (*GetLibProtobufLibrariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibProtobufLibrariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibProtobufLibrariesIdResponse parses an HTTP response from a GetLibProtobufLibrariesIdWithResponse call
func ParseGetLibProtobufLibrariesIdResponse(rsp *http.Response) (*GetLibProtobufLibrariesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibProtobufLibrariesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]ProtobufLibraryConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibProtobufLibrariesIdEncodingsResponse parses an HTTP response from a GetLibProtobufLibrariesIdEncodingsWithResponse call
func ParseGetLibProtobufLibrariesIdEncodingsResponse(rsp *http.Response) (*GetLibProtobufLibrariesIdEncodingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibProtobufLibrariesIdEncodingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibProtobufLibrariesIdEncodingsEncidResponse parses an HTTP response from a GetLibProtobufLibrariesIdEncodingsEncidWithResponse call
func ParseGetLibProtobufLibrariesIdEncodingsEncidResponse(rsp *http.Response) (*GetLibProtobufLibrariesIdEncodingsEncidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibProtobufLibrariesIdEncodingsEncidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]ProtobufEncodingConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibRegexResponse parses an HTTP response from a GetLibRegexWithResponse call
func ParseGetLibRegexResponse(rsp *http.Response) (*GetLibRegexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibRegexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]RegexLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibRegexResponse parses an HTTP response from a PostLibRegexWithResponse call
func ParsePostLibRegexResponse(rsp *http.Response) (*PostLibRegexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibRegexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]RegexLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibRegexIdResponse parses an HTTP response from a DeleteLibRegexIdWithResponse call
func ParseDeleteLibRegexIdResponse(rsp *http.Response) (*DeleteLibRegexIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibRegexIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]RegexLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibRegexIdResponse parses an HTTP response from a GetLibRegexIdWithResponse call
func ParseGetLibRegexIdResponse(rsp *http.Response) (*GetLibRegexIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibRegexIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]RegexLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibRegexIdResponse parses an HTTP response from a PatchLibRegexIdWithResponse call
func ParsePatchLibRegexIdResponse(rsp *http.Response) (*PatchLibRegexIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibRegexIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]RegexLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibSchemasResponse parses an HTTP response from a GetLibSchemasWithResponse call
func ParseGetLibSchemasResponse(rsp *http.Response) (*GetLibSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibSchemasResponse parses an HTTP response from a PostLibSchemasWithResponse call
func ParsePostLibSchemasResponse(rsp *http.Response) (*PostLibSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibSchemasIdResponse parses an HTTP response from a DeleteLibSchemasIdWithResponse call
func ParseDeleteLibSchemasIdResponse(rsp *http.Response) (*DeleteLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibSchemasIdResponse parses an HTTP response from a GetLibSchemasIdWithResponse call
func ParseGetLibSchemasIdResponse(rsp *http.Response) (*GetLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibSchemasIdResponse parses an HTTP response from a PatchLibSchemasIdWithResponse call
func ParsePatchLibSchemasIdResponse(rsp *http.Response) (*PatchLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibVarsResponse parses an HTTP response from a GetLibVarsWithResponse call
func ParseGetLibVarsResponse(rsp *http.Response) (*GetLibVarsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibVarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostLibVarsResponse parses an HTTP response from a PostLibVarsWithResponse call
func ParsePostLibVarsResponse(rsp *http.Response) (*PostLibVarsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLibVarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLibVarsIdResponse parses an HTTP response from a DeleteLibVarsIdWithResponse call
func ParseDeleteLibVarsIdResponse(rsp *http.Response) (*DeleteLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLibVarsIdResponse parses an HTTP response from a GetLibVarsIdWithResponse call
func ParseGetLibVarsIdResponse(rsp *http.Response) (*GetLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLibVarsIdResponse parses an HTTP response from a PatchLibVarsIdWithResponse call
func ParsePatchLibVarsIdResponse(rsp *http.Response) (*PatchLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostMGroupIdSystemProjectsProjectIdCaptureResponse parses an HTTP response from a PostMGroupIdSystemProjectsProjectIdCaptureWithResponse call
func ParsePostMGroupIdSystemProjectsProjectIdCaptureResponse(rsp *http.Response) (*PostMGroupIdSystemProjectsProjectIdCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMGroupIdSystemProjectsProjectIdCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdPipelinesResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdPipelinesWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdPipelinesResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostMGroupIdSystemProjectsProjectIdPipelinesResponse parses an HTTP response from a PostMGroupIdSystemProjectsProjectIdPipelinesWithResponse call
func ParsePostMGroupIdSystemProjectsProjectIdPipelinesResponse(rsp *http.Response) (*PostMGroupIdSystemProjectsProjectIdPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMGroupIdSystemProjectsProjectIdPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse parses an HTTP response from a DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse call
func ParseDeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp *http.Response) (*DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse parses an HTTP response from a PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdWithResponse call
func ParsePatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse(rsp *http.Response) (*PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostMGroupIdSystemProjectsProjectIdPreviewResponse parses an HTTP response from a PostMGroupIdSystemProjectsProjectIdPreviewWithResponse call
func ParsePostMGroupIdSystemProjectsProjectIdPreviewResponse(rsp *http.Response) (*PostMGroupIdSystemProjectsProjectIdPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMGroupIdSystemProjectsProjectIdPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdSubscriptionsResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdSubscriptionsWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdSubscriptionsResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse parses an HTTP response from a PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse call
func ParsePostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp *http.Response) (*PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostMGroupIdSystemProjectsProjectIdVersionCommitResponse parses an HTTP response from a PostMGroupIdSystemProjectsProjectIdVersionCommitWithResponse call
func ParsePostMGroupIdSystemProjectsProjectIdVersionCommitResponse(rsp *http.Response) (*PostMGroupIdSystemProjectsProjectIdVersionCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMGroupIdSystemProjectsProjectIdVersionCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitCommitSummary `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdVersionCountResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdVersionCountWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdVersionCountResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdVersionCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdVersionCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdVersionDiffResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdVersionDiffWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdVersionDiffResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdVersionDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdVersionDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMGroupIdSystemProjectsProjectIdVersionFilesResponse parses an HTTP response from a GetMGroupIdSystemProjectsProjectIdVersionFilesWithResponse call
func ParseGetMGroupIdSystemProjectsProjectIdVersionFilesResponse(rsp *http.Response) (*GetMGroupIdSystemProjectsProjectIdVersionFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMGroupIdSystemProjectsProjectIdVersionFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count Number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitFilesResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterBundlesGroupVersionResponse parses an HTTP response from a GetMasterBundlesGroupVersionWithResponse call
func ParseGetMasterBundlesGroupVersionResponse(rsp *http.Response) (*GetMasterBundlesGroupVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterBundlesGroupVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMasterGroupsIdResponse parses an HTTP response from a GetMasterGroupsIdWithResponse call
func ParseGetMasterGroupsIdResponse(rsp *http.Response) (*GetMasterGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]ConfigGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterGroupsIdAclResponse parses an HTTP response from a GetMasterGroupsIdAclWithResponse call
func ParseGetMasterGroupsIdAclResponse(rsp *http.Response) (*GetMasterGroupsIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterGroupsIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterGroupsIdConfigVersionResponse parses an HTTP response from a GetMasterGroupsIdConfigVersionWithResponse call
func ParseGetMasterGroupsIdConfigVersionResponse(rsp *http.Response) (*GetMasterGroupsIdConfigVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterGroupsIdConfigVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchMasterGroupsIdDeployResponse parses an HTTP response from a PatchMasterGroupsIdDeployWithResponse call
func ParsePatchMasterGroupsIdDeployResponse(rsp *http.Response) (*PatchMasterGroupsIdDeployResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMasterGroupsIdDeployResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]ConfigGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterSummaryResponse parses an HTTP response from a GetMasterSummaryWithResponse call
func ParseGetMasterSummaryResponse(rsp *http.Response) (*GetMasterSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]DistributedSummary `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterSummaryWorkersResponse parses an HTTP response from a GetMasterSummaryWorkersWithResponse call
func ParseGetMasterSummaryWorkersResponse(rsp *http.Response) (*GetMasterSummaryWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterSummaryWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]float32 `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMasterWorkersResponse parses an HTTP response from a GetMasterWorkersWithResponse call
func ParseGetMasterWorkersResponse(rsp *http.Response) (*GetMasterWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]MasterWorkerEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchMasterWorkersRestartResponse parses an HTTP response from a PatchMasterWorkersRestartWithResponse call
func ParsePatchMasterWorkersRestartResponse(rsp *http.Response) (*PatchMasterWorkersRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchMasterWorkersRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]RestartResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationTargetsResponse parses an HTTP response from a GetNotificationTargetsWithResponse call
func ParseGetNotificationTargetsResponse(rsp *http.Response) (*GetNotificationTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]NotificationTarget `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNotificationTargetsResponse parses an HTTP response from a PostNotificationTargetsWithResponse call
func ParsePostNotificationTargetsResponse(rsp *http.Response) (*PostNotificationTargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNotificationTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]NotificationTarget `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationTargetsIdResponse parses an HTTP response from a DeleteNotificationTargetsIdWithResponse call
func ParseDeleteNotificationTargetsIdResponse(rsp *http.Response) (*DeleteNotificationTargetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationTargetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]NotificationTarget `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationTargetsIdResponse parses an HTTP response from a GetNotificationTargetsIdWithResponse call
func ParseGetNotificationTargetsIdResponse(rsp *http.Response) (*GetNotificationTargetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationTargetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]NotificationTarget `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchNotificationTargetsIdResponse parses an HTTP response from a PatchNotificationTargetsIdWithResponse call
func ParsePatchNotificationTargetsIdResponse(rsp *http.Response) (*PatchNotificationTargetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchNotificationTargetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]NotificationTarget `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationsResponse parses an HTTP response from a GetNotificationsWithResponse call
func ParseGetNotificationsResponse(rsp *http.Response) (*GetNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Notification `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNotificationsResponse parses an HTTP response from a PostNotificationsWithResponse call
func ParsePostNotificationsResponse(rsp *http.Response) (*PostNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Notification `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationsIdResponse parses an HTTP response from a DeleteNotificationsIdWithResponse call
func ParseDeleteNotificationsIdResponse(rsp *http.Response) (*DeleteNotificationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Notification `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationsIdResponse parses an HTTP response from a GetNotificationsIdWithResponse call
func ParseGetNotificationsIdResponse(rsp *http.Response) (*GetNotificationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Notification `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchNotificationsIdResponse parses an HTTP response from a PatchNotificationsIdWithResponse call
func ParsePatchNotificationsIdResponse(rsp *http.Response) (*PatchNotificationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchNotificationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Notification `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOutputClickHouseDescribeTableResponse parses an HTTP response from a PostOutputClickHouseDescribeTableWithResponse call
func ParsePostOutputClickHouseDescribeTableResponse(rsp *http.Response) (*PostOutputClickHouseDescribeTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOutputClickHouseDescribeTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                           `json:"count,omitempty"`
			Items *[]ClickHouseDescriptionResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackFunctionsResponse parses an HTTP response from a GetPPackFunctionsWithResponse call
func ParseGetPPackFunctionsResponse(rsp *http.Response) (*GetPPackFunctionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackFunctionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Function `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackFunctionsIdResponse parses an HTTP response from a GetPPackFunctionsIdWithResponse call
func ParseGetPPackFunctionsIdResponse(rsp *http.Response) (*GetPPackFunctionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackFunctionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Function `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackLibSchemasResponse parses an HTTP response from a GetPPackLibSchemasWithResponse call
func ParseGetPPackLibSchemasResponse(rsp *http.Response) (*GetPPackLibSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackLibSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPPackLibSchemasResponse parses an HTTP response from a PostPPackLibSchemasWithResponse call
func ParsePostPPackLibSchemasResponse(rsp *http.Response) (*PostPPackLibSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPPackLibSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePPackLibSchemasIdResponse parses an HTTP response from a DeletePPackLibSchemasIdWithResponse call
func ParseDeletePPackLibSchemasIdResponse(rsp *http.Response) (*DeletePPackLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePPackLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackLibSchemasIdResponse parses an HTTP response from a GetPPackLibSchemasIdWithResponse call
func ParseGetPPackLibSchemasIdResponse(rsp *http.Response) (*GetPPackLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPPackLibSchemasIdResponse parses an HTTP response from a PatchPPackLibSchemasIdWithResponse call
func ParsePatchPPackLibSchemasIdResponse(rsp *http.Response) (*PatchPPackLibSchemasIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPPackLibSchemasIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SchemaLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackLibVarsResponse parses an HTTP response from a GetPPackLibVarsWithResponse call
func ParseGetPPackLibVarsResponse(rsp *http.Response) (*GetPPackLibVarsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackLibVarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPPackLibVarsResponse parses an HTTP response from a PostPPackLibVarsWithResponse call
func ParsePostPPackLibVarsResponse(rsp *http.Response) (*PostPPackLibVarsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPPackLibVarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePPackLibVarsIdResponse parses an HTTP response from a DeletePPackLibVarsIdWithResponse call
func ParseDeletePPackLibVarsIdResponse(rsp *http.Response) (*DeletePPackLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePPackLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackLibVarsIdResponse parses an HTTP response from a GetPPackLibVarsIdWithResponse call
func ParseGetPPackLibVarsIdResponse(rsp *http.Response) (*GetPPackLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPPackLibVarsIdResponse parses an HTTP response from a PatchPPackLibVarsIdWithResponse call
func ParsePatchPPackLibVarsIdResponse(rsp *http.Response) (*PatchPPackLibVarsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPPackLibVarsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]GlobalVar `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackPipelinesResponse parses an HTTP response from a GetPPackPipelinesWithResponse call
func ParseGetPPackPipelinesResponse(rsp *http.Response) (*GetPPackPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPPackPipelinesResponse parses an HTTP response from a PostPPackPipelinesWithResponse call
func ParsePostPPackPipelinesResponse(rsp *http.Response) (*PostPPackPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPPackPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePPackPipelinesIdResponse parses an HTTP response from a DeletePPackPipelinesIdWithResponse call
func ParseDeletePPackPipelinesIdResponse(rsp *http.Response) (*DeletePPackPipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePPackPipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackPipelinesIdResponse parses an HTTP response from a GetPPackPipelinesIdWithResponse call
func ParseGetPPackPipelinesIdResponse(rsp *http.Response) (*GetPPackPipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackPipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPPackPipelinesIdResponse parses an HTTP response from a PatchPPackPipelinesIdWithResponse call
func ParsePatchPPackPipelinesIdResponse(rsp *http.Response) (*PatchPPackPipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPPackPipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackRoutesResponse parses an HTTP response from a GetPPackRoutesWithResponse call
func ParseGetPPackRoutesResponse(rsp *http.Response) (*GetPPackRoutesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackRoutesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPPackRoutesIdResponse parses an HTTP response from a GetPPackRoutesIdWithResponse call
func ParseGetPPackRoutesIdResponse(rsp *http.Response) (*GetPPackRoutesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPPackRoutesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPPackRoutesIdResponse parses an HTTP response from a PatchPPackRoutesIdWithResponse call
func ParsePatchPPackRoutesIdResponse(rsp *http.Response) (*PatchPPackRoutesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPPackRoutesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPPackRoutesIdAppendResponse parses an HTTP response from a PostPPackRoutesIdAppendWithResponse call
func ParsePostPPackRoutesIdAppendResponse(rsp *http.Response) (*PostPPackRoutesIdAppendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPPackRoutesIdAppendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPacksResponse parses an HTTP response from a GetPacksWithResponse call
func ParseGetPacksResponse(rsp *http.Response) (*GetPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]PackInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPacksResponse parses an HTTP response from a PostPacksWithResponse call
func ParsePostPacksResponse(rsp *http.Response) (*PostPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]PackInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutPacksResponse parses an HTTP response from a PutPacksWithResponse call
func ParsePutPacksResponse(rsp *http.Response) (*PutPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPacksCloneResponse parses an HTTP response from a PostPacksCloneWithResponse call
func ParsePostPacksCloneResponse(rsp *http.Response) (*PostPacksCloneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPacksCloneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePacksIdResponse parses an HTTP response from a DeletePacksIdWithResponse call
func ParseDeletePacksIdResponse(rsp *http.Response) (*DeletePacksIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePacksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]PackInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPacksIdResponse parses an HTTP response from a PatchPacksIdWithResponse call
func ParsePatchPacksIdResponse(rsp *http.Response) (*PatchPacksIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPacksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]PackInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPacksIdExportResponse parses an HTTP response from a GetPacksIdExportWithResponse call
func ParseGetPacksIdExportResponse(rsp *http.Response) (*GetPacksIdExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPacksIdExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPipelinesResponse parses an HTTP response from a GetPipelinesWithResponse call
func ParseGetPipelinesResponse(rsp *http.Response) (*GetPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPipelinesResponse parses an HTTP response from a PostPipelinesWithResponse call
func ParsePostPipelinesResponse(rsp *http.Response) (*PostPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePipelinesIdResponse parses an HTTP response from a DeletePipelinesIdWithResponse call
func ParseDeletePipelinesIdResponse(rsp *http.Response) (*DeletePipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPipelinesIdResponse parses an HTTP response from a GetPipelinesIdWithResponse call
func ParseGetPipelinesIdResponse(rsp *http.Response) (*GetPipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPipelinesIdResponse parses an HTTP response from a PatchPipelinesIdWithResponse call
func ParsePatchPipelinesIdResponse(rsp *http.Response) (*PatchPipelinesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPipelinesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int        `json:"count,omitempty"`
			Items *[]Pipeline `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPreviewResponse parses an HTTP response from a PostPreviewWithResponse call
func ParsePostPreviewResponse(rsp *http.Response) (*PostPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsEdgeMapQueryResponse parses an HTTP response from a PostProductsEdgeMapQueryWithResponse call
func ParsePostProductsEdgeMapQueryResponse(rsp *http.Response) (*PostProductsEdgeMapQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsEdgeMapQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]EdgeMapQueryResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsLakeLakesLakeIdDatasetsResponse parses an HTTP response from a GetProductsLakeLakesLakeIdDatasetsWithResponse call
func ParseGetProductsLakeLakesLakeIdDatasetsResponse(rsp *http.Response) (*GetProductsLakeLakesLakeIdDatasetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsLakeLakesLakeIdDatasetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]CriblLakeDataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsLakeLakesLakeIdDatasetsResponse parses an HTTP response from a PostProductsLakeLakesLakeIdDatasetsWithResponse call
func ParsePostProductsLakeLakesLakeIdDatasetsResponse(rsp *http.Response) (*PostProductsLakeLakesLakeIdDatasetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsLakeLakesLakeIdDatasetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]CriblLakeDataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsLakeLakesLakeIdDatasetsIdResponse parses an HTTP response from a DeleteProductsLakeLakesLakeIdDatasetsIdWithResponse call
func ParseDeleteProductsLakeLakesLakeIdDatasetsIdResponse(rsp *http.Response) (*DeleteProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsLakeLakesLakeIdDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]CriblLakeDataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsLakeLakesLakeIdDatasetsIdResponse parses an HTTP response from a GetProductsLakeLakesLakeIdDatasetsIdWithResponse call
func ParseGetProductsLakeLakesLakeIdDatasetsIdResponse(rsp *http.Response) (*GetProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsLakeLakesLakeIdDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]CriblLakeDataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchProductsLakeLakesLakeIdDatasetsIdResponse parses an HTTP response from a PatchProductsLakeLakesLakeIdDatasetsIdWithResponse call
func ParsePatchProductsLakeLakesLakeIdDatasetsIdResponse(rsp *http.Response) (*PatchProductsLakeLakesLakeIdDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchProductsLakeLakesLakeIdDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]CriblLakeDataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductGroupsResponse parses an HTTP response from a GetProductsProductGroupsWithResponse call
func ParseGetProductsProductGroupsResponse(rsp *http.Response) (*GetProductsProductGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]ConfigGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductGroupsResponse parses an HTTP response from a PostProductsProductGroupsWithResponse call
func ParsePostProductsProductGroupsResponse(rsp *http.Response) (*PostProductsProductGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]ConfigGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductGroupsIdAclTeamsResponse parses an HTTP response from a GetProductsProductGroupsIdAclTeamsWithResponse call
func ParseGetProductsProductGroupsIdAclTeamsResponse(rsp *http.Response) (*GetProductsProductGroupsIdAclTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductGroupsIdAclTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]TeamAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductUsersResponse parses an HTTP response from a GetProductsProductUsersWithResponse call
func ParseGetProductsProductUsersResponse(rsp *http.Response) (*GetProductsProductUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]User `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsProductUsersCacheResponse parses an HTTP response from a DeleteProductsProductUsersCacheWithResponse call
func ParseDeleteProductsProductUsersCacheResponse(rsp *http.Response) (*DeleteProductsProductUsersCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsProductUsersCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductUsersIdAclResponse parses an HTTP response from a GetProductsProductUsersIdAclWithResponse call
func ParseGetProductsProductUsersIdAclResponse(rsp *http.Response) (*GetProductsProductUsersIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductUsersIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ResourcePolicy `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoutesResponse parses an HTTP response from a GetRoutesWithResponse call
func ParseGetRoutesResponse(rsp *http.Response) (*GetRoutesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoutesIdResponse parses an HTTP response from a GetRoutesIdWithResponse call
func ParseGetRoutesIdResponse(rsp *http.Response) (*GetRoutesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchRoutesIdResponse parses an HTTP response from a PatchRoutesIdWithResponse call
func ParsePatchRoutesIdResponse(rsp *http.Response) (*PatchRoutesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRoutesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Routes `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRoutesIdAppendResponse parses an HTTP response from a PostRoutesIdAppendWithResponse call
func ParsePostRoutesIdAppendResponse(rsp *http.Response) (*PostRoutesIdAppendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRoutesIdAppendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardCategoriesResponse parses an HTTP response from a GetSearchDashboardCategoriesWithResponse call
func ParseGetSearchDashboardCategoriesResponse(rsp *http.Response) (*GetSearchDashboardCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DashboardCategory `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDashboardCategoriesResponse parses an HTTP response from a PostSearchDashboardCategoriesWithResponse call
func ParsePostSearchDashboardCategoriesResponse(rsp *http.Response) (*PostSearchDashboardCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDashboardCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DashboardCategory `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchDashboardCategoriesIdResponse parses an HTTP response from a DeleteSearchDashboardCategoriesIdWithResponse call
func ParseDeleteSearchDashboardCategoriesIdResponse(rsp *http.Response) (*DeleteSearchDashboardCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchDashboardCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DashboardCategory `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardCategoriesIdResponse parses an HTTP response from a GetSearchDashboardCategoriesIdWithResponse call
func ParseGetSearchDashboardCategoriesIdResponse(rsp *http.Response) (*GetSearchDashboardCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DashboardCategory `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchDashboardCategoriesIdResponse parses an HTTP response from a PatchSearchDashboardCategoriesIdWithResponse call
func ParsePatchSearchDashboardCategoriesIdResponse(rsp *http.Response) (*PatchSearchDashboardCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchDashboardCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DashboardCategory `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardsResponse parses an HTTP response from a GetSearchDashboardsWithResponse call
func ParseGetSearchDashboardsResponse(rsp *http.Response) (*GetSearchDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]SearchDashboard `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDashboardsResponse parses an HTTP response from a PostSearchDashboardsWithResponse call
func ParsePostSearchDashboardsResponse(rsp *http.Response) (*PostSearchDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]SearchDashboard `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchDashboardsIdResponse parses an HTTP response from a DeleteSearchDashboardsIdWithResponse call
func ParseDeleteSearchDashboardsIdResponse(rsp *http.Response) (*DeleteSearchDashboardsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchDashboardsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]SearchDashboard `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardsIdResponse parses an HTTP response from a GetSearchDashboardsIdWithResponse call
func ParseGetSearchDashboardsIdResponse(rsp *http.Response) (*GetSearchDashboardsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]SearchDashboard `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchDashboardsIdResponse parses an HTTP response from a PatchSearchDashboardsIdWithResponse call
func ParsePatchSearchDashboardsIdResponse(rsp *http.Response) (*PatchSearchDashboardsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchDashboardsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]SearchDashboard `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardsIdAclResponse parses an HTTP response from a GetSearchDashboardsIdAclWithResponse call
func ParseGetSearchDashboardsIdAclResponse(rsp *http.Response) (*GetSearchDashboardsIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardsIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDashboardsIdAclApplyResponse parses an HTTP response from a PostSearchDashboardsIdAclApplyWithResponse call
func ParsePostSearchDashboardsIdAclApplyResponse(rsp *http.Response) (*PostSearchDashboardsIdAclApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDashboardsIdAclApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDashboardsIdAclTeamsResponse parses an HTTP response from a GetSearchDashboardsIdAclTeamsWithResponse call
func ParseGetSearchDashboardsIdAclTeamsResponse(rsp *http.Response) (*GetSearchDashboardsIdAclTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDashboardsIdAclTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDashboardsIdAclTeamsApplyResponse parses an HTTP response from a PostSearchDashboardsIdAclTeamsApplyWithResponse call
func ParsePostSearchDashboardsIdAclTeamsApplyResponse(rsp *http.Response) (*PostSearchDashboardsIdAclTeamsApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDashboardsIdAclTeamsApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetProviderTypesResponse parses an HTTP response from a GetSearchDatasetProviderTypesWithResponse call
func ParseGetSearchDatasetProviderTypesResponse(rsp *http.Response) (*GetSearchDatasetProviderTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetProviderTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]DatasetProviderType `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDatasetProviderTypesResponse parses an HTTP response from a PostSearchDatasetProviderTypesWithResponse call
func ParsePostSearchDatasetProviderTypesResponse(rsp *http.Response) (*PostSearchDatasetProviderTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDatasetProviderTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]DatasetProviderType `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchDatasetProviderTypesIdResponse parses an HTTP response from a DeleteSearchDatasetProviderTypesIdWithResponse call
func ParseDeleteSearchDatasetProviderTypesIdResponse(rsp *http.Response) (*DeleteSearchDatasetProviderTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchDatasetProviderTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]DatasetProviderType `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetProviderTypesIdResponse parses an HTTP response from a GetSearchDatasetProviderTypesIdWithResponse call
func ParseGetSearchDatasetProviderTypesIdResponse(rsp *http.Response) (*GetSearchDatasetProviderTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetProviderTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]DatasetProviderType `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchDatasetProviderTypesIdResponse parses an HTTP response from a PatchSearchDatasetProviderTypesIdWithResponse call
func ParsePatchSearchDatasetProviderTypesIdResponse(rsp *http.Response) (*PatchSearchDatasetProviderTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchDatasetProviderTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]DatasetProviderType `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetProvidersResponse parses an HTTP response from a GetSearchDatasetProvidersWithResponse call
func ParseGetSearchDatasetProvidersResponse(rsp *http.Response) (*GetSearchDatasetProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]DatasetProvider `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDatasetProvidersResponse parses an HTTP response from a PostSearchDatasetProvidersWithResponse call
func ParsePostSearchDatasetProvidersResponse(rsp *http.Response) (*PostSearchDatasetProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDatasetProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]DatasetProvider `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchDatasetProvidersIdResponse parses an HTTP response from a DeleteSearchDatasetProvidersIdWithResponse call
func ParseDeleteSearchDatasetProvidersIdResponse(rsp *http.Response) (*DeleteSearchDatasetProvidersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchDatasetProvidersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]DatasetProvider `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetProvidersIdResponse parses an HTTP response from a GetSearchDatasetProvidersIdWithResponse call
func ParseGetSearchDatasetProvidersIdResponse(rsp *http.Response) (*GetSearchDatasetProvidersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetProvidersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]DatasetProvider `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchDatasetProvidersIdResponse parses an HTTP response from a PatchSearchDatasetProvidersIdWithResponse call
func ParsePatchSearchDatasetProvidersIdResponse(rsp *http.Response) (*PatchSearchDatasetProvidersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchDatasetProvidersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]DatasetProvider `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetsResponse parses an HTTP response from a GetSearchDatasetsWithResponse call
func ParseGetSearchDatasetsResponse(rsp *http.Response) (*GetSearchDatasetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Dataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDatasetsResponse parses an HTTP response from a PostSearchDatasetsWithResponse call
func ParsePostSearchDatasetsResponse(rsp *http.Response) (*PostSearchDatasetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDatasetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Dataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchDatasetsIdResponse parses an HTTP response from a DeleteSearchDatasetsIdWithResponse call
func ParseDeleteSearchDatasetsIdResponse(rsp *http.Response) (*DeleteSearchDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Dataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetsIdResponse parses an HTTP response from a GetSearchDatasetsIdWithResponse call
func ParseGetSearchDatasetsIdResponse(rsp *http.Response) (*GetSearchDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Dataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchDatasetsIdResponse parses an HTTP response from a PatchSearchDatasetsIdWithResponse call
func ParsePatchSearchDatasetsIdResponse(rsp *http.Response) (*PatchSearchDatasetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchDatasetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]Dataset `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetsIdAclResponse parses an HTTP response from a GetSearchDatasetsIdAclWithResponse call
func ParseGetSearchDatasetsIdAclResponse(rsp *http.Response) (*GetSearchDatasetsIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetsIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDatasetsIdAclApplyResponse parses an HTTP response from a PostSearchDatasetsIdAclApplyWithResponse call
func ParsePostSearchDatasetsIdAclApplyResponse(rsp *http.Response) (*PostSearchDatasetsIdAclApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDatasetsIdAclApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDatasetsIdAclTeamsResponse parses an HTTP response from a GetSearchDatasetsIdAclTeamsWithResponse call
func ParseGetSearchDatasetsIdAclTeamsResponse(rsp *http.Response) (*GetSearchDatasetsIdAclTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDatasetsIdAclTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchDatasetsIdAclTeamsApplyResponse parses an HTTP response from a PostSearchDatasetsIdAclTeamsApplyWithResponse call
func ParsePostSearchDatasetsIdAclTeamsApplyResponse(rsp *http.Response) (*PostSearchDatasetsIdAclTeamsApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchDatasetsIdAclTeamsApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchEventBreakerPreviewResponse parses an HTTP response from a PostSearchEventBreakerPreviewWithResponse call
func ParsePostSearchEventBreakerPreviewResponse(rsp *http.Response) (*PostSearchEventBreakerPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchEventBreakerPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]PreviewResponseBody `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchHealthcheckResponse parses an HTTP response from a GetSearchHealthcheckWithResponse call
func ParseGetSearchHealthcheckResponse(rsp *http.Response) (*GetSearchHealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchHealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                       `json:"count,omitempty"`
			Items *[]SearchHealthCheckStatus `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobMetricsResponse parses an HTTP response from a GetSearchJobMetricsWithResponse call
func ParseGetSearchJobMetricsResponse(rsp *http.Response) (*GetSearchJobMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsResponse parses an HTTP response from a GetSearchJobsWithResponse call
func ParseGetSearchJobsResponse(rsp *http.Response) (*GetSearchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]SearchJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchJobsResponse parses an HTTP response from a PostSearchJobsWithResponse call
func ParsePostSearchJobsResponse(rsp *http.Response) (*PostSearchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]SearchJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchJobsIdResponse parses an HTTP response from a DeleteSearchJobsIdWithResponse call
func ParseDeleteSearchJobsIdResponse(rsp *http.Response) (*DeleteSearchJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]SearchJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdResponse parses an HTTP response from a GetSearchJobsIdWithResponse call
func ParseGetSearchJobsIdResponse(rsp *http.Response) (*GetSearchJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]SearchJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchJobsIdResponse parses an HTTP response from a PatchSearchJobsIdWithResponse call
func ParsePatchSearchJobsIdResponse(rsp *http.Response) (*PatchSearchJobsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchJobsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]SearchJob `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchJobsIdDispatchExecutorsResponse parses an HTTP response from a PostSearchJobsIdDispatchExecutorsWithResponse call
func ParsePostSearchJobsIdDispatchExecutorsResponse(rsp *http.Response) (*PostSearchJobsIdDispatchExecutorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchJobsIdDispatchExecutorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdLogsResponse parses an HTTP response from a GetSearchJobsIdLogsWithResponse call
func ParseGetSearchJobsIdLogsResponse(rsp *http.Response) (*GetSearchJobsIdLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdMetricsResponse parses an HTTP response from a GetSearchJobsIdMetricsWithResponse call
func ParseGetSearchJobsIdMetricsResponse(rsp *http.Response) (*GetSearchJobsIdMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdResultsResponse parses an HTTP response from a GetSearchJobsIdResultsWithResponse call
func ParseGetSearchJobsIdResultsResponse(rsp *http.Response) (*GetSearchJobsIdResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchJobResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdResultsPollResponse parses an HTTP response from a GetSearchJobsIdResultsPollWithResponse call
func ParseGetSearchJobsIdResultsPollResponse(rsp *http.Response) (*GetSearchJobsIdResultsPollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdResultsPollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchJobResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchJobsIdStagesStageIdResultsResponse parses an HTTP response from a GetSearchJobsIdStagesStageIdResultsWithResponse call
func ParseGetSearchJobsIdStagesStageIdResultsResponse(rsp *http.Response) (*GetSearchJobsIdStagesStageIdResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchJobsIdStagesStageIdResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchMacrosResponse parses an HTTP response from a GetSearchMacrosWithResponse call
func ParseGetSearchMacrosResponse(rsp *http.Response) (*GetSearchMacrosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchMacrosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]SearchMacro `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchMacrosResponse parses an HTTP response from a PostSearchMacrosWithResponse call
func ParsePostSearchMacrosResponse(rsp *http.Response) (*PostSearchMacrosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchMacrosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]SearchMacro `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchMacrosIdResponse parses an HTTP response from a DeleteSearchMacrosIdWithResponse call
func ParseDeleteSearchMacrosIdResponse(rsp *http.Response) (*DeleteSearchMacrosIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchMacrosIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]SearchMacro `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchMacrosIdResponse parses an HTTP response from a GetSearchMacrosIdWithResponse call
func ParseGetSearchMacrosIdResponse(rsp *http.Response) (*GetSearchMacrosIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchMacrosIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]SearchMacro `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchMacrosIdResponse parses an HTTP response from a PatchSearchMacrosIdWithResponse call
func ParsePatchSearchMacrosIdResponse(rsp *http.Response) (*PatchSearchMacrosIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchMacrosIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]SearchMacro `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchPreviewResponse parses an HTTP response from a PostSearchPreviewWithResponse call
func ParsePostSearchPreviewResponse(rsp *http.Response) (*PostSearchPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                   `json:"count,omitempty"`
			Items *[]PreviewResponseBody `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchSavedResponse parses an HTTP response from a GetSearchSavedWithResponse call
func ParseGetSearchSavedResponse(rsp *http.Response) (*GetSearchSavedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchSavedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SavedQuery `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchSavedResponse parses an HTTP response from a PostSearchSavedWithResponse call
func ParsePostSearchSavedResponse(rsp *http.Response) (*PostSearchSavedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchSavedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SavedQuery `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchSavedIdResponse parses an HTTP response from a DeleteSearchSavedIdWithResponse call
func ParseDeleteSearchSavedIdResponse(rsp *http.Response) (*DeleteSearchSavedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchSavedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SavedQuery `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchSavedIdResponse parses an HTTP response from a GetSearchSavedIdWithResponse call
func ParseGetSearchSavedIdResponse(rsp *http.Response) (*GetSearchSavedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchSavedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SavedQuery `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchSavedIdResponse parses an HTTP response from a PatchSearchSavedIdWithResponse call
func ParsePatchSearchSavedIdResponse(rsp *http.Response) (*PatchSearchSavedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchSavedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SavedQuery `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchTrustPoliciesResponse parses an HTTP response from a GetSearchTrustPoliciesWithResponse call
func ParseGetSearchTrustPoliciesResponse(rsp *http.Response) (*GetSearchTrustPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchTrustPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]TrustPolicy `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchUsageGroupsResponse parses an HTTP response from a GetSearchUsageGroupsWithResponse call
func ParseGetSearchUsageGroupsResponse(rsp *http.Response) (*GetSearchUsageGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchUsageGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]UsageGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSearchUsageGroupsResponse parses an HTTP response from a PostSearchUsageGroupsWithResponse call
func ParsePostSearchUsageGroupsResponse(rsp *http.Response) (*PostSearchUsageGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSearchUsageGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]UsageGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSearchUsageGroupsIdResponse parses an HTTP response from a DeleteSearchUsageGroupsIdWithResponse call
func ParseDeleteSearchUsageGroupsIdResponse(rsp *http.Response) (*DeleteSearchUsageGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSearchUsageGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]UsageGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchUsageGroupsIdResponse parses an HTTP response from a GetSearchUsageGroupsIdWithResponse call
func ParseGetSearchUsageGroupsIdResponse(rsp *http.Response) (*GetSearchUsageGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchUsageGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]UsageGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSearchUsageGroupsIdResponse parses an HTTP response from a PatchSearchUsageGroupsIdWithResponse call
func ParsePatchSearchUsageGroupsIdResponse(rsp *http.Response) (*PatchSearchUsageGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSearchUsageGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]UsageGroup `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecurityKmsConfigResponse parses an HTTP response from a GetSecurityKmsConfigWithResponse call
func ParseGetSecurityKmsConfigResponse(rsp *http.Response) (*GetSecurityKmsConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityKmsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KMSProviderConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSecurityKmsConfigResponse parses an HTTP response from a PatchSecurityKmsConfigWithResponse call
func ParsePatchSecurityKmsConfigResponse(rsp *http.Response) (*PatchSecurityKmsConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSecurityKmsConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KMSProviderConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecurityKmsHealthResponse parses an HTTP response from a GetSecurityKmsHealthWithResponse call
func ParseGetSecurityKmsHealthResponse(rsp *http.Response) (*GetSecurityKmsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityKmsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int         `json:"count,omitempty"`
			Items *[]KMSHealth `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSettingsFeaturesResponse parses an HTTP response from a GetSettingsFeaturesWithResponse call
func ParseGetSettingsFeaturesResponse(rsp *http.Response) (*GetSettingsFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]FeaturesEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSettingsFeaturesIdResponse parses an HTTP response from a GetSettingsFeaturesIdWithResponse call
func ParseGetSettingsFeaturesIdResponse(rsp *http.Response) (*GetSettingsFeaturesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsFeaturesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]FeaturesEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemBannersResponse parses an HTTP response from a GetSystemBannersWithResponse call
func ParseGetSystemBannersResponse(rsp *http.Response) (*GetSystemBannersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemBannersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]BannerMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemBannersResponse parses an HTTP response from a PostSystemBannersWithResponse call
func ParsePostSystemBannersResponse(rsp *http.Response) (*PostSystemBannersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemBannersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]BannerMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemBannersIdResponse parses an HTTP response from a DeleteSystemBannersIdWithResponse call
func ParseDeleteSystemBannersIdResponse(rsp *http.Response) (*DeleteSystemBannersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemBannersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]BannerMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemBannersIdResponse parses an HTTP response from a GetSystemBannersIdWithResponse call
func ParseGetSystemBannersIdResponse(rsp *http.Response) (*GetSystemBannersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemBannersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]BannerMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemBannersIdResponse parses an HTTP response from a PatchSystemBannersIdWithResponse call
func ParsePatchSystemBannersIdResponse(rsp *http.Response) (*PatchSystemBannersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemBannersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]BannerMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemCaptureResponse parses an HTTP response from a PostSystemCaptureWithResponse call
func ParsePostSystemCaptureResponse(rsp *http.Response) (*PostSystemCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemCertificatesResponse parses an HTTP response from a GetSystemCertificatesWithResponse call
func ParseGetSystemCertificatesResponse(rsp *http.Response) (*GetSystemCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]Certificate `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemCertificatesResponse parses an HTTP response from a PostSystemCertificatesWithResponse call
func ParsePostSystemCertificatesResponse(rsp *http.Response) (*PostSystemCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]Certificate `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemCertificatesIdResponse parses an HTTP response from a DeleteSystemCertificatesIdWithResponse call
func ParseDeleteSystemCertificatesIdResponse(rsp *http.Response) (*DeleteSystemCertificatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemCertificatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]Certificate `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemCertificatesIdResponse parses an HTTP response from a GetSystemCertificatesIdWithResponse call
func ParseGetSystemCertificatesIdResponse(rsp *http.Response) (*GetSystemCertificatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemCertificatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]Certificate `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemCertificatesIdResponse parses an HTTP response from a PatchSystemCertificatesIdWithResponse call
func ParsePatchSystemCertificatesIdResponse(rsp *http.Response) (*PatchSystemCertificatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemCertificatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]Certificate `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemDiagResponse parses an HTTP response from a DeleteSystemDiagWithResponse call
func ParseDeleteSystemDiagResponse(rsp *http.Response) (*DeleteSystemDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemDiagResponse parses an HTTP response from a GetSystemDiagWithResponse call
func ParseGetSystemDiagResponse(rsp *http.Response) (*GetSystemDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Diag `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemDiagDownloadResponse parses an HTTP response from a GetSystemDiagDownloadWithResponse call
func ParseGetSystemDiagDownloadResponse(rsp *http.Response) (*GetSystemDiagDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemDiagDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostSystemDiagSendResponse parses an HTTP response from a PostSystemDiagSendWithResponse call
func ParsePostSystemDiagSendResponse(rsp *http.Response) (*PostSystemDiagSendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemDiagSendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemDistributedUpgradeCancelGroupResponse parses an HTTP response from a PostSystemDistributedUpgradeCancelGroupWithResponse call
func ParsePostSystemDistributedUpgradeCancelGroupResponse(rsp *http.Response) (*PostSystemDistributedUpgradeCancelGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemDistributedUpgradeCancelGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemDistributedUpgradeDownloadFileResponse parses an HTTP response from a GetSystemDistributedUpgradeDownloadFileWithResponse call
func ParseGetSystemDistributedUpgradeDownloadFileResponse(rsp *http.Response) (*GetSystemDistributedUpgradeDownloadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemDistributedUpgradeDownloadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemDistributedUpgradeStageGroupResponse parses an HTTP response from a PostSystemDistributedUpgradeStageGroupWithResponse call
func ParsePostSystemDistributedUpgradeStageGroupResponse(rsp *http.Response) (*PostSystemDistributedUpgradeStageGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemDistributedUpgradeStageGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemDistributedUpgradeGroupResponse parses an HTTP response from a PostSystemDistributedUpgradeGroupWithResponse call
func ParsePostSystemDistributedUpgradeGroupResponse(rsp *http.Response) (*PostSystemDistributedUpgradeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemDistributedUpgradeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemInfoResponse parses an HTTP response from a GetSystemInfoWithResponse call
func ParseGetSystemInfoResponse(rsp *http.Response) (*GetSystemInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]SystemInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemInputsResponse parses an HTTP response from a GetSystemInputsWithResponse call
func ParseGetSystemInputsResponse(rsp *http.Response) (*GetSystemInputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int     `json:"count,omitempty"`
			Items *[]Input `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemInputsResponse parses an HTTP response from a PostSystemInputsWithResponse call
func ParsePostSystemInputsResponse(rsp *http.Response) (*PostSystemInputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int     `json:"count,omitempty"`
			Items *[]Input `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemInputsIdResponse parses an HTTP response from a DeleteSystemInputsIdWithResponse call
func ParseDeleteSystemInputsIdResponse(rsp *http.Response) (*DeleteSystemInputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemInputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int     `json:"count,omitempty"`
			Items *[]Input `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemInputsIdResponse parses an HTTP response from a GetSystemInputsIdWithResponse call
func ParseGetSystemInputsIdResponse(rsp *http.Response) (*GetSystemInputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int     `json:"count,omitempty"`
			Items *[]Input `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemInputsIdResponse parses an HTTP response from a PatchSystemInputsIdWithResponse call
func ParsePatchSystemInputsIdResponse(rsp *http.Response) (*PatchSystemInputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemInputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int     `json:"count,omitempty"`
			Items *[]Input `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemInputsIdHectokenResponse parses an HTTP response from a PostSystemInputsIdHectokenWithResponse call
func ParsePostSystemInputsIdHectokenResponse(rsp *http.Response) (*PostSystemInputsIdHectokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemInputsIdHectokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemInputsIdHectokenTokenResponse parses an HTTP response from a PatchSystemInputsIdHectokenTokenWithResponse call
func ParsePatchSystemInputsIdHectokenTokenResponse(rsp *http.Response) (*PatchSystemInputsIdHectokenTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemInputsIdHectokenTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemJobsLogsIdGroupIdResponse parses an HTTP response from a GetSystemJobsLogsIdGroupIdWithResponse call
func ParseGetSystemJobsLogsIdGroupIdResponse(rsp *http.Response) (*GetSystemJobsLogsIdGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemJobsLogsIdGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemKeysResponse parses an HTTP response from a GetSystemKeysWithResponse call
func ParseGetSystemKeysResponse(rsp *http.Response) (*GetSystemKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KeyMetadataEntity `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemKeysResponse parses an HTTP response from a PostSystemKeysWithResponse call
func ParsePostSystemKeysResponse(rsp *http.Response) (*PostSystemKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KeyMetadataEntity `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemKeysIdResponse parses an HTTP response from a DeleteSystemKeysIdWithResponse call
func ParseDeleteSystemKeysIdResponse(rsp *http.Response) (*DeleteSystemKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KeyMetadataEntity `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemKeysIdResponse parses an HTTP response from a GetSystemKeysIdWithResponse call
func ParseGetSystemKeysIdResponse(rsp *http.Response) (*GetSystemKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KeyMetadataEntity `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemKeysIdResponse parses an HTTP response from a PatchSystemKeysIdWithResponse call
func ParsePatchSystemKeysIdResponse(rsp *http.Response) (*PatchSystemKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]KeyMetadataEntity `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLicensesResponse parses an HTTP response from a GetSystemLicensesWithResponse call
func ParseGetSystemLicensesResponse(rsp *http.Response) (*GetSystemLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]License `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemLicensesResponse parses an HTTP response from a PostSystemLicensesWithResponse call
func ParsePostSystemLicensesResponse(rsp *http.Response) (*PostSystemLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]License `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLicensesUsageResponse parses an HTTP response from a GetSystemLicensesUsageWithResponse call
func ParseGetSystemLicensesUsageResponse(rsp *http.Response) (*GetSystemLicensesUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLicensesUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                 `json:"count,omitempty"`
			Items *[]DailyUsageMetrics `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemLicensesIdResponse parses an HTTP response from a DeleteSystemLicensesIdWithResponse call
func ParseDeleteSystemLicensesIdResponse(rsp *http.Response) (*DeleteSystemLicensesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemLicensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]License `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLicensesIdResponse parses an HTTP response from a GetSystemLicensesIdWithResponse call
func ParseGetSystemLicensesIdResponse(rsp *http.Response) (*GetSystemLicensesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLicensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]License `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLoggerResponse parses an HTTP response from a GetSystemLoggerWithResponse call
func ParseGetSystemLoggerResponse(rsp *http.Response) (*GetSystemLoggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLoggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]LoggerConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemLoggerIdResponse parses an HTTP response from a DeleteSystemLoggerIdWithResponse call
func ParseDeleteSystemLoggerIdResponse(rsp *http.Response) (*DeleteSystemLoggerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemLoggerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]LoggerConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLoggerIdResponse parses an HTTP response from a GetSystemLoggerIdWithResponse call
func ParseGetSystemLoggerIdResponse(rsp *http.Response) (*GetSystemLoggerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLoggerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]LoggerConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemLoggerIdResponse parses an HTTP response from a PatchSystemLoggerIdWithResponse call
func ParsePatchSystemLoggerIdResponse(rsp *http.Response) (*PatchSystemLoggerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemLoggerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]LoggerConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLogsResponse parses an HTTP response from a GetSystemLogsWithResponse call
func ParseGetSystemLogsResponse(rsp *http.Response) (*GetSystemLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]LogFileInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLogsSearchResponse parses an HTTP response from a GetSystemLogsSearchWithResponse call
func ParseGetSystemLogsSearchResponse(rsp *http.Response) (*GetSystemLogsSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLogsSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLogsIdResponse parses an HTTP response from a GetSystemLogsIdWithResponse call
func ParseGetSystemLogsIdResponse(rsp *http.Response) (*GetSystemLogsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLogsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLookupsResponse parses an HTTP response from a GetSystemLookupsWithResponse call
func ParseGetSystemLookupsResponse(rsp *http.Response) (*GetSystemLookupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLookupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]LookupFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemLookupsResponse parses an HTTP response from a PostSystemLookupsWithResponse call
func ParsePostSystemLookupsResponse(rsp *http.Response) (*PostSystemLookupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemLookupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]LookupFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutSystemLookupsResponse parses an HTTP response from a PutSystemLookupsWithResponse call
func ParsePutSystemLookupsResponse(rsp *http.Response) (*PutSystemLookupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutSystemLookupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LookupFileInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemLookupsIdResponse parses an HTTP response from a DeleteSystemLookupsIdWithResponse call
func ParseDeleteSystemLookupsIdResponse(rsp *http.Response) (*DeleteSystemLookupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemLookupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]LookupFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemLookupsIdResponse parses an HTTP response from a GetSystemLookupsIdWithResponse call
func ParseGetSystemLookupsIdResponse(rsp *http.Response) (*GetSystemLookupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemLookupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]LookupFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemLookupsIdResponse parses an HTTP response from a PatchSystemLookupsIdWithResponse call
func ParsePatchSystemLookupsIdResponse(rsp *http.Response) (*PatchSystemLookupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemLookupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]LookupFile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemMessagesResponse parses an HTTP response from a GetSystemMessagesWithResponse call
func ParseGetSystemMessagesResponse(rsp *http.Response) (*GetSystemMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]BulletinMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemMessagesResponse parses an HTTP response from a PostSystemMessagesWithResponse call
func ParsePostSystemMessagesResponse(rsp *http.Response) (*PostSystemMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]BulletinMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemMessagesIdResponse parses an HTTP response from a DeleteSystemMessagesIdWithResponse call
func ParseDeleteSystemMessagesIdResponse(rsp *http.Response) (*DeleteSystemMessagesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemMessagesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]BulletinMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemMessagesIdResponse parses an HTTP response from a GetSystemMessagesIdWithResponse call
func ParseGetSystemMessagesIdResponse(rsp *http.Response) (*GetSystemMessagesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemMessagesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]BulletinMessage `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemMetricsResponse parses an HTTP response from a GetSystemMetricsWithResponse call
func ParseGetSystemMetricsResponse(rsp *http.Response) (*GetSystemMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemMetricsEnumResponse parses an HTTP response from a PostSystemMetricsEnumWithResponse call
func ParsePostSystemMetricsEnumResponse(rsp *http.Response) (*PostSystemMetricsEnumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemMetricsEnumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]MetricNameInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemMetricsQueryResponse parses an HTTP response from a PostSystemMetricsQueryWithResponse call
func ParsePostSystemMetricsQueryResponse(rsp *http.Response) (*PostSystemMetricsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemMetricsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemOutputsResponse parses an HTTP response from a GetSystemOutputsWithResponse call
func ParseGetSystemOutputsResponse(rsp *http.Response) (*GetSystemOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Output `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemOutputsResponse parses an HTTP response from a PostSystemOutputsWithResponse call
func ParsePostSystemOutputsResponse(rsp *http.Response) (*PostSystemOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Output `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemOutputsIdResponse parses an HTTP response from a DeleteSystemOutputsIdWithResponse call
func ParseDeleteSystemOutputsIdResponse(rsp *http.Response) (*DeleteSystemOutputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemOutputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Output `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemOutputsIdResponse parses an HTTP response from a GetSystemOutputsIdWithResponse call
func ParseGetSystemOutputsIdResponse(rsp *http.Response) (*GetSystemOutputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemOutputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Output `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemOutputsIdResponse parses an HTTP response from a PatchSystemOutputsIdWithResponse call
func ParsePatchSystemOutputsIdResponse(rsp *http.Response) (*PatchSystemOutputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemOutputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]Output `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemOutputsIdPqResponse parses an HTTP response from a DeleteSystemOutputsIdPqWithResponse call
func ParseDeleteSystemOutputsIdPqResponse(rsp *http.Response) (*DeleteSystemOutputsIdPqResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemOutputsIdPqResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemOutputsIdPqResponse parses an HTTP response from a GetSystemOutputsIdPqWithResponse call
func ParseGetSystemOutputsIdPqResponse(rsp *http.Response) (*GetSystemOutputsIdPqResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemOutputsIdPqResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemOutputsIdSamplesResponse parses an HTTP response from a GetSystemOutputsIdSamplesWithResponse call
func ParseGetSystemOutputsIdSamplesResponse(rsp *http.Response) (*GetSystemOutputsIdSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemOutputsIdSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]OutputSamplesResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemOutputsIdTestResponse parses an HTTP response from a PostSystemOutputsIdTestWithResponse call
func ParsePostSystemOutputsIdTestResponse(rsp *http.Response) (*PostSystemOutputsIdTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemOutputsIdTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]OutputTestResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemPoliciesResponse parses an HTTP response from a GetSystemPoliciesWithResponse call
func ParseGetSystemPoliciesResponse(rsp *http.Response) (*GetSystemPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]PolicyRule `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemPoliciesResponse parses an HTTP response from a PostSystemPoliciesWithResponse call
func ParsePostSystemPoliciesResponse(rsp *http.Response) (*PostSystemPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]PolicyRule `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemPoliciesIdResponse parses an HTTP response from a DeleteSystemPoliciesIdWithResponse call
func ParseDeleteSystemPoliciesIdResponse(rsp *http.Response) (*DeleteSystemPoliciesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemPoliciesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]PolicyRule `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemPoliciesIdResponse parses an HTTP response from a GetSystemPoliciesIdWithResponse call
func ParseGetSystemPoliciesIdResponse(rsp *http.Response) (*GetSystemPoliciesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemPoliciesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]PolicyRule `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemPoliciesIdResponse parses an HTTP response from a PatchSystemPoliciesIdWithResponse call
func ParsePatchSystemPoliciesIdResponse(rsp *http.Response) (*PatchSystemPoliciesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemPoliciesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]PolicyRule `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProcessesResponse parses an HTTP response from a GetSystemProcessesWithResponse call
func ParseGetSystemProcessesResponse(rsp *http.Response) (*GetSystemProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProcessEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProfilerResponse parses an HTTP response from a GetSystemProfilerWithResponse call
func ParseGetSystemProfilerResponse(rsp *http.Response) (*GetSystemProfilerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProfilerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProfilerItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProfilerResponse parses an HTTP response from a PostSystemProfilerWithResponse call
func ParsePostSystemProfilerResponse(rsp *http.Response) (*PostSystemProfilerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProfilerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProfilerItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemProfilerIdResponse parses an HTTP response from a DeleteSystemProfilerIdWithResponse call
func ParseDeleteSystemProfilerIdResponse(rsp *http.Response) (*DeleteSystemProfilerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemProfilerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProfilerItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProfilerIdResponse parses an HTTP response from a GetSystemProfilerIdWithResponse call
func ParseGetSystemProfilerIdResponse(rsp *http.Response) (*GetSystemProfilerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProfilerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProfilerItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemProfilerIdResponse parses an HTTP response from a PatchSystemProfilerIdWithResponse call
func ParsePatchSystemProfilerIdResponse(rsp *http.Response) (*PatchSystemProfilerIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemProfilerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]ProfilerItem `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsResponse parses an HTTP response from a GetSystemProjectsWithResponse call
func ParseGetSystemProjectsResponse(rsp *http.Response) (*GetSystemProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]ProjectConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsResponse parses an HTTP response from a PostSystemProjectsWithResponse call
func ParsePostSystemProjectsResponse(rsp *http.Response) (*PostSystemProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]ProjectConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemProjectsIdResponse parses an HTTP response from a DeleteSystemProjectsIdWithResponse call
func ParseDeleteSystemProjectsIdResponse(rsp *http.Response) (*DeleteSystemProjectsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]ProjectConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsIdResponse parses an HTTP response from a GetSystemProjectsIdWithResponse call
func ParseGetSystemProjectsIdResponse(rsp *http.Response) (*GetSystemProjectsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]ProjectConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemProjectsIdResponse parses an HTTP response from a PatchSystemProjectsIdWithResponse call
func ParsePatchSystemProjectsIdResponse(rsp *http.Response) (*PatchSystemProjectsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]ProjectConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsIdAclResponse parses an HTTP response from a GetSystemProjectsIdAclWithResponse call
func ParseGetSystemProjectsIdAclResponse(rsp *http.Response) (*GetSystemProjectsIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsIdAclApplyResponse parses an HTTP response from a PostSystemProjectsIdAclApplyWithResponse call
func ParsePostSystemProjectsIdAclApplyResponse(rsp *http.Response) (*PostSystemProjectsIdAclApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsIdAclApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsIdAclTeamsResponse parses an HTTP response from a GetSystemProjectsIdAclTeamsWithResponse call
func ParseGetSystemProjectsIdAclTeamsResponse(rsp *http.Response) (*GetSystemProjectsIdAclTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsIdAclTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                     `json:"count,omitempty"`
			Items *[]UserAccessControlList `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsIdAclTeamsApplyResponse parses an HTTP response from a PostSystemProjectsIdAclTeamsApplyWithResponse call
func ParsePostSystemProjectsIdAclTeamsApplyResponse(rsp *http.Response) (*PostSystemProjectsIdAclTeamsApplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsIdAclTeamsApplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsProjectIdCaptureResponse parses an HTTP response from a PostSystemProjectsProjectIdCaptureWithResponse call
func ParsePostSystemProjectsProjectIdCaptureResponse(rsp *http.Response) (*PostSystemProjectsProjectIdCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsProjectIdCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdDestinationsResponse parses an HTTP response from a GetSystemProjectsProjectIdDestinationsWithResponse call
func ParseGetSystemProjectsProjectIdDestinationsResponse(rsp *http.Response) (*GetSystemProjectsProjectIdDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]ProjectDestination `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdSubscriptionsResponse parses an HTTP response from a GetSystemProjectsProjectIdSubscriptionsWithResponse call
func ParseGetSystemProjectsProjectIdSubscriptionsResponse(rsp *http.Response) (*GetSystemProjectsProjectIdSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse parses an HTTP response from a PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureWithResponse call
func ParsePostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse(rsp *http.Response) (*PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsProjectIdVersionCommitResponse parses an HTTP response from a PostSystemProjectsProjectIdVersionCommitWithResponse call
func ParsePostSystemProjectsProjectIdVersionCommitResponse(rsp *http.Response) (*PostSystemProjectsProjectIdVersionCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsProjectIdVersionCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitCommitSummary `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdVersionCountResponse parses an HTTP response from a GetSystemProjectsProjectIdVersionCountWithResponse call
func ParseGetSystemProjectsProjectIdVersionCountResponse(rsp *http.Response) (*GetSystemProjectsProjectIdVersionCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdVersionCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdVersionDiffResponse parses an HTTP response from a GetSystemProjectsProjectIdVersionDiffWithResponse call
func ParseGetSystemProjectsProjectIdVersionDiffResponse(rsp *http.Response) (*GetSystemProjectsProjectIdVersionDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdVersionDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdVersionFilesResponse parses an HTTP response from a GetSystemProjectsProjectIdVersionFilesWithResponse call
func ParseGetSystemProjectsProjectIdVersionFilesResponse(rsp *http.Response) (*GetSystemProjectsProjectIdVersionFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdVersionFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitFilesResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemProjectsProjectIdVersionRevertResponse parses an HTTP response from a PostSystemProjectsProjectIdVersionRevertWithResponse call
func ParsePostSystemProjectsProjectIdVersionRevertResponse(rsp *http.Response) (*PostSystemProjectsProjectIdVersionRevertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemProjectsProjectIdVersionRevertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]GitRevertResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemProjectsProjectIdVersionShowResponse parses an HTTP response from a GetSystemProjectsProjectIdVersionShowWithResponse call
func ParseGetSystemProjectsProjectIdVersionShowResponse(rsp *http.Response) (*GetSystemProjectsProjectIdVersionShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemProjectsProjectIdVersionShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemRolesResponse parses an HTTP response from a GetSystemRolesWithResponse call
func ParseGetSystemRolesResponse(rsp *http.Response) (*GetSystemRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Role `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemRolesResponse parses an HTTP response from a PostSystemRolesWithResponse call
func ParsePostSystemRolesResponse(rsp *http.Response) (*PostSystemRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Role `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemRolesIdResponse parses an HTTP response from a DeleteSystemRolesIdWithResponse call
func ParseDeleteSystemRolesIdResponse(rsp *http.Response) (*DeleteSystemRolesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemRolesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Role `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemRolesIdResponse parses an HTTP response from a GetSystemRolesIdWithResponse call
func ParseGetSystemRolesIdResponse(rsp *http.Response) (*GetSystemRolesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemRolesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Role `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemRolesIdResponse parses an HTTP response from a PatchSystemRolesIdWithResponse call
func ParsePatchSystemRolesIdResponse(rsp *http.Response) (*PatchSystemRolesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemRolesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Role `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSamplesResponse parses an HTTP response from a GetSystemSamplesWithResponse call
func ParseGetSystemSamplesResponse(rsp *http.Response) (*GetSystemSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]DataSample `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSamplesResponse parses an HTTP response from a PostSystemSamplesWithResponse call
func ParsePostSystemSamplesResponse(rsp *http.Response) (*PostSystemSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]DataSample `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemSamplesIdResponse parses an HTTP response from a DeleteSystemSamplesIdWithResponse call
func ParseDeleteSystemSamplesIdResponse(rsp *http.Response) (*DeleteSystemSamplesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemSamplesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]DataSample `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSamplesIdResponse parses an HTTP response from a GetSystemSamplesIdWithResponse call
func ParseGetSystemSamplesIdResponse(rsp *http.Response) (*GetSystemSamplesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSamplesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]DataSample `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSamplesIdResponse parses an HTTP response from a PatchSystemSamplesIdWithResponse call
func ParsePatchSystemSamplesIdResponse(rsp *http.Response) (*PatchSystemSamplesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSamplesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]DataSample `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSamplesIdContentResponse parses an HTTP response from a GetSystemSamplesIdContentWithResponse call
func ParseGetSystemSamplesIdContentResponse(rsp *http.Response) (*GetSystemSamplesIdContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSamplesIdContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]SampleContent `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemScriptsResponse parses an HTTP response from a GetSystemScriptsWithResponse call
func ParseGetSystemScriptsResponse(rsp *http.Response) (*GetSystemScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ScriptLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemScriptsResponse parses an HTTP response from a PostSystemScriptsWithResponse call
func ParsePostSystemScriptsResponse(rsp *http.Response) (*PostSystemScriptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ScriptLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemScriptsIdResponse parses an HTTP response from a DeleteSystemScriptsIdWithResponse call
func ParseDeleteSystemScriptsIdResponse(rsp *http.Response) (*DeleteSystemScriptsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemScriptsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ScriptLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemScriptsIdResponse parses an HTTP response from a GetSystemScriptsIdWithResponse call
func ParseGetSystemScriptsIdResponse(rsp *http.Response) (*GetSystemScriptsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemScriptsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ScriptLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemScriptsIdResponse parses an HTTP response from a PatchSystemScriptsIdWithResponse call
func ParsePatchSystemScriptsIdResponse(rsp *http.Response) (*PatchSystemScriptsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemScriptsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ScriptLibEntry `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSecretsResponse parses an HTTP response from a GetSystemSecretsWithResponse call
func ParseGetSystemSecretsResponse(rsp *http.Response) (*GetSystemSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]RestSecret `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSecretsResponse parses an HTTP response from a PostSystemSecretsWithResponse call
func ParsePostSystemSecretsResponse(rsp *http.Response) (*PostSystemSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]RestSecret `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemSecretsIdResponse parses an HTTP response from a DeleteSystemSecretsIdWithResponse call
func ParseDeleteSystemSecretsIdResponse(rsp *http.Response) (*DeleteSystemSecretsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemSecretsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]RestSecret `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSecretsIdResponse parses an HTTP response from a GetSystemSecretsIdWithResponse call
func ParseGetSystemSecretsIdResponse(rsp *http.Response) (*GetSystemSecretsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSecretsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]RestSecret `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSecretsIdResponse parses an HTTP response from a PatchSystemSecretsIdWithResponse call
func ParsePatchSystemSecretsIdResponse(rsp *http.Response) (*PatchSystemSecretsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSecretsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]RestSecret `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsResponse parses an HTTP response from a GetSystemSettingsWithResponse call
func ParseGetSystemSettingsResponse(rsp *http.Response) (*GetSystemSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SystemSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSettingsResponse parses an HTTP response from a PatchSystemSettingsWithResponse call
func ParsePatchSystemSettingsResponse(rsp *http.Response) (*PatchSystemSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SystemSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsAuthResponse parses an HTTP response from a GetSystemSettingsAuthWithResponse call
func ParseGetSystemSettingsAuthResponse(rsp *http.Response) (*GetSystemSettingsAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]AuthConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSettingsAuthResponse parses an HTTP response from a PatchSystemSettingsAuthWithResponse call
func ParsePatchSystemSettingsAuthResponse(rsp *http.Response) (*PatchSystemSettingsAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSettingsAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int          `json:"count,omitempty"`
			Items *[]AuthConfig `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsConfResponse parses an HTTP response from a GetSystemSettingsConfWithResponse call
func ParseGetSystemSettingsConfResponse(rsp *http.Response) (*GetSystemSettingsConfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsConfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                  `json:"count,omitempty"`
			Items *[]SystemSettingsConf `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSettingsConfResponse parses an HTTP response from a PatchSystemSettingsConfWithResponse call
func ParsePatchSystemSettingsConfResponse(rsp *http.Response) (*PatchSystemSettingsConfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSettingsConfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SystemSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsCriblResponse parses an HTTP response from a GetSystemSettingsCriblWithResponse call
func ParseGetSystemSettingsCriblResponse(rsp *http.Response) (*GetSystemSettingsCriblResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsCriblResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]PublicSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsGitSettingsResponse parses an HTTP response from a GetSystemSettingsGitSettingsWithResponse call
func ParseGetSystemSettingsGitSettingsResponse(rsp *http.Response) (*GetSystemSettingsGitSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsGitSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]GitSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSettingsGitSettingsResponse parses an HTTP response from a PatchSystemSettingsGitSettingsWithResponse call
func ParsePatchSystemSettingsGitSettingsResponse(rsp *http.Response) (*PatchSystemSettingsGitSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSettingsGitSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]GitSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSettingsReloadResponse parses an HTTP response from a PostSystemSettingsReloadWithResponse call
func ParsePostSystemSettingsReloadResponse(rsp *http.Response) (*PostSystemSettingsReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSettingsReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostSystemSettingsRestartResponse parses an HTTP response from a PostSystemSettingsRestartWithResponse call
func ParsePostSystemSettingsRestartResponse(rsp *http.Response) (*PostSystemSettingsRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSettingsRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemSettingsSearchLimitsResponse parses an HTTP response from a GetSystemSettingsSearchLimitsWithResponse call
func ParseGetSystemSettingsSearchLimitsResponse(rsp *http.Response) (*GetSystemSettingsSearchLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsSearchLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]SearchSettings `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSettingsUpgradeResponse parses an HTTP response from a GetSystemSettingsUpgradeWithResponse call
func ParseGetSystemSettingsUpgradeResponse(rsp *http.Response) (*GetSystemSettingsUpgradeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSettingsUpgradeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int             `json:"count,omitempty"`
			Items *[]UpgradeResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSettingsUpgradeFromPackageResponse parses an HTTP response from a PostSystemSettingsUpgradeFromPackageWithResponse call
func ParsePostSystemSettingsUpgradeFromPackageResponse(rsp *http.Response) (*PostSystemSettingsUpgradeFromPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSettingsUpgradeFromPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSettingsUpgradeVersionResponse parses an HTTP response from a PostSystemSettingsUpgradeVersionWithResponse call
func ParsePostSystemSettingsUpgradeVersionResponse(rsp *http.Response) (*PostSystemSettingsUpgradeVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSettingsUpgradeVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemStatusInputsResponse parses an HTTP response from a GetSystemStatusInputsWithResponse call
func ParseGetSystemStatusInputsResponse(rsp *http.Response) (*GetSystemStatusInputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]InputStatus `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemStatusInputsIdResponse parses an HTTP response from a GetSystemStatusInputsIdWithResponse call
func ParseGetSystemStatusInputsIdResponse(rsp *http.Response) (*GetSystemStatusInputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusInputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]InputStatus `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemStatusOutputsResponse parses an HTTP response from a GetSystemStatusOutputsWithResponse call
func ParseGetSystemStatusOutputsResponse(rsp *http.Response) (*GetSystemStatusOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]OutputStatus `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemStatusOutputsIdResponse parses an HTTP response from a GetSystemStatusOutputsIdWithResponse call
func ParseGetSystemStatusOutputsIdResponse(rsp *http.Response) (*GetSystemStatusOutputsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusOutputsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]OutputStatus `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSubscriptionsResponse parses an HTTP response from a GetSystemSubscriptionsWithResponse call
func ParseGetSystemSubscriptionsResponse(rsp *http.Response) (*GetSystemSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemSubscriptionsResponse parses an HTTP response from a PostSystemSubscriptionsWithResponse call
func ParsePostSystemSubscriptionsResponse(rsp *http.Response) (*PostSystemSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemSubscriptionsIdResponse parses an HTTP response from a DeleteSystemSubscriptionsIdWithResponse call
func ParseDeleteSystemSubscriptionsIdResponse(rsp *http.Response) (*DeleteSystemSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemSubscriptionsIdResponse parses an HTTP response from a GetSystemSubscriptionsIdWithResponse call
func ParseGetSystemSubscriptionsIdResponse(rsp *http.Response) (*GetSystemSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemSubscriptionsIdResponse parses an HTTP response from a PatchSystemSubscriptionsIdWithResponse call
func ParsePatchSystemSubscriptionsIdResponse(rsp *http.Response) (*PatchSystemSubscriptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemSubscriptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int            `json:"count,omitempty"`
			Items *[]Subscription `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemTeamsResponse parses an HTTP response from a GetSystemTeamsWithResponse call
func ParseGetSystemTeamsResponse(rsp *http.Response) (*GetSystemTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Team `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemTeamsResponse parses an HTTP response from a PostSystemTeamsWithResponse call
func ParsePostSystemTeamsResponse(rsp *http.Response) (*PostSystemTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Team `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemTeamsUsersIdRolesResponse parses an HTTP response from a GetSystemTeamsUsersIdRolesWithResponse call
func ParseGetSystemTeamsUsersIdRolesResponse(rsp *http.Response) (*GetSystemTeamsUsersIdRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemTeamsUsersIdRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemTeamsIdResponse parses an HTTP response from a DeleteSystemTeamsIdWithResponse call
func ParseDeleteSystemTeamsIdResponse(rsp *http.Response) (*DeleteSystemTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Team `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemTeamsIdResponse parses an HTTP response from a GetSystemTeamsIdWithResponse call
func ParseGetSystemTeamsIdResponse(rsp *http.Response) (*GetSystemTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Team `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemTeamsIdResponse parses an HTTP response from a PatchSystemTeamsIdWithResponse call
func ParsePatchSystemTeamsIdResponse(rsp *http.Response) (*PatchSystemTeamsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]Team `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemTeamsIdAclResponse parses an HTTP response from a GetSystemTeamsIdAclWithResponse call
func ParseGetSystemTeamsIdAclResponse(rsp *http.Response) (*GetSystemTeamsIdAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemTeamsIdAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int              `json:"count,omitempty"`
			Items *[]ResourcePolicy `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemTeamsIdUsersResponse parses an HTTP response from a GetSystemTeamsIdUsersWithResponse call
func ParseGetSystemTeamsIdUsersResponse(rsp *http.Response) (*GetSystemTeamsIdUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemTeamsIdUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemTeamsIdUsersResponse parses an HTTP response from a PostSystemTeamsIdUsersWithResponse call
func ParsePostSystemTeamsIdUsersResponse(rsp *http.Response) (*PostSystemTeamsIdUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemTeamsIdUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int      `json:"count,omitempty"`
			Items *[]string `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemUsersResponse parses an HTTP response from a GetSystemUsersWithResponse call
func ParseGetSystemUsersResponse(rsp *http.Response) (*GetSystemUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]User `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSystemUsersResponse parses an HTTP response from a PostSystemUsersWithResponse call
func ParsePostSystemUsersResponse(rsp *http.Response) (*PostSystemUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSystemUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]UserProfile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSystemUsersIdResponse parses an HTTP response from a DeleteSystemUsersIdWithResponse call
func ParseDeleteSystemUsersIdResponse(rsp *http.Response) (*DeleteSystemUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSystemUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]User `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSystemUsersIdResponse parses an HTTP response from a GetSystemUsersIdWithResponse call
func ParseGetSystemUsersIdResponse(rsp *http.Response) (*GetSystemUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]User `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemUsersIdResponse parses an HTTP response from a PatchSystemUsersIdWithResponse call
func ParsePatchSystemUsersIdResponse(rsp *http.Response) (*PatchSystemUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int           `json:"count,omitempty"`
			Items *[]UserProfile `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchSystemUsersIdInfoResponse parses an HTTP response from a PatchSystemUsersIdInfoWithResponse call
func ParsePatchSystemUsersIdInfoResponse(rsp *http.Response) (*PatchSystemUsersIdInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSystemUsersIdInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int    `json:"count,omitempty"`
			Items *[]User `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUiKeyResponse parses an HTTP response from a GetUiKeyWithResponse call
func ParseGetUiKeyResponse(rsp *http.Response) (*GetUiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchUiKeyResponse parses an HTTP response from a PatchUiKeyWithResponse call
func ParsePatchUiKeyResponse(rsp *http.Response) (*PatchUiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionBranchResponse parses an HTTP response from a GetVersionBranchWithResponse call
func ParseGetVersionBranchResponse(rsp *http.Response) (*GetVersionBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVersionCommitResponse parses an HTTP response from a PostVersionCommitWithResponse call
func ParsePostVersionCommitResponse(rsp *http.Response) (*PostVersionCommitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVersionCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitCommitSummary `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionCountResponse parses an HTTP response from a GetVersionCountWithResponse call
func ParseGetVersionCountResponse(rsp *http.Response) (*GetVersionCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionCurrentBranchResponse parses an HTTP response from a GetVersionCurrentBranchWithResponse call
func ParseGetVersionCurrentBranchResponse(rsp *http.Response) (*GetVersionCurrentBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionCurrentBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionDiffResponse parses an HTTP response from a GetVersionDiffWithResponse call
func ParseGetVersionDiffResponse(rsp *http.Response) (*GetVersionDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionFilesResponse parses an HTTP response from a GetVersionFilesWithResponse call
func ParseGetVersionFilesResponse(rsp *http.Response) (*GetVersionFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                `json:"count,omitempty"`
			Items *[]GitFilesResponse `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionInfoResponse parses an HTTP response from a GetVersionInfoWithResponse call
func ParseGetVersionInfoResponse(rsp *http.Response) (*GetVersionInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int       `json:"count,omitempty"`
			Items *[]GitInfo `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVersionPushResponse parses an HTTP response from a PostVersionPushWithResponse call
func ParsePostVersionPushResponse(rsp *http.Response) (*PostVersionPushResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVersionPushResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVersionRevertResponse parses an HTTP response from a PostVersionRevertWithResponse call
func ParsePostVersionRevertResponse(rsp *http.Response) (*PostVersionRevertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVersionRevertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]GitRevertResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionShowResponse parses an HTTP response from a GetVersionShowWithResponse call
func ParseGetVersionShowResponse(rsp *http.Response) (*GetVersionShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVersionStatusResponse parses an HTTP response from a GetVersionStatusWithResponse call
func ParseGetVersionStatusResponse(rsp *http.Response) (*GetVersionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int               `json:"count,omitempty"`
			Items *[]GitStatusResult `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVersionSyncResponse parses an HTTP response from a PostVersionSyncWithResponse call
func ParsePostVersionSyncResponse(rsp *http.Response) (*PostVersionSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVersionSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count number of items present in the items array
			Count *int                      `json:"count,omitempty"`
			Items *[]map[string]interface{} `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostVersionUndoResponse parses an HTTP response from a PostVersionUndoWithResponse call
func ParsePostVersionUndoResponse(rsp *http.Response) (*PostVersionUndoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVersionUndoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Fetches the AI consent information, specifically the org GUID and accepted boolean.
	// (GET /ai/consent)
	GetAiConsent(ctx echo.Context) error
	// Stores the AI consent information, specifically the org GUID and accepted boolean.
	// (POST /ai/consent)
	PostAiConsent(ctx echo.Context) error
	// API call that the IDP should use for an authorization code callback
	// (GET /auth/authorization-code/callback)
	GetAuthAuthorizationCodeCallback(ctx echo.Context, params GetAuthAuthorizationCodeCallbackParams) error
	// List the external authentication system's groups
	// (GET /auth/groups)
	GetAuthGroups(ctx echo.Context) error
	// Log in and obtain Auth token
	// (POST /auth/login)
	PostAuthLogin(ctx echo.Context) error
	// Log current user out
	// (POST /auth/logout)
	PostAuthLogout(ctx echo.Context) error
	// Obtain metadata which Cribl Stream/Edge uses when acting as a Service Provider
	// (GET /auth/metadata)
	GetAuthMetadata(ctx echo.Context) error
	// Get PIV configuration
	// (GET /auth/multi-factor)
	GetAuthMultiFactor(ctx echo.Context) error
	// Redirect user to IDP with logout request
	// (GET /auth/slo)
	GetAuthSlo(ctx echo.Context) error
	// Accepts a logout request from an IDP and logs out the user
	// (GET /auth/slo/callback)
	GetAuthSloCallback(ctx echo.Context, params GetAuthSloCallbackParams) error
	// API call that the IDP should use for a logout request
	// (POST /auth/slo/callback)
	PostAuthSloCallback(ctx echo.Context) error
	// Obtain redirect information
	// (GET /auth/sso)
	GetAuthSso(ctx echo.Context) error
	// Accepts an authentication request from an IDP and authenticates the user
	// (GET /auth/sso/callback)
	GetAuthSsoCallback(ctx echo.Context, params GetAuthSsoCallbackParams) error
	// API call that the IDP should use for an authentication request
	// (POST /auth/sso/callback)
	PostAuthSsoCallback(ctx echo.Context) error
	// Invalidate token(s) for user *id*
	// (DELETE /auth/users/{id}/token)
	DeleteAuthUsersIdToken(ctx echo.Context, id string) error
	// get the client's authorization policy
	// (GET /authorize/policy)
	GetAuthorizePolicy(ctx echo.Context) error
	// get the client's roles
	// (GET /authorize/roles)
	GetAuthorizeRoles(ctx echo.Context) error
	// Get changelog viewed state
	// (GET /changelog/viewed)
	GetChangelogViewed(ctx echo.Context) error
	// Update changelog viewed state
	// (PATCH /changelog/viewed)
	PatchChangelogViewed(ctx echo.Context) error
	// Get CLUI search results
	// (GET /clui)
	GetClui(ctx echo.Context, params GetCluiParams) error
	// Get a list of Collector objects
	// (GET /collectors)
	GetCollectors(ctx echo.Context) error
	// Get Collector by ID
	// (GET /collectors/{id})
	GetCollectorsId(ctx echo.Context, id string) error
	// Get a list of Condition objects
	// (GET /conditions)
	GetConditions(ctx echo.Context) error
	// Get Condition by ID
	// (GET /conditions/{id})
	GetConditionsId(ctx echo.Context, id string) error
	// Get a detailed list of scoped processes running on the edge host
	// (GET /edge/appscope/processes)
	GetEdgeAppscopeProcesses(ctx echo.Context) error
	// Attach AppScope to a process running on the edge host
	// (POST /edge/appscope/processes/)
	PostEdgeAppscopeProcesses(ctx echo.Context, params PostEdgeAppscopeProcessesParams) error
	// Detach AppScope from a process running on the edge host
	// (DELETE /edge/appscope/processes/{pid})
	DeleteEdgeAppscopeProcessesPid(ctx echo.Context, pid string) error
	// Get details of a scoped process running on the edge host
	// (GET /edge/appscope/processes/{pid})
	GetEdgeAppscopeProcessesPid(ctx echo.Context, pid string) error
	// Update AppScope configuration for a process running on the edge host
	// (PUT /edge/appscope/processes/{pid})
	PutEdgeAppscopeProcessesPid(ctx echo.Context, pid string) error
	// Get a detailed list of containers running on the edge host.
	// (GET /edge/containers)
	GetEdgeContainers(ctx echo.Context) error
	// Get details for a single container on the edge host. Add stream=true to get a stream instead.
	// (GET /edge/containers/{id})
	GetEdgeContainersId(ctx echo.Context, id string) error
	// Get list of configured collectors
	// (GET /edge/events/collectors)
	GetEdgeEventsCollectors(ctx echo.Context) error
	// Get events generated by a specified source
	// (GET /edge/events/query)
	GetEdgeEventsQuery(ctx echo.Context, params GetEdgeEventsQueryParams) error
	// Ingest a specified file through a specified pipeline to a specified destination or send to routes.
	// (POST /edge/file/ingest)
	PostEdgeFileIngest(ctx echo.Context, params PostEdgeFileIngestParams) error
	// Get some number of bytes from the file at the given path
	// (GET /edge/file/sample)
	GetEdgeFileSample(ctx echo.Context, params GetEdgeFileSampleParams) error
	// Get details about a file on the edge host.
	// (GET /edge/fileinspect)
	GetEdgeFileinspect(ctx echo.Context) error
	// Make a request to the K8s API logs endpoint
	// (POST /edge/kube-logs)
	PostEdgeKubeLogs(ctx echo.Context) error
	// Make a GET request to the K8s API
	// (GET /edge/kube_proxy)
	GetEdgeKubeProxy(ctx echo.Context, params GetEdgeKubeProxyParams) error
	// list log files
	// (GET /edge/logs)
	GetEdgeLogs(ctx echo.Context, params GetEdgeLogsParams) error
	// Get a directory listing of the given path
	// (GET /edge/ls{path})
	GetEdgeLsPath(ctx echo.Context, path string) error
	// Get the host's metadata structure
	// (GET /edge/metadata)
	GetEdgeMetadata(ctx echo.Context) error
	// Get a detailed list of processes running on the edge host
	// (GET /edge/processes)
	GetEdgeProcesses(ctx echo.Context) error
	// Get details of a process running on the edge host
	// (GET /edge/processes/{pid})
	GetEdgeProcessesPid(ctx echo.Context, pid string) error
	// Get a list of Executor objects
	// (GET /executors)
	GetExecutors(ctx echo.Context) error
	// Get Executor by ID
	// (GET /executors/{id})
	GetExecutorsId(ctx echo.Context, id string) error
	// Get a list of Function objects
	// (GET /functions)
	GetFunctions(ctx echo.Context) error
	// Get Function by ID
	// (GET /functions/{id})
	GetFunctionsId(ctx echo.Context, id string) error
	// Provides health info for the service REST server
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// Get info on jobs
	// (GET /jobs)
	GetJobs(ctx echo.Context, params GetJobsParams) error
	// Run or schedule a job
	// (POST /jobs)
	PostJobs(ctx echo.Context) error
	// Remove job from job inspector by instance id
	// (DELETE /jobs/{id})
	DeleteJobsId(ctx echo.Context, id string) error
	// Get job info by instance id
	// (GET /jobs/{id})
	GetJobsId(ctx echo.Context, id string) error
	// Cancel a job by instance id
	// (PATCH /jobs/{id}/cancel)
	PatchJobsIdCancel(ctx echo.Context, id string) error
	// Get Task errors for a job by id
	// (GET /jobs/{id}/errors/)
	GetJobsIdErrors(ctx echo.Context, id string) error
	// Get Task errors for a job by id
	// (GET /jobs/{id}/errors/{group})
	GetJobsIdErrorsGroup(ctx echo.Context, id string, group string) error
	// prevent job from being deleted automatically
	// (PATCH /jobs/{id}/keep)
	PatchJobsIdKeep(ctx echo.Context, id string) error
	// Pause a job by instance id
	// (PATCH /jobs/{id}/pause)
	PatchJobsIdPause(ctx echo.Context, id string) error
	// Get results for a discover job by instance id
	// (GET /jobs/{id}/results/)
	GetJobsIdResults(ctx echo.Context, id string) error
	// Get results for a discover job by instance id
	// (GET /jobs/{id}/results/{group})
	GetJobsIdResultsGroup(ctx echo.Context, id string, group string, params GetJobsIdResultsGroupParams) error
	// Resume a job by instance id
	// (PATCH /jobs/{id}/resume)
	PatchJobsIdResume(ctx echo.Context, id string) error
	// Get a list of AppscopeLibEntry objects
	// (GET /lib/appscope-configs)
	GetLibAppscopeConfigs(ctx echo.Context) error
	// Create AppscopeLibEntry
	// (POST /lib/appscope-configs)
	PostLibAppscopeConfigs(ctx echo.Context) error
	// Delete AppscopeLibEntry
	// (DELETE /lib/appscope-configs/{id})
	DeleteLibAppscopeConfigsId(ctx echo.Context, id string) error
	// Get AppscopeLibEntry by ID
	// (GET /lib/appscope-configs/{id})
	GetLibAppscopeConfigsId(ctx echo.Context, id string) error
	// Update AppscopeLibEntry
	// (PATCH /lib/appscope-configs/{id})
	PatchLibAppscopeConfigsId(ctx echo.Context, id string) error
	// Get a list of Event Breaker Ruleset objects
	// (GET /lib/breakers)
	GetLibBreakers(ctx echo.Context) error
	// Create Event Breaker Ruleset
	// (POST /lib/breakers)
	PostLibBreakers(ctx echo.Context) error
	// Delete Event Breaker Ruleset
	// (DELETE /lib/breakers/{id})
	DeleteLibBreakersId(ctx echo.Context, id string) error
	// Get Event Breaker Ruleset by ID
	// (GET /lib/breakers/{id})
	GetLibBreakersId(ctx echo.Context, id string) error
	// Update Event Breaker Ruleset
	// (PATCH /lib/breakers/{id})
	PatchLibBreakersId(ctx echo.Context, id string) error
	// Get a list of DatabaseConnection objects
	// (GET /lib/database-connections)
	GetLibDatabaseConnections(ctx echo.Context, params GetLibDatabaseConnectionsParams) error
	// Create DatabaseConnectionConfig
	// (POST /lib/database-connections)
	PostLibDatabaseConnections(ctx echo.Context) error
	// Test a database connection given a type and connectionString
	// (POST /lib/database-connections/test)
	PostLibDatabaseConnectionsTest(ctx echo.Context) error
	// Delete DatabaseConnectionConfig
	// (DELETE /lib/database-connections/{id})
	DeleteLibDatabaseConnectionsId(ctx echo.Context, id string) error
	// Get DatabaseConnectionConfig by ID
	// (GET /lib/database-connections/{id})
	GetLibDatabaseConnectionsId(ctx echo.Context, id string) error
	// Update DatabaseConnectionConfig
	// (PATCH /lib/database-connections/{id})
	PatchLibDatabaseConnectionsId(ctx echo.Context, id string) error
	// Evaluate JavaScript expression
	// (POST /lib/expression)
	PostLibExpression(ctx echo.Context) error
	// Get a list of GrokFile objects
	// (GET /lib/grok)
	GetLibGrok(ctx echo.Context) error
	// Create GrokFile
	// (POST /lib/grok)
	PostLibGrok(ctx echo.Context) error
	// Delete GrokFile
	// (DELETE /lib/grok/{id})
	DeleteLibGrokId(ctx echo.Context, id string) error
	// Get GrokFile by ID
	// (GET /lib/grok/{id})
	GetLibGrokId(ctx echo.Context, id string) error
	// Update GrokFile
	// (PATCH /lib/grok/{id})
	PatchLibGrokId(ctx echo.Context, id string) error
	// Get a list of HmacFunction objects
	// (GET /lib/hmac-functions)
	GetLibHmacFunctions(ctx echo.Context) error
	// Create HmacFunction
	// (POST /lib/hmac-functions)
	PostLibHmacFunctions(ctx echo.Context) error
	// Delete HmacFunction
	// (DELETE /lib/hmac-functions/{id})
	DeleteLibHmacFunctionsId(ctx echo.Context, id string) error
	// Get HmacFunction by ID
	// (GET /lib/hmac-functions/{id})
	GetLibHmacFunctionsId(ctx echo.Context, id string) error
	// Update HmacFunction
	// (PATCH /lib/hmac-functions/{id})
	PatchLibHmacFunctionsId(ctx echo.Context, id string) error
	// Get a list of SavedJob objects
	// (GET /lib/jobs)
	GetLibJobs(ctx echo.Context) error
	// Create SavedJob
	// (POST /lib/jobs)
	PostLibJobs(ctx echo.Context) error
	// Delete SavedJob
	// (DELETE /lib/jobs/{id})
	DeleteLibJobsId(ctx echo.Context, id string) error
	// Get SavedJob by ID
	// (GET /lib/jobs/{id})
	GetLibJobsId(ctx echo.Context, id string) error
	// Update SavedJob
	// (PATCH /lib/jobs/{id})
	PatchLibJobsId(ctx echo.Context, id string) error
	// Get a list of Schema objects
	// (GET /lib/parquet-schemas)
	GetLibParquetSchemas(ctx echo.Context) error
	// Create Schema
	// (POST /lib/parquet-schemas)
	PostLibParquetSchemas(ctx echo.Context) error
	// Delete Schema
	// (DELETE /lib/parquet-schemas/{id})
	DeleteLibParquetSchemasId(ctx echo.Context, id string) error
	// Get Schema by ID
	// (GET /lib/parquet-schemas/{id})
	GetLibParquetSchemasId(ctx echo.Context, id string) error
	// Update Schema
	// (PATCH /lib/parquet-schemas/{id})
	PatchLibParquetSchemasId(ctx echo.Context, id string) error
	// Get a list of Parser objects
	// (GET /lib/parsers)
	GetLibParsers(ctx echo.Context) error
	// Create Parser
	// (POST /lib/parsers)
	PostLibParsers(ctx echo.Context) error
	// Delete Parser
	// (DELETE /lib/parsers/{id})
	DeleteLibParsersId(ctx echo.Context, id string) error
	// Get Parser by ID
	// (GET /lib/parsers/{id})
	GetLibParsersId(ctx echo.Context, id string) error
	// Update Parser
	// (PATCH /lib/parsers/{id})
	PatchLibParsersId(ctx echo.Context, id string) error
	// Show list of Protobuf encodings for a given Library
	// (GET /lib/protobuf-libraries)
	GetLibProtobufLibraries(ctx echo.Context, params GetLibProtobufLibrariesParams) error
	// Show Library by Id
	// (GET /lib/protobuf-libraries/{id})
	GetLibProtobufLibrariesId(ctx echo.Context, id string) error
	// Show list of Protobuf encodings for a given Library
	// (GET /lib/protobuf-libraries/{id}/encodings)
	GetLibProtobufLibrariesIdEncodings(ctx echo.Context, id string) error
	// Show Protobuf library encodings by encoding id
	// (GET /lib/protobuf-libraries/{id}/encodings/{encid})
	GetLibProtobufLibrariesIdEncodingsEncid(ctx echo.Context, id string, encid string) error
	// Get a list of RegexLibEntry objects
	// (GET /lib/regex)
	GetLibRegex(ctx echo.Context) error
	// Create RegexLibEntry
	// (POST /lib/regex)
	PostLibRegex(ctx echo.Context) error
	// Delete RegexLibEntry
	// (DELETE /lib/regex/{id})
	DeleteLibRegexId(ctx echo.Context, id string) error
	// Get RegexLibEntry by ID
	// (GET /lib/regex/{id})
	GetLibRegexId(ctx echo.Context, id string) error
	// Update RegexLibEntry
	// (PATCH /lib/regex/{id})
	PatchLibRegexId(ctx echo.Context, id string) error
	// Get a list of Schema objects
	// (GET /lib/schemas)
	GetLibSchemas(ctx echo.Context) error
	// Create Schema
	// (POST /lib/schemas)
	PostLibSchemas(ctx echo.Context) error
	// Delete Schema
	// (DELETE /lib/schemas/{id})
	DeleteLibSchemasId(ctx echo.Context, id string) error
	// Get Schema by ID
	// (GET /lib/schemas/{id})
	GetLibSchemasId(ctx echo.Context, id string) error
	// Update Schema
	// (PATCH /lib/schemas/{id})
	PatchLibSchemasId(ctx echo.Context, id string) error
	// Get a list of Global Variable objects
	// (GET /lib/vars)
	GetLibVars(ctx echo.Context) error
	// Create Global Variable
	// (POST /lib/vars)
	PostLibVars(ctx echo.Context) error
	// Delete Global Variable
	// (DELETE /lib/vars/{id})
	DeleteLibVarsId(ctx echo.Context, id string) error
	// Get Global Variable by ID
	// (GET /lib/vars/{id})
	GetLibVarsId(ctx echo.Context, id string) error
	// Update Global Variable
	// (PATCH /lib/vars/{id})
	PatchLibVarsId(ctx echo.Context, id string) error
	// Capture live incoming data from a particular Project and Subscription at the Destination
	// (POST /m/{groupId}/system/projects/{projectId}/capture)
	PostMGroupIdSystemProjectsProjectIdCapture(ctx echo.Context, groupId string, projectId string) error
	// Get A list of Pipeline objects for specified Project
	// (GET /m/{groupId}/system/projects/{projectId}/pipelines)
	GetMGroupIdSystemProjectsProjectIdPipelines(ctx echo.Context, groupId string, projectId string) error
	// Create Pipeline
	// (POST /m/{groupId}/system/projects/{projectId}/pipelines)
	PostMGroupIdSystemProjectsProjectIdPipelines(ctx echo.Context, groupId string, projectId string) error
	// Delete Pipeline in specified Project
	// (DELETE /m/{groupId}/system/projects/{projectId}/pipelines/{pipelineId})
	DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context, groupId string, projectId string, pipelineId string) error
	// Get Pipeline by ID in specified Project
	// (GET /m/{groupId}/system/projects/{projectId}/pipelines/{pipelineId})
	GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context, groupId string, projectId string, pipelineId string) error
	// Update Pipeline in specified Project
	// (PATCH /m/{groupId}/system/projects/{projectId}/pipelines/{pipelineId})
	PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context, groupId string, projectId string, pipelineId string) error
	// Sends sample events through a Pipeline  for specified Project and returns the results
	// (POST /m/{groupId}/system/projects/{projectId}/preview)
	PostMGroupIdSystemProjectsProjectIdPreview(ctx echo.Context, groupId string, projectId string) error
	// Get the Subscriptions associated with the Project
	// (GET /m/{groupId}/system/projects/{projectId}/subscriptions)
	GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx echo.Context, groupId string, projectId string) error
	// Capture live incoming data from a particular Project and Subscription at the Subscription
	// (POST /m/{groupId}/system/projects/{projectId}/subscriptions/{subscriptionId}/capture)
	PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx echo.Context, groupId string, projectId string, subscriptionId string) error
	// Commit project changes
	// (POST /m/{groupId}/system/projects/{projectId}/version/commit)
	PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx echo.Context, groupId string, projectId string) error
	// Get the count of files of changed
	// (GET /m/{groupId}/system/projects/{projectId}/version/count)
	GetMGroupIdSystemProjectsProjectIdVersionCount(ctx echo.Context, groupId string, projectId string) error
	// Get the textual diff for given commit
	// (GET /m/{groupId}/system/projects/{projectId}/version/diff)
	GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx echo.Context, groupId string, projectId string, params GetMGroupIdSystemProjectsProjectIdVersionDiffParams) error
	// Get the files changed
	// (GET /m/{groupId}/system/projects/{projectId}/version/files)
	GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx echo.Context, groupId string, projectId string) error
	// Download config bundle (used by remote nodes)
	// (GET /master/bundles/{group}/{version})
	GetMasterBundlesGroupVersion(ctx echo.Context, group string, version string) error
	// Get a specific ConfigGroup object
	// (GET /master/groups/{id})
	GetMasterGroupsId(ctx echo.Context, id string, params GetMasterGroupsIdParams) error
	// ACL of members with permissions for resources in this Group
	// (GET /master/groups/{id}/acl)
	GetMasterGroupsIdAcl(ctx echo.Context, id string, params GetMasterGroupsIdAclParams) error
	// Get effective bundle version for given Group
	// (GET /master/groups/{id}/configVersion)
	GetMasterGroupsIdConfigVersion(ctx echo.Context, id string) error
	// Deploy commits for a Fleet or Worker Group
	// (PATCH /master/groups/{id}/deploy)
	PatchMasterGroupsIdDeploy(ctx echo.Context, id string) error
	// Get summary of Distributed deployment
	// (GET /master/summary)
	GetMasterSummary(ctx echo.Context, params GetMasterSummaryParams) error
	// get worker and edge nodes count
	// (GET /master/summary/workers)
	GetMasterSummaryWorkers(ctx echo.Context, params GetMasterSummaryWorkersParams) error
	// get worker and edge nodes
	// (GET /master/workers)
	GetMasterWorkers(ctx echo.Context, params GetMasterWorkersParams) error
	// restarts worker nodes
	// (PATCH /master/workers/restart)
	PatchMasterWorkersRestart(ctx echo.Context) error
	// Get a list of NotificationTarget objects
	// (GET /notification-targets)
	GetNotificationTargets(ctx echo.Context) error
	// Create NotificationTarget
	// (POST /notification-targets)
	PostNotificationTargets(ctx echo.Context) error
	// Delete NotificationTarget
	// (DELETE /notification-targets/{id})
	DeleteNotificationTargetsId(ctx echo.Context, id string) error
	// Get NotificationTarget by ID
	// (GET /notification-targets/{id})
	GetNotificationTargetsId(ctx echo.Context, id string) error
	// Update NotificationTarget
	// (PATCH /notification-targets/{id})
	PatchNotificationTargetsId(ctx echo.Context, id string) error
	// Get a list of Notification objects
	// (GET /notifications)
	GetNotifications(ctx echo.Context) error
	// Create Notification
	// (POST /notifications)
	PostNotifications(ctx echo.Context) error
	// Delete Notification
	// (DELETE /notifications/{id})
	DeleteNotificationsId(ctx echo.Context, id string) error
	// Get Notification by ID
	// (GET /notifications/{id})
	GetNotificationsId(ctx echo.Context, id string) error
	// Update Notification
	// (PATCH /notifications/{id})
	PatchNotificationsId(ctx echo.Context, id string) error
	// Retrieve the description of the configured ClickHouse table
	// (POST /output/click-house/describe-table)
	PostOutputClickHouseDescribeTable(ctx echo.Context) error
	// Get a list of Function objects within a Pack
	// (GET /p/{pack}/functions)
	GetPPackFunctions(ctx echo.Context, pack string) error
	// Get Function by ID within a Pack
	// (GET /p/{pack}/functions/{id})
	GetPPackFunctionsId(ctx echo.Context, pack string, id string) error
	// Get a list of Schema objects within a Pack
	// (GET /p/{pack}/lib/schemas)
	GetPPackLibSchemas(ctx echo.Context, pack string) error
	// Create Schema within a Pack
	// (POST /p/{pack}/lib/schemas)
	PostPPackLibSchemas(ctx echo.Context, pack string) error
	// Delete Schema within a Pack
	// (DELETE /p/{pack}/lib/schemas/{id})
	DeletePPackLibSchemasId(ctx echo.Context, pack string, id string) error
	// Get Schema by ID within a Pack
	// (GET /p/{pack}/lib/schemas/{id})
	GetPPackLibSchemasId(ctx echo.Context, pack string, id string) error
	// Update Schema within a Pack
	// (PATCH /p/{pack}/lib/schemas/{id})
	PatchPPackLibSchemasId(ctx echo.Context, pack string, id string) error
	// Get a list of Global Variable objects within a Pack
	// (GET /p/{pack}/lib/vars)
	GetPPackLibVars(ctx echo.Context, pack string) error
	// Create Global Variable within a Pack
	// (POST /p/{pack}/lib/vars)
	PostPPackLibVars(ctx echo.Context, pack string) error
	// Delete Global Variable within a Pack
	// (DELETE /p/{pack}/lib/vars/{id})
	DeletePPackLibVarsId(ctx echo.Context, pack string, id string) error
	// Get Global Variable by ID within a Pack
	// (GET /p/{pack}/lib/vars/{id})
	GetPPackLibVarsId(ctx echo.Context, pack string, id string) error
	// Update Global Variable within a Pack
	// (PATCH /p/{pack}/lib/vars/{id})
	PatchPPackLibVarsId(ctx echo.Context, pack string, id string) error
	// Get a list of Pipeline objects within a Pack
	// (GET /p/{pack}/pipelines)
	GetPPackPipelines(ctx echo.Context, pack string) error
	// Create Pipeline within a Pack
	// (POST /p/{pack}/pipelines)
	PostPPackPipelines(ctx echo.Context, pack string) error
	// Delete Pipeline within a Pack
	// (DELETE /p/{pack}/pipelines/{id})
	DeletePPackPipelinesId(ctx echo.Context, pack string, id string) error
	// Get Pipeline by ID within a Pack
	// (GET /p/{pack}/pipelines/{id})
	GetPPackPipelinesId(ctx echo.Context, pack string, id string) error
	// Update Pipeline within a Pack
	// (PATCH /p/{pack}/pipelines/{id})
	PatchPPackPipelinesId(ctx echo.Context, pack string, id string) error
	// Get a list of Routes objects within a Pack
	// (GET /p/{pack}/routes)
	GetPPackRoutes(ctx echo.Context, pack string) error
	// Get Routes by ID within a Pack
	// (GET /p/{pack}/routes/{id})
	GetPPackRoutesId(ctx echo.Context, pack string, id string) error
	// Update Routes within a Pack
	// (PATCH /p/{pack}/routes/{id})
	PatchPPackRoutesId(ctx echo.Context, pack string, id string) error
	// Appends routes to the end of the routing table within a Pack
	// (POST /p/{pack}/routes/{id}/append)
	PostPPackRoutesIdAppend(ctx echo.Context, pack string, id string) error
	// Get info on packs
	// (GET /packs)
	GetPacks(ctx echo.Context) error
	// Install Pack
	// (POST /packs)
	PostPacks(ctx echo.Context) error
	// Upload Pack
	// (PUT /packs)
	PutPacks(ctx echo.Context, params PutPacksParams) error
	// Clone Pack
	// (POST /packs/__clone__)
	PostPacksClone(ctx echo.Context) error
	// Uninstall Pack from the system
	// (DELETE /packs/{id})
	DeletePacksId(ctx echo.Context, id string) error
	// Upgrade Pack
	// (PATCH /packs/{id})
	PatchPacksId(ctx echo.Context, id string, params PatchPacksIdParams) error
	// Export Pack
	// (GET /packs/{id}/export)
	GetPacksIdExport(ctx echo.Context, id string, params GetPacksIdExportParams) error
	// Get a list of Pipeline objects
	// (GET /pipelines)
	GetPipelines(ctx echo.Context) error
	// Create Pipeline
	// (POST /pipelines)
	PostPipelines(ctx echo.Context) error
	// Delete Pipeline
	// (DELETE /pipelines/{id})
	DeletePipelinesId(ctx echo.Context, id string) error
	// Get Pipeline by ID
	// (GET /pipelines/{id})
	GetPipelinesId(ctx echo.Context, id string) error
	// Update Pipeline
	// (PATCH /pipelines/{id})
	PatchPipelinesId(ctx echo.Context, id string) error
	// Sends sample events through a pipeline and returns the results
	// (POST /preview)
	PostPreview(ctx echo.Context) error
	// Data for the Map View for Edge Fleets (Leader only)
	// (POST /products/edge/map/query)
	PostProductsEdgeMapQuery(ctx echo.Context) error
	// Get the list of Dataset contained in the specified Lake
	// (GET /products/lake/lakes/{lakeId}/datasets)
	GetProductsLakeLakesLakeIdDatasets(ctx echo.Context, lakeId string) error
	// Create a Dataset in the specified Lake
	// (POST /products/lake/lakes/{lakeId}/datasets)
	PostProductsLakeLakesLakeIdDatasets(ctx echo.Context, lakeId string) error
	// Delete a Dataset in the specified Lake
	// (DELETE /products/lake/lakes/{lakeId}/datasets/{id})
	DeleteProductsLakeLakesLakeIdDatasetsId(ctx echo.Context, lakeId string, id string) error
	// Get a Dataset in the specified Lake
	// (GET /products/lake/lakes/{lakeId}/datasets/{id})
	GetProductsLakeLakesLakeIdDatasetsId(ctx echo.Context, lakeId string, id string) error
	// Update a Dataset in the specified Lake
	// (PATCH /products/lake/lakes/{lakeId}/datasets/{id})
	PatchProductsLakeLakesLakeIdDatasetsId(ctx echo.Context, lakeId string, id string) error
	// Get a list of ConfigGroup objects
	// (GET /products/{product}/groups)
	GetProductsProductGroups(ctx echo.Context, product GetProductsProductGroupsParamsProduct, params GetProductsProductGroupsParams) error
	// Create a Fleet or Worker Group
	// (POST /products/{product}/groups)
	PostProductsProductGroups(ctx echo.Context, product PostProductsProductGroupsParamsProduct) error
	// ACL of team with permissions for resources in this Group
	// (GET /products/{product}/groups/{id}/acl/teams)
	GetProductsProductGroupsIdAclTeams(ctx echo.Context, product GetProductsProductGroupsIdAclTeamsParamsProduct, id string, params GetProductsProductGroupsIdAclTeamsParams) error
	// Get Users belonging to a product
	// (GET /products/{product}/users)
	GetProductsProductUsers(ctx echo.Context, product GetProductsProductUsersParamsProduct, params GetProductsProductUsersParams) error
	// Invalidate the members cache for a given product in SaaS deployment.
	// (DELETE /products/{product}/users/__cache__)
	DeleteProductsProductUsersCache(ctx echo.Context, product DeleteProductsProductUsersCacheParamsProduct) error
	// Get user's Access Control List
	// (GET /products/{product}/users/{id}/acl)
	GetProductsProductUsersIdAcl(ctx echo.Context, product GetProductsProductUsersIdAclParamsProduct, id string, params GetProductsProductUsersIdAclParams) error
	// Get a list of Routes objects
	// (GET /routes)
	GetRoutes(ctx echo.Context) error
	// Get Routes by ID
	// (GET /routes/{id})
	GetRoutesId(ctx echo.Context, id string) error
	// Update Routes
	// (PATCH /routes/{id})
	PatchRoutesId(ctx echo.Context, id string) error
	// Appends routes to the end of the routing table
	// (POST /routes/{id}/append)
	PostRoutesIdAppend(ctx echo.Context, id string) error
	// Get a list of DashboardCategory objects
	// (GET /search/dashboard-categories)
	GetSearchDashboardCategories(ctx echo.Context) error
	// Create DashboardCategory
	// (POST /search/dashboard-categories)
	PostSearchDashboardCategories(ctx echo.Context) error
	// Delete DashboardCategory
	// (DELETE /search/dashboard-categories/{id})
	DeleteSearchDashboardCategoriesId(ctx echo.Context, id string) error
	// Get DashboardCategory by ID
	// (GET /search/dashboard-categories/{id})
	GetSearchDashboardCategoriesId(ctx echo.Context, id string) error
	// Update DashboardCategory
	// (PATCH /search/dashboard-categories/{id})
	PatchSearchDashboardCategoriesId(ctx echo.Context, id string) error
	// Get a list of SearchDashboard objects
	// (GET /search/dashboards)
	GetSearchDashboards(ctx echo.Context) error
	// Create SearchDashboard
	// (POST /search/dashboards)
	PostSearchDashboards(ctx echo.Context) error
	// Delete SearchDashboard
	// (DELETE /search/dashboards/{id})
	DeleteSearchDashboardsId(ctx echo.Context, id string) error
	// Get SearchDashboard by ID
	// (GET /search/dashboards/{id})
	GetSearchDashboardsId(ctx echo.Context, id string) error
	// Update SearchDashboard
	// (PATCH /search/dashboards/{id})
	PatchSearchDashboardsId(ctx echo.Context, id string) error
	// Get SearchDashboard ACL
	// (GET /search/dashboards/{id}/acl)
	GetSearchDashboardsIdAcl(ctx echo.Context, id string) error
	// Modify SearchDashboard ACL
	// (POST /search/dashboards/{id}/acl/apply)
	PostSearchDashboardsIdAclApply(ctx echo.Context, id string) error
	// Get SearchDashboard Teams
	// (GET /search/dashboards/{id}/acl/teams)
	GetSearchDashboardsIdAclTeams(ctx echo.Context, id string) error
	// Modify SearchDashboard Teams ACL
	// (POST /search/dashboards/{id}/acl/teams/apply)
	PostSearchDashboardsIdAclTeamsApply(ctx echo.Context, id string) error
	// Get a list of DatasetProviderType objects
	// (GET /search/dataset-provider-types)
	GetSearchDatasetProviderTypes(ctx echo.Context) error
	// Create DatasetProviderType
	// (POST /search/dataset-provider-types)
	PostSearchDatasetProviderTypes(ctx echo.Context) error
	// Delete DatasetProviderType
	// (DELETE /search/dataset-provider-types/{id})
	DeleteSearchDatasetProviderTypesId(ctx echo.Context, id string) error
	// Get DatasetProviderType by ID
	// (GET /search/dataset-provider-types/{id})
	GetSearchDatasetProviderTypesId(ctx echo.Context, id string) error
	// Update DatasetProviderType
	// (PATCH /search/dataset-provider-types/{id})
	PatchSearchDatasetProviderTypesId(ctx echo.Context, id string) error
	// Get a list of DatasetProvider objects
	// (GET /search/dataset-providers)
	GetSearchDatasetProviders(ctx echo.Context) error
	// Create DatasetProvider
	// (POST /search/dataset-providers)
	PostSearchDatasetProviders(ctx echo.Context) error
	// Delete DatasetProvider
	// (DELETE /search/dataset-providers/{id})
	DeleteSearchDatasetProvidersId(ctx echo.Context, id string) error
	// Get DatasetProvider by ID
	// (GET /search/dataset-providers/{id})
	GetSearchDatasetProvidersId(ctx echo.Context, id string) error
	// Update DatasetProvider
	// (PATCH /search/dataset-providers/{id})
	PatchSearchDatasetProvidersId(ctx echo.Context, id string) error
	// Get a list of Dataset objects
	// (GET /search/datasets)
	GetSearchDatasets(ctx echo.Context) error
	// Create Dataset
	// (POST /search/datasets)
	PostSearchDatasets(ctx echo.Context) error
	// Delete Dataset
	// (DELETE /search/datasets/{id})
	DeleteSearchDatasetsId(ctx echo.Context, id string) error
	// Get Dataset by ID
	// (GET /search/datasets/{id})
	GetSearchDatasetsId(ctx echo.Context, id string) error
	// Update Dataset
	// (PATCH /search/datasets/{id})
	PatchSearchDatasetsId(ctx echo.Context, id string) error
	// Get Dataset ACL
	// (GET /search/datasets/{id}/acl)
	GetSearchDatasetsIdAcl(ctx echo.Context, id string) error
	// Modify Dataset ACL
	// (POST /search/datasets/{id}/acl/apply)
	PostSearchDatasetsIdAclApply(ctx echo.Context, id string) error
	// Get Dataset Teams
	// (GET /search/datasets/{id}/acl/teams)
	GetSearchDatasetsIdAclTeams(ctx echo.Context, id string) error
	// Modify Dataset Teams ACL
	// (POST /search/datasets/{id}/acl/teams/apply)
	PostSearchDatasetsIdAclTeamsApply(ctx echo.Context, id string) error
	// Runs an event breaker rule on the specified data
	// (POST /search/event-breaker-preview)
	PostSearchEventBreakerPreview(ctx echo.Context) error
	// Get health check metric for search
	// (GET /search/healthcheck)
	GetSearchHealthcheck(ctx echo.Context) error
	// List metrics for all search jobs
	// (GET /search/job-metrics)
	GetSearchJobMetrics(ctx echo.Context) error
	// Get a list of SearchJob objects
	// (GET /search/jobs)
	GetSearchJobs(ctx echo.Context) error
	// Create SearchJob
	// (POST /search/jobs)
	PostSearchJobs(ctx echo.Context) error
	// Delete SearchJob
	// (DELETE /search/jobs/{id})
	DeleteSearchJobsId(ctx echo.Context, id string) error
	// Get SearchJob by ID
	// (GET /search/jobs/{id})
	GetSearchJobsId(ctx echo.Context, id string) error
	// Update SearchJob
	// (PATCH /search/jobs/{id})
	PatchSearchJobsId(ctx echo.Context, id string) error
	// internal endpoint, dispatch search *id* to worker nodes filtered by worker node filter using RPC
	// (POST /search/jobs/{id}/dispatch-executors)
	PostSearchJobsIdDispatchExecutors(ctx echo.Context, id string) error
	// Get search logs
	// (GET /search/jobs/{id}/logs)
	GetSearchJobsIdLogs(ctx echo.Context, id string) error
	// Get search job metrics
	// (GET /search/jobs/{id}/metrics)
	GetSearchJobsIdMetrics(ctx echo.Context, id string) error
	// List search results, when lower/upper bound is provided, offset is relative to the time range.
	// (GET /search/jobs/{id}/results)
	GetSearchJobsIdResults(ctx echo.Context, id string, params GetSearchJobsIdResultsParams) error
	// List search results
	// (GET /search/jobs/{id}/results-poll)
	GetSearchJobsIdResultsPoll(ctx echo.Context, id string, params GetSearchJobsIdResultsPollParams) error
	// List search results for a given stage. Note that this cannot be the root stage!
	// (GET /search/jobs/{id}/stages/{stageId}/results)
	GetSearchJobsIdStagesStageIdResults(ctx echo.Context, id string, stageId string) error
	// Get a list of SearchMacro objects
	// (GET /search/macros)
	GetSearchMacros(ctx echo.Context) error
	// Create SearchMacro
	// (POST /search/macros)
	PostSearchMacros(ctx echo.Context) error
	// Delete SearchMacro
	// (DELETE /search/macros/{id})
	DeleteSearchMacrosId(ctx echo.Context, id string) error
	// Get SearchMacro by ID
	// (GET /search/macros/{id})
	GetSearchMacrosId(ctx echo.Context, id string) error
	// Update SearchMacro
	// (PATCH /search/macros/{id})
	PatchSearchMacrosId(ctx echo.Context, id string) error
	// Applies a query snippet on a set of input events for preview
	// (POST /search/preview)
	PostSearchPreview(ctx echo.Context) error
	// Get a list of SavedQuery objects
	// (GET /search/saved)
	GetSearchSaved(ctx echo.Context) error
	// Create SavedQuery
	// (POST /search/saved)
	PostSearchSaved(ctx echo.Context) error
	// Delete SavedQuery
	// (DELETE /search/saved/{id})
	DeleteSearchSavedId(ctx echo.Context, id string) error
	// Get SavedQuery by ID
	// (GET /search/saved/{id})
	GetSearchSavedId(ctx echo.Context, id string) error
	// Update SavedQuery
	// (PATCH /search/saved/{id})
	PatchSearchSavedId(ctx echo.Context, id string) error
	// Get a list of TrustPolicy objects
	// (GET /search/trust-policies)
	GetSearchTrustPolicies(ctx echo.Context) error
	// Get a list of UsageGroup objects
	// (GET /search/usage-groups)
	GetSearchUsageGroups(ctx echo.Context) error
	// Create UsageGroup
	// (POST /search/usage-groups)
	PostSearchUsageGroups(ctx echo.Context) error
	// Delete UsageGroup
	// (DELETE /search/usage-groups/{id})
	DeleteSearchUsageGroupsId(ctx echo.Context, id string) error
	// Get UsageGroup by ID
	// (GET /search/usage-groups/{id})
	GetSearchUsageGroupsId(ctx echo.Context, id string) error
	// Update UsageGroup
	// (PATCH /search/usage-groups/{id})
	PatchSearchUsageGroupsId(ctx echo.Context, id string) error
	// Get Cribl KMS config
	// (GET /security/kms/config)
	GetSecurityKmsConfig(ctx echo.Context) error
	// Update Cribl KMS config
	// (PATCH /security/kms/config)
	PatchSecurityKmsConfig(ctx echo.Context) error
	// Get Cribl KMS health
	// (GET /security/kms/health)
	GetSecurityKmsHealth(ctx echo.Context) error
	// List all features
	// (GET /settings/features)
	GetSettingsFeatures(ctx echo.Context) error
	// Get feature by id (i.e. 'type-name`)
	// (GET /settings/features/{id})
	GetSettingsFeaturesId(ctx echo.Context, id string) error
	// Get a list of BannerMessage objects
	// (GET /system/banners)
	GetSystemBanners(ctx echo.Context) error
	// Create BannerMessage
	// (POST /system/banners)
	PostSystemBanners(ctx echo.Context) error
	// Delete BannerMessage
	// (DELETE /system/banners/{id})
	DeleteSystemBannersId(ctx echo.Context, id string) error
	// Get BannerMessage by ID
	// (GET /system/banners/{id})
	GetSystemBannersId(ctx echo.Context, id string) error
	// Update BannerMessage
	// (PATCH /system/banners/{id})
	PatchSystemBannersId(ctx echo.Context, id string) error
	// Capture live incoming data
	// (POST /system/capture)
	PostSystemCapture(ctx echo.Context) error
	// Get a list of Certificate objects
	// (GET /system/certificates)
	GetSystemCertificates(ctx echo.Context) error
	// Create Certificate
	// (POST /system/certificates)
	PostSystemCertificates(ctx echo.Context) error
	// Delete Certificate
	// (DELETE /system/certificates/{id})
	DeleteSystemCertificatesId(ctx echo.Context, id string) error
	// Get Certificate by ID
	// (GET /system/certificates/{id})
	GetSystemCertificatesId(ctx echo.Context, id string) error
	// Update Certificate
	// (PATCH /system/certificates/{id})
	PatchSystemCertificatesId(ctx echo.Context, id string) error
	// Remove diag bundle
	// (DELETE /system/diag)
	DeleteSystemDiag(ctx echo.Context, params DeleteSystemDiagParams) error
	// Get list of existing diag bundles
	// (GET /system/diag)
	GetSystemDiag(ctx echo.Context) error
	// Returns a diag bundle as a tar.gz archive
	// (GET /system/diag/download)
	GetSystemDiagDownload(ctx echo.Context) error
	// Send a diag bundle (tar.gz archive) to Cribl
	// (POST /system/diag/send)
	PostSystemDiagSend(ctx echo.Context) error
	// Cancel a running group upgrade
	// (POST /system/distributed/upgrade/cancel/{group})
	PostSystemDistributedUpgradeCancelGroup(ctx echo.Context, group string) error
	// Get the previously downloaded Cribl package
	// (GET /system/distributed/upgrade/download/{file})
	GetSystemDistributedUpgradeDownloadFile(ctx echo.Context, file string) error
	// Stage distributed group upgrade
	// (POST /system/distributed/upgrade/stage/{group})
	PostSystemDistributedUpgradeStageGroup(ctx echo.Context, group string, params PostSystemDistributedUpgradeStageGroupParams) error
	// Execute distributed group upgrade
	// (POST /system/distributed/upgrade/{group})
	PostSystemDistributedUpgradeGroup(ctx echo.Context, group string) error
	// Get basic system information
	// (GET /system/info)
	GetSystemInfo(ctx echo.Context) error
	// Get a list of Input objects
	// (GET /system/inputs)
	GetSystemInputs(ctx echo.Context) error
	// Create Input
	// (POST /system/inputs)
	PostSystemInputs(ctx echo.Context) error
	// Delete Input
	// (DELETE /system/inputs/{id})
	DeleteSystemInputsId(ctx echo.Context, id string) error
	// Get Input by ID
	// (GET /system/inputs/{id})
	GetSystemInputsId(ctx echo.Context, id string) error
	// Update Input
	// (PATCH /system/inputs/{id})
	PatchSystemInputsId(ctx echo.Context, id string) error
	// Add token and optional metadata to an existing hec input
	// (POST /system/inputs/{id}/hectoken)
	PostSystemInputsIdHectoken(ctx echo.Context, id string) error
	// Update token metadata on existing hec input
	// (PATCH /system/inputs/{id}/hectoken/{token})
	PatchSystemInputsIdHectokenToken(ctx echo.Context, id string, token string) error
	// Get contents of the log file
	// (GET /system/jobs/logs/{id}/{groupId})
	GetSystemJobsLogsIdGroupId(ctx echo.Context, id string, groupId string, params GetSystemJobsLogsIdGroupIdParams) error
	// Get a list of KeyMetadataEntity objects
	// (GET /system/keys)
	GetSystemKeys(ctx echo.Context) error
	// Create KeyMetadataEntity
	// (POST /system/keys)
	PostSystemKeys(ctx echo.Context) error
	// Delete KeyMetadataEntity
	// (DELETE /system/keys/{id})
	DeleteSystemKeysId(ctx echo.Context, id string) error
	// Get KeyMetadataEntity by ID
	// (GET /system/keys/{id})
	GetSystemKeysId(ctx echo.Context, id string) error
	// Update KeyMetadataEntity
	// (PATCH /system/keys/{id})
	PatchSystemKeysId(ctx echo.Context, id string) error
	// Get a list of License objects
	// (GET /system/licenses)
	GetSystemLicenses(ctx echo.Context) error
	// Add a license to your deployment
	// (POST /system/licenses)
	PostSystemLicenses(ctx echo.Context) error
	// Get license usage metrics, aggregated by day, up to last 90 days
	// (GET /system/licenses/usage)
	GetSystemLicensesUsage(ctx echo.Context) error
	// Delete License
	// (DELETE /system/licenses/{id})
	DeleteSystemLicensesId(ctx echo.Context, id string) error
	// Get License by ID
	// (GET /system/licenses/{id})
	GetSystemLicensesId(ctx echo.Context, id string) error
	// Get a list of LoggerConfig objects
	// (GET /system/logger)
	GetSystemLogger(ctx echo.Context) error
	// Delete LoggerConfig
	// (DELETE /system/logger/{id})
	DeleteSystemLoggerId(ctx echo.Context, id string) error
	// Get LoggerConfig by ID
	// (GET /system/logger/{id})
	GetSystemLoggerId(ctx echo.Context, id string) error
	// Update LoggerConfig
	// (PATCH /system/logger/{id})
	PatchSystemLoggerId(ctx echo.Context, id string) error
	// Get a list of log files
	// (GET /system/logs)
	GetSystemLogs(ctx echo.Context) error
	// Get contents of the log file
	// (GET /system/logs/search)
	GetSystemLogsSearch(ctx echo.Context, params GetSystemLogsSearchParams) error
	// Get contents of the log file
	// (GET /system/logs/{id})
	GetSystemLogsId(ctx echo.Context, id string, params GetSystemLogsIdParams) error
	// Get a list of LookupFile objects
	// (GET /system/lookups)
	GetSystemLookups(ctx echo.Context) error
	// Create LookupFile
	// (POST /system/lookups)
	PostSystemLookups(ctx echo.Context) error
	// Upload LookupFile
	// (PUT /system/lookups)
	PutSystemLookups(ctx echo.Context, params PutSystemLookupsParams) error
	// Delete LookupFile
	// (DELETE /system/lookups/{id})
	DeleteSystemLookupsId(ctx echo.Context, id string) error
	// Get LookupFile by ID
	// (GET /system/lookups/{id})
	GetSystemLookupsId(ctx echo.Context, id string) error
	// Update LookupFile
	// (PATCH /system/lookups/{id})
	PatchSystemLookupsId(ctx echo.Context, id string) error
	// Get a list of BulletinMessage objects
	// (GET /system/messages)
	GetSystemMessages(ctx echo.Context) error
	// Create BulletinMessage
	// (POST /system/messages)
	PostSystemMessages(ctx echo.Context) error
	// Delete BulletinMessage
	// (DELETE /system/messages/{id})
	DeleteSystemMessagesId(ctx echo.Context, id string) error
	// Get BulletinMessage by ID
	// (GET /system/messages/{id})
	GetSystemMessagesId(ctx echo.Context, id string) error
	// Query raw internal system metrics
	// (GET /system/metrics)
	GetSystemMetrics(ctx echo.Context, params GetSystemMetricsParams) error
	// Enumerate all internal system metrics
	// (POST /system/metrics/enum)
	PostSystemMetricsEnum(ctx echo.Context) error
	// Aggregate raw internal system metrics
	// (POST /system/metrics/query)
	PostSystemMetricsQuery(ctx echo.Context) error
	// Get a list of Output objects
	// (GET /system/outputs)
	GetSystemOutputs(ctx echo.Context) error
	// Create Output
	// (POST /system/outputs)
	PostSystemOutputs(ctx echo.Context) error
	// Delete Output
	// (DELETE /system/outputs/{id})
	DeleteSystemOutputsId(ctx echo.Context, id string) error
	// Get Output by ID
	// (GET /system/outputs/{id})
	GetSystemOutputsId(ctx echo.Context, id string) error
	// Update Output
	// (PATCH /system/outputs/{id})
	PatchSystemOutputsId(ctx echo.Context, id string) error
	// Clears destination persistent queue
	// (DELETE /system/outputs/{id}/pq)
	DeleteSystemOutputsIdPq(ctx echo.Context, id string) error
	// Retrieves status of latest clear PQ job for an output
	// (GET /system/outputs/{id}/pq)
	GetSystemOutputsIdPq(ctx echo.Context, id string) error
	// Retrieve samples data for the specified output. Used to get sample data for the test action.
	// (GET /system/outputs/{id}/samples)
	GetSystemOutputsIdSamples(ctx echo.Context, id string) error
	// Send sample data to an output to validate configuration or test connectivity
	// (POST /system/outputs/{id}/test)
	PostSystemOutputsIdTest(ctx echo.Context, id string) error
	// Get a list of PolicyRule objects
	// (GET /system/policies)
	GetSystemPolicies(ctx echo.Context) error
	// Create PolicyRule
	// (POST /system/policies)
	PostSystemPolicies(ctx echo.Context) error
	// Delete PolicyRule
	// (DELETE /system/policies/{id})
	DeleteSystemPoliciesId(ctx echo.Context, id string) error
	// Get PolicyRule by ID
	// (GET /system/policies/{id})
	GetSystemPoliciesId(ctx echo.Context, id string) error
	// Update PolicyRule
	// (PATCH /system/policies/{id})
	PatchSystemPoliciesId(ctx echo.Context, id string) error
	// Get a list of processes under management
	// (GET /system/processes)
	GetSystemProcesses(ctx echo.Context) error
	// Get a list of ProfilerItem objects
	// (GET /system/profiler)
	GetSystemProfiler(ctx echo.Context) error
	// Create ProfilerItem
	// (POST /system/profiler)
	PostSystemProfiler(ctx echo.Context) error
	// Delete ProfilerItem
	// (DELETE /system/profiler/{id})
	DeleteSystemProfilerId(ctx echo.Context, id string) error
	// Get ProfilerItem by ID
	// (GET /system/profiler/{id})
	GetSystemProfilerId(ctx echo.Context, id string) error
	// Update ProfilerItem
	// (PATCH /system/profiler/{id})
	PatchSystemProfilerId(ctx echo.Context, id string) error
	// Get a list of Project objects
	// (GET /system/projects)
	GetSystemProjects(ctx echo.Context) error
	// Create Project
	// (POST /system/projects)
	PostSystemProjects(ctx echo.Context) error
	// Delete Project
	// (DELETE /system/projects/{id})
	DeleteSystemProjectsId(ctx echo.Context, id string) error
	// Get Project by ID
	// (GET /system/projects/{id})
	GetSystemProjectsId(ctx echo.Context, id string) error
	// Update Project
	// (PATCH /system/projects/{id})
	PatchSystemProjectsId(ctx echo.Context, id string) error
	// Get Project ACL
	// (GET /system/projects/{id}/acl)
	GetSystemProjectsIdAcl(ctx echo.Context, id string) error
	// Modify Project ACL
	// (POST /system/projects/{id}/acl/apply)
	PostSystemProjectsIdAclApply(ctx echo.Context, id string) error
	// Get Project Teams
	// (GET /system/projects/{id}/acl/teams)
	GetSystemProjectsIdAclTeams(ctx echo.Context, id string) error
	// Modify Project Teams ACL
	// (POST /system/projects/{id}/acl/teams/apply)
	PostSystemProjectsIdAclTeamsApply(ctx echo.Context, id string) error
	// Capture live incoming data from a particular project and subscription at the destination
	// (POST /system/projects/{projectId}/capture)
	PostSystemProjectsProjectIdCapture(ctx echo.Context, projectId string) error
	// Lists destinations associated with this project.
	// (GET /system/projects/{projectId}/destinations)
	GetSystemProjectsProjectIdDestinations(ctx echo.Context, projectId string) error
	// Get the subscriptions associated with the project
	// (GET /system/projects/{projectId}/subscriptions)
	GetSystemProjectsProjectIdSubscriptions(ctx echo.Context, projectId string) error
	// Capture live incoming data from a particular project and subscription at the subscription
	// (POST /system/projects/{projectId}/subscriptions/{subscriptionId}/capture)
	PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx echo.Context, projectId string, subscriptionId string) error
	// Commit project changes.
	// (POST /system/projects/{projectId}/version/commit)
	PostSystemProjectsProjectIdVersionCommit(ctx echo.Context, projectId string) error
	// get the count of files of changed
	// (GET /system/projects/{projectId}/version/count)
	GetSystemProjectsProjectIdVersionCount(ctx echo.Context, projectId string, params GetSystemProjectsProjectIdVersionCountParams) error
	// get the textual diff for given commit
	// (GET /system/projects/{projectId}/version/diff)
	GetSystemProjectsProjectIdVersionDiff(ctx echo.Context, projectId string, params GetSystemProjectsProjectIdVersionDiffParams) error
	// get the files changed
	// (GET /system/projects/{projectId}/version/files)
	GetSystemProjectsProjectIdVersionFiles(ctx echo.Context, projectId string, params GetSystemProjectsProjectIdVersionFilesParams) error
	// Revert project changes.
	// (POST /system/projects/{projectId}/version/revert)
	PostSystemProjectsProjectIdVersionRevert(ctx echo.Context, projectId string) error
	// Show project changes.
	// (GET /system/projects/{projectId}/version/show)
	GetSystemProjectsProjectIdVersionShow(ctx echo.Context, projectId string, params GetSystemProjectsProjectIdVersionShowParams) error
	// Get a list of Role objects
	// (GET /system/roles)
	GetSystemRoles(ctx echo.Context) error
	// Create Role
	// (POST /system/roles)
	PostSystemRoles(ctx echo.Context) error
	// Delete Role
	// (DELETE /system/roles/{id})
	DeleteSystemRolesId(ctx echo.Context, id string) error
	// Get Role by ID
	// (GET /system/roles/{id})
	GetSystemRolesId(ctx echo.Context, id string) error
	// Update Role
	// (PATCH /system/roles/{id})
	PatchSystemRolesId(ctx echo.Context, id string) error
	// Get a list of DataSample objects
	// (GET /system/samples)
	GetSystemSamples(ctx echo.Context) error
	// Create DataSample
	// (POST /system/samples)
	PostSystemSamples(ctx echo.Context) error
	// Delete DataSample
	// (DELETE /system/samples/{id})
	DeleteSystemSamplesId(ctx echo.Context, id string) error
	// Get DataSample by ID
	// (GET /system/samples/{id})
	GetSystemSamplesId(ctx echo.Context, id string) error
	// Update DataSample
	// (PATCH /system/samples/{id})
	PatchSystemSamplesId(ctx echo.Context, id string) error
	// Get sample content by ID
	// (GET /system/samples/{id}/content)
	GetSystemSamplesIdContent(ctx echo.Context, id string) error
	// Get a list of Script objects
	// (GET /system/scripts)
	GetSystemScripts(ctx echo.Context) error
	// Create Script
	// (POST /system/scripts)
	PostSystemScripts(ctx echo.Context) error
	// Delete Script
	// (DELETE /system/scripts/{id})
	DeleteSystemScriptsId(ctx echo.Context, id string) error
	// Get Script by ID
	// (GET /system/scripts/{id})
	GetSystemScriptsId(ctx echo.Context, id string) error
	// Update Script
	// (PATCH /system/scripts/{id})
	PatchSystemScriptsId(ctx echo.Context, id string) error
	// Get a list of RestSecret objects
	// (GET /system/secrets)
	GetSystemSecrets(ctx echo.Context) error
	// Create RestSecret
	// (POST /system/secrets)
	PostSystemSecrets(ctx echo.Context) error
	// Delete RestSecret
	// (DELETE /system/secrets/{id})
	DeleteSystemSecretsId(ctx echo.Context, id string) error
	// Get RestSecret by ID
	// (GET /system/secrets/{id})
	GetSystemSecretsId(ctx echo.Context, id string) error
	// Update RestSecret
	// (PATCH /system/secrets/{id})
	PatchSystemSecretsId(ctx echo.Context, id string) error
	// Get Cribl system settings. Deprecated: use specific endpoints /system/limits, /system/job-limits, /system/redis-cache-limits, /system/services-limits, /system/settings/git-settings, and /system/settings/conf respectively
	// (GET /system/settings)
	GetSystemSettings(ctx echo.Context) error
	// Update Cribl system settings. Deprecated: use specific endpoints /system/limits, /system/job-limits, /system/settings/git-settings, /system/settings/auth and /system/settings/conf respectively
	// (PATCH /system/settings)
	PatchSystemSettings(ctx echo.Context) error
	// Get authentication settings
	// (GET /system/settings/auth)
	GetSystemSettingsAuth(ctx echo.Context) error
	// Update authentication settings
	// (PATCH /system/settings/auth)
	PatchSystemSettingsAuth(ctx echo.Context) error
	// Get Cribl system settings
	// (GET /system/settings/conf)
	GetSystemSettingsConf(ctx echo.Context) error
	// Update Cribl system settings
	// (PATCH /system/settings/conf)
	PatchSystemSettingsConf(ctx echo.Context) error
	// Get public settings visible to any logged user
	// (GET /system/settings/cribl)
	GetSystemSettingsCribl(ctx echo.Context) error
	// Get git settings
	// (GET /system/settings/git-settings)
	GetSystemSettingsGitSettings(ctx echo.Context) error
	// Update git settings
	// (PATCH /system/settings/git-settings)
	PatchSystemSettingsGitSettings(ctx echo.Context) error
	// Reload Cribl settings from the filesystem
	// (POST /system/settings/reload)
	PostSystemSettingsReload(ctx echo.Context) error
	// Restart Cribl server
	// (POST /system/settings/restart)
	PostSystemSettingsRestart(ctx echo.Context) error
	// Get search limits
	// (GET /system/settings/search-limits)
	GetSystemSettingsSearchLimits(ctx echo.Context) error
	// Get a list of Cribl versions available for upgrade
	// (GET /system/settings/upgrade)
	GetSystemSettingsUpgrade(ctx echo.Context) error
	// Upgrade master node with the provided package
	// (POST /system/settings/upgrade-from-package)
	PostSystemSettingsUpgradeFromPackage(ctx echo.Context) error
	// Upgrade Cribl to a given version
	// (POST /system/settings/upgrade/{version})
	PostSystemSettingsUpgradeVersion(ctx echo.Context, version string) error
	// Get a list of InputStatus objects
	// (GET /system/status/inputs)
	GetSystemStatusInputs(ctx echo.Context) error
	// Get InputStatus by ID
	// (GET /system/status/inputs/{id})
	GetSystemStatusInputsId(ctx echo.Context, id string) error
	// Get a list of OutputStatus objects
	// (GET /system/status/outputs)
	GetSystemStatusOutputs(ctx echo.Context) error
	// Get OutputStatus by ID
	// (GET /system/status/outputs/{id})
	GetSystemStatusOutputsId(ctx echo.Context, id string) error
	// Get a list of Subscription objects
	// (GET /system/subscriptions)
	GetSystemSubscriptions(ctx echo.Context) error
	// Create subscription
	// (POST /system/subscriptions)
	PostSystemSubscriptions(ctx echo.Context) error
	// Delete subscription
	// (DELETE /system/subscriptions/{id})
	DeleteSystemSubscriptionsId(ctx echo.Context, id string) error
	// Get Subscription by ID
	// (GET /system/subscriptions/{id})
	GetSystemSubscriptionsId(ctx echo.Context, id string) error
	// Update subscription
	// (PATCH /system/subscriptions/{id})
	PatchSystemSubscriptionsId(ctx echo.Context, id string) error
	// Get a list of Team objects
	// (GET /system/teams)
	GetSystemTeams(ctx echo.Context, params GetSystemTeamsParams) error
	// Create Team
	// (POST /system/teams)
	PostSystemTeams(ctx echo.Context) error
	// Get user's product roles
	// (GET /system/teams/users/{id}/roles)
	GetSystemTeamsUsersIdRoles(ctx echo.Context, id string) error
	// Delete Team
	// (DELETE /system/teams/{id})
	DeleteSystemTeamsId(ctx echo.Context, id string) error
	// Get Team by ID
	// (GET /system/teams/{id})
	GetSystemTeamsId(ctx echo.Context, id string) error
	// Update Team
	// (PATCH /system/teams/{id})
	PatchSystemTeamsId(ctx echo.Context, id string) error
	// Get Teams's Access Control List
	// (GET /system/teams/{id}/acl)
	GetSystemTeamsIdAcl(ctx echo.Context, id string, params GetSystemTeamsIdAclParams) error
	// Get users on a team
	// (GET /system/teams/{id}/users)
	GetSystemTeamsIdUsers(ctx echo.Context, id string) error
	// Update existing users on a team – admin use only
	// (POST /system/teams/{id}/users)
	PostSystemTeamsIdUsers(ctx echo.Context, id string) error
	// Get a list of User objects
	// (GET /system/users)
	GetSystemUsers(ctx echo.Context) error
	// Create User – admin use only
	// (POST /system/users)
	PostSystemUsers(ctx echo.Context) error
	// Delete User
	// (DELETE /system/users/{id})
	DeleteSystemUsersId(ctx echo.Context, id string) error
	// Get User by ID
	// (GET /system/users/{id})
	GetSystemUsersId(ctx echo.Context, id string) error
	// Update User properties – admin use only
	// (PATCH /system/users/{id})
	PatchSystemUsersId(ctx echo.Context, id string) error
	// Update User except for their roles
	// (PATCH /system/users/{id}/info)
	PatchSystemUsersIdInfo(ctx echo.Context, id string) error
	// Get UI state by key
	// (GET /ui/{key})
	GetUiKey(ctx echo.Context, key string) error
	// Update UI state by key
	// (PATCH /ui/{key})
	PatchUiKey(ctx echo.Context, key string) error
	// get the list of branches
	// (GET /version/branch)
	GetVersionBranch(ctx echo.Context) error
	// create a new commit containing the current configs the given log message describing the changes.
	// (POST /version/commit)
	PostVersionCommit(ctx echo.Context) error
	// get the count of files of changed
	// (GET /version/count)
	GetVersionCount(ctx echo.Context, params GetVersionCountParams) error
	// returns git branch that the config is checked out to, if any
	// (GET /version/current-branch)
	GetVersionCurrentBranch(ctx echo.Context) error
	// get the textual diff for given commit
	// (GET /version/diff)
	GetVersionDiff(ctx echo.Context, params GetVersionDiffParams) error
	// get the files changed
	// (GET /version/files)
	GetVersionFiles(ctx echo.Context, params GetVersionFilesParams) error
	// Get info about versioning availability
	// (GET /version/info)
	GetVersionInfo(ctx echo.Context) error
	// push the current configs to the remote repository.
	// (POST /version/push)
	PostVersionPush(ctx echo.Context) error
	// revert a commit
	// (POST /version/revert)
	PostVersionRevert(ctx echo.Context, params PostVersionRevertParams) error
	// get the log message and textual diff for given commit
	// (GET /version/show)
	GetVersionShow(ctx echo.Context, params GetVersionShowParams) error
	// get the the working tree status
	// (GET /version/status)
	GetVersionStatus(ctx echo.Context, params GetVersionStatusParams) error
	// syncs with remote repo via POST requests
	// (POST /version/sync)
	PostVersionSync(ctx echo.Context) error
	// undo the last commit
	// (POST /version/undo)
	PostVersionUndo(ctx echo.Context, params PostVersionUndoParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAiConsent converts echo context to params.
func (w *ServerInterfaceWrapper) GetAiConsent(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAiConsent(ctx)
	return err
}

// PostAiConsent converts echo context to params.
func (w *ServerInterfaceWrapper) PostAiConsent(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAiConsent(ctx)
	return err
}

// GetAuthAuthorizationCodeCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthAuthorizationCodeCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthAuthorizationCodeCallbackParams
	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthAuthorizationCodeCallback(ctx, params)
	return err
}

// GetAuthGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthGroups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthGroups(ctx)
	return err
}

// PostAuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthLogin(ctx)
	return err
}

// PostAuthLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthLogout(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthLogout(ctx)
	return err
}

// GetAuthMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthMetadata(ctx)
	return err
}

// GetAuthMultiFactor converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthMultiFactor(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthMultiFactor(ctx)
	return err
}

// GetAuthSlo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthSlo(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthSlo(ctx)
	return err
}

// GetAuthSloCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthSloCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthSloCallbackParams
	// ------------- Optional query parameter "SAMLResponse" -------------

	err = runtime.BindQueryParameter("form", true, false, "SAMLResponse", ctx.QueryParams(), &params.SAMLResponse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter SAMLResponse: %s", err))
	}

	// ------------- Optional query parameter "RelayState" -------------

	err = runtime.BindQueryParameter("form", true, false, "RelayState", ctx.QueryParams(), &params.RelayState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter RelayState: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthSloCallback(ctx, params)
	return err
}

// PostAuthSloCallback converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSloCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthSloCallback(ctx)
	return err
}

// GetAuthSso converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthSso(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthSso(ctx)
	return err
}

// GetAuthSsoCallback converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthSsoCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthSsoCallbackParams
	// ------------- Optional query parameter "SAMLResponse" -------------

	err = runtime.BindQueryParameter("form", true, false, "SAMLResponse", ctx.QueryParams(), &params.SAMLResponse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter SAMLResponse: %s", err))
	}

	// ------------- Optional query parameter "RelayState" -------------

	err = runtime.BindQueryParameter("form", true, false, "RelayState", ctx.QueryParams(), &params.RelayState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter RelayState: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthSsoCallback(ctx, params)
	return err
}

// PostAuthSsoCallback converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSsoCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthSsoCallback(ctx)
	return err
}

// DeleteAuthUsersIdToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthUsersIdToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthUsersIdToken(ctx, id)
	return err
}

// GetAuthorizePolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthorizePolicy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthorizePolicy(ctx)
	return err
}

// GetAuthorizeRoles converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthorizeRoles(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthorizeRoles(ctx)
	return err
}

// GetChangelogViewed converts echo context to params.
func (w *ServerInterfaceWrapper) GetChangelogViewed(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetChangelogViewed(ctx)
	return err
}

// PatchChangelogViewed converts echo context to params.
func (w *ServerInterfaceWrapper) PatchChangelogViewed(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchChangelogViewed(ctx)
	return err
}

// GetClui converts echo context to params.
func (w *ServerInterfaceWrapper) GetClui(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCluiParams
	// ------------- Required query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, true, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "context" -------------

	err = runtime.BindQueryParameter("form", true, false, "context", ctx.QueryParams(), &params.Context)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter context: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClui(ctx, params)
	return err
}

// GetCollectors converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectors(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectors(ctx)
	return err
}

// GetCollectorsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectorsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectorsId(ctx, id)
	return err
}

// GetConditions converts echo context to params.
func (w *ServerInterfaceWrapper) GetConditions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConditions(ctx)
	return err
}

// GetConditionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetConditionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConditionsId(ctx, id)
	return err
}

// GetEdgeAppscopeProcesses converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeAppscopeProcesses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeAppscopeProcesses(ctx)
	return err
}

// PostEdgeAppscopeProcesses converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdgeAppscopeProcesses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEdgeAppscopeProcessesParams
	// ------------- Required query parameter "pid" -------------

	err = runtime.BindQueryParameter("form", true, true, "pid", ctx.QueryParams(), &params.Pid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdgeAppscopeProcesses(ctx, params)
	return err
}

// DeleteEdgeAppscopeProcessesPid converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEdgeAppscopeProcessesPid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pid" -------------
	var pid string

	err = runtime.BindStyledParameterWithOptions("simple", "pid", ctx.Param("pid"), &pid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pid: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEdgeAppscopeProcessesPid(ctx, pid)
	return err
}

// GetEdgeAppscopeProcessesPid converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeAppscopeProcessesPid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pid" -------------
	var pid string

	err = runtime.BindStyledParameterWithOptions("simple", "pid", ctx.Param("pid"), &pid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pid: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeAppscopeProcessesPid(ctx, pid)
	return err
}

// PutEdgeAppscopeProcessesPid converts echo context to params.
func (w *ServerInterfaceWrapper) PutEdgeAppscopeProcessesPid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pid" -------------
	var pid string

	err = runtime.BindStyledParameterWithOptions("simple", "pid", ctx.Param("pid"), &pid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pid: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutEdgeAppscopeProcessesPid(ctx, pid)
	return err
}

// GetEdgeContainers converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeContainers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeContainers(ctx)
	return err
}

// GetEdgeContainersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeContainersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeContainersId(ctx, id)
	return err
}

// GetEdgeEventsCollectors converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeEventsCollectors(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeEventsCollectors(ctx)
	return err
}

// GetEdgeEventsQuery converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeEventsQuery(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEdgeEventsQueryParams
	// ------------- Optional query parameter "Files" -------------

	err = runtime.BindQueryParameter("form", true, false, "Files", ctx.QueryParams(), &params.Files)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Files: %s", err))
	}

	// ------------- Optional query parameter "source" -------------

	err = runtime.BindQueryParameter("form", true, false, "source", ctx.QueryParams(), &params.Source)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "et" -------------

	err = runtime.BindQueryParameter("form", true, false, "et", ctx.QueryParams(), &params.Et)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter et: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeEventsQuery(ctx, params)
	return err
}

// PostEdgeFileIngest converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdgeFileIngest(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEdgeFileIngestParams
	// ------------- Optional query parameter "filePath" -------------

	err = runtime.BindQueryParameter("form", true, false, "filePath", ctx.QueryParams(), &params.FilePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filePath: %s", err))
	}

	// ------------- Optional query parameter "pipelineId" -------------

	err = runtime.BindQueryParameter("form", true, false, "pipelineId", ctx.QueryParams(), &params.PipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipelineId: %s", err))
	}

	// ------------- Optional query parameter "outputId" -------------

	err = runtime.BindQueryParameter("form", true, false, "outputId", ctx.QueryParams(), &params.OutputId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter outputId: %s", err))
	}

	// ------------- Optional query parameter "preProcessingPipelineId" -------------

	err = runtime.BindQueryParameter("form", true, false, "preProcessingPipelineId", ctx.QueryParams(), &params.PreProcessingPipelineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter preProcessingPipelineId: %s", err))
	}

	// ------------- Optional query parameter "sendToRoutes" -------------

	err = runtime.BindQueryParameter("form", true, false, "sendToRoutes", ctx.QueryParams(), &params.SendToRoutes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sendToRoutes: %s", err))
	}

	// ------------- Optional query parameter "breakerRuleSet" -------------

	err = runtime.BindQueryParameter("form", true, false, "breakerRuleSet", ctx.QueryParams(), &params.BreakerRuleSet)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter breakerRuleSet: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdgeFileIngest(ctx, params)
	return err
}

// GetEdgeFileSample converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeFileSample(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEdgeFileSampleParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Optional query parameter "bytesRequested" -------------

	err = runtime.BindQueryParameter("form", true, false, "bytesRequested", ctx.QueryParams(), &params.BytesRequested)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bytesRequested: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeFileSample(ctx, params)
	return err
}

// GetEdgeFileinspect converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeFileinspect(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeFileinspect(ctx)
	return err
}

// PostEdgeKubeLogs converts echo context to params.
func (w *ServerInterfaceWrapper) PostEdgeKubeLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEdgeKubeLogs(ctx)
	return err
}

// GetEdgeKubeProxy converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeKubeProxy(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEdgeKubeProxyParams
	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeKubeProxy(ctx, params)
	return err
}

// GetEdgeLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEdgeLogsParams
	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// ------------- Optional query parameter "allow" -------------

	err = runtime.BindQueryParameter("form", true, false, "allow", ctx.QueryParams(), &params.Allow)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter allow: %s", err))
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Optional query parameter "depth" -------------

	err = runtime.BindQueryParameter("form", true, false, "depth", ctx.QueryParams(), &params.Depth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter depth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeLogs(ctx, params)
	return err
}

// GetEdgeLsPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeLsPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeLsPath(ctx, path)
	return err
}

// GetEdgeMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeMetadata(ctx)
	return err
}

// GetEdgeProcesses converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeProcesses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeProcesses(ctx)
	return err
}

// GetEdgeProcessesPid converts echo context to params.
func (w *ServerInterfaceWrapper) GetEdgeProcessesPid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pid" -------------
	var pid string

	err = runtime.BindStyledParameterWithOptions("simple", "pid", ctx.Param("pid"), &pid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pid: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEdgeProcessesPid(ctx, pid)
	return err
}

// GetExecutors converts echo context to params.
func (w *ServerInterfaceWrapper) GetExecutors(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetExecutors(ctx)
	return err
}

// GetExecutorsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetExecutorsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetExecutorsId(ctx, id)
	return err
}

// GetFunctions converts echo context to params.
func (w *ServerInterfaceWrapper) GetFunctions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFunctions(ctx)
	return err
}

// GetFunctionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetFunctionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFunctionsId(ctx, id)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "runType" -------------

	err = runtime.BindQueryParameter("form", true, false, "runType", ctx.QueryParams(), &params.RunType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter runType: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "collectorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "collectorId", ctx.QueryParams(), &params.CollectorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collectorId: %s", err))
	}

	// ------------- Optional query parameter "groupId" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupId", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobs(ctx, params)
	return err
}

// PostJobs converts echo context to params.
func (w *ServerInterfaceWrapper) PostJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostJobs(ctx)
	return err
}

// DeleteJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteJobsId(ctx, id)
	return err
}

// GetJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsId(ctx, id)
	return err
}

// PatchJobsIdCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PatchJobsIdCancel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchJobsIdCancel(ctx, id)
	return err
}

// GetJobsIdErrors converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsIdErrors(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsIdErrors(ctx, id)
	return err
}

// GetJobsIdErrorsGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsIdErrorsGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsIdErrorsGroup(ctx, id, group)
	return err
}

// PatchJobsIdKeep converts echo context to params.
func (w *ServerInterfaceWrapper) PatchJobsIdKeep(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchJobsIdKeep(ctx, id)
	return err
}

// PatchJobsIdPause converts echo context to params.
func (w *ServerInterfaceWrapper) PatchJobsIdPause(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchJobsIdPause(ctx, id)
	return err
}

// GetJobsIdResults converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsIdResults(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsIdResults(ctx, id)
	return err
}

// GetJobsIdResultsGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobsIdResultsGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobsIdResultsGroupParams
	// ------------- Optional query parameter "maxFiles" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxFiles", ctx.QueryParams(), &params.MaxFiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxFiles: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobsIdResultsGroup(ctx, id, group, params)
	return err
}

// PatchJobsIdResume converts echo context to params.
func (w *ServerInterfaceWrapper) PatchJobsIdResume(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchJobsIdResume(ctx, id)
	return err
}

// GetLibAppscopeConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibAppscopeConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibAppscopeConfigs(ctx)
	return err
}

// PostLibAppscopeConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibAppscopeConfigs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibAppscopeConfigs(ctx)
	return err
}

// DeleteLibAppscopeConfigsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibAppscopeConfigsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibAppscopeConfigsId(ctx, id)
	return err
}

// GetLibAppscopeConfigsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibAppscopeConfigsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibAppscopeConfigsId(ctx, id)
	return err
}

// PatchLibAppscopeConfigsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibAppscopeConfigsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibAppscopeConfigsId(ctx, id)
	return err
}

// GetLibBreakers converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibBreakers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibBreakers(ctx)
	return err
}

// PostLibBreakers converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibBreakers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibBreakers(ctx)
	return err
}

// DeleteLibBreakersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibBreakersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibBreakersId(ctx, id)
	return err
}

// GetLibBreakersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibBreakersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibBreakersId(ctx, id)
	return err
}

// PatchLibBreakersId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibBreakersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibBreakersId(ctx, id)
	return err
}

// GetLibDatabaseConnections converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibDatabaseConnections(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLibDatabaseConnectionsParams
	// ------------- Optional query parameter "databaseType" -------------

	err = runtime.BindQueryParameter("form", true, false, "databaseType", ctx.QueryParams(), &params.DatabaseType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter databaseType: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibDatabaseConnections(ctx, params)
	return err
}

// PostLibDatabaseConnections converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibDatabaseConnections(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibDatabaseConnections(ctx)
	return err
}

// PostLibDatabaseConnectionsTest converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibDatabaseConnectionsTest(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibDatabaseConnectionsTest(ctx)
	return err
}

// DeleteLibDatabaseConnectionsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibDatabaseConnectionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibDatabaseConnectionsId(ctx, id)
	return err
}

// GetLibDatabaseConnectionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibDatabaseConnectionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibDatabaseConnectionsId(ctx, id)
	return err
}

// PatchLibDatabaseConnectionsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibDatabaseConnectionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibDatabaseConnectionsId(ctx, id)
	return err
}

// PostLibExpression converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibExpression(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibExpression(ctx)
	return err
}

// GetLibGrok converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibGrok(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibGrok(ctx)
	return err
}

// PostLibGrok converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibGrok(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibGrok(ctx)
	return err
}

// DeleteLibGrokId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibGrokId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibGrokId(ctx, id)
	return err
}

// GetLibGrokId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibGrokId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibGrokId(ctx, id)
	return err
}

// PatchLibGrokId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibGrokId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibGrokId(ctx, id)
	return err
}

// GetLibHmacFunctions converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibHmacFunctions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibHmacFunctions(ctx)
	return err
}

// PostLibHmacFunctions converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibHmacFunctions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibHmacFunctions(ctx)
	return err
}

// DeleteLibHmacFunctionsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibHmacFunctionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibHmacFunctionsId(ctx, id)
	return err
}

// GetLibHmacFunctionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibHmacFunctionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibHmacFunctionsId(ctx, id)
	return err
}

// PatchLibHmacFunctionsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibHmacFunctionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibHmacFunctionsId(ctx, id)
	return err
}

// GetLibJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibJobs(ctx)
	return err
}

// PostLibJobs converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibJobs(ctx)
	return err
}

// DeleteLibJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibJobsId(ctx, id)
	return err
}

// GetLibJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibJobsId(ctx, id)
	return err
}

// PatchLibJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibJobsId(ctx, id)
	return err
}

// GetLibParquetSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibParquetSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibParquetSchemas(ctx)
	return err
}

// PostLibParquetSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibParquetSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibParquetSchemas(ctx)
	return err
}

// DeleteLibParquetSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibParquetSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibParquetSchemasId(ctx, id)
	return err
}

// GetLibParquetSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibParquetSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibParquetSchemasId(ctx, id)
	return err
}

// PatchLibParquetSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibParquetSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibParquetSchemasId(ctx, id)
	return err
}

// GetLibParsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibParsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibParsers(ctx)
	return err
}

// PostLibParsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibParsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibParsers(ctx)
	return err
}

// DeleteLibParsersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibParsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibParsersId(ctx, id)
	return err
}

// GetLibParsersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibParsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibParsersId(ctx, id)
	return err
}

// PatchLibParsersId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibParsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibParsersId(ctx, id)
	return err
}

// GetLibProtobufLibraries converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibProtobufLibraries(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLibProtobufLibrariesParams
	// ------------- Required query parameter "onlyWithEncodings" -------------

	err = runtime.BindQueryParameter("form", true, true, "onlyWithEncodings", ctx.QueryParams(), &params.OnlyWithEncodings)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter onlyWithEncodings: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibProtobufLibraries(ctx, params)
	return err
}

// GetLibProtobufLibrariesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibProtobufLibrariesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibProtobufLibrariesId(ctx, id)
	return err
}

// GetLibProtobufLibrariesIdEncodings converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibProtobufLibrariesIdEncodings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibProtobufLibrariesIdEncodings(ctx, id)
	return err
}

// GetLibProtobufLibrariesIdEncodingsEncid converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibProtobufLibrariesIdEncodingsEncid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "encid" -------------
	var encid string

	err = runtime.BindStyledParameterWithOptions("simple", "encid", ctx.Param("encid"), &encid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter encid: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibProtobufLibrariesIdEncodingsEncid(ctx, id, encid)
	return err
}

// GetLibRegex converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibRegex(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibRegex(ctx)
	return err
}

// PostLibRegex converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibRegex(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibRegex(ctx)
	return err
}

// DeleteLibRegexId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibRegexId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibRegexId(ctx, id)
	return err
}

// GetLibRegexId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibRegexId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibRegexId(ctx, id)
	return err
}

// PatchLibRegexId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibRegexId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibRegexId(ctx, id)
	return err
}

// GetLibSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibSchemas(ctx)
	return err
}

// PostLibSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibSchemas(ctx)
	return err
}

// DeleteLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibSchemasId(ctx, id)
	return err
}

// GetLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibSchemasId(ctx, id)
	return err
}

// PatchLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibSchemasId(ctx, id)
	return err
}

// GetLibVars converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibVars(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibVars(ctx)
	return err
}

// PostLibVars converts echo context to params.
func (w *ServerInterfaceWrapper) PostLibVars(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostLibVars(ctx)
	return err
}

// DeleteLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteLibVarsId(ctx, id)
	return err
}

// GetLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLibVarsId(ctx, id)
	return err
}

// PatchLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchLibVarsId(ctx, id)
	return err
}

// PostMGroupIdSystemProjectsProjectIdCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostMGroupIdSystemProjectsProjectIdCapture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostMGroupIdSystemProjectsProjectIdCapture(ctx, groupId, projectId)
	return err
}

// GetMGroupIdSystemProjectsProjectIdPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdPipelines(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdPipelines(ctx, groupId, projectId)
	return err
}

// PostMGroupIdSystemProjectsProjectIdPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) PostMGroupIdSystemProjectsProjectIdPipelines(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostMGroupIdSystemProjectsProjectIdPipelines(ctx, groupId, projectId)
	return err
}

// DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameterWithOptions("simple", "pipelineId", ctx.Param("pipelineId"), &pipelineId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipelineId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId)
	return err
}

// GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameterWithOptions("simple", "pipelineId", ctx.Param("pipelineId"), &pipelineId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipelineId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId)
	return err
}

// PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "pipelineId" -------------
	var pipelineId string

	err = runtime.BindStyledParameterWithOptions("simple", "pipelineId", ctx.Param("pipelineId"), &pipelineId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pipelineId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId(ctx, groupId, projectId, pipelineId)
	return err
}

// PostMGroupIdSystemProjectsProjectIdPreview converts echo context to params.
func (w *ServerInterfaceWrapper) PostMGroupIdSystemProjectsProjectIdPreview(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostMGroupIdSystemProjectsProjectIdPreview(ctx, groupId, projectId)
	return err
}

// GetMGroupIdSystemProjectsProjectIdSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdSubscriptions(ctx, groupId, projectId)
	return err
}

// PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", ctx.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscriptionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx, groupId, projectId, subscriptionId)
	return err
}

// PostMGroupIdSystemProjectsProjectIdVersionCommit converts echo context to params.
func (w *ServerInterfaceWrapper) PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostMGroupIdSystemProjectsProjectIdVersionCommit(ctx, groupId, projectId)
	return err
}

// GetMGroupIdSystemProjectsProjectIdVersionCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdVersionCount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdVersionCount(ctx, groupId, projectId)
	return err
}

// GetMGroupIdSystemProjectsProjectIdVersionDiff converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMGroupIdSystemProjectsProjectIdVersionDiffParams
	// ------------- Optional query parameter "commit" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit", ctx.QueryParams(), &params.Commit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdVersionDiff(ctx, groupId, projectId, params)
	return err
}

// GetMGroupIdSystemProjectsProjectIdVersionFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMGroupIdSystemProjectsProjectIdVersionFiles(ctx, groupId, projectId)
	return err
}

// GetMasterBundlesGroupVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterBundlesGroupVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", ctx.Param("version"), &version, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterBundlesGroupVersion(ctx, group, version)
	return err
}

// GetMasterGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMasterGroupsIdParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterGroupsId(ctx, id, params)
	return err
}

// GetMasterGroupsIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterGroupsIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMasterGroupsIdAclParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterGroupsIdAcl(ctx, id, params)
	return err
}

// GetMasterGroupsIdConfigVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterGroupsIdConfigVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterGroupsIdConfigVersion(ctx, id)
	return err
}

// PatchMasterGroupsIdDeploy converts echo context to params.
func (w *ServerInterfaceWrapper) PatchMasterGroupsIdDeploy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchMasterGroupsIdDeploy(ctx, id)
	return err
}

// GetMasterSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterSummary(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMasterSummaryParams
	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterSummary(ctx, params)
	return err
}

// GetMasterSummaryWorkers converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterSummaryWorkers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMasterSummaryWorkersParams
	// ------------- Optional query parameter "filterExp" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterExp", ctx.QueryParams(), &params.FilterExp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterExp: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterSummaryWorkers(ctx, params)
	return err
}

// GetMasterWorkers converts echo context to params.
func (w *ServerInterfaceWrapper) GetMasterWorkers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMasterWorkersParams
	// ------------- Optional query parameter "filterExp" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterExp", ctx.QueryParams(), &params.FilterExp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterExp: %s", err))
	}

	// ------------- Optional query parameter "sortExp" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortExp", ctx.QueryParams(), &params.SortExp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sortExp: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMasterWorkers(ctx, params)
	return err
}

// PatchMasterWorkersRestart converts echo context to params.
func (w *ServerInterfaceWrapper) PatchMasterWorkersRestart(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchMasterWorkersRestart(ctx)
	return err
}

// GetNotificationTargets converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotificationTargets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotificationTargets(ctx)
	return err
}

// PostNotificationTargets converts echo context to params.
func (w *ServerInterfaceWrapper) PostNotificationTargets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostNotificationTargets(ctx)
	return err
}

// DeleteNotificationTargetsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNotificationTargetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNotificationTargetsId(ctx, id)
	return err
}

// GetNotificationTargetsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotificationTargetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotificationTargetsId(ctx, id)
	return err
}

// PatchNotificationTargetsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchNotificationTargetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchNotificationTargetsId(ctx, id)
	return err
}

// GetNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotifications(ctx)
	return err
}

// PostNotifications converts echo context to params.
func (w *ServerInterfaceWrapper) PostNotifications(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostNotifications(ctx)
	return err
}

// DeleteNotificationsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNotificationsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNotificationsId(ctx, id)
	return err
}

// GetNotificationsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetNotificationsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNotificationsId(ctx, id)
	return err
}

// PatchNotificationsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchNotificationsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchNotificationsId(ctx, id)
	return err
}

// PostOutputClickHouseDescribeTable converts echo context to params.
func (w *ServerInterfaceWrapper) PostOutputClickHouseDescribeTable(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostOutputClickHouseDescribeTable(ctx)
	return err
}

// GetPPackFunctions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackFunctions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackFunctions(ctx, pack)
	return err
}

// GetPPackFunctionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackFunctionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackFunctionsId(ctx, pack, id)
	return err
}

// GetPPackLibSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackLibSchemas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackLibSchemas(ctx, pack)
	return err
}

// PostPPackLibSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) PostPPackLibSchemas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPPackLibSchemas(ctx, pack)
	return err
}

// DeletePPackLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePPackLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePPackLibSchemasId(ctx, pack, id)
	return err
}

// GetPPackLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackLibSchemasId(ctx, pack, id)
	return err
}

// PatchPPackLibSchemasId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPPackLibSchemasId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPPackLibSchemasId(ctx, pack, id)
	return err
}

// GetPPackLibVars converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackLibVars(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackLibVars(ctx, pack)
	return err
}

// PostPPackLibVars converts echo context to params.
func (w *ServerInterfaceWrapper) PostPPackLibVars(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPPackLibVars(ctx, pack)
	return err
}

// DeletePPackLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePPackLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePPackLibVarsId(ctx, pack, id)
	return err
}

// GetPPackLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackLibVarsId(ctx, pack, id)
	return err
}

// PatchPPackLibVarsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPPackLibVarsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPPackLibVarsId(ctx, pack, id)
	return err
}

// GetPPackPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackPipelines(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackPipelines(ctx, pack)
	return err
}

// PostPPackPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) PostPPackPipelines(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPPackPipelines(ctx, pack)
	return err
}

// DeletePPackPipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePPackPipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePPackPipelinesId(ctx, pack, id)
	return err
}

// GetPPackPipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackPipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackPipelinesId(ctx, pack, id)
	return err
}

// PatchPPackPipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPPackPipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPPackPipelinesId(ctx, pack, id)
	return err
}

// GetPPackRoutes converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackRoutes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackRoutes(ctx, pack)
	return err
}

// GetPPackRoutesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPPackRoutesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPPackRoutesId(ctx, pack, id)
	return err
}

// PatchPPackRoutesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPPackRoutesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPPackRoutesId(ctx, pack, id)
	return err
}

// PostPPackRoutesIdAppend converts echo context to params.
func (w *ServerInterfaceWrapper) PostPPackRoutesIdAppend(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pack" -------------
	var pack string

	err = runtime.BindStyledParameterWithOptions("simple", "pack", ctx.Param("pack"), &pack, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pack: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPPackRoutesIdAppend(ctx, pack, id)
	return err
}

// GetPacks converts echo context to params.
func (w *ServerInterfaceWrapper) GetPacks(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPacks(ctx)
	return err
}

// PostPacks converts echo context to params.
func (w *ServerInterfaceWrapper) PostPacks(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPacks(ctx)
	return err
}

// PutPacks converts echo context to params.
func (w *ServerInterfaceWrapper) PutPacks(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutPacksParams
	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutPacks(ctx, params)
	return err
}

// PostPacksClone converts echo context to params.
func (w *ServerInterfaceWrapper) PostPacksClone(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPacksClone(ctx)
	return err
}

// DeletePacksId converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePacksId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePacksId(ctx, id)
	return err
}

// PatchPacksId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPacksId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchPacksIdParams
	// ------------- Optional query parameter "source" -------------

	err = runtime.BindQueryParameter("form", true, false, "source", ctx.QueryParams(), &params.Source)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source: %s", err))
	}

	// ------------- Optional query parameter "minor" -------------

	err = runtime.BindQueryParameter("form", true, false, "minor", ctx.QueryParams(), &params.Minor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minor: %s", err))
	}

	// ------------- Optional query parameter "spec" -------------

	err = runtime.BindQueryParameter("form", true, false, "spec", ctx.QueryParams(), &params.Spec)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter spec: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPacksId(ctx, id, params)
	return err
}

// GetPacksIdExport converts echo context to params.
func (w *ServerInterfaceWrapper) GetPacksIdExport(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPacksIdExportParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPacksIdExport(ctx, id, params)
	return err
}

// GetPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipelines(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPipelines(ctx)
	return err
}

// PostPipelines converts echo context to params.
func (w *ServerInterfaceWrapper) PostPipelines(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPipelines(ctx)
	return err
}

// DeletePipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePipelinesId(ctx, id)
	return err
}

// GetPipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPipelinesId(ctx, id)
	return err
}

// PatchPipelinesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchPipelinesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchPipelinesId(ctx, id)
	return err
}

// PostPreview converts echo context to params.
func (w *ServerInterfaceWrapper) PostPreview(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostPreview(ctx)
	return err
}

// PostProductsEdgeMapQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsEdgeMapQuery(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductsEdgeMapQuery(ctx)
	return err
}

// GetProductsLakeLakesLakeIdDatasets converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsLakeLakesLakeIdDatasets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lakeId" -------------
	var lakeId string

	err = runtime.BindStyledParameterWithOptions("simple", "lakeId", ctx.Param("lakeId"), &lakeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lakeId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsLakeLakesLakeIdDatasets(ctx, lakeId)
	return err
}

// PostProductsLakeLakesLakeIdDatasets converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsLakeLakesLakeIdDatasets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lakeId" -------------
	var lakeId string

	err = runtime.BindStyledParameterWithOptions("simple", "lakeId", ctx.Param("lakeId"), &lakeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lakeId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductsLakeLakesLakeIdDatasets(ctx, lakeId)
	return err
}

// DeleteProductsLakeLakesLakeIdDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsLakeLakesLakeIdDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lakeId" -------------
	var lakeId string

	err = runtime.BindStyledParameterWithOptions("simple", "lakeId", ctx.Param("lakeId"), &lakeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lakeId: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id)
	return err
}

// GetProductsLakeLakesLakeIdDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsLakeLakesLakeIdDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lakeId" -------------
	var lakeId string

	err = runtime.BindStyledParameterWithOptions("simple", "lakeId", ctx.Param("lakeId"), &lakeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lakeId: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id)
	return err
}

// PatchProductsLakeLakesLakeIdDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProductsLakeLakesLakeIdDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lakeId" -------------
	var lakeId string

	err = runtime.BindStyledParameterWithOptions("simple", "lakeId", ctx.Param("lakeId"), &lakeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lakeId: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProductsLakeLakesLakeIdDatasetsId(ctx, lakeId, id)
	return err
}

// GetProductsProductGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProductGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product GetProductsProductGroupsParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsProductGroupsParams
	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsProductGroups(ctx, product, params)
	return err
}

// PostProductsProductGroups converts echo context to params.
func (w *ServerInterfaceWrapper) PostProductsProductGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product PostProductsProductGroupsParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProductsProductGroups(ctx, product)
	return err
}

// GetProductsProductGroupsIdAclTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProductGroupsIdAclTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product GetProductsProductGroupsIdAclTeamsParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsProductGroupsIdAclTeamsParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsProductGroupsIdAclTeams(ctx, product, id, params)
	return err
}

// GetProductsProductUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProductUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product GetProductsProductUsersParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsProductUsersParams
	// ------------- Optional query parameter "groupId" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupId", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsProductUsers(ctx, product, params)
	return err
}

// DeleteProductsProductUsersCache converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProductsProductUsersCache(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product DeleteProductsProductUsersCacheParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProductsProductUsersCache(ctx, product)
	return err
}

// GetProductsProductUsersIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsProductUsersIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "product" -------------
	var product GetProductsProductUsersIdAclParamsProduct

	err = runtime.BindStyledParameterWithOptions("simple", "product", ctx.Param("product"), &product, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsProductUsersIdAclParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsProductUsersIdAcl(ctx, product, id, params)
	return err
}

// GetRoutes converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoutes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoutes(ctx)
	return err
}

// GetRoutesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoutesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoutesId(ctx, id)
	return err
}

// PatchRoutesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchRoutesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchRoutesId(ctx, id)
	return err
}

// PostRoutesIdAppend converts echo context to params.
func (w *ServerInterfaceWrapper) PostRoutesIdAppend(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRoutesIdAppend(ctx, id)
	return err
}

// GetSearchDashboardCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboardCategories(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboardCategories(ctx)
	return err
}

// PostSearchDashboardCategories converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDashboardCategories(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDashboardCategories(ctx)
	return err
}

// DeleteSearchDashboardCategoriesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchDashboardCategoriesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchDashboardCategoriesId(ctx, id)
	return err
}

// GetSearchDashboardCategoriesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboardCategoriesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboardCategoriesId(ctx, id)
	return err
}

// PatchSearchDashboardCategoriesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchDashboardCategoriesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchDashboardCategoriesId(ctx, id)
	return err
}

// GetSearchDashboards converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboards(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboards(ctx)
	return err
}

// PostSearchDashboards converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDashboards(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDashboards(ctx)
	return err
}

// DeleteSearchDashboardsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchDashboardsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchDashboardsId(ctx, id)
	return err
}

// GetSearchDashboardsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboardsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboardsId(ctx, id)
	return err
}

// PatchSearchDashboardsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchDashboardsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchDashboardsId(ctx, id)
	return err
}

// GetSearchDashboardsIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboardsIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboardsIdAcl(ctx, id)
	return err
}

// PostSearchDashboardsIdAclApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDashboardsIdAclApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDashboardsIdAclApply(ctx, id)
	return err
}

// GetSearchDashboardsIdAclTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDashboardsIdAclTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDashboardsIdAclTeams(ctx, id)
	return err
}

// PostSearchDashboardsIdAclTeamsApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDashboardsIdAclTeamsApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDashboardsIdAclTeamsApply(ctx, id)
	return err
}

// GetSearchDatasetProviderTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetProviderTypes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetProviderTypes(ctx)
	return err
}

// PostSearchDatasetProviderTypes converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDatasetProviderTypes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDatasetProviderTypes(ctx)
	return err
}

// DeleteSearchDatasetProviderTypesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchDatasetProviderTypesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchDatasetProviderTypesId(ctx, id)
	return err
}

// GetSearchDatasetProviderTypesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetProviderTypesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetProviderTypesId(ctx, id)
	return err
}

// PatchSearchDatasetProviderTypesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchDatasetProviderTypesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchDatasetProviderTypesId(ctx, id)
	return err
}

// GetSearchDatasetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetProviders(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetProviders(ctx)
	return err
}

// PostSearchDatasetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDatasetProviders(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDatasetProviders(ctx)
	return err
}

// DeleteSearchDatasetProvidersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchDatasetProvidersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchDatasetProvidersId(ctx, id)
	return err
}

// GetSearchDatasetProvidersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetProvidersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetProvidersId(ctx, id)
	return err
}

// PatchSearchDatasetProvidersId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchDatasetProvidersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchDatasetProvidersId(ctx, id)
	return err
}

// GetSearchDatasets converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasets(ctx)
	return err
}

// PostSearchDatasets converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDatasets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDatasets(ctx)
	return err
}

// DeleteSearchDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchDatasetsId(ctx, id)
	return err
}

// GetSearchDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetsId(ctx, id)
	return err
}

// PatchSearchDatasetsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchDatasetsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchDatasetsId(ctx, id)
	return err
}

// GetSearchDatasetsIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetsIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetsIdAcl(ctx, id)
	return err
}

// PostSearchDatasetsIdAclApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDatasetsIdAclApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDatasetsIdAclApply(ctx, id)
	return err
}

// GetSearchDatasetsIdAclTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchDatasetsIdAclTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchDatasetsIdAclTeams(ctx, id)
	return err
}

// PostSearchDatasetsIdAclTeamsApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchDatasetsIdAclTeamsApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchDatasetsIdAclTeamsApply(ctx, id)
	return err
}

// PostSearchEventBreakerPreview converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchEventBreakerPreview(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchEventBreakerPreview(ctx)
	return err
}

// GetSearchHealthcheck converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchHealthcheck(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchHealthcheck(ctx)
	return err
}

// GetSearchJobMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobMetrics(ctx)
	return err
}

// GetSearchJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobs(ctx)
	return err
}

// PostSearchJobs converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchJobs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchJobs(ctx)
	return err
}

// DeleteSearchJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchJobsId(ctx, id)
	return err
}

// GetSearchJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsId(ctx, id)
	return err
}

// PatchSearchJobsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchJobsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchJobsId(ctx, id)
	return err
}

// PostSearchJobsIdDispatchExecutors converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchJobsIdDispatchExecutors(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchJobsIdDispatchExecutors(ctx, id)
	return err
}

// GetSearchJobsIdLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsIdLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsIdLogs(ctx, id)
	return err
}

// GetSearchJobsIdMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsIdMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsIdMetrics(ctx, id)
	return err
}

// GetSearchJobsIdResults converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsIdResults(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSearchJobsIdResultsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "lowerBound" -------------

	err = runtime.BindQueryParameter("form", true, false, "lowerBound", ctx.QueryParams(), &params.LowerBound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lowerBound: %s", err))
	}

	// ------------- Optional query parameter "upperBound" -------------

	err = runtime.BindQueryParameter("form", true, false, "upperBound", ctx.QueryParams(), &params.UpperBound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter upperBound: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsIdResults(ctx, id, params)
	return err
}

// GetSearchJobsIdResultsPoll converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsIdResultsPoll(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSearchJobsIdResultsPollParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "lowerBound" -------------

	err = runtime.BindQueryParameter("form", true, false, "lowerBound", ctx.QueryParams(), &params.LowerBound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lowerBound: %s", err))
	}

	// ------------- Optional query parameter "upperBound" -------------

	err = runtime.BindQueryParameter("form", true, false, "upperBound", ctx.QueryParams(), &params.UpperBound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter upperBound: %s", err))
	}

	// ------------- Optional query parameter "lastJobStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "lastJobStatus", ctx.QueryParams(), &params.LastJobStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lastJobStatus: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsIdResultsPoll(ctx, id, params)
	return err
}

// GetSearchJobsIdStagesStageIdResults converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchJobsIdStagesStageIdResults(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "stageId" -------------
	var stageId string

	err = runtime.BindStyledParameterWithOptions("simple", "stageId", ctx.Param("stageId"), &stageId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stageId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchJobsIdStagesStageIdResults(ctx, id, stageId)
	return err
}

// GetSearchMacros converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchMacros(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchMacros(ctx)
	return err
}

// PostSearchMacros converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchMacros(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchMacros(ctx)
	return err
}

// DeleteSearchMacrosId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchMacrosId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchMacrosId(ctx, id)
	return err
}

// GetSearchMacrosId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchMacrosId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchMacrosId(ctx, id)
	return err
}

// PatchSearchMacrosId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchMacrosId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchMacrosId(ctx, id)
	return err
}

// PostSearchPreview converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchPreview(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchPreview(ctx)
	return err
}

// GetSearchSaved converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchSaved(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchSaved(ctx)
	return err
}

// PostSearchSaved converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchSaved(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchSaved(ctx)
	return err
}

// DeleteSearchSavedId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchSavedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchSavedId(ctx, id)
	return err
}

// GetSearchSavedId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchSavedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchSavedId(ctx, id)
	return err
}

// PatchSearchSavedId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchSavedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchSavedId(ctx, id)
	return err
}

// GetSearchTrustPolicies converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchTrustPolicies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchTrustPolicies(ctx)
	return err
}

// GetSearchUsageGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchUsageGroups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchUsageGroups(ctx)
	return err
}

// PostSearchUsageGroups converts echo context to params.
func (w *ServerInterfaceWrapper) PostSearchUsageGroups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSearchUsageGroups(ctx)
	return err
}

// DeleteSearchUsageGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSearchUsageGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSearchUsageGroupsId(ctx, id)
	return err
}

// GetSearchUsageGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchUsageGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchUsageGroupsId(ctx, id)
	return err
}

// PatchSearchUsageGroupsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSearchUsageGroupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSearchUsageGroupsId(ctx, id)
	return err
}

// GetSecurityKmsConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetSecurityKmsConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSecurityKmsConfig(ctx)
	return err
}

// PatchSecurityKmsConfig converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSecurityKmsConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSecurityKmsConfig(ctx)
	return err
}

// GetSecurityKmsHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetSecurityKmsHealth(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSecurityKmsHealth(ctx)
	return err
}

// GetSettingsFeatures converts echo context to params.
func (w *ServerInterfaceWrapper) GetSettingsFeatures(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSettingsFeatures(ctx)
	return err
}

// GetSettingsFeaturesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSettingsFeaturesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSettingsFeaturesId(ctx, id)
	return err
}

// GetSystemBanners converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemBanners(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemBanners(ctx)
	return err
}

// PostSystemBanners converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemBanners(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemBanners(ctx)
	return err
}

// DeleteSystemBannersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemBannersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemBannersId(ctx, id)
	return err
}

// GetSystemBannersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemBannersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemBannersId(ctx, id)
	return err
}

// PatchSystemBannersId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemBannersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemBannersId(ctx, id)
	return err
}

// PostSystemCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemCapture(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemCapture(ctx)
	return err
}

// GetSystemCertificates converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemCertificates(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemCertificates(ctx)
	return err
}

// PostSystemCertificates converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemCertificates(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemCertificates(ctx)
	return err
}

// DeleteSystemCertificatesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemCertificatesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemCertificatesId(ctx, id)
	return err
}

// GetSystemCertificatesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemCertificatesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemCertificatesId(ctx, id)
	return err
}

// PatchSystemCertificatesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemCertificatesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemCertificatesId(ctx, id)
	return err
}

// DeleteSystemDiag converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemDiag(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSystemDiagParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemDiag(ctx, params)
	return err
}

// GetSystemDiag converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemDiag(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemDiag(ctx)
	return err
}

// GetSystemDiagDownload converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemDiagDownload(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemDiagDownload(ctx)
	return err
}

// PostSystemDiagSend converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemDiagSend(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemDiagSend(ctx)
	return err
}

// PostSystemDistributedUpgradeCancelGroup converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemDistributedUpgradeCancelGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemDistributedUpgradeCancelGroup(ctx, group)
	return err
}

// GetSystemDistributedUpgradeDownloadFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemDistributedUpgradeDownloadFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "file" -------------
	var file string

	err = runtime.BindStyledParameterWithOptions("simple", "file", ctx.Param("file"), &file, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter file: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemDistributedUpgradeDownloadFile(ctx, file)
	return err
}

// PostSystemDistributedUpgradeStageGroup converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemDistributedUpgradeStageGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSystemDistributedUpgradeStageGroupParams
	// ------------- Optional query parameter "upgradePercentage" -------------

	err = runtime.BindQueryParameter("form", true, false, "upgradePercentage", ctx.QueryParams(), &params.UpgradePercentage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter upgradePercentage: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemDistributedUpgradeStageGroup(ctx, group, params)
	return err
}

// PostSystemDistributedUpgradeGroup converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemDistributedUpgradeGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "group" -------------
	var group string

	err = runtime.BindStyledParameterWithOptions("simple", "group", ctx.Param("group"), &group, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemDistributedUpgradeGroup(ctx, group)
	return err
}

// GetSystemInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemInfo(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemInfo(ctx)
	return err
}

// GetSystemInputs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemInputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemInputs(ctx)
	return err
}

// PostSystemInputs converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemInputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemInputs(ctx)
	return err
}

// DeleteSystemInputsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemInputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemInputsId(ctx, id)
	return err
}

// GetSystemInputsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemInputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemInputsId(ctx, id)
	return err
}

// PatchSystemInputsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemInputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemInputsId(ctx, id)
	return err
}

// PostSystemInputsIdHectoken converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemInputsIdHectoken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemInputsIdHectoken(ctx, id)
	return err
}

// PatchSystemInputsIdHectokenToken converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemInputsIdHectokenToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", ctx.Param("token"), &token, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemInputsIdHectokenToken(ctx, id, token)
	return err
}

// GetSystemJobsLogsIdGroupId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemJobsLogsIdGroupId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "groupId", ctx.Param("groupId"), &groupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemJobsLogsIdGroupIdParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "endOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "endOffset", ctx.QueryParams(), &params.EndOffset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endOffset: %s", err))
	}

	// ------------- Optional query parameter "et" -------------

	err = runtime.BindQueryParameter("form", true, false, "et", ctx.QueryParams(), &params.Et)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter et: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemJobsLogsIdGroupId(ctx, id, groupId, params)
	return err
}

// GetSystemKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemKeys(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemKeys(ctx)
	return err
}

// PostSystemKeys converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemKeys(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemKeys(ctx)
	return err
}

// DeleteSystemKeysId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemKeysId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemKeysId(ctx, id)
	return err
}

// GetSystemKeysId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemKeysId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemKeysId(ctx, id)
	return err
}

// PatchSystemKeysId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemKeysId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemKeysId(ctx, id)
	return err
}

// GetSystemLicenses converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLicenses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLicenses(ctx)
	return err
}

// PostSystemLicenses converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemLicenses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemLicenses(ctx)
	return err
}

// GetSystemLicensesUsage converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLicensesUsage(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLicensesUsage(ctx)
	return err
}

// DeleteSystemLicensesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemLicensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemLicensesId(ctx, id)
	return err
}

// GetSystemLicensesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLicensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLicensesId(ctx, id)
	return err
}

// GetSystemLogger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLogger(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLogger(ctx)
	return err
}

// DeleteSystemLoggerId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemLoggerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemLoggerId(ctx, id)
	return err
}

// GetSystemLoggerId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLoggerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLoggerId(ctx, id)
	return err
}

// PatchSystemLoggerId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemLoggerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemLoggerId(ctx, id)
	return err
}

// GetSystemLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLogs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLogs(ctx)
	return err
}

// GetSystemLogsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLogsSearch(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemLogsSearchParams
	// ------------- Required query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, true, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "groupId" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupId", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupId: %s", err))
	}

	// ------------- Optional query parameter "files" -------------

	err = runtime.BindQueryParameter("form", true, false, "files", ctx.QueryParams(), &params.Files)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter files: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "et" -------------

	err = runtime.BindQueryParameter("form", true, false, "et", ctx.QueryParams(), &params.Et)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter et: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLogsSearch(ctx, params)
	return err
}

// GetSystemLogsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLogsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemLogsIdParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "endOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "endOffset", ctx.QueryParams(), &params.EndOffset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endOffset: %s", err))
	}

	// ------------- Optional query parameter "et" -------------

	err = runtime.BindQueryParameter("form", true, false, "et", ctx.QueryParams(), &params.Et)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter et: %s", err))
	}

	// ------------- Optional query parameter "lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "lt", ctx.QueryParams(), &params.Lt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lt: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLogsId(ctx, id, params)
	return err
}

// GetSystemLookups converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLookups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLookups(ctx)
	return err
}

// PostSystemLookups converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemLookups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemLookups(ctx)
	return err
}

// PutSystemLookups converts echo context to params.
func (w *ServerInterfaceWrapper) PutSystemLookups(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutSystemLookupsParams
	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutSystemLookups(ctx, params)
	return err
}

// DeleteSystemLookupsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemLookupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemLookupsId(ctx, id)
	return err
}

// GetSystemLookupsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemLookupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemLookupsId(ctx, id)
	return err
}

// PatchSystemLookupsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemLookupsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemLookupsId(ctx, id)
	return err
}

// GetSystemMessages converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemMessages(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemMessages(ctx)
	return err
}

// PostSystemMessages converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemMessages(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemMessages(ctx)
	return err
}

// DeleteSystemMessagesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemMessagesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemMessagesId(ctx, id)
	return err
}

// GetSystemMessagesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemMessagesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemMessagesId(ctx, id)
	return err
}

// GetSystemMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemMetricsParams
	// ------------- Optional query parameter "wp" -------------

	err = runtime.BindQueryParameter("form", true, false, "wp", ctx.QueryParams(), &params.Wp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wp: %s", err))
	}

	// ------------- Optional query parameter "numBuckets" -------------

	err = runtime.BindQueryParameter("form", true, false, "numBuckets", ctx.QueryParams(), &params.NumBuckets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter numBuckets: %s", err))
	}

	// ------------- Optional query parameter "earliest" -------------

	err = runtime.BindQueryParameter("form", true, false, "earliest", ctx.QueryParams(), &params.Earliest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter earliest: %s", err))
	}

	// ------------- Optional query parameter "latest" -------------

	err = runtime.BindQueryParameter("form", true, false, "latest", ctx.QueryParams(), &params.Latest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter latest: %s", err))
	}

	// ------------- Optional query parameter "metricNameFilter" -------------

	err = runtime.BindQueryParameter("form", true, false, "metricNameFilter", ctx.QueryParams(), &params.MetricNameFilter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metricNameFilter: %s", err))
	}

	// ------------- Optional query parameter "filterExpr" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterExpr", ctx.QueryParams(), &params.FilterExpr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterExpr: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemMetrics(ctx, params)
	return err
}

// PostSystemMetricsEnum converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemMetricsEnum(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemMetricsEnum(ctx)
	return err
}

// PostSystemMetricsQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemMetricsQuery(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemMetricsQuery(ctx)
	return err
}

// GetSystemOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemOutputs(ctx)
	return err
}

// PostSystemOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemOutputs(ctx)
	return err
}

// DeleteSystemOutputsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemOutputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemOutputsId(ctx, id)
	return err
}

// GetSystemOutputsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemOutputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemOutputsId(ctx, id)
	return err
}

// PatchSystemOutputsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemOutputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemOutputsId(ctx, id)
	return err
}

// DeleteSystemOutputsIdPq converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemOutputsIdPq(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemOutputsIdPq(ctx, id)
	return err
}

// GetSystemOutputsIdPq converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemOutputsIdPq(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemOutputsIdPq(ctx, id)
	return err
}

// GetSystemOutputsIdSamples converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemOutputsIdSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemOutputsIdSamples(ctx, id)
	return err
}

// PostSystemOutputsIdTest converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemOutputsIdTest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemOutputsIdTest(ctx, id)
	return err
}

// GetSystemPolicies converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemPolicies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemPolicies(ctx)
	return err
}

// PostSystemPolicies converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemPolicies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemPolicies(ctx)
	return err
}

// DeleteSystemPoliciesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemPoliciesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemPoliciesId(ctx, id)
	return err
}

// GetSystemPoliciesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemPoliciesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemPoliciesId(ctx, id)
	return err
}

// PatchSystemPoliciesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemPoliciesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemPoliciesId(ctx, id)
	return err
}

// GetSystemProcesses converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProcesses(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProcesses(ctx)
	return err
}

// GetSystemProfiler converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProfiler(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProfiler(ctx)
	return err
}

// PostSystemProfiler converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProfiler(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProfiler(ctx)
	return err
}

// DeleteSystemProfilerId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemProfilerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemProfilerId(ctx, id)
	return err
}

// GetSystemProfilerId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProfilerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProfilerId(ctx, id)
	return err
}

// PatchSystemProfilerId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemProfilerId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemProfilerId(ctx, id)
	return err
}

// GetSystemProjects converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjects(ctx)
	return err
}

// PostSystemProjects converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjects(ctx)
	return err
}

// DeleteSystemProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemProjectsId(ctx, id)
	return err
}

// GetSystemProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsId(ctx, id)
	return err
}

// PatchSystemProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemProjectsId(ctx, id)
	return err
}

// GetSystemProjectsIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsIdAcl(ctx, id)
	return err
}

// PostSystemProjectsIdAclApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsIdAclApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsIdAclApply(ctx, id)
	return err
}

// GetSystemProjectsIdAclTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsIdAclTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsIdAclTeams(ctx, id)
	return err
}

// PostSystemProjectsIdAclTeamsApply converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsIdAclTeamsApply(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsIdAclTeamsApply(ctx, id)
	return err
}

// PostSystemProjectsProjectIdCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsProjectIdCapture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsProjectIdCapture(ctx, projectId)
	return err
}

// GetSystemProjectsProjectIdDestinations converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdDestinations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdDestinations(ctx, projectId)
	return err
}

// GetSystemProjectsProjectIdSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdSubscriptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdSubscriptions(ctx, projectId)
	return err
}

// PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", ctx.Param("subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscriptionId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture(ctx, projectId, subscriptionId)
	return err
}

// PostSystemProjectsProjectIdVersionCommit converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsProjectIdVersionCommit(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsProjectIdVersionCommit(ctx, projectId)
	return err
}

// GetSystemProjectsProjectIdVersionCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdVersionCount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemProjectsProjectIdVersionCountParams
	// ------------- Optional query parameter "ID" -------------

	err = runtime.BindQueryParameter("form", true, false, "ID", ctx.QueryParams(), &params.ID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdVersionCount(ctx, projectId, params)
	return err
}

// GetSystemProjectsProjectIdVersionDiff converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdVersionDiff(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemProjectsProjectIdVersionDiffParams
	// ------------- Optional query parameter "commit" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit", ctx.QueryParams(), &params.Commit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit: %s", err))
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Optional query parameter "diffLineLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "diffLineLimit", ctx.QueryParams(), &params.DiffLineLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter diffLineLimit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdVersionDiff(ctx, projectId, params)
	return err
}

// GetSystemProjectsProjectIdVersionFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdVersionFiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemProjectsProjectIdVersionFilesParams
	// ------------- Optional query parameter "ID" -------------

	err = runtime.BindQueryParameter("form", true, false, "ID", ctx.QueryParams(), &params.ID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdVersionFiles(ctx, projectId, params)
	return err
}

// PostSystemProjectsProjectIdVersionRevert converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemProjectsProjectIdVersionRevert(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemProjectsProjectIdVersionRevert(ctx, projectId)
	return err
}

// GetSystemProjectsProjectIdVersionShow converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemProjectsProjectIdVersionShow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "projectId" -------------
	var projectId string

	err = runtime.BindStyledParameterWithOptions("simple", "projectId", ctx.Param("projectId"), &projectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemProjectsProjectIdVersionShowParams
	// ------------- Optional query parameter "ID" -------------

	err = runtime.BindQueryParameter("form", true, false, "ID", ctx.QueryParams(), &params.ID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ID: %s", err))
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Optional query parameter "diffLineLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "diffLineLimit", ctx.QueryParams(), &params.DiffLineLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter diffLineLimit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemProjectsProjectIdVersionShow(ctx, projectId, params)
	return err
}

// GetSystemRoles converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemRoles(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemRoles(ctx)
	return err
}

// PostSystemRoles converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemRoles(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemRoles(ctx)
	return err
}

// DeleteSystemRolesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemRolesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemRolesId(ctx, id)
	return err
}

// GetSystemRolesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemRolesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemRolesId(ctx, id)
	return err
}

// PatchSystemRolesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemRolesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemRolesId(ctx, id)
	return err
}

// GetSystemSamples converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSamples(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSamples(ctx)
	return err
}

// PostSystemSamples converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSamples(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSamples(ctx)
	return err
}

// DeleteSystemSamplesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemSamplesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemSamplesId(ctx, id)
	return err
}

// GetSystemSamplesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSamplesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSamplesId(ctx, id)
	return err
}

// PatchSystemSamplesId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSamplesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSamplesId(ctx, id)
	return err
}

// GetSystemSamplesIdContent converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSamplesIdContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSamplesIdContent(ctx, id)
	return err
}

// GetSystemScripts converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemScripts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemScripts(ctx)
	return err
}

// PostSystemScripts converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemScripts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemScripts(ctx)
	return err
}

// DeleteSystemScriptsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemScriptsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemScriptsId(ctx, id)
	return err
}

// GetSystemScriptsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemScriptsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemScriptsId(ctx, id)
	return err
}

// PatchSystemScriptsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemScriptsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemScriptsId(ctx, id)
	return err
}

// GetSystemSecrets converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSecrets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSecrets(ctx)
	return err
}

// PostSystemSecrets converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSecrets(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSecrets(ctx)
	return err
}

// DeleteSystemSecretsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemSecretsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemSecretsId(ctx, id)
	return err
}

// GetSystemSecretsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSecretsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSecretsId(ctx, id)
	return err
}

// PatchSystemSecretsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSecretsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSecretsId(ctx, id)
	return err
}

// GetSystemSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettings(ctx)
	return err
}

// PatchSystemSettings converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSettings(ctx)
	return err
}

// GetSystemSettingsAuth converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsAuth(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsAuth(ctx)
	return err
}

// PatchSystemSettingsAuth converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSettingsAuth(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSettingsAuth(ctx)
	return err
}

// GetSystemSettingsConf converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsConf(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsConf(ctx)
	return err
}

// PatchSystemSettingsConf converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSettingsConf(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSettingsConf(ctx)
	return err
}

// GetSystemSettingsCribl converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsCribl(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsCribl(ctx)
	return err
}

// GetSystemSettingsGitSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsGitSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsGitSettings(ctx)
	return err
}

// PatchSystemSettingsGitSettings converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSettingsGitSettings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSettingsGitSettings(ctx)
	return err
}

// PostSystemSettingsReload converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSettingsReload(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSettingsReload(ctx)
	return err
}

// PostSystemSettingsRestart converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSettingsRestart(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSettingsRestart(ctx)
	return err
}

// GetSystemSettingsSearchLimits converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsSearchLimits(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsSearchLimits(ctx)
	return err
}

// GetSystemSettingsUpgrade converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSettingsUpgrade(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSettingsUpgrade(ctx)
	return err
}

// PostSystemSettingsUpgradeFromPackage converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSettingsUpgradeFromPackage(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSettingsUpgradeFromPackage(ctx)
	return err
}

// PostSystemSettingsUpgradeVersion converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSettingsUpgradeVersion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameterWithOptions("simple", "version", ctx.Param("version"), &version, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSettingsUpgradeVersion(ctx, version)
	return err
}

// GetSystemStatusInputs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStatusInputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStatusInputs(ctx)
	return err
}

// GetSystemStatusInputsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStatusInputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStatusInputsId(ctx, id)
	return err
}

// GetSystemStatusOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStatusOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStatusOutputs(ctx)
	return err
}

// GetSystemStatusOutputsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStatusOutputsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStatusOutputsId(ctx, id)
	return err
}

// GetSystemSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSubscriptions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSubscriptions(ctx)
	return err
}

// PostSystemSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemSubscriptions(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemSubscriptions(ctx)
	return err
}

// DeleteSystemSubscriptionsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemSubscriptionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemSubscriptionsId(ctx, id)
	return err
}

// GetSystemSubscriptionsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemSubscriptionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemSubscriptionsId(ctx, id)
	return err
}

// PatchSystemSubscriptionsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemSubscriptionsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemSubscriptionsId(ctx, id)
	return err
}

// GetSystemTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemTeams(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemTeamsParams
	// ------------- Optional query parameter "product" -------------

	err = runtime.BindQueryParameter("form", true, false, "product", ctx.QueryParams(), &params.Product)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter product: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemTeams(ctx, params)
	return err
}

// PostSystemTeams converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemTeams(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemTeams(ctx)
	return err
}

// GetSystemTeamsUsersIdRoles converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemTeamsUsersIdRoles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemTeamsUsersIdRoles(ctx, id)
	return err
}

// DeleteSystemTeamsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemTeamsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemTeamsId(ctx, id)
	return err
}

// GetSystemTeamsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemTeamsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemTeamsId(ctx, id)
	return err
}

// PatchSystemTeamsId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemTeamsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemTeamsId(ctx, id)
	return err
}

// GetSystemTeamsIdAcl converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemTeamsIdAcl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSystemTeamsIdAclParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemTeamsIdAcl(ctx, id, params)
	return err
}

// GetSystemTeamsIdUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemTeamsIdUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemTeamsIdUsers(ctx, id)
	return err
}

// PostSystemTeamsIdUsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemTeamsIdUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemTeamsIdUsers(ctx, id)
	return err
}

// GetSystemUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemUsers(ctx)
	return err
}

// PostSystemUsers converts echo context to params.
func (w *ServerInterfaceWrapper) PostSystemUsers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSystemUsers(ctx)
	return err
}

// DeleteSystemUsersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSystemUsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSystemUsersId(ctx, id)
	return err
}

// GetSystemUsersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemUsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemUsersId(ctx, id)
	return err
}

// PatchSystemUsersId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemUsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemUsersId(ctx, id)
	return err
}

// PatchSystemUsersIdInfo converts echo context to params.
func (w *ServerInterfaceWrapper) PatchSystemUsersIdInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchSystemUsersIdInfo(ctx, id)
	return err
}

// GetUiKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetUiKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameterWithOptions("simple", "key", ctx.Param("key"), &key, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUiKey(ctx, key)
	return err
}

// PatchUiKey converts echo context to params.
func (w *ServerInterfaceWrapper) PatchUiKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameterWithOptions("simple", "key", ctx.Param("key"), &key, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchUiKey(ctx, key)
	return err
}

// GetVersionBranch converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionBranch(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionBranch(ctx)
	return err
}

// PostVersionCommit converts echo context to params.
func (w *ServerInterfaceWrapper) PostVersionCommit(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVersionCommit(ctx)
	return err
}

// GetVersionCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionCount(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionCountParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "ID" -------------

	err = runtime.BindQueryParameter("form", true, false, "ID", ctx.QueryParams(), &params.ID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionCount(ctx, params)
	return err
}

// GetVersionCurrentBranch converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionCurrentBranch(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionCurrentBranch(ctx)
	return err
}

// GetVersionDiff converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionDiff(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionDiffParams
	// ------------- Optional query parameter "commit" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit", ctx.QueryParams(), &params.Commit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Optional query parameter "diffLineLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "diffLineLimit", ctx.QueryParams(), &params.DiffLineLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter diffLineLimit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionDiff(ctx, params)
	return err
}

// GetVersionFiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionFiles(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionFilesParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "ID" -------------

	err = runtime.BindQueryParameter("form", true, false, "ID", ctx.QueryParams(), &params.ID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionFiles(ctx, params)
	return err
}

// GetVersionInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionInfo(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionInfo(ctx)
	return err
}

// PostVersionPush converts echo context to params.
func (w *ServerInterfaceWrapper) PostVersionPush(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVersionPush(ctx)
	return err
}

// PostVersionRevert converts echo context to params.
func (w *ServerInterfaceWrapper) PostVersionRevert(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostVersionRevertParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVersionRevert(ctx, params)
	return err
}

// GetVersionShow converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionShow(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionShowParams
	// ------------- Optional query parameter "commit" -------------

	err = runtime.BindQueryParameter("form", true, false, "commit", ctx.QueryParams(), &params.Commit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter commit: %s", err))
	}

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// ------------- Optional query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, false, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Optional query parameter "diffLineLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "diffLineLimit", ctx.QueryParams(), &params.DiffLineLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter diffLineLimit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionShow(ctx, params)
	return err
}

// GetVersionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersionStatus(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionStatusParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersionStatus(ctx, params)
	return err
}

// PostVersionSync converts echo context to params.
func (w *ServerInterfaceWrapper) PostVersionSync(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVersionSync(ctx)
	return err
}

// PostVersionUndo converts echo context to params.
func (w *ServerInterfaceWrapper) PostVersionUndo(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostVersionUndoParams
	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", ctx.QueryParams(), &params.Group)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVersionUndo(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/ai/consent", wrapper.GetAiConsent)
	router.POST(baseURL+"/ai/consent", wrapper.PostAiConsent)
	router.GET(baseURL+"/auth/authorization-code/callback", wrapper.GetAuthAuthorizationCodeCallback)
	router.GET(baseURL+"/auth/groups", wrapper.GetAuthGroups)
	router.POST(baseURL+"/auth/login", wrapper.PostAuthLogin)
	router.POST(baseURL+"/auth/logout", wrapper.PostAuthLogout)
	router.GET(baseURL+"/auth/metadata", wrapper.GetAuthMetadata)
	router.GET(baseURL+"/auth/multi-factor", wrapper.GetAuthMultiFactor)
	router.GET(baseURL+"/auth/slo", wrapper.GetAuthSlo)
	router.GET(baseURL+"/auth/slo/callback", wrapper.GetAuthSloCallback)
	router.POST(baseURL+"/auth/slo/callback", wrapper.PostAuthSloCallback)
	router.GET(baseURL+"/auth/sso", wrapper.GetAuthSso)
	router.GET(baseURL+"/auth/sso/callback", wrapper.GetAuthSsoCallback)
	router.POST(baseURL+"/auth/sso/callback", wrapper.PostAuthSsoCallback)
	router.DELETE(baseURL+"/auth/users/:id/token", wrapper.DeleteAuthUsersIdToken)
	router.GET(baseURL+"/authorize/policy", wrapper.GetAuthorizePolicy)
	router.GET(baseURL+"/authorize/roles", wrapper.GetAuthorizeRoles)
	router.GET(baseURL+"/changelog/viewed", wrapper.GetChangelogViewed)
	router.PATCH(baseURL+"/changelog/viewed", wrapper.PatchChangelogViewed)
	router.GET(baseURL+"/clui", wrapper.GetClui)
	router.GET(baseURL+"/collectors", wrapper.GetCollectors)
	router.GET(baseURL+"/collectors/:id", wrapper.GetCollectorsId)
	router.GET(baseURL+"/conditions", wrapper.GetConditions)
	router.GET(baseURL+"/conditions/:id", wrapper.GetConditionsId)
	router.GET(baseURL+"/edge/appscope/processes", wrapper.GetEdgeAppscopeProcesses)
	router.POST(baseURL+"/edge/appscope/processes/", wrapper.PostEdgeAppscopeProcesses)
	router.DELETE(baseURL+"/edge/appscope/processes/:pid", wrapper.DeleteEdgeAppscopeProcessesPid)
	router.GET(baseURL+"/edge/appscope/processes/:pid", wrapper.GetEdgeAppscopeProcessesPid)
	router.PUT(baseURL+"/edge/appscope/processes/:pid", wrapper.PutEdgeAppscopeProcessesPid)
	router.GET(baseURL+"/edge/containers", wrapper.GetEdgeContainers)
	router.GET(baseURL+"/edge/containers/:id", wrapper.GetEdgeContainersId)
	router.GET(baseURL+"/edge/events/collectors", wrapper.GetEdgeEventsCollectors)
	router.GET(baseURL+"/edge/events/query", wrapper.GetEdgeEventsQuery)
	router.POST(baseURL+"/edge/file/ingest", wrapper.PostEdgeFileIngest)
	router.GET(baseURL+"/edge/file/sample", wrapper.GetEdgeFileSample)
	router.GET(baseURL+"/edge/fileinspect", wrapper.GetEdgeFileinspect)
	router.POST(baseURL+"/edge/kube-logs", wrapper.PostEdgeKubeLogs)
	router.GET(baseURL+"/edge/kube_proxy", wrapper.GetEdgeKubeProxy)
	router.GET(baseURL+"/edge/logs", wrapper.GetEdgeLogs)
	router.GET(baseURL+"/edge/ls:path", wrapper.GetEdgeLsPath)
	router.GET(baseURL+"/edge/metadata", wrapper.GetEdgeMetadata)
	router.GET(baseURL+"/edge/processes", wrapper.GetEdgeProcesses)
	router.GET(baseURL+"/edge/processes/:pid", wrapper.GetEdgeProcessesPid)
	router.GET(baseURL+"/executors", wrapper.GetExecutors)
	router.GET(baseURL+"/executors/:id", wrapper.GetExecutorsId)
	router.GET(baseURL+"/functions", wrapper.GetFunctions)
	router.GET(baseURL+"/functions/:id", wrapper.GetFunctionsId)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/jobs", wrapper.GetJobs)
	router.POST(baseURL+"/jobs", wrapper.PostJobs)
	router.DELETE(baseURL+"/jobs/:id", wrapper.DeleteJobsId)
	router.GET(baseURL+"/jobs/:id", wrapper.GetJobsId)
	router.PATCH(baseURL+"/jobs/:id/cancel", wrapper.PatchJobsIdCancel)
	router.GET(baseURL+"/jobs/:id/errors/", wrapper.GetJobsIdErrors)
	router.GET(baseURL+"/jobs/:id/errors/:group", wrapper.GetJobsIdErrorsGroup)
	router.PATCH(baseURL+"/jobs/:id/keep", wrapper.PatchJobsIdKeep)
	router.PATCH(baseURL+"/jobs/:id/pause", wrapper.PatchJobsIdPause)
	router.GET(baseURL+"/jobs/:id/results/", wrapper.GetJobsIdResults)
	router.GET(baseURL+"/jobs/:id/results/:group", wrapper.GetJobsIdResultsGroup)
	router.PATCH(baseURL+"/jobs/:id/resume", wrapper.PatchJobsIdResume)
	router.GET(baseURL+"/lib/appscope-configs", wrapper.GetLibAppscopeConfigs)
	router.POST(baseURL+"/lib/appscope-configs", wrapper.PostLibAppscopeConfigs)
	router.DELETE(baseURL+"/lib/appscope-configs/:id", wrapper.DeleteLibAppscopeConfigsId)
	router.GET(baseURL+"/lib/appscope-configs/:id", wrapper.GetLibAppscopeConfigsId)
	router.PATCH(baseURL+"/lib/appscope-configs/:id", wrapper.PatchLibAppscopeConfigsId)
	router.GET(baseURL+"/lib/breakers", wrapper.GetLibBreakers)
	router.POST(baseURL+"/lib/breakers", wrapper.PostLibBreakers)
	router.DELETE(baseURL+"/lib/breakers/:id", wrapper.DeleteLibBreakersId)
	router.GET(baseURL+"/lib/breakers/:id", wrapper.GetLibBreakersId)
	router.PATCH(baseURL+"/lib/breakers/:id", wrapper.PatchLibBreakersId)
	router.GET(baseURL+"/lib/database-connections", wrapper.GetLibDatabaseConnections)
	router.POST(baseURL+"/lib/database-connections", wrapper.PostLibDatabaseConnections)
	router.POST(baseURL+"/lib/database-connections/test", wrapper.PostLibDatabaseConnectionsTest)
	router.DELETE(baseURL+"/lib/database-connections/:id", wrapper.DeleteLibDatabaseConnectionsId)
	router.GET(baseURL+"/lib/database-connections/:id", wrapper.GetLibDatabaseConnectionsId)
	router.PATCH(baseURL+"/lib/database-connections/:id", wrapper.PatchLibDatabaseConnectionsId)
	router.POST(baseURL+"/lib/expression", wrapper.PostLibExpression)
	router.GET(baseURL+"/lib/grok", wrapper.GetLibGrok)
	router.POST(baseURL+"/lib/grok", wrapper.PostLibGrok)
	router.DELETE(baseURL+"/lib/grok/:id", wrapper.DeleteLibGrokId)
	router.GET(baseURL+"/lib/grok/:id", wrapper.GetLibGrokId)
	router.PATCH(baseURL+"/lib/grok/:id", wrapper.PatchLibGrokId)
	router.GET(baseURL+"/lib/hmac-functions", wrapper.GetLibHmacFunctions)
	router.POST(baseURL+"/lib/hmac-functions", wrapper.PostLibHmacFunctions)
	router.DELETE(baseURL+"/lib/hmac-functions/:id", wrapper.DeleteLibHmacFunctionsId)
	router.GET(baseURL+"/lib/hmac-functions/:id", wrapper.GetLibHmacFunctionsId)
	router.PATCH(baseURL+"/lib/hmac-functions/:id", wrapper.PatchLibHmacFunctionsId)
	router.GET(baseURL+"/lib/jobs", wrapper.GetLibJobs)
	router.POST(baseURL+"/lib/jobs", wrapper.PostLibJobs)
	router.DELETE(baseURL+"/lib/jobs/:id", wrapper.DeleteLibJobsId)
	router.GET(baseURL+"/lib/jobs/:id", wrapper.GetLibJobsId)
	router.PATCH(baseURL+"/lib/jobs/:id", wrapper.PatchLibJobsId)
	router.GET(baseURL+"/lib/parquet-schemas", wrapper.GetLibParquetSchemas)
	router.POST(baseURL+"/lib/parquet-schemas", wrapper.PostLibParquetSchemas)
	router.DELETE(baseURL+"/lib/parquet-schemas/:id", wrapper.DeleteLibParquetSchemasId)
	router.GET(baseURL+"/lib/parquet-schemas/:id", wrapper.GetLibParquetSchemasId)
	router.PATCH(baseURL+"/lib/parquet-schemas/:id", wrapper.PatchLibParquetSchemasId)
	router.GET(baseURL+"/lib/parsers", wrapper.GetLibParsers)
	router.POST(baseURL+"/lib/parsers", wrapper.PostLibParsers)
	router.DELETE(baseURL+"/lib/parsers/:id", wrapper.DeleteLibParsersId)
	router.GET(baseURL+"/lib/parsers/:id", wrapper.GetLibParsersId)
	router.PATCH(baseURL+"/lib/parsers/:id", wrapper.PatchLibParsersId)
	router.GET(baseURL+"/lib/protobuf-libraries", wrapper.GetLibProtobufLibraries)
	router.GET(baseURL+"/lib/protobuf-libraries/:id", wrapper.GetLibProtobufLibrariesId)
	router.GET(baseURL+"/lib/protobuf-libraries/:id/encodings", wrapper.GetLibProtobufLibrariesIdEncodings)
	router.GET(baseURL+"/lib/protobuf-libraries/:id/encodings/:encid", wrapper.GetLibProtobufLibrariesIdEncodingsEncid)
	router.GET(baseURL+"/lib/regex", wrapper.GetLibRegex)
	router.POST(baseURL+"/lib/regex", wrapper.PostLibRegex)
	router.DELETE(baseURL+"/lib/regex/:id", wrapper.DeleteLibRegexId)
	router.GET(baseURL+"/lib/regex/:id", wrapper.GetLibRegexId)
	router.PATCH(baseURL+"/lib/regex/:id", wrapper.PatchLibRegexId)
	router.GET(baseURL+"/lib/schemas", wrapper.GetLibSchemas)
	router.POST(baseURL+"/lib/schemas", wrapper.PostLibSchemas)
	router.DELETE(baseURL+"/lib/schemas/:id", wrapper.DeleteLibSchemasId)
	router.GET(baseURL+"/lib/schemas/:id", wrapper.GetLibSchemasId)
	router.PATCH(baseURL+"/lib/schemas/:id", wrapper.PatchLibSchemasId)
	router.GET(baseURL+"/lib/vars", wrapper.GetLibVars)
	router.POST(baseURL+"/lib/vars", wrapper.PostLibVars)
	router.DELETE(baseURL+"/lib/vars/:id", wrapper.DeleteLibVarsId)
	router.GET(baseURL+"/lib/vars/:id", wrapper.GetLibVarsId)
	router.PATCH(baseURL+"/lib/vars/:id", wrapper.PatchLibVarsId)
	router.POST(baseURL+"/m/:groupId/system/projects/:projectId/capture", wrapper.PostMGroupIdSystemProjectsProjectIdCapture)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/pipelines", wrapper.GetMGroupIdSystemProjectsProjectIdPipelines)
	router.POST(baseURL+"/m/:groupId/system/projects/:projectId/pipelines", wrapper.PostMGroupIdSystemProjectsProjectIdPipelines)
	router.DELETE(baseURL+"/m/:groupId/system/projects/:projectId/pipelines/:pipelineId", wrapper.DeleteMGroupIdSystemProjectsProjectIdPipelinesPipelineId)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/pipelines/:pipelineId", wrapper.GetMGroupIdSystemProjectsProjectIdPipelinesPipelineId)
	router.PATCH(baseURL+"/m/:groupId/system/projects/:projectId/pipelines/:pipelineId", wrapper.PatchMGroupIdSystemProjectsProjectIdPipelinesPipelineId)
	router.POST(baseURL+"/m/:groupId/system/projects/:projectId/preview", wrapper.PostMGroupIdSystemProjectsProjectIdPreview)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/subscriptions", wrapper.GetMGroupIdSystemProjectsProjectIdSubscriptions)
	router.POST(baseURL+"/m/:groupId/system/projects/:projectId/subscriptions/:subscriptionId/capture", wrapper.PostMGroupIdSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture)
	router.POST(baseURL+"/m/:groupId/system/projects/:projectId/version/commit", wrapper.PostMGroupIdSystemProjectsProjectIdVersionCommit)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/version/count", wrapper.GetMGroupIdSystemProjectsProjectIdVersionCount)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/version/diff", wrapper.GetMGroupIdSystemProjectsProjectIdVersionDiff)
	router.GET(baseURL+"/m/:groupId/system/projects/:projectId/version/files", wrapper.GetMGroupIdSystemProjectsProjectIdVersionFiles)
	router.GET(baseURL+"/master/bundles/:group/:version", wrapper.GetMasterBundlesGroupVersion)
	router.GET(baseURL+"/master/groups/:id", wrapper.GetMasterGroupsId)
	router.GET(baseURL+"/master/groups/:id/acl", wrapper.GetMasterGroupsIdAcl)
	router.GET(baseURL+"/master/groups/:id/configVersion", wrapper.GetMasterGroupsIdConfigVersion)
	router.PATCH(baseURL+"/master/groups/:id/deploy", wrapper.PatchMasterGroupsIdDeploy)
	router.GET(baseURL+"/master/summary", wrapper.GetMasterSummary)
	router.GET(baseURL+"/master/summary/workers", wrapper.GetMasterSummaryWorkers)
	router.GET(baseURL+"/master/workers", wrapper.GetMasterWorkers)
	router.PATCH(baseURL+"/master/workers/restart", wrapper.PatchMasterWorkersRestart)
	router.GET(baseURL+"/notification-targets", wrapper.GetNotificationTargets)
	router.POST(baseURL+"/notification-targets", wrapper.PostNotificationTargets)
	router.DELETE(baseURL+"/notification-targets/:id", wrapper.DeleteNotificationTargetsId)
	router.GET(baseURL+"/notification-targets/:id", wrapper.GetNotificationTargetsId)
	router.PATCH(baseURL+"/notification-targets/:id", wrapper.PatchNotificationTargetsId)
	router.GET(baseURL+"/notifications", wrapper.GetNotifications)
	router.POST(baseURL+"/notifications", wrapper.PostNotifications)
	router.DELETE(baseURL+"/notifications/:id", wrapper.DeleteNotificationsId)
	router.GET(baseURL+"/notifications/:id", wrapper.GetNotificationsId)
	router.PATCH(baseURL+"/notifications/:id", wrapper.PatchNotificationsId)
	router.POST(baseURL+"/output/click-house/describe-table", wrapper.PostOutputClickHouseDescribeTable)
	router.GET(baseURL+"/p/:pack/functions", wrapper.GetPPackFunctions)
	router.GET(baseURL+"/p/:pack/functions/:id", wrapper.GetPPackFunctionsId)
	router.GET(baseURL+"/p/:pack/lib/schemas", wrapper.GetPPackLibSchemas)
	router.POST(baseURL+"/p/:pack/lib/schemas", wrapper.PostPPackLibSchemas)
	router.DELETE(baseURL+"/p/:pack/lib/schemas/:id", wrapper.DeletePPackLibSchemasId)
	router.GET(baseURL+"/p/:pack/lib/schemas/:id", wrapper.GetPPackLibSchemasId)
	router.PATCH(baseURL+"/p/:pack/lib/schemas/:id", wrapper.PatchPPackLibSchemasId)
	router.GET(baseURL+"/p/:pack/lib/vars", wrapper.GetPPackLibVars)
	router.POST(baseURL+"/p/:pack/lib/vars", wrapper.PostPPackLibVars)
	router.DELETE(baseURL+"/p/:pack/lib/vars/:id", wrapper.DeletePPackLibVarsId)
	router.GET(baseURL+"/p/:pack/lib/vars/:id", wrapper.GetPPackLibVarsId)
	router.PATCH(baseURL+"/p/:pack/lib/vars/:id", wrapper.PatchPPackLibVarsId)
	router.GET(baseURL+"/p/:pack/pipelines", wrapper.GetPPackPipelines)
	router.POST(baseURL+"/p/:pack/pipelines", wrapper.PostPPackPipelines)
	router.DELETE(baseURL+"/p/:pack/pipelines/:id", wrapper.DeletePPackPipelinesId)
	router.GET(baseURL+"/p/:pack/pipelines/:id", wrapper.GetPPackPipelinesId)
	router.PATCH(baseURL+"/p/:pack/pipelines/:id", wrapper.PatchPPackPipelinesId)
	router.GET(baseURL+"/p/:pack/routes", wrapper.GetPPackRoutes)
	router.GET(baseURL+"/p/:pack/routes/:id", wrapper.GetPPackRoutesId)
	router.PATCH(baseURL+"/p/:pack/routes/:id", wrapper.PatchPPackRoutesId)
	router.POST(baseURL+"/p/:pack/routes/:id/append", wrapper.PostPPackRoutesIdAppend)
	router.GET(baseURL+"/packs", wrapper.GetPacks)
	router.POST(baseURL+"/packs", wrapper.PostPacks)
	router.PUT(baseURL+"/packs", wrapper.PutPacks)
	router.POST(baseURL+"/packs/__clone__", wrapper.PostPacksClone)
	router.DELETE(baseURL+"/packs/:id", wrapper.DeletePacksId)
	router.PATCH(baseURL+"/packs/:id", wrapper.PatchPacksId)
	router.GET(baseURL+"/packs/:id/export", wrapper.GetPacksIdExport)
	router.GET(baseURL+"/pipelines", wrapper.GetPipelines)
	router.POST(baseURL+"/pipelines", wrapper.PostPipelines)
	router.DELETE(baseURL+"/pipelines/:id", wrapper.DeletePipelinesId)
	router.GET(baseURL+"/pipelines/:id", wrapper.GetPipelinesId)
	router.PATCH(baseURL+"/pipelines/:id", wrapper.PatchPipelinesId)
	router.POST(baseURL+"/preview", wrapper.PostPreview)
	router.POST(baseURL+"/products/edge/map/query", wrapper.PostProductsEdgeMapQuery)
	router.GET(baseURL+"/products/lake/lakes/:lakeId/datasets", wrapper.GetProductsLakeLakesLakeIdDatasets)
	router.POST(baseURL+"/products/lake/lakes/:lakeId/datasets", wrapper.PostProductsLakeLakesLakeIdDatasets)
	router.DELETE(baseURL+"/products/lake/lakes/:lakeId/datasets/:id", wrapper.DeleteProductsLakeLakesLakeIdDatasetsId)
	router.GET(baseURL+"/products/lake/lakes/:lakeId/datasets/:id", wrapper.GetProductsLakeLakesLakeIdDatasetsId)
	router.PATCH(baseURL+"/products/lake/lakes/:lakeId/datasets/:id", wrapper.PatchProductsLakeLakesLakeIdDatasetsId)
	router.GET(baseURL+"/products/:product/groups", wrapper.GetProductsProductGroups)
	router.POST(baseURL+"/products/:product/groups", wrapper.PostProductsProductGroups)
	router.GET(baseURL+"/products/:product/groups/:id/acl/teams", wrapper.GetProductsProductGroupsIdAclTeams)
	router.GET(baseURL+"/products/:product/users", wrapper.GetProductsProductUsers)
	router.DELETE(baseURL+"/products/:product/users/__cache__", wrapper.DeleteProductsProductUsersCache)
	router.GET(baseURL+"/products/:product/users/:id/acl", wrapper.GetProductsProductUsersIdAcl)
	router.GET(baseURL+"/routes", wrapper.GetRoutes)
	router.GET(baseURL+"/routes/:id", wrapper.GetRoutesId)
	router.PATCH(baseURL+"/routes/:id", wrapper.PatchRoutesId)
	router.POST(baseURL+"/routes/:id/append", wrapper.PostRoutesIdAppend)
	router.GET(baseURL+"/search/dashboard-categories", wrapper.GetSearchDashboardCategories)
	router.POST(baseURL+"/search/dashboard-categories", wrapper.PostSearchDashboardCategories)
	router.DELETE(baseURL+"/search/dashboard-categories/:id", wrapper.DeleteSearchDashboardCategoriesId)
	router.GET(baseURL+"/search/dashboard-categories/:id", wrapper.GetSearchDashboardCategoriesId)
	router.PATCH(baseURL+"/search/dashboard-categories/:id", wrapper.PatchSearchDashboardCategoriesId)
	router.GET(baseURL+"/search/dashboards", wrapper.GetSearchDashboards)
	router.POST(baseURL+"/search/dashboards", wrapper.PostSearchDashboards)
	router.DELETE(baseURL+"/search/dashboards/:id", wrapper.DeleteSearchDashboardsId)
	router.GET(baseURL+"/search/dashboards/:id", wrapper.GetSearchDashboardsId)
	router.PATCH(baseURL+"/search/dashboards/:id", wrapper.PatchSearchDashboardsId)
	router.GET(baseURL+"/search/dashboards/:id/acl", wrapper.GetSearchDashboardsIdAcl)
	router.POST(baseURL+"/search/dashboards/:id/acl/apply", wrapper.PostSearchDashboardsIdAclApply)
	router.GET(baseURL+"/search/dashboards/:id/acl/teams", wrapper.GetSearchDashboardsIdAclTeams)
	router.POST(baseURL+"/search/dashboards/:id/acl/teams/apply", wrapper.PostSearchDashboardsIdAclTeamsApply)
	router.GET(baseURL+"/search/dataset-provider-types", wrapper.GetSearchDatasetProviderTypes)
	router.POST(baseURL+"/search/dataset-provider-types", wrapper.PostSearchDatasetProviderTypes)
	router.DELETE(baseURL+"/search/dataset-provider-types/:id", wrapper.DeleteSearchDatasetProviderTypesId)
	router.GET(baseURL+"/search/dataset-provider-types/:id", wrapper.GetSearchDatasetProviderTypesId)
	router.PATCH(baseURL+"/search/dataset-provider-types/:id", wrapper.PatchSearchDatasetProviderTypesId)
	router.GET(baseURL+"/search/dataset-providers", wrapper.GetSearchDatasetProviders)
	router.POST(baseURL+"/search/dataset-providers", wrapper.PostSearchDatasetProviders)
	router.DELETE(baseURL+"/search/dataset-providers/:id", wrapper.DeleteSearchDatasetProvidersId)
	router.GET(baseURL+"/search/dataset-providers/:id", wrapper.GetSearchDatasetProvidersId)
	router.PATCH(baseURL+"/search/dataset-providers/:id", wrapper.PatchSearchDatasetProvidersId)
	router.GET(baseURL+"/search/datasets", wrapper.GetSearchDatasets)
	router.POST(baseURL+"/search/datasets", wrapper.PostSearchDatasets)
	router.DELETE(baseURL+"/search/datasets/:id", wrapper.DeleteSearchDatasetsId)
	router.GET(baseURL+"/search/datasets/:id", wrapper.GetSearchDatasetsId)
	router.PATCH(baseURL+"/search/datasets/:id", wrapper.PatchSearchDatasetsId)
	router.GET(baseURL+"/search/datasets/:id/acl", wrapper.GetSearchDatasetsIdAcl)
	router.POST(baseURL+"/search/datasets/:id/acl/apply", wrapper.PostSearchDatasetsIdAclApply)
	router.GET(baseURL+"/search/datasets/:id/acl/teams", wrapper.GetSearchDatasetsIdAclTeams)
	router.POST(baseURL+"/search/datasets/:id/acl/teams/apply", wrapper.PostSearchDatasetsIdAclTeamsApply)
	router.POST(baseURL+"/search/event-breaker-preview", wrapper.PostSearchEventBreakerPreview)
	router.GET(baseURL+"/search/healthcheck", wrapper.GetSearchHealthcheck)
	router.GET(baseURL+"/search/job-metrics", wrapper.GetSearchJobMetrics)
	router.GET(baseURL+"/search/jobs", wrapper.GetSearchJobs)
	router.POST(baseURL+"/search/jobs", wrapper.PostSearchJobs)
	router.DELETE(baseURL+"/search/jobs/:id", wrapper.DeleteSearchJobsId)
	router.GET(baseURL+"/search/jobs/:id", wrapper.GetSearchJobsId)
	router.PATCH(baseURL+"/search/jobs/:id", wrapper.PatchSearchJobsId)
	router.POST(baseURL+"/search/jobs/:id/dispatch-executors", wrapper.PostSearchJobsIdDispatchExecutors)
	router.GET(baseURL+"/search/jobs/:id/logs", wrapper.GetSearchJobsIdLogs)
	router.GET(baseURL+"/search/jobs/:id/metrics", wrapper.GetSearchJobsIdMetrics)
	router.GET(baseURL+"/search/jobs/:id/results", wrapper.GetSearchJobsIdResults)
	router.GET(baseURL+"/search/jobs/:id/results-poll", wrapper.GetSearchJobsIdResultsPoll)
	router.GET(baseURL+"/search/jobs/:id/stages/:stageId/results", wrapper.GetSearchJobsIdStagesStageIdResults)
	router.GET(baseURL+"/search/macros", wrapper.GetSearchMacros)
	router.POST(baseURL+"/search/macros", wrapper.PostSearchMacros)
	router.DELETE(baseURL+"/search/macros/:id", wrapper.DeleteSearchMacrosId)
	router.GET(baseURL+"/search/macros/:id", wrapper.GetSearchMacrosId)
	router.PATCH(baseURL+"/search/macros/:id", wrapper.PatchSearchMacrosId)
	router.POST(baseURL+"/search/preview", wrapper.PostSearchPreview)
	router.GET(baseURL+"/search/saved", wrapper.GetSearchSaved)
	router.POST(baseURL+"/search/saved", wrapper.PostSearchSaved)
	router.DELETE(baseURL+"/search/saved/:id", wrapper.DeleteSearchSavedId)
	router.GET(baseURL+"/search/saved/:id", wrapper.GetSearchSavedId)
	router.PATCH(baseURL+"/search/saved/:id", wrapper.PatchSearchSavedId)
	router.GET(baseURL+"/search/trust-policies", wrapper.GetSearchTrustPolicies)
	router.GET(baseURL+"/search/usage-groups", wrapper.GetSearchUsageGroups)
	router.POST(baseURL+"/search/usage-groups", wrapper.PostSearchUsageGroups)
	router.DELETE(baseURL+"/search/usage-groups/:id", wrapper.DeleteSearchUsageGroupsId)
	router.GET(baseURL+"/search/usage-groups/:id", wrapper.GetSearchUsageGroupsId)
	router.PATCH(baseURL+"/search/usage-groups/:id", wrapper.PatchSearchUsageGroupsId)
	router.GET(baseURL+"/security/kms/config", wrapper.GetSecurityKmsConfig)
	router.PATCH(baseURL+"/security/kms/config", wrapper.PatchSecurityKmsConfig)
	router.GET(baseURL+"/security/kms/health", wrapper.GetSecurityKmsHealth)
	router.GET(baseURL+"/settings/features", wrapper.GetSettingsFeatures)
	router.GET(baseURL+"/settings/features/:id", wrapper.GetSettingsFeaturesId)
	router.GET(baseURL+"/system/banners", wrapper.GetSystemBanners)
	router.POST(baseURL+"/system/banners", wrapper.PostSystemBanners)
	router.DELETE(baseURL+"/system/banners/:id", wrapper.DeleteSystemBannersId)
	router.GET(baseURL+"/system/banners/:id", wrapper.GetSystemBannersId)
	router.PATCH(baseURL+"/system/banners/:id", wrapper.PatchSystemBannersId)
	router.POST(baseURL+"/system/capture", wrapper.PostSystemCapture)
	router.GET(baseURL+"/system/certificates", wrapper.GetSystemCertificates)
	router.POST(baseURL+"/system/certificates", wrapper.PostSystemCertificates)
	router.DELETE(baseURL+"/system/certificates/:id", wrapper.DeleteSystemCertificatesId)
	router.GET(baseURL+"/system/certificates/:id", wrapper.GetSystemCertificatesId)
	router.PATCH(baseURL+"/system/certificates/:id", wrapper.PatchSystemCertificatesId)
	router.DELETE(baseURL+"/system/diag", wrapper.DeleteSystemDiag)
	router.GET(baseURL+"/system/diag", wrapper.GetSystemDiag)
	router.GET(baseURL+"/system/diag/download", wrapper.GetSystemDiagDownload)
	router.POST(baseURL+"/system/diag/send", wrapper.PostSystemDiagSend)
	router.POST(baseURL+"/system/distributed/upgrade/cancel/:group", wrapper.PostSystemDistributedUpgradeCancelGroup)
	router.GET(baseURL+"/system/distributed/upgrade/download/:file", wrapper.GetSystemDistributedUpgradeDownloadFile)
	router.POST(baseURL+"/system/distributed/upgrade/stage/:group", wrapper.PostSystemDistributedUpgradeStageGroup)
	router.POST(baseURL+"/system/distributed/upgrade/:group", wrapper.PostSystemDistributedUpgradeGroup)
	router.GET(baseURL+"/system/info", wrapper.GetSystemInfo)
	router.GET(baseURL+"/system/inputs", wrapper.GetSystemInputs)
	router.POST(baseURL+"/system/inputs", wrapper.PostSystemInputs)
	router.DELETE(baseURL+"/system/inputs/:id", wrapper.DeleteSystemInputsId)
	router.GET(baseURL+"/system/inputs/:id", wrapper.GetSystemInputsId)
	router.PATCH(baseURL+"/system/inputs/:id", wrapper.PatchSystemInputsId)
	router.POST(baseURL+"/system/inputs/:id/hectoken", wrapper.PostSystemInputsIdHectoken)
	router.PATCH(baseURL+"/system/inputs/:id/hectoken/:token", wrapper.PatchSystemInputsIdHectokenToken)
	router.GET(baseURL+"/system/jobs/logs/:id/:groupId", wrapper.GetSystemJobsLogsIdGroupId)
	router.GET(baseURL+"/system/keys", wrapper.GetSystemKeys)
	router.POST(baseURL+"/system/keys", wrapper.PostSystemKeys)
	router.DELETE(baseURL+"/system/keys/:id", wrapper.DeleteSystemKeysId)
	router.GET(baseURL+"/system/keys/:id", wrapper.GetSystemKeysId)
	router.PATCH(baseURL+"/system/keys/:id", wrapper.PatchSystemKeysId)
	router.GET(baseURL+"/system/licenses", wrapper.GetSystemLicenses)
	router.POST(baseURL+"/system/licenses", wrapper.PostSystemLicenses)
	router.GET(baseURL+"/system/licenses/usage", wrapper.GetSystemLicensesUsage)
	router.DELETE(baseURL+"/system/licenses/:id", wrapper.DeleteSystemLicensesId)
	router.GET(baseURL+"/system/licenses/:id", wrapper.GetSystemLicensesId)
	router.GET(baseURL+"/system/logger", wrapper.GetSystemLogger)
	router.DELETE(baseURL+"/system/logger/:id", wrapper.DeleteSystemLoggerId)
	router.GET(baseURL+"/system/logger/:id", wrapper.GetSystemLoggerId)
	router.PATCH(baseURL+"/system/logger/:id", wrapper.PatchSystemLoggerId)
	router.GET(baseURL+"/system/logs", wrapper.GetSystemLogs)
	router.GET(baseURL+"/system/logs/search", wrapper.GetSystemLogsSearch)
	router.GET(baseURL+"/system/logs/:id", wrapper.GetSystemLogsId)
	router.GET(baseURL+"/system/lookups", wrapper.GetSystemLookups)
	router.POST(baseURL+"/system/lookups", wrapper.PostSystemLookups)
	router.PUT(baseURL+"/system/lookups", wrapper.PutSystemLookups)
	router.DELETE(baseURL+"/system/lookups/:id", wrapper.DeleteSystemLookupsId)
	router.GET(baseURL+"/system/lookups/:id", wrapper.GetSystemLookupsId)
	router.PATCH(baseURL+"/system/lookups/:id", wrapper.PatchSystemLookupsId)
	router.GET(baseURL+"/system/messages", wrapper.GetSystemMessages)
	router.POST(baseURL+"/system/messages", wrapper.PostSystemMessages)
	router.DELETE(baseURL+"/system/messages/:id", wrapper.DeleteSystemMessagesId)
	router.GET(baseURL+"/system/messages/:id", wrapper.GetSystemMessagesId)
	router.GET(baseURL+"/system/metrics", wrapper.GetSystemMetrics)
	router.POST(baseURL+"/system/metrics/enum", wrapper.PostSystemMetricsEnum)
	router.POST(baseURL+"/system/metrics/query", wrapper.PostSystemMetricsQuery)
	router.GET(baseURL+"/system/outputs", wrapper.GetSystemOutputs)
	router.POST(baseURL+"/system/outputs", wrapper.PostSystemOutputs)
	router.DELETE(baseURL+"/system/outputs/:id", wrapper.DeleteSystemOutputsId)
	router.GET(baseURL+"/system/outputs/:id", wrapper.GetSystemOutputsId)
	router.PATCH(baseURL+"/system/outputs/:id", wrapper.PatchSystemOutputsId)
	router.DELETE(baseURL+"/system/outputs/:id/pq", wrapper.DeleteSystemOutputsIdPq)
	router.GET(baseURL+"/system/outputs/:id/pq", wrapper.GetSystemOutputsIdPq)
	router.GET(baseURL+"/system/outputs/:id/samples", wrapper.GetSystemOutputsIdSamples)
	router.POST(baseURL+"/system/outputs/:id/test", wrapper.PostSystemOutputsIdTest)
	router.GET(baseURL+"/system/policies", wrapper.GetSystemPolicies)
	router.POST(baseURL+"/system/policies", wrapper.PostSystemPolicies)
	router.DELETE(baseURL+"/system/policies/:id", wrapper.DeleteSystemPoliciesId)
	router.GET(baseURL+"/system/policies/:id", wrapper.GetSystemPoliciesId)
	router.PATCH(baseURL+"/system/policies/:id", wrapper.PatchSystemPoliciesId)
	router.GET(baseURL+"/system/processes", wrapper.GetSystemProcesses)
	router.GET(baseURL+"/system/profiler", wrapper.GetSystemProfiler)
	router.POST(baseURL+"/system/profiler", wrapper.PostSystemProfiler)
	router.DELETE(baseURL+"/system/profiler/:id", wrapper.DeleteSystemProfilerId)
	router.GET(baseURL+"/system/profiler/:id", wrapper.GetSystemProfilerId)
	router.PATCH(baseURL+"/system/profiler/:id", wrapper.PatchSystemProfilerId)
	router.GET(baseURL+"/system/projects", wrapper.GetSystemProjects)
	router.POST(baseURL+"/system/projects", wrapper.PostSystemProjects)
	router.DELETE(baseURL+"/system/projects/:id", wrapper.DeleteSystemProjectsId)
	router.GET(baseURL+"/system/projects/:id", wrapper.GetSystemProjectsId)
	router.PATCH(baseURL+"/system/projects/:id", wrapper.PatchSystemProjectsId)
	router.GET(baseURL+"/system/projects/:id/acl", wrapper.GetSystemProjectsIdAcl)
	router.POST(baseURL+"/system/projects/:id/acl/apply", wrapper.PostSystemProjectsIdAclApply)
	router.GET(baseURL+"/system/projects/:id/acl/teams", wrapper.GetSystemProjectsIdAclTeams)
	router.POST(baseURL+"/system/projects/:id/acl/teams/apply", wrapper.PostSystemProjectsIdAclTeamsApply)
	router.POST(baseURL+"/system/projects/:projectId/capture", wrapper.PostSystemProjectsProjectIdCapture)
	router.GET(baseURL+"/system/projects/:projectId/destinations", wrapper.GetSystemProjectsProjectIdDestinations)
	router.GET(baseURL+"/system/projects/:projectId/subscriptions", wrapper.GetSystemProjectsProjectIdSubscriptions)
	router.POST(baseURL+"/system/projects/:projectId/subscriptions/:subscriptionId/capture", wrapper.PostSystemProjectsProjectIdSubscriptionsSubscriptionIdCapture)
	router.POST(baseURL+"/system/projects/:projectId/version/commit", wrapper.PostSystemProjectsProjectIdVersionCommit)
	router.GET(baseURL+"/system/projects/:projectId/version/count", wrapper.GetSystemProjectsProjectIdVersionCount)
	router.GET(baseURL+"/system/projects/:projectId/version/diff", wrapper.GetSystemProjectsProjectIdVersionDiff)
	router.GET(baseURL+"/system/projects/:projectId/version/files", wrapper.GetSystemProjectsProjectIdVersionFiles)
	router.POST(baseURL+"/system/projects/:projectId/version/revert", wrapper.PostSystemProjectsProjectIdVersionRevert)
	router.GET(baseURL+"/system/projects/:projectId/version/show", wrapper.GetSystemProjectsProjectIdVersionShow)
	router.GET(baseURL+"/system/roles", wrapper.GetSystemRoles)
	router.POST(baseURL+"/system/roles", wrapper.PostSystemRoles)
	router.DELETE(baseURL+"/system/roles/:id", wrapper.DeleteSystemRolesId)
	router.GET(baseURL+"/system/roles/:id", wrapper.GetSystemRolesId)
	router.PATCH(baseURL+"/system/roles/:id", wrapper.PatchSystemRolesId)
	router.GET(baseURL+"/system/samples", wrapper.GetSystemSamples)
	router.POST(baseURL+"/system/samples", wrapper.PostSystemSamples)
	router.DELETE(baseURL+"/system/samples/:id", wrapper.DeleteSystemSamplesId)
	router.GET(baseURL+"/system/samples/:id", wrapper.GetSystemSamplesId)
	router.PATCH(baseURL+"/system/samples/:id", wrapper.PatchSystemSamplesId)
	router.GET(baseURL+"/system/samples/:id/content", wrapper.GetSystemSamplesIdContent)
	router.GET(baseURL+"/system/scripts", wrapper.GetSystemScripts)
	router.POST(baseURL+"/system/scripts", wrapper.PostSystemScripts)
	router.DELETE(baseURL+"/system/scripts/:id", wrapper.DeleteSystemScriptsId)
	router.GET(baseURL+"/system/scripts/:id", wrapper.GetSystemScriptsId)
	router.PATCH(baseURL+"/system/scripts/:id", wrapper.PatchSystemScriptsId)
	router.GET(baseURL+"/system/secrets", wrapper.GetSystemSecrets)
	router.POST(baseURL+"/system/secrets", wrapper.PostSystemSecrets)
	router.DELETE(baseURL+"/system/secrets/:id", wrapper.DeleteSystemSecretsId)
	router.GET(baseURL+"/system/secrets/:id", wrapper.GetSystemSecretsId)
	router.PATCH(baseURL+"/system/secrets/:id", wrapper.PatchSystemSecretsId)
	router.GET(baseURL+"/system/settings", wrapper.GetSystemSettings)
	router.PATCH(baseURL+"/system/settings", wrapper.PatchSystemSettings)
	router.GET(baseURL+"/system/settings/auth", wrapper.GetSystemSettingsAuth)
	router.PATCH(baseURL+"/system/settings/auth", wrapper.PatchSystemSettingsAuth)
	router.GET(baseURL+"/system/settings/conf", wrapper.GetSystemSettingsConf)
	router.PATCH(baseURL+"/system/settings/conf", wrapper.PatchSystemSettingsConf)
	router.GET(baseURL+"/system/settings/cribl", wrapper.GetSystemSettingsCribl)
	router.GET(baseURL+"/system/settings/git-settings", wrapper.GetSystemSettingsGitSettings)
	router.PATCH(baseURL+"/system/settings/git-settings", wrapper.PatchSystemSettingsGitSettings)
	router.POST(baseURL+"/system/settings/reload", wrapper.PostSystemSettingsReload)
	router.POST(baseURL+"/system/settings/restart", wrapper.PostSystemSettingsRestart)
	router.GET(baseURL+"/system/settings/search-limits", wrapper.GetSystemSettingsSearchLimits)
	router.GET(baseURL+"/system/settings/upgrade", wrapper.GetSystemSettingsUpgrade)
	router.POST(baseURL+"/system/settings/upgrade-from-package", wrapper.PostSystemSettingsUpgradeFromPackage)
	router.POST(baseURL+"/system/settings/upgrade/:version", wrapper.PostSystemSettingsUpgradeVersion)
	router.GET(baseURL+"/system/status/inputs", wrapper.GetSystemStatusInputs)
	router.GET(baseURL+"/system/status/inputs/:id", wrapper.GetSystemStatusInputsId)
	router.GET(baseURL+"/system/status/outputs", wrapper.GetSystemStatusOutputs)
	router.GET(baseURL+"/system/status/outputs/:id", wrapper.GetSystemStatusOutputsId)
	router.GET(baseURL+"/system/subscriptions", wrapper.GetSystemSubscriptions)
	router.POST(baseURL+"/system/subscriptions", wrapper.PostSystemSubscriptions)
	router.DELETE(baseURL+"/system/subscriptions/:id", wrapper.DeleteSystemSubscriptionsId)
	router.GET(baseURL+"/system/subscriptions/:id", wrapper.GetSystemSubscriptionsId)
	router.PATCH(baseURL+"/system/subscriptions/:id", wrapper.PatchSystemSubscriptionsId)
	router.GET(baseURL+"/system/teams", wrapper.GetSystemTeams)
	router.POST(baseURL+"/system/teams", wrapper.PostSystemTeams)
	router.GET(baseURL+"/system/teams/users/:id/roles", wrapper.GetSystemTeamsUsersIdRoles)
	router.DELETE(baseURL+"/system/teams/:id", wrapper.DeleteSystemTeamsId)
	router.GET(baseURL+"/system/teams/:id", wrapper.GetSystemTeamsId)
	router.PATCH(baseURL+"/system/teams/:id", wrapper.PatchSystemTeamsId)
	router.GET(baseURL+"/system/teams/:id/acl", wrapper.GetSystemTeamsIdAcl)
	router.GET(baseURL+"/system/teams/:id/users", wrapper.GetSystemTeamsIdUsers)
	router.POST(baseURL+"/system/teams/:id/users", wrapper.PostSystemTeamsIdUsers)
	router.GET(baseURL+"/system/users", wrapper.GetSystemUsers)
	router.POST(baseURL+"/system/users", wrapper.PostSystemUsers)
	router.DELETE(baseURL+"/system/users/:id", wrapper.DeleteSystemUsersId)
	router.GET(baseURL+"/system/users/:id", wrapper.GetSystemUsersId)
	router.PATCH(baseURL+"/system/users/:id", wrapper.PatchSystemUsersId)
	router.PATCH(baseURL+"/system/users/:id/info", wrapper.PatchSystemUsersIdInfo)
	router.GET(baseURL+"/ui/:key", wrapper.GetUiKey)
	router.PATCH(baseURL+"/ui/:key", wrapper.PatchUiKey)
	router.GET(baseURL+"/version/branch", wrapper.GetVersionBranch)
	router.POST(baseURL+"/version/commit", wrapper.PostVersionCommit)
	router.GET(baseURL+"/version/count", wrapper.GetVersionCount)
	router.GET(baseURL+"/version/current-branch", wrapper.GetVersionCurrentBranch)
	router.GET(baseURL+"/version/diff", wrapper.GetVersionDiff)
	router.GET(baseURL+"/version/files", wrapper.GetVersionFiles)
	router.GET(baseURL+"/version/info", wrapper.GetVersionInfo)
	router.POST(baseURL+"/version/push", wrapper.PostVersionPush)
	router.POST(baseURL+"/version/revert", wrapper.PostVersionRevert)
	router.GET(baseURL+"/version/show", wrapper.GetVersionShow)
	router.GET(baseURL+"/version/status", wrapper.GetVersionStatus)
	router.POST(baseURL+"/version/sync", wrapper.PostVersionSync)
	router.POST(baseURL+"/version/undo", wrapper.PostVersionUndo)

}
